<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elly's Cafe - A Cafe World Tribute</title>
  <meta name="description" content="A loving recreation of the classic Cafe World game, made with love for Elly">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚òï</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel">
const { useEffect, useRef, useReducer, useState } = React;

// ============================================
// CONSTANTS & CONFIG
// ============================================
const COLORS = {
  floor: { wood: 0xd4a574, kitchen: 0xe8e8e8, tile1: 0xf5e6d3, tile2: 0xe8d4b8 },
  walls: { cream: 0xfff5e6, trim: 0x8b4513, window: 0x87ceeb },
  roof: { tiles: 0xb45309 },
  stove: { body: 0x505050, burnerOff: 0x2a2a2a, burnerOn: 0xff4444, door: 0x1a1a1a },
  counter: { top: 0xfafafa, cabinet: 0x2e8b57 },
  table: { wood: 0x8b4513, cloth: 0xdc3545 },
  chair: { wood: 0xa0522d },
  customer: [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da],
  ui: {
    gold: '#ffd700',
    green: '#22c55e',
    red: '#ef4444',
    blue: '#3b82f6',
    purple: '#8b5cf6',
  },
  readyGlow: 0x22c55e,
  warningGlow: 0xeab308,
  dangerGlow: 0xef4444,
  grass: 0x7cad7c,
};

// ============================================
// AUDIO SYSTEM
// ============================================
let audioContext = null;
let audioEnabled = true;
let soundTogglesGlobal = {
  cooking: true,
  foodReady: true,
  foodSpoiled: true,
  customerArrive: true,
  customerServed: true,
  customerHappy: true,
  customerAngry: true,
  coins: true,
  levelUp: true,
  purchase: true,
  achievement: true,
};

function getAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Resume if suspended (browsers require user interaction)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  return audioContext;
}

// Simple synth sound generator
function playTone(frequency, duration, type = 'sine', volume = 0.3, decay = true) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
    
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    if (decay) {
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    }
    
    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + duration);
  } catch (e) {
    // Audio not supported or blocked
  }
}

// Create noise for sizzle effects
function playNoise(duration, volume = 0.1, filterFreq = 3000) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const bufferSize = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Fill with white noise
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    
    // Filter to make it sound more like sizzling
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = filterFreq;
    filter.Q.value = 1;
    
    const gainNode = ctx.createGain();
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    
    noise.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    noise.start();
    noise.stop(ctx.currentTime + duration);
  } catch (e) {}
}

// Metallic coin clink sound
function playCoinClink(delay = 0) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const time = ctx.currentTime + delay;
    
    // High metallic frequencies for coin sound
    const frequencies = [2500, 3500, 4200];
    
    frequencies.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      // Quick pitch bend down for metallic quality
      osc.frequency.exponentialRampToValueAtTime(freq * 0.7, time + 0.08);
      
      // Quick attack, fast decay for "clink"
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.12 - i * 0.03, time + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
      
      osc.start(time);
      osc.stop(time + 0.12);
    });
  } catch (e) {}
}

// Sound effects
const SFX = {
  // Cooking start - sizzle/grill sound
  cookStart: () => {
    if (!audioEnabled || !soundTogglesGlobal.cooking) return;
    // Initial "fwoosh" of putting food on grill
    playNoise(0.15, 0.2, 2000);
    // Followed by sizzling
    setTimeout(() => {
      playNoise(0.3, 0.12, 4000);
      playNoise(0.25, 0.08, 5000);
    }, 100);
    setTimeout(() => {
      playNoise(0.2, 0.06, 3500);
    }, 250);
  },
  
  // Food ready - pleasant ding (like a kitchen timer)
  foodReady: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodReady) return;
    // Bell-like ding
    playTone(1200, 0.3, 'sine', 0.25);
    playTone(2400, 0.2, 'sine', 0.1); // Harmonic
    setTimeout(() => {
      playTone(1200, 0.25, 'sine', 0.15);
      playTone(2400, 0.15, 'sine', 0.05);
    }, 180);
  },
  
  // Food spoiled - buzzer/sad sound
  foodSpoiled: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodSpoiled) return;
    playTone(180, 0.3, 'sawtooth', 0.15);
    playTone(175, 0.3, 'sawtooth', 0.1); // Slight detune for dissonance
    setTimeout(() => {
      playTone(140, 0.35, 'sawtooth', 0.12);
      playTone(138, 0.35, 'sawtooth', 0.08);
    }, 200);
  },
  
  // Customer arrives - door chime / bell
  customerArrive: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerArrive) return;
    playTone(880, 0.2, 'sine', 0.15);
    playTone(1760, 0.15, 'sine', 0.08); // Harmonic
    setTimeout(() => playTone(1100, 0.25, 'sine', 0.12), 120);
  },
  
  // Customer served - plate down sound
  customerServed: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    // Soft thud + clink
    playTone(200, 0.08, 'sine', 0.2);
    setTimeout(() => {
      playTone(800, 0.06, 'triangle', 0.1);
      playTone(1200, 0.05, 'triangle', 0.05);
    }, 30);
  },
  
  // Customer leaves happy - cheerful
  customerHappy: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerHappy) return;
    playTone(523, 0.12, 'sine', 0.15);
    setTimeout(() => playTone(659, 0.12, 'sine', 0.15), 80);
    setTimeout(() => playTone(784, 0.18, 'sine', 0.12), 160);
  },
  
  // Customer leaves angry - negative sound
  customerAngry: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerAngry) return;
    playTone(200, 0.2, 'sawtooth', 0.12);
    setTimeout(() => playTone(150, 0.25, 'sawtooth', 0.08), 150);
  },
  
  // Coin earned - actual coin clink sounds!
  coinEarn: () => {
    if (!audioEnabled || !soundTogglesGlobal.coins) return;
    playCoinClink(0);
    playCoinClink(0.08); // Second coin for "ka-ching"
  },
  
  // Level up fanfare!
  levelUp: () => {
    if (!audioEnabled || !soundTogglesGlobal.levelUp) return;
    const notes = [523, 659, 784, 1047]; // C E G C
    notes.forEach((freq, i) => {
      setTimeout(() => playTone(freq, 0.22, 'sine', 0.2), i * 100);
    });
    // Triumphant chord + coin shower
    setTimeout(() => {
      playTone(523, 0.5, 'sine', 0.15);
      playTone(659, 0.5, 'sine', 0.12);
      playTone(784, 0.5, 'sine', 0.12);
      playTone(1047, 0.5, 'sine', 0.15);
      // Coin sounds
      playCoinClink(0.1);
      playCoinClink(0.2);
      playCoinClink(0.35);
    }, 420);
  },
  
  // UI click
  click: () => {
    playTone(800, 0.04, 'sine', 0.08);
  },
  
  // Purchase - cash register style
  purchase: () => {
    if (!audioEnabled || !soundTogglesGlobal.purchase) return;
    // Register "ka-ching"
    playCoinClink(0);
    setTimeout(() => {
      playTone(600, 0.08, 'sine', 0.12);
      playTone(750, 0.1, 'sine', 0.1);
    }, 80);
    playCoinClink(0.15);
  },
  
  // Serve food to counter - plate sound
  serveToCounter: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    playTone(300, 0.06, 'sine', 0.15);
    setTimeout(() => {
      playTone(600, 0.05, 'triangle', 0.08);
    }, 40);
  },
  
  // Achievement unlocked - triumphant!
  achievement: () => {
    if (!audioEnabled || !soundTogglesGlobal.achievement) return;
    // Magical sparkle + fanfare
    playTone(880, 0.15, 'sine', 0.2);
    playTone(1760, 0.1, 'sine', 0.1);
    setTimeout(() => {
      playTone(1100, 0.15, 'sine', 0.2);
      playTone(2200, 0.1, 'sine', 0.08);
    }, 100);
    setTimeout(() => {
      playTone(1320, 0.2, 'sine', 0.18);
      playTone(2640, 0.12, 'sine', 0.06);
      playCoinClink(0.05);
    }, 200);
    setTimeout(() => {
      playCoinClink(0);
      playCoinClink(0.08);
    }, 350);
  },
};

const GRID = { width: 16, height: 14 };
const TILE_SIZE = 1;

const RECIPES = {
  burger: { name: 'Burger', icon: 'üçî', cost: 25, servings: 13, revenue: 4, cookTime: 12, xp: 7, level: 1 },
  salad: { name: 'Salad', icon: 'ü•ó', cost: 50, servings: 75, revenue: 4, cookTime: 20, xp: 14, level: 1 },
  soup: { name: 'Soup', icon: 'üç≤', cost: 125, servings: 85, revenue: 4, cookTime: 45, xp: 61, level: 2 },
  cake: { name: 'Cake', icon: 'üéÇ', cost: 125, servings: 98, revenue: 5, cookTime: 60, xp: 70, level: 3 },
  pizza: { name: 'Pizza', icon: 'üçï', cost: 200, servings: 120, revenue: 4, cookTime: 35, xp: 40, level: 4 },
  chicken: { name: 'Chicken', icon: 'üçó', cost: 600, servings: 640, revenue: 5, cookTime: 120, xp: 105, level: 5 },
  sushi: { name: 'Sushi', icon: 'üç£', cost: 400, servings: 200, revenue: 6, cookTime: 90, xp: 85, level: 6 },
  steak: { name: 'Steak', icon: 'ü•©', cost: 800, servings: 400, revenue: 7, cookTime: 150, xp: 140, level: 8 },
};

const XP_LEVELS = [0, 120, 280, 520, 840, 1240, 1720, 2280, 2920, 3640, 4440];

// Decoration types for cafe customization
const DECORATIONS = {
  plant: { name: 'Potted Plant', icon: 'ü™¥', cost: 100, buzz: 2, category: 'floor' },
  floorLamp: { name: 'Floor Lamp', icon: 'ü™î', cost: 150, buzz: 2, category: 'floor' },
  rug: { name: 'Cozy Rug', icon: 'üü´', cost: 200, buzz: 3, category: 'floor' },
  picture: { name: 'Wall Art', icon: 'üñºÔ∏è', cost: 250, buzz: 3, category: 'wall' },
  plant2: { name: 'Tall Plant', icon: 'üåø', cost: 175, buzz: 2, category: 'floor' },
  cactus: { name: 'Cactus', icon: 'üåµ', cost: 125, buzz: 2, category: 'floor' },
};

// Achievements system
const ACHIEVEMENTS = {
  firstDish: {
    id: 'firstDish',
    name: 'First Dish',
    description: 'Cook your first meal',
    icon: 'üç≥',
    reward: 100,
  },
  firstCustomer: {
    id: 'firstCustomer',
    name: 'First Customer',
    description: 'Serve your first customer',
    icon: 'üòä',
    reward: 100,
  },
  busyKitchen: {
    id: 'busyKitchen',
    name: 'Busy Kitchen',
    description: 'Have all 3 stoves cooking at once',
    icon: 'üî•',
    reward: 250,
  },
  fullHouse: {
    id: 'fullHouse',
    name: 'Full House',
    description: 'Fill all tables with customers',
    icon: 'ü™ë',
    reward: 500,
  },
  bigSpender: {
    id: 'bigSpender',
    name: 'Big Spender',
    description: 'Spend 5,000 coins total',
    icon: 'üí∏',
    reward: 300,
  },
  decorator: {
    id: 'decorator',
    name: 'Interior Designer',
    description: 'Place 5 decorations',
    icon: 'üé®',
    reward: 200,
  },
  speedyChef: {
    id: 'speedyChef',
    name: 'Speedy Chef',
    description: 'Serve 10 customers in one session',
    icon: '‚ö°',
    reward: 300,
  },
  chef: {
    id: 'chef',
    name: 'Rising Chef',
    description: 'Reach level 5',
    icon: 'üë®‚Äçüç≥',
    reward: 500,
  },
  masterChef: {
    id: 'masterChef',
    name: 'Master Chef',
    description: 'Reach level 10',
    icon: 'üëë',
    reward: 1000,
  },
  mogul: {
    id: 'mogul',
    name: 'Cafe Mogul',
    description: 'Earn 10,000 coins total',
    icon: 'üí∞',
    reward: 1000,
  },
  expansion: {
    id: 'expansion',
    name: 'Growing Business',
    description: 'Own 3 stoves and 10 tables',
    icon: 'üìà',
    reward: 500,
  },
  nightOwl: {
    id: 'nightOwl',
    name: 'Night Owl',
    description: 'Serve a customer after 10 PM',
    icon: 'üåô',
    reward: 150,
  },
};

// ============================================
// INITIAL GAME STATE
// ============================================
// ============================================
// AVATAR CUSTOMIZATION OPTIONS
// ============================================
const AVATAR_OPTIONS = {
  genders: [
    { id: 'female', name: 'Female', icon: 'üë©‚Äçüç≥' },
    { id: 'male', name: 'Male', icon: 'üë®‚Äçüç≥' },
  ],
  skinTones: [
    { id: 'light', name: 'Light', color: 0xFFDBAC },
    { id: 'fair', name: 'Fair', color: 0xF5D0B5 },
    { id: 'medium', name: 'Medium', color: 0xD4A574 },
    { id: 'tan', name: 'Tan', color: 0xC68642 },
    { id: 'brown', name: 'Brown', color: 0x8D5524 },
    { id: 'dark', name: 'Dark', color: 0x5C3A21 },
  ],
  hairColors: [
    { id: 'black', name: 'Black', color: 0x1a1a1a },
    { id: 'brown', name: 'Brown', color: 0x4a3728 },
    { id: 'auburn', name: 'Auburn', color: 0x8B4513 },
    { id: 'blonde', name: 'Blonde', color: 0xD4A76A },
    { id: 'ginger', name: 'Ginger', color: 0xB85C38 },
    { id: 'gray', name: 'Gray', color: 0x888888 },
    { id: 'white', name: 'White', color: 0xE8E8E8 },
    { id: 'pink', name: 'Pink', color: 0xFF69B4 },
    { id: 'blue', name: 'Blue', color: 0x4169E1 },
    { id: 'purple', name: 'Purple', color: 0x9370DB },
  ],
  hairStyles: [
    { id: 'short', name: 'Short' },
    { id: 'bun', name: 'Bun' },
    { id: 'ponytail', name: 'Ponytail' },
    { id: 'long', name: 'Long' },
    { id: 'none', name: 'Bald' },
  ],
  apronColors: [
    { id: 'lightBlue', name: 'Light Blue', color: 0x87CEEB },
    { id: 'pink', name: 'Pink', color: 0xFFB6C1 },
    { id: 'mint', name: 'Mint', color: 0x98FF98 },
    { id: 'yellow', name: 'Yellow', color: 0xFFE66D },
    { id: 'lavender', name: 'Lavender', color: 0xE6E6FA },
    { id: 'coral', name: 'Coral', color: 0xFF7F7F },
    { id: 'white', name: 'White', color: 0xFFFFFF },
    { id: 'red', name: 'Red', color: 0xE74C3C },
  ],
  outfitColors: [
    { id: 'white', name: 'Classic White', color: 0xFFFFFF },
    { id: 'cream', name: 'Cream', color: 0xFFFDD0 },
    { id: 'black', name: 'Black', color: 0x2D2D2D },
    { id: 'navy', name: 'Navy', color: 0x1E3A5F },
    { id: 'burgundy', name: 'Burgundy', color: 0x800020 },
    { id: 'forest', name: 'Forest Green', color: 0x228B22 },
  ],
};

const initialState = {
  coins: 5000,
  xp: 0,
  level: 1,
  buzz: 50, // Starts at 50, not 0!
  
  // Avatar customization
  avatar: {
    gender: 'female',
    skinTone: 'light',
    hairColor: 'brown',
    hairStyle: 'short',
    apronColor: 'lightBlue',
    outfitColor: 'white',
  },
  
  stoves: [
    { id: 'stove-1', gridX: 2, gridZ: 1, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
    { id: 'stove-2', gridX: 4, gridZ: 1, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
  ],
  
  counters: [
    { id: 'counter-1', gridX: 8, gridZ: 1, dishes: [] },
    { id: 'counter-2', gridX: 10, gridZ: 1, dishes: [] },
    { id: 'counter-3', gridX: 12, gridZ: 1, dishes: [] },
  ],
  
  tables: [
    { id: 'table-1', gridX: 3, gridZ: 5, customer: null },
    { id: 'table-2', gridX: 7, gridZ: 5, customer: null },
    { id: 'table-3', gridX: 11, gridZ: 5, customer: null },
    { id: 'table-4', gridX: 3, gridZ: 8, customer: null },
    { id: 'table-5', gridX: 7, gridZ: 8, customer: null },
    { id: 'table-6', gridX: 11, gridZ: 8, customer: null },
    { id: 'table-7', gridX: 5, gridZ: 11, customer: null },
    { id: 'table-8', gridX: 9, gridZ: 11, customer: null },
  ],
  
  stats: {
    dishesCooked: 0,
    customersServed: 0,
    totalEarned: 0,
    totalSpent: 0,
    customersServedSession: 0, // Resets each session
  },
  
  achievements: [], // Array of unlocked achievement IDs
  
  decorations: [], // Player-placed decorations
  
  nextCustomerId: 1,
};

// ============================================
// GAME REDUCER
// ============================================
function gameReducer(state, action) {
  switch (action.type) {
    case 'START_COOKING': {
      const { stoveId, recipeKey } = action.payload;
      const recipe = RECIPES[recipeKey];
      if (state.coins < recipe.cost) return state;
      
      return {
        ...state,
        coins: state.coins - recipe.cost,
        stats: {
          ...state.stats,
          totalSpent: state.stats.totalSpent + recipe.cost,
          dishesCooked: state.stats.dishesCooked + 1,
        },
        stoves: state.stoves.map(s => 
          s.id === stoveId 
            ? { ...s, state: 'cooking', recipe: recipeKey, startTime: Date.now(), servingsLeft: recipe.servings }
            : s
        ),
      };
    }
    
    case 'FINISH_COOKING': {
      const { stoveId } = action.payload;
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'ready' } : s
        ),
        stats: { ...state.stats, dishesCooked: state.stats.dishesCooked + 1 },
      };
    }
    
    case 'SPOIL_FOOD': {
      const { stoveId } = action.payload;
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'spoiled' } : s
        ),
      };
    }
    
    case 'SERVE_TO_COUNTER': {
      const { stoveId, counterId } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      if (!stove || stove.state !== 'ready') return state;
      
      const recipe = RECIPES[stove.recipe];
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
        counters: state.counters.map(c =>
          c.id === counterId 
            ? { ...c, dishes: [...c.dishes, { recipe: stove.recipe, servings: stove.servingsLeft }] }
            : c
        ),
        xp: state.xp + recipe.xp,
      };
    }
    
    case 'CLEAN_STOVE': {
      const { stoveId } = action.payload;
      if (state.coins < 15) return state;
      return {
        ...state,
        coins: state.coins - 15,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
      };
    }
    
    case 'SPAWN_CUSTOMER': {
      const { tableId } = action.payload;
      const colorIndex = Math.floor(Math.random() * COLORS.customer.length);
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { id: state.nextCustomerId, patience: 100, state: 'waiting', colorIndex, spawnTime: Date.now() } }
            : t
        ),
        nextCustomerId: state.nextCustomerId + 1,
      };
    }
    
    case 'UPDATE_CUSTOMER_PATIENCE': {
      const { tableId, patience } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, patience } }
            : t
        ),
      };
    }
    
    case 'SERVE_CUSTOMER': {
      const { tableId, counterId } = action.payload;
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter || counter.dishes.length === 0) return state;
      
      const dish = counter.dishes[0];
      const recipe = RECIPES[dish.recipe];
      const newServings = dish.servings - 1;
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 ? [{ ...dish, servings: newServings }, ...c.dishes.slice(1)] : c.dishes.slice(1) }
            : c
        ),
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'TRASH_COUNTER': {
      const { counterId } = action.payload;
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId ? { ...c, dishes: [] } : c
        ),
      };
    }
    
    case 'CUSTOMER_LEAVE_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.min(105, state.buzz + 2),
        stats: { ...state.stats, customersServed: state.stats.customersServed + 1 },
      };
    }
    
    case 'CUSTOMER_LEAVE_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.max(0, state.buzz - 5),
      };
    }
    
    case 'START_LEAVING_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingHappy', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'START_LEAVING_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingAngry', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'LEVEL_UP': {
      return {
        ...state,
        level: state.level + 1,
        coins: state.coins + 1000,
      };
    }
    
    case 'BUY_STOVE': {
      const { gridX, gridZ } = action.payload || {};
      if (state.coins < 500) return state;
      if (state.stoves.length >= 3) return state; // Max 3 stoves
      
      // Check position not already taken by another stove
      const posTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      if (posTaken) return state;
      
      return {
        ...state,
        coins: state.coins - 500,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + 500 },
        stoves: [...state.stoves, { id: `stove-${Date.now()}`, gridX, gridZ, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 }],
      };
    }
    
    case 'BUY_TABLE': {
      const { gridX, gridZ } = action.payload || {};
      if (state.coins < 300) return state;
      if (state.tables.length >= 15) return state;
      
      // Check position not already taken
      const tableTaken = state.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
      if (tableTaken) return state;
      
      return {
        ...state,
        coins: state.coins - 300,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + 300 },
        tables: [...state.tables, { id: `table-${Date.now()}`, gridX, gridZ, customer: null }],
      };
    }
    
    case 'BUY_COUNTER': {
      const { gridX, gridZ } = action.payload || {};
      if (state.coins < 400) return state;
      if (state.counters.length >= 3) return state;
      
      // Check position not already taken
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      if (counterTaken) return state;
      
      return {
        ...state,
        coins: state.coins - 400,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + 400 },
        counters: [...state.counters, { id: `counter-${Date.now()}`, gridX, gridZ, dishes: [] }],
      };
    }
    
    case 'PLACE_DECORATION': {
      const { decorationType, gridX, gridZ } = action.payload;
      const decor = DECORATIONS[decorationType];
      if (!decor || state.coins < decor.cost) return state;
      
      // Check if position is already taken by a decoration
      const posTaken = state.decorations.some(d => d.gridX === gridX && d.gridZ === gridZ);
      if (posTaken) return state;
      
      return {
        ...state,
        coins: state.coins - decor.cost,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + decor.cost },
        buzz: Math.min(100, state.buzz + decor.buzz),
        decorations: [...state.decorations, {
          id: `decor-${Date.now()}`,
          type: decorationType,
          gridX,
          gridZ,
        }],
      };
    }
    
    case 'REMOVE_DECORATION': {
      const { decorationId } = action.payload;
      const decor = state.decorations.find(d => d.id === decorationId);
      if (!decor) return state;
      const decorType = DECORATIONS[decor.type];
      const refund = Math.floor(decorType.cost * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: Math.max(0, state.buzz - decorType.buzz),
        decorations: state.decorations.filter(d => d.id !== decorationId),
      };
    }
    
    case 'LOAD_SAVE': {
      const gs = action.payload;
      const now = Date.now();
      
      // Process stoves - cooking becomes ready, ready gets fresh spoil timer
      const loadedStoves = (gs.stoves || state.stoves).map(s => {
        if (s.state === 'cooking') {
          // Food finished cooking while you were away!
          return { ...s, state: 'ready', startTime: now };
        }
        if (s.state === 'ready') {
          // Reset spoil timer so it doesn't immediately spoil
          return { ...s, startTime: now };
        }
        return s;
      });
      
      return {
        ...state,
        coins: gs.coins || 5000,
        xp: gs.xp || 0,
        level: gs.level || 1,
        buzz: gs.buzz || 50,
        avatar: gs.avatar || state.avatar, // Load avatar customization
        stats: {
          dishesCooked: gs.stats?.dishesCooked || 0,
          customersServed: gs.stats?.customersServed || 0,
          totalEarned: gs.stats?.totalEarned || 0,
          totalSpent: gs.stats?.totalSpent || 0,
          customersServedSession: 0, // Reset session stats on load
        },
        achievements: gs.achievements || [],
        stoves: loadedStoves,
        counters: gs.counters || state.counters,
        tables: gs.tables || state.tables,
        decorations: gs.decorations || [],
      };
    }
    
    case 'UPDATE_AVATAR': {
      const { field, value } = action.payload;
      return {
        ...state,
        avatar: {
          ...state.avatar,
          [field]: value,
        },
      };
    }
    
    case 'UNLOCK_ACHIEVEMENT': {
      const { achievementId } = action.payload;
      // Don't unlock if already unlocked
      if (state.achievements.includes(achievementId)) return state;
      
      const achievement = ACHIEVEMENTS[achievementId];
      if (!achievement) return state;
      
      return {
        ...state,
        achievements: [...state.achievements, achievementId],
        coins: state.coins + achievement.reward,
        stats: { ...state.stats, totalEarned: state.stats.totalEarned + achievement.reward },
      };
    }
    
    default:
      return state;
  }
}

// ============================================
// 3D OBJECT CREATION HELPERS
// ============================================
function createVoxelBox(width, height, depth, color, x = 0, y = 0, z = 0) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function createFloor(scene) {
  // Kitchen floor (white tiles) - rows 0-2
  for (let x = 0; x < GRID.width; x++) {
    for (let z = 0; z < 3; z++) {
      const isLight = (x + z) % 2 === 0;
      const tile = createVoxelBox(
        TILE_SIZE * 0.98, 0.1, TILE_SIZE * 0.98,
        isLight ? 0xffffff : 0xe8e8e8,
        x - GRID.width / 2 + 0.5, 0, z - GRID.height / 2 + 0.5
      );
      tile.receiveShadow = true;
      scene.add(tile);
    }
  }
  
  // Dining floor (warm wood) - rows 3 to end
  for (let x = 0; x < GRID.width; x++) {
    for (let z = 3; z < GRID.height; z++) {
      const isLight = (x + z) % 2 === 0;
      const tile = createVoxelBox(
        TILE_SIZE * 0.98, 0.1, TILE_SIZE * 0.98,
        isLight ? COLORS.floor.tile1 : COLORS.floor.tile2,
        x - GRID.width / 2 + 0.5, 0, z - GRID.height / 2 + 0.5
      );
      tile.receiveShadow = true;
      scene.add(tile);
    }
  }
}

function createWalls(scene, windowMaterialsRef) {
  // Back wall
  const backWall = createVoxelBox(GRID.width, 3, 0.3, COLORS.walls.cream, 0, 1.5, -GRID.height / 2 + 0.15);
  scene.add(backWall);
  
  // Windows on back wall (more windows for larger wall)
  for (let i = 0; i < 4; i++) {
    const windowFrame = createVoxelBox(1.5, 1.5, 0.1, COLORS.walls.trim, -5 + i * 3.5, 1.8, -GRID.height / 2 + 0.35);
    scene.add(windowFrame);
    
    // Use StandardMaterial for emissive glow at night
    const windowGeo = new THREE.BoxGeometry(1.2, 1.2, 0.05);
    const windowMat = new THREE.MeshStandardMaterial({ 
      color: COLORS.walls.window,
      emissive: 0x000000,
      emissiveIntensity: 0
    });
    const windowGlass = new THREE.Mesh(windowGeo, windowMat);
    windowGlass.position.set(-5 + i * 3.5, 1.8, -GRID.height / 2 + 0.4);
    scene.add(windowGlass);
    if (windowMaterialsRef) windowMaterialsRef.current.push(windowMat);
  }
  
  // Left wall
  const leftWall = createVoxelBox(0.3, 3, GRID.height, COLORS.walls.cream, -GRID.width / 2 + 0.15, 1.5, 0);
  scene.add(leftWall);
  
  // Right wall
  const rightWall = createVoxelBox(0.3, 3, GRID.height, COLORS.walls.cream, GRID.width / 2 - 0.15, 1.5, 0);
  scene.add(rightWall);
  
  // Windows on right wall
  for (let i = 0; i < 3; i++) {
    const windowFrame = createVoxelBox(0.1, 1.5, 1.5, COLORS.walls.trim, GRID.width / 2 - 0.1, 1.8, -2 + i * 4);
    scene.add(windowFrame);
    
    const windowGeo = new THREE.BoxGeometry(0.05, 1.2, 1.2);
    const windowMat = new THREE.MeshStandardMaterial({ 
      color: COLORS.walls.window,
      emissive: 0x000000,
      emissiveIntensity: 0
    });
    const windowGlass = new THREE.Mesh(windowGeo, windowMat);
    windowGlass.position.set(GRID.width / 2 - 0.05, 1.8, -2 + i * 4);
    scene.add(windowGlass);
    if (windowMaterialsRef) windowMaterialsRef.current.push(windowMat);
  }
  
  // Kitchen/dining divider (counter height wall)
  const divider = createVoxelBox(GRID.width - 2, 0.8, 0.2, COLORS.walls.trim, 0, 0.4, -GRID.height / 2 + 3);
  scene.add(divider);
}

function createTree(scene, x, z, scale = 1) {
  // Trunk
  const trunkGeo = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 1.5 * scale, 8);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.set(x, 0.75 * scale, z);
  trunk.castShadow = true;
  scene.add(trunk);
  
  // Foliage layers (stacked cones for a fuller look)
  const foliageColors = [0x228B22, 0x2E8B2E, 0x32CD32];
  for (let i = 0; i < 3; i++) {
    const foliageGeo = new THREE.ConeGeometry(1.2 * scale - i * 0.2, 1.5 * scale - i * 0.2, 8);
    const foliageMat = new THREE.MeshLambertMaterial({ color: foliageColors[i % 3] });
    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
    foliage.position.set(x, 1.8 * scale + i * 0.6 * scale, z);
    foliage.castShadow = true;
    scene.add(foliage);
  }
}

function createBush(scene, x, z, scale = 1) {
  const bushGeo = new THREE.SphereGeometry(0.5 * scale, 8, 6);
  const bushMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
  const bush = new THREE.Mesh(bushGeo, bushMat);
  bush.position.set(x, 0.3 * scale, z);
  bush.scale.y = 0.7; // Flatten a bit
  bush.castShadow = true;
  scene.add(bush);
}

// ============================================
// DECORATION CREATION FUNCTIONS
// ============================================
function createDecoration(type, x, z) {
  const group = new THREE.Group();
  group.position.set(x, 0, z);
  
  switch (type) {
    case 'plant': {
      // Terracotta pot
      const potGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.25, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.125;
      pot.castShadow = true;
      group.add(pot);
      
      // Plant leaves (small sphere cluster)
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 5), leafMat);
      leaf1.position.set(0, 0.35, 0);
      leaf1.castShadow = true;
      group.add(leaf1);
      const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 5), leafMat);
      leaf2.position.set(0.08, 0.45, 0.05);
      group.add(leaf2);
      const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 5), leafMat);
      leaf3.position.set(-0.06, 0.42, -0.04);
      group.add(leaf3);
      break;
    }
    
    case 'plant2': {
      // Tall plant in white pot
      const potGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.35, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xF5F5DC });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.175;
      pot.castShadow = true;
      group.add(pot);
      
      // Tall leaves
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      for (let i = 0; i < 5; i++) {
        const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.5, 4), leafMat);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(Math.cos(angle) * 0.08, 0.55, Math.sin(angle) * 0.08);
        leaf.rotation.x = -0.2;
        leaf.rotation.z = Math.cos(angle) * 0.3;
        group.add(leaf);
      }
      break;
    }
    
    case 'cactus': {
      // Small pot
      const potGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.1;
      pot.castShadow = true;
      group.add(pot);
      
      // Cactus body
      const cactusMat = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8), cactusMat);
      body.position.y = 0.4;
      body.castShadow = true;
      group.add(body);
      
      // Arms
      const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.2, 6), cactusMat);
      arm1.position.set(0.12, 0.45, 0);
      arm1.rotation.z = -0.8;
      group.add(arm1);
      break;
    }
    
    case 'floorLamp': {
      // Base
      const baseGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 8);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.025;
      group.add(base);
      
      // Pole
      const poleGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.2, 8);
      const poleMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = 0.65;
      group.add(pole);
      
      // Lamp shade - cream colored, glows at night
      const shadeGeo = new THREE.CylinderGeometry(0.15, 0.28, 0.35, 8, 1, true);
      const shadeMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFF8DC, 
        emissive: 0xFFAA55,
        emissiveIntensity: 0.1, // Slight glow even during day
        side: THREE.DoubleSide
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.position.y = 1.2;
      group.add(shade);
      group.userData.lampMaterial = shadeMat; // Store for night glow
      
      // Bulb inside
      const bulbGeo = new THREE.SphereGeometry(0.08, 8, 6);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xFFFFAA,
        emissive: 0xFFDD88,
        emissiveIntensity: 0.2
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.y = 1.1;
      group.add(bulb);
      group.userData.bulbMaterial = bulbMat;
      
      // Point light for the lamp
      const lampLight = new THREE.PointLight(0xFFAA55, 0.3, 5, 2); // Slight glow during day
      lampLight.position.y = 1.1;
      group.add(lampLight);
      group.userData.lampLight = lampLight; // Store for night intensity
      break;
    }
    
    case 'rug': {
      // Oval rug - raised above floor tiles (tiles are 0.1 thick at y=0)
      const rugGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.04, 16);
      const rugMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.y = 0.08; // Above the 0.1 thick floor tiles
      rug.scale.set(1, 1, 0.6); // Make oval
      rug.receiveShadow = true;
      group.add(rug);
      
      // Inner pattern
      const innerGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.045, 16);
      const innerMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.position.y = 0.09;
      inner.scale.set(1, 1, 0.6);
      group.add(inner);
      break;
    }
    
    case 'picture': {
      // Wall art frame - larger and more visible
      const frameGeo = new THREE.BoxGeometry(1.0, 0.8, 0.08);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.castShadow = true;
      group.add(frame);
      
      // Canvas with random color for variety
      const colors = [0x87CEEB, 0xFFB6C1, 0x98FB98, 0xDDA0DD, 0xF0E68C, 0xFFDAB9];
      const canvasGeo = new THREE.BoxGeometry(0.8, 0.6, 0.09);
      const canvasMat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
      const canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.y = 1.8;
      group.add(canvas);
      break;
    }
    
    default:
      break;
  }
  
  return group;
}

function createLampPost(scene, x, z, lampMaterialsRef, streetLightsRef) {
  // Pole
  const poleGeo = new THREE.CylinderGeometry(0.05, 0.08, 2.5, 8);
  const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.set(x, 1.25, z);
  scene.add(pole);
  
  // Lamp head - use StandardMaterial for dynamic emissive
  const lampGeo = new THREE.SphereGeometry(0.2, 8, 6);
  const lampMat = new THREE.MeshStandardMaterial({ 
    color: 0xFFF8DC, 
    emissive: 0xFFE4B5, 
    emissiveIntensity: 0.2 
  });
  const lamp = new THREE.Mesh(lampGeo, lampMat);
  lamp.position.set(x, 2.6, z);
  scene.add(lamp);
  if (lampMaterialsRef) lampMaterialsRef.current.push(lampMat);
  
  // Add actual point light for the lamp
  const pointLight = new THREE.PointLight(0xFFE4B5, 0, 15, 1); // intensity 0 initially, range 15, decay 1
  pointLight.position.set(x, 2.4, z);
  scene.add(pointLight);
  if (streetLightsRef) streetLightsRef.current.push(pointLight);
}

function createBench(scene, x, z, rotation = 0) {
  const group = new THREE.Group();
  
  // Seat
  const seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
  const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const seat = new THREE.Mesh(seatGeo, woodMat);
  seat.position.y = 0.4;
  group.add(seat);
  
  // Back
  const backGeo = new THREE.BoxGeometry(1.2, 0.5, 0.08);
  const back = new THREE.Mesh(backGeo, woodMat);
  back.position.set(0, 0.65, -0.18);
  group.add(back);
  
  // Legs
  const legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
  const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  [-0.5, 0.5].forEach(xOff => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(xOff, 0.2, 0);
    group.add(leg);
  });
  
  group.position.set(x, 0, z);
  group.rotation.y = rotation;
  group.castShadow = true;
  scene.add(group);
}

function createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef) {
  // Large grass ground - extended much further
  const grassGeo = new THREE.PlaneGeometry(100, 100);
  const grassMat = new THREE.MeshStandardMaterial({ 
    color: 0x6CB06C, // Slightly darker green
    roughness: 0.9,
    metalness: 0
  });
  const grass = new THREE.Mesh(grassGeo, grassMat);
  grass.rotation.x = -Math.PI / 2;
  grass.position.y = -0.05;
  grass.receiveShadow = true;
  scene.add(grass);
  
  // Distant hills/mountains in the background
  const hillColors = [0x5B8C5B, 0x4A7A4A, 0x3D6B3D];
  
  // Back hills (behind kitchen)
  const hill1 = new THREE.Mesh(
    new THREE.ConeGeometry(15, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill1.position.set(-20, 2, -35);
  hill1.scale.y = 0.5;
  scene.add(hill1);
  
  const hill2 = new THREE.Mesh(
    new THREE.ConeGeometry(20, 12, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill2.position.set(5, 4, -40);
  hill2.scale.y = 0.5;
  scene.add(hill2);
  
  const hill3 = new THREE.Mesh(
    new THREE.ConeGeometry(18, 10, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[2] })
  );
  hill3.position.set(25, 3, -38);
  hill3.scale.y = 0.5;
  scene.add(hill3);
  
  // Side hills
  const hill4 = new THREE.Mesh(
    new THREE.ConeGeometry(12, 7, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill4.position.set(-35, 2, 0);
  hill4.scale.y = 0.5;
  scene.add(hill4);
  
  const hill5 = new THREE.Mesh(
    new THREE.ConeGeometry(14, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill5.position.set(35, 2.5, -5);
  hill5.scale.y = 0.5;
  scene.add(hill5);
  
  // Roads - horizontal road in front of cafe
  const roadMat = new THREE.MeshStandardMaterial({ 
    color: 0x3a3a3a, // Dark asphalt
    roughness: 0.95,
    metalness: 0
  });
  const frontRoad = new THREE.Mesh(new THREE.PlaneGeometry(100, 4), roadMat);
  frontRoad.rotation.x = -Math.PI / 2;
  frontRoad.position.set(0, -0.03, GRID.height / 2 + 4);
  frontRoad.receiveShadow = true;
  scene.add(frontRoad);
  
  // Road markings - matte white
  const markingMat = new THREE.MeshStandardMaterial({ 
    color: 0xDDDDDD, // Off-white
    roughness: 0.8,
    metalness: 0
  });
  for (let i = -45; i < 45; i += 4) {
    const marking = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), markingMat);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(i, -0.02, GRID.height / 2 + 4);
    scene.add(marking);
  }
  
  // Side road
  const sideRoad = new THREE.Mesh(new THREE.PlaneGeometry(4, 50), roadMat);
  sideRoad.rotation.x = -Math.PI / 2;
  sideRoad.position.set(-GRID.width / 2 - 4, -0.03, 0);
  sideRoad.receiveShadow = true;
  scene.add(sideRoad);
  
  // Sidewalks - use StandardMaterial with high roughness to avoid glowing
  const sidewalkMat = new THREE.MeshStandardMaterial({ 
    color: 0x909090, // Darker gray
    roughness: 0.9,  // Very matte, no reflection
    metalness: 0
  });
  
  // Front sidewalk
  const frontSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(GRID.width + 4, 2), sidewalkMat);
  frontSidewalk.rotation.x = -Math.PI / 2;
  frontSidewalk.position.set(0, -0.04, GRID.height / 2 + 1.5);
  frontSidewalk.receiveShadow = true;
  scene.add(frontSidewalk);
  
  // Left sidewalk
  const leftSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(2, GRID.height + 4), sidewalkMat);
  leftSidewalk.rotation.x = -Math.PI / 2;
  leftSidewalk.position.set(-GRID.width / 2 - 1.5, -0.04, 0);
  leftSidewalk.receiveShadow = true;
  scene.add(leftSidewalk);
  
  // === CAFE EXTERIOR - Brick/Stone walls ===
  const brickColor = 0xB5651D; // Warm brick color
  const stoneAccent = 0x8B7355; // Stone trim
  
  // Brick exterior on left wall
  const leftBrick = createVoxelBox(0.4, 3, GRID.height + 0.5, brickColor, -GRID.width / 2 - 0.2, 1.5, 0);
  scene.add(leftBrick);
  
  // Brick exterior on right wall  
  const rightBrick = createVoxelBox(0.4, 3, GRID.height + 0.5, brickColor, GRID.width / 2 + 0.2, 1.5, 0);
  scene.add(rightBrick);
  
  // Brick exterior on back wall
  const backBrick = createVoxelBox(GRID.width + 0.8, 3, 0.4, brickColor, 0, 1.5, -GRID.height / 2 - 0.2);
  scene.add(backBrick);
  
  // Stone foundation/base around cafe
  const foundationHeight = 0.3;
  const foundation1 = createVoxelBox(GRID.width + 1.2, foundationHeight, 0.6, stoneAccent, 0, foundationHeight/2, -GRID.height / 2 - 0.3);
  scene.add(foundation1);
  const foundation2 = createVoxelBox(0.6, foundationHeight, GRID.height + 0.6, stoneAccent, -GRID.width / 2 - 0.3, foundationHeight/2, 0);
  scene.add(foundation2);
  const foundation3 = createVoxelBox(0.6, foundationHeight, GRID.height + 0.6, stoneAccent, GRID.width / 2 + 0.3, foundationHeight/2, 0);
  scene.add(foundation3);
  
  // Stone caps on top of walls
  const capHeight = 0.15;
  const cap1 = createVoxelBox(GRID.width + 1, capHeight, 0.5, stoneAccent, 0, 3.07, -GRID.height / 2 - 0.25);
  scene.add(cap1);
  const cap2 = createVoxelBox(0.5, capHeight, GRID.height + 0.5, stoneAccent, -GRID.width / 2 - 0.25, 3.07, 0);
  scene.add(cap2);
  const cap3 = createVoxelBox(0.5, capHeight, GRID.height + 0.5, stoneAccent, GRID.width / 2 + 0.25, 3.07, 0);
  scene.add(cap3);
  
  // === PARK BEHIND CAFE (kitchen side) ===
  
  // Pond behind the cafe
  const pondGeo = new THREE.CircleGeometry(3, 16);
  const pondMat = new THREE.MeshLambertMaterial({ color: 0x4A90D9 });
  const pond = new THREE.Mesh(pondGeo, pondMat);
  pond.rotation.x = -Math.PI / 2;
  pond.position.set(0, -0.02, -GRID.height / 2 - 8);
  scene.add(pond);
  
  // Pond edge stones
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const stoneGeo = new THREE.SphereGeometry(0.3, 6, 4);
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
    const stone = new THREE.Mesh(stoneGeo, stoneMat);
    stone.position.set(
      Math.cos(angle) * 3.2,
      0.1,
      -GRID.height / 2 - 8 + Math.sin(angle) * 3.2
    );
    stone.scale.y = 0.5;
    scene.add(stone);
  }
  
  // Trees around the cafe - left side
  createTree(scene, -GRID.width / 2 - 5, -GRID.height / 2 - 3, 1.2);
  createTree(scene, -GRID.width / 2 - 7, 2, 1);
  createTree(scene, -GRID.width / 2 - 5, GRID.height / 2 - 2, 0.9);
  
  // Trees - right side
  createTree(scene, GRID.width / 2 + 4, -GRID.height / 2 - 2, 1.1);
  createTree(scene, GRID.width / 2 + 6, 3, 1);
  createTree(scene, GRID.width / 2 + 4, GRID.height / 2, 0.8);
  
  // Trees across the street (front)
  createTree(scene, -10, GRID.height / 2 + 9, 1.3);
  createTree(scene, 0, GRID.height / 2 + 10, 1.1);
  createTree(scene, 10, GRID.height / 2 + 9, 1.2);
  createTree(scene, -18, GRID.height / 2 + 8, 0.9);
  createTree(scene, 18, GRID.height / 2 + 8, 0.9);
  
  // Trees behind cafe (park area)
  createTree(scene, -6, -GRID.height / 2 - 5, 1);
  createTree(scene, 6, -GRID.height / 2 - 5, 1);
  createTree(scene, -4, -GRID.height / 2 - 12, 1.3);
  createTree(scene, 5, -GRID.height / 2 - 13, 1.2);
  createTree(scene, -10, -GRID.height / 2 - 10, 0.9);
  createTree(scene, 10, -GRID.height / 2 - 9, 1);
  
  // Distant trees
  createTree(scene, -25, -20, 1.5);
  createTree(scene, -20, -25, 1.3);
  createTree(scene, 25, -18, 1.4);
  createTree(scene, 20, -22, 1.2);
  createTree(scene, -30, 10, 1.3);
  createTree(scene, 28, 8, 1.4);
  
  // Bushes near the cafe entrance
  createBush(scene, -GRID.width / 2 - 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, GRID.width / 2 + 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, -GRID.width / 2 - 1.5, GRID.height / 2 - 1, 0.6);
  createBush(scene, GRID.width / 2 + 1.5, GRID.height / 2 - 1, 0.6);
  
  // Bushes around the back/park
  createBush(scene, -GRID.width / 2 - 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, GRID.width / 2 + 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, -3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, 3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, -2, -GRID.height / 2 - 12, 0.8);
  createBush(scene, 2, -GRID.height / 2 - 11, 0.7);
  
  // Lamp posts
  createLampPost(scene, -GRID.width / 2 - 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, GRID.width / 2 + 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, -GRID.width / 2 - 7, -2, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, 0, -GRID.height / 2 - 5, lampMaterialsRef, streetLightsRef); // Park lamp
  
  // Benches in park area
  createBench(scene, -5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, 5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, -4, -GRID.height / 2 - 6, 0); // Behind cafe
  createBench(scene, 4, -GRID.height / 2 - 6, 0);  // Behind cafe
  
  // Small flower beds in front
  const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB, 0x00CED1, 0xFFA500];
  [-4, -2, 0, 2, 4].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.25, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff, 0.15, GRID.height / 2 + 1);
    flower.scale.y = 0.6;
    scene.add(flower);
  });
  
  // Flower bed behind cafe (near pond)
  [-2, -1, 0, 1, 2].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.2, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[(i + 2) % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff * 1.5, 0.12, -GRID.height / 2 - 4);
    flower.scale.y = 0.5;
    scene.add(flower);
  });
  
  // Picnic table in the back park
  const picnicGroup = new THREE.Group();
  const tableMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  
  // Table top
  const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), tableMat);
  tableTop.position.y = 0.6;
  picnicGroup.add(tableTop);
  
  // Benches
  const bench1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench1.position.set(0, 0.35, 0.5);
  picnicGroup.add(bench1);
  const bench2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench2.position.set(0, 0.35, -0.5);
  picnicGroup.add(bench2);
  
  // Legs
  const legMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
  [[-0.7, 0], [0.7, 0]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.8), legMat);
    leg.position.set(x, 0.3, z);
    picnicGroup.add(leg);
  });
  
  picnicGroup.position.set(8, 0, -GRID.height / 2 - 10);
  scene.add(picnicGroup);
}

function createStove(x, z) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Main body
  const body = createVoxelBox(0.9, 0.8, 0.9, COLORS.stove.body, 0, 0.45, 0);
  group.add(body);
  
  // Stove top
  const top = createVoxelBox(0.95, 0.05, 0.95, 0x333333, 0, 0.88, 0);
  group.add(top);
  
  // Burners (2x2)
  for (let bx = -1; bx <= 1; bx += 2) {
    for (let bz = -1; bz <= 1; bz += 2) {
      const burner = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 0.02, 16),
        new THREE.MeshLambertMaterial({ color: COLORS.stove.burnerOff })
      );
      burner.position.set(bx * 0.2, 0.91, bz * 0.2);
      burner.name = 'burner';
      group.add(burner);
    }
  }
  
  // Oven door
  const door = createVoxelBox(0.6, 0.4, 0.05, COLORS.stove.door, 0, 0.25, 0.45);
  group.add(door);
  
  // Door handle
  const handle = createVoxelBox(0.3, 0.03, 0.03, 0x888888, 0, 0.35, 0.5);
  group.add(handle);
  
  group.position.set(worldX, 0, worldZ);
  return group;
}

function createCounter(x, z) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Cabinet base
  const cabinet = createVoxelBox(0.9, 0.7, 0.9, COLORS.counter.cabinet, 0, 0.35, 0);
  group.add(cabinet);
  
  // Counter top
  const top = createVoxelBox(1, 0.1, 1, COLORS.counter.top, 0, 0.75, 0);
  group.add(top);
  
  // Handles
  const handle1 = createVoxelBox(0.15, 0.03, 0.03, 0xffd700, -0.15, 0.35, 0.48);
  const handle2 = createVoxelBox(0.15, 0.03, 0.03, 0xffd700, 0.15, 0.35, 0.48);
  group.add(handle1, handle2);
  
  group.position.set(worldX, 0, worldZ);
  return group;
}

function createTable(x, z) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Table top (circular)
  const tableTop = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.08, 16),
    new THREE.MeshLambertMaterial({ color: COLORS.table.wood })
  );
  tableTop.position.y = 0.6;
  tableTop.castShadow = true;
  group.add(tableTop);
  
  // Tablecloth (slightly larger)
  const cloth = new THREE.Mesh(
    new THREE.CylinderGeometry(0.55, 0.6, 0.03, 16),
    new THREE.MeshLambertMaterial({ color: COLORS.table.cloth })
  );
  cloth.position.y = 0.56;
  group.add(cloth);
  
  // Pedestal
  const pedestal = createVoxelBox(0.15, 0.5, 0.15, COLORS.table.wood, 0, 0.28, 0);
  group.add(pedestal);
  
  // Base
  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(0.25, 0.3, 0.06, 16),
    new THREE.MeshLambertMaterial({ color: COLORS.table.wood })
  );
  base.position.y = 0.03;
  group.add(base);
  
  // Two chairs
  const chair1 = createChair();
  chair1.position.set(-0.7, 0, 0);
  chair1.rotation.y = Math.PI / 2;
  group.add(chair1);
  
  const chair2 = createChair();
  chair2.position.set(0.7, 0, 0);
  chair2.rotation.y = -Math.PI / 2;
  group.add(chair2);
  
  group.position.set(worldX, 0, worldZ);
  return group;
}

function createChair() {
  const group = new THREE.Group();
  
  // Seat
  const seat = createVoxelBox(0.3, 0.05, 0.3, COLORS.chair.wood, 0, 0.35, 0);
  group.add(seat);
  
  // Back
  const back = createVoxelBox(0.3, 0.35, 0.05, COLORS.chair.wood, 0, 0.55, -0.15);
  group.add(back);
  
  // Legs
  const legPositions = [[-0.1, -0.1], [0.1, -0.1], [-0.1, 0.1], [0.1, 0.1]];
  legPositions.forEach(([lx, lz]) => {
    const leg = createVoxelBox(0.04, 0.32, 0.04, COLORS.chair.wood, lx, 0.16, lz);
    group.add(leg);
  });
  
  return group;
}

function createFoodPlate(recipeKey) {
  const group = new THREE.Group();
  const recipe = RECIPES[recipeKey];
  
  // Plate (bigger and more visible)
  const plate = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.32, 0.05, 16),
    new THREE.MeshLambertMaterial({ color: 0xffffff })
  );
  plate.position.y = 0;
  plate.castShadow = true;
  group.add(plate);
  
  // Food item (colored dome based on recipe) - bigger
  const foodColors = {
    burger: 0x8B4513,
    salad: 0x228B22,
    soup: 0xDAA520,
    cake: 0xFFB6C1,
    chicken: 0xD2691E,
    pizza: 0xFF6347,
  };
  
  const food = new THREE.Mesh(
    new THREE.SphereGeometry(0.18, 12, 12),
    new THREE.MeshLambertMaterial({ color: foodColors[recipeKey] || 0xffd700 })
  );
  food.scale.y = 0.5;
  food.position.y = 0.1;
  food.castShadow = true;
  group.add(food);
  
  // Add a little garnish/topping
  const topping = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 8, 8),
    new THREE.MeshLambertMaterial({ color: 0xff0000 })
  );
  topping.position.set(0, 0.18, 0);
  group.add(topping);
  
  return group;
}

function createCustomer(colorIndex) {
  const group = new THREE.Group();
  const color = COLORS.customer[colorIndex % COLORS.customer.length];
  
  // Body
  const body = createVoxelBox(0.25, 0.35, 0.2, color, 0, 0.55, 0);
  group.add(body);
  
  // Head
  const head = createVoxelBox(0.22, 0.22, 0.22, 0xffdbac, 0, 0.88, 0);
  group.add(head);
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.06, 0.9, 0.1);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.06, 0.9, 0.1);
  group.add(leftEye, rightEye);
  
  return group;
}

function createChef(avatarOptions = {}) {
  const group = new THREE.Group();
  
  // Get colors from options with defaults
  const gender = avatarOptions.gender || 'female';
  const skinTone = AVATAR_OPTIONS.skinTones.find(s => s.id === avatarOptions.skinTone) || AVATAR_OPTIONS.skinTones[0];
  const hairColor = AVATAR_OPTIONS.hairColors.find(h => h.id === avatarOptions.hairColor) || AVATAR_OPTIONS.hairColors[1];
  const apronColor = AVATAR_OPTIONS.apronColors.find(a => a.id === avatarOptions.apronColor) || AVATAR_OPTIONS.apronColors[0];
  const outfitColor = AVATAR_OPTIONS.outfitColors.find(o => o.id === avatarOptions.outfitColor) || AVATAR_OPTIONS.outfitColors[0];
  const hairStyle = avatarOptions.hairStyle || 'short';
  
  // Legs (dark pants)
  const leftLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, -0.08, 0.125, 0);
  const rightLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, 0.08, 0.125, 0);
  group.add(leftLeg, rightLeg);
  
  // Body (chef coat - customizable color)
  const bodyWidth = gender === 'female' ? 0.28 : 0.32;
  const body = createVoxelBox(bodyWidth, 0.4, 0.22, outfitColor.color, 0, 0.5, 0);
  group.add(body);
  
  // Apron (customizable color)
  const apron = createVoxelBox(0.26, 0.3, 0.05, apronColor.color, 0, 0.45, 0.1);
  group.add(apron);
  
  // Arms (same as outfit)
  const armOffset = gender === 'female' ? 0.20 : 0.24;
  const leftArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, -armOffset, 0.5, 0);
  const rightArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, armOffset, 0.5, 0);
  group.add(leftArm, rightArm);
  
  // Hands (skin color - customizable)
  const leftHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, -armOffset, 0.3, 0);
  const rightHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, armOffset, 0.3, 0);
  group.add(leftHand, rightHand);
  
  // Head (skin - customizable)
  const head = createVoxelBox(0.26, 0.26, 0.26, skinTone.color, 0, 0.93, 0);
  group.add(head);
  
  // Hair (customizable color and style)
  if (hairStyle !== 'none') {
    if (hairStyle === 'short') {
      // Short hair peeking from under hat
      const hair = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hair);
    } else if (hairStyle === 'bun') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Bun behind hat
      const bunGeo = new THREE.SphereGeometry(0.12, 8, 6);
      const bunMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const bun = new THREE.Mesh(bunGeo, bunMat);
      bun.position.set(0, 1.2, -0.15);
      group.add(bun);
    } else if (hairStyle === 'ponytail') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Ponytail
      const tailGeo = new THREE.CylinderGeometry(0.06, 0.04, 0.35, 8);
      const tailMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.position.set(0, 1.0, -0.2);
      tail.rotation.x = 0.5;
      group.add(tail);
    } else if (hairStyle === 'long') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Long flowing hair down both sides
      const longHairGeo = new THREE.BoxGeometry(0.08, 0.4, 0.1);
      const longHairMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const leftHair = new THREE.Mesh(longHairGeo, longHairMat);
      leftHair.position.set(-0.16, 0.75, -0.02);
      group.add(leftHair);
      const rightHair = new THREE.Mesh(longHairGeo, longHairMat);
      rightHair.position.set(0.16, 0.75, -0.02);
      group.add(rightHair);
      // Back hair
      const backHairGeo = new THREE.BoxGeometry(0.24, 0.35, 0.08);
      const backHair = new THREE.Mesh(backHairGeo, longHairMat);
      backHair.position.set(0, 0.78, -0.14);
      group.add(backHair);
    }
  }
  
  // Chef Hat (white toque)
  const hatBase = createVoxelBox(0.28, 0.08, 0.28, 0xffffff, 0, 1.1, 0);
  group.add(hatBase);
  const hatTop = createVoxelBox(0.24, 0.2, 0.24, 0xffffff, 0, 1.25, 0);
  group.add(hatTop);
  const hatPuff = createVoxelBox(0.26, 0.1, 0.26, 0xffffff, 0, 1.38, 0);
  group.add(hatPuff);
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.035, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3d2314 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 0.95, 0.12);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 0.95, 0.12);
  group.add(leftEye, rightEye);
  
  // Eyelashes for female
  if (gender === 'female') {
    const lashMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
    // Left eye lashes
    const leftLashGeo = new THREE.BoxGeometry(0.06, 0.01, 0.01);
    const leftLash = new THREE.Mesh(leftLashGeo, lashMat);
    leftLash.position.set(-0.07, 0.975, 0.13);
    group.add(leftLash);
    // Right eye lashes
    const rightLash = new THREE.Mesh(leftLashGeo, lashMat);
    rightLash.position.set(0.07, 0.975, 0.13);
    group.add(rightLash);
  }
  
  // Smile - happy face!
  const smileGeo = new THREE.TorusGeometry(0.05, 0.015, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0xcc6666 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.86, 0.13);
  smile.rotation.z = Math.PI; // Curve faces up = smile :)
  group.add(smile);
  
  // Plate (carried in front when delivering food) - initially hidden
  const plateGroup = new THREE.Group();
  plateGroup.name = 'plate';
  
  // White plate
  const plateGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.04, 12);
  const plateMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plateGroup.add(plate);
  
  // Food on plate (colorful dome)
  const foodGeo = new THREE.SphereGeometry(0.08, 8, 6);
  const foodMat = new THREE.MeshLambertMaterial({ color: 0xE67E22 }); // Orange/brown food
  const food = new THREE.Mesh(foodGeo, foodMat);
  food.position.y = 0.06;
  food.scale.y = 0.6; // Flatten slightly
  plateGroup.add(food);
  
  // Green garnish
  const garnishGeo = new THREE.SphereGeometry(0.03, 6, 4);
  const garnishMat = new THREE.MeshLambertMaterial({ color: 0x2ECC71 });
  const garnish = new THREE.Mesh(garnishGeo, garnishMat);
  garnish.position.set(0.05, 0.1, 0);
  plateGroup.add(garnish);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front of chef at waist height
  plateGroup.visible = false; // Hidden by default
  group.add(plateGroup);
  
  // Cast shadow
  group.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
    }
  });
  
  return group;
}

function createSteamParticles() {
  const group = new THREE.Group();
  const particleCount = 15;
  
  // Create particles as small white spheres
  const particleGeo = new THREE.SphereGeometry(0.04, 6, 6);
  const particleMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.7 
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(particleGeo, particleMat.clone());
    // Randomize initial position around stove top
    particle.position.set(
      (Math.random() - 0.5) * 0.4,
      0.9 + Math.random() * 0.5, // Start above stove
      (Math.random() - 0.5) * 0.4
    );
    // Store velocity and life data
    particle.userData = {
      velocityY: 0.01 + Math.random() * 0.02,
      velocityX: (Math.random() - 0.5) * 0.005,
      velocityZ: (Math.random() - 0.5) * 0.005,
      life: Math.random(), // Stagger initial life so they don't all reset at once
      maxLife: 1,
    };
    group.add(particle);
  }
  
  return group;
}

function animateSteamParticles(steamGroup) {
  if (!steamGroup) return;
  
  steamGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Move particle
    particle.position.y += data.velocityY;
    particle.position.x += data.velocityX;
    particle.position.z += data.velocityZ;
    
    // Update life
    data.life += 0.02;
    
    // Fade out as life increases
    particle.material.opacity = Math.max(0, 0.7 * (1 - data.life / data.maxLife));
    
    // Scale up slightly as it rises
    const scale = 1 + (data.life / data.maxLife) * 0.5;
    particle.scale.setScalar(scale);
    
    // Reset particle when life expires
    if (data.life >= data.maxLife) {
      particle.position.set(
        (Math.random() - 0.5) * 0.4,
        0.9,
        (Math.random() - 0.5) * 0.4
      );
      particle.material.opacity = 0.7;
      particle.scale.setScalar(1);
      data.life = 0;
      data.velocityY = 0.01 + Math.random() * 0.02;
      data.velocityX = (Math.random() - 0.5) * 0.005;
      data.velocityZ = (Math.random() - 0.5) * 0.005;
    }
  });
}

function createSparkleParticles() {
  const group = new THREE.Group();
  const particleCount = 8; // Fewer particles
  
  // Create sparkle particles as small gold spheres
  const particleGeo = new THREE.SphereGeometry(0.045, 6, 6);
  
  for (let i = 0; i < particleCount; i++) {
    const particleMat = new THREE.MeshBasicMaterial({ 
      color: 0xffd700, // Gold
      transparent: true, 
      opacity: 0.9 
    });
    const particle = new THREE.Mesh(particleGeo, particleMat);
    
    // Position in a ring around the stove top
    const angle = (i / particleCount) * Math.PI * 2;
    const radius = 0.3;
    particle.position.set(
      Math.cos(angle) * radius,
      1.0 + Math.random() * 0.15,
      Math.sin(angle) * radius
    );
    
    // Store animation data - MUCH slower speeds
    particle.userData = {
      baseAngle: angle,
      radius: radius,
      baseY: 1.0 + (i % 3) * 0.1, // Stagger heights
      phase: (i / particleCount) * Math.PI * 2, // Evenly staggered phase
    };
    group.add(particle);
  }
  
  return group;
}

function animateSparkleParticles(sparkleGroup, time) {
  if (!sparkleGroup) return;
  
  const slowTime = time * 0.001; // Convert to seconds, much slower
  
  sparkleGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Very slow orbit around center
    const angle = data.baseAngle + slowTime * 0.3; // Slow rotation
    particle.position.x = Math.cos(angle) * data.radius;
    particle.position.z = Math.sin(angle) * data.radius;
    
    // Gentle float up and down
    particle.position.y = data.baseY + Math.sin(slowTime * 1.5 + data.phase) * 0.08;
    
    // Gentle twinkle effect (opacity pulsing)
    particle.material.opacity = 0.6 + Math.sin(slowTime * 2 + data.phase) * 0.35;
    
    // Subtle scale pulsing
    const scale = 0.9 + Math.sin(slowTime * 1.8 + data.phase) * 0.2;
    particle.scale.setScalar(scale);
  });
}

// ============================================
// MAIN COMPONENT
// ============================================
function CafeWorld3D() {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const objectsRef = useRef({ stoves: {}, counters: {}, tables: {}, customers: {}, counterFood: {}, steamParticles: {}, sparkleParticles: {}, decorations: {} });
  const raycasterRef = useRef(new THREE.Raycaster());
  const mouseRef = useRef(new THREE.Vector2());
  
  const [gameState, dispatch] = useReducer(gameReducer, initialState);
  const [selectedStove, setSelectedStove] = useState(null);
  const [showShop, setShowShop] = useState(false);
  const [shopCategory, setShopCategory] = useState('equipment'); // 'equipment' or 'decor'
  const [showLevelUp, setShowLevelUp] = useState(false);
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [flyingCoins, setFlyingCoins] = useState([]); // [{id, startX, startY, startTime}]
  const [coinPop, setCoinPop] = useState(false);
  const [newPurchases, setNewPurchases] = useState([]); // [{id, type, time}]
  const [showSettings, setShowSettings] = useState(false);
  const [saveMessage, setSaveMessage] = useState(null); // {type: 'success'|'error', text: '...'}
  const [saveTextArea, setSaveTextArea] = useState(''); // For manual copy/paste
  const [showExportText, setShowExportText] = useState(false);
  const [placingDecoration, setPlacingDecoration] = useState(null); // Decoration type being placed
  const [placingEquipment, setPlacingEquipment] = useState(null); // 'stove', 'counter', or 'table'
  const [autoServe, setAutoServe] = useState(false); // Auto-serve customers when food is ready
  const [soundEnabled, setSoundEnabled] = useState(true); // Audio toggle
  const [sceneReady, setSceneReady] = useState(false); // Scene initialization flag
  const [showAchievement, setShowAchievement] = useState(null); // Achievement popup {id, name, icon, reward}
  const [showTrophies, setShowTrophies] = useState(false); // Trophy panel
  const [showAudioSettings, setShowAudioSettings] = useState(false); // Audio settings panel
  const [showAvatarCustomize, setShowAvatarCustomize] = useState(false); // Avatar customization panel
  const avatarPreviewRef = useRef(null); // Canvas for avatar preview
  const avatarPreviewSceneRef = useRef(null); // Three.js scene for preview
  
  // Individual sound toggles
  const [soundToggles, setSoundToggles] = useState({
    cooking: true,
    foodReady: true,
    foodSpoiled: true,
    customerArrive: true,
    customerServed: true,
    customerHappy: true,
    customerAngry: true,
    coins: true,
    levelUp: true,
    purchase: true,
    achievement: true,
  });
  const previewDecorationRef = useRef(null); // Ghost preview during placement
  const [cameraAngle, setCameraAngle] = useState(Math.PI / 4); // Horizontal rotation in radians (start at 45¬∞)
  const cameraAngleRef = useRef(Math.PI / 4);
  const [cameraPitch, setCameraPitch] = useState(0.6); // Vertical angle (0.2 = low, 1.2 = high/top-down)
  const cameraPitchRef = useRef(0.6);
  const [zoomLevel, setZoomLevel] = useState(1); // 0.5 = zoomed in, 2 = zoomed out
  const zoomLevelRef = useRef(1);
  const [isDragging, setIsDragging] = useState(false);
  const lastMouseX = useRef(0);
  const lastMouseY = useRef(0);
  const [projectedPositions, setProjectedPositions] = useState({}); // {stove_1: {x, y}, table_2: {x, y}, etc}
  const [trashConfirm, setTrashConfirm] = useState(null); // {counterId, recipeName, servings} or null
  const [timeOfDay, setTimeOfDay] = useState(10); // 0-24 hours (starts at 10am)
  const timeOfDayRef = useRef(10);
  const ambientLightRef = useRef(null);
  const sunLightRef = useRef(null);
  const sceneRef2 = useRef(null); // For background updates
  const windowMaterialsRef = useRef([]); // Store window glass materials for night glow
  const lampMaterialsRef = useRef([]); // Store lamp materials for night glow
  const interiorLightsRef = useRef([]); // Interior cafe lights
  const streetLightsRef = useRef([]); // Street lamp point lights
  const chefRef = useRef(null); // Chef avatar
  const gameStateRef = useRef(null); // Reference to current game state for animation loop
  const chefStateRef = useRef({
    targetX: 0,
    targetZ: 2,
    currentX: 0,
    currentZ: 2,
    idleTime: 0,
    state: 'idle', // 'idle', 'walking'
    task: null, // { type: 'cook', stoveId } or { type: 'deliver', stoveId } or { type: 'serve', tableId }
    carryingPlate: false, // true when carrying food to counter
    waypoints: [], // Array of {x, z} intermediate points to navigate around obstacles
  });
  
  // Pathfinding constants
  const DIVIDER_Z = -4; // Kitchen/dining divider z position in world coords
  const DOORWAY_X = 5.5; // Doorway gap position (right side)
  
  // Helper function to set chef target with pathfinding
  const setChefTargetWithPath = (targetX, targetZ, task = null) => {
    const chef = chefStateRef.current;
    const currentZ = chef.currentZ;
    const currentX = chef.currentX;
    
    // Check if we need to cross the divider
    const inKitchen = currentZ < DIVIDER_Z;
    const targetInKitchen = targetZ < DIVIDER_Z;
    const crossingDivider = inKitchen !== targetInKitchen;
    
    // Get table positions to avoid
    const tables = gameStateRef.current?.tables || [];
    const tablePositions = tables.map(t => ({
      x: t.gridX - GRID.width / 2 + 0.5,
      z: t.gridZ - GRID.height / 2 + 0.5,
    }));
    
    // Check if direct path crosses a table
    const pathCrossesTable = (fromX, fromZ, toX, toZ) => {
      for (const table of tablePositions) {
        // Simple circle collision check along path
        const steps = 10;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const px = fromX + (toX - fromX) * t;
          const pz = fromZ + (toZ - fromZ) * t;
          const dist = Math.sqrt((px - table.x) ** 2 + (pz - table.z) ** 2);
          if (dist < 1.2) return table; // Too close to table
        }
      }
      return null;
    };
    
    chef.waypoints = [];
    
    if (crossingDivider) {
      // Must go through doorway
      const doorwayZ = inKitchen ? DIVIDER_Z + 0.5 : DIVIDER_Z - 0.5;
      chef.waypoints.push({ x: DOORWAY_X, z: inKitchen ? DIVIDER_Z - 0.3 : DIVIDER_Z + 0.3 }); // Approach doorway
      chef.waypoints.push({ x: DOORWAY_X, z: doorwayZ }); // Through doorway
      chef.waypoints.push({ x: targetX, z: targetZ }); // Final destination
      
      // Start with first waypoint
      const first = chef.waypoints.shift();
      chef.targetX = first.x;
      chef.targetZ = first.z;
    } else {
      // Check if direct path crosses any tables
      const blockingTable = pathCrossesTable(currentX, currentZ, targetX, targetZ);
      
      if (blockingTable && !inKitchen) {
        // Route around the table (go to side then to target)
        const goLeft = currentX > blockingTable.x;
        const detourX = blockingTable.x + (goLeft ? -1.5 : 1.5);
        chef.waypoints.push({ x: detourX, z: currentZ });
        chef.waypoints.push({ x: detourX, z: targetZ });
        chef.waypoints.push({ x: targetX, z: targetZ });
        
        const first = chef.waypoints.shift();
        chef.targetX = first.x;
        chef.targetZ = first.z;
      } else {
        // Direct path is clear
        chef.targetX = targetX;
        chef.targetZ = targetZ;
      }
    }
    
    chef.task = task;
    chef.idleTime = 0;
  };
  
  // Keep ref in sync with state
  useEffect(() => {
    cameraAngleRef.current = cameraAngle;
  }, [cameraAngle]);
  
  useEffect(() => {
    cameraPitchRef.current = cameraPitch;
  }, [cameraPitch]);
  
  useEffect(() => {
    zoomLevelRef.current = zoomLevel;
  }, [zoomLevel]);
  
  useEffect(() => {
    timeOfDayRef.current = timeOfDay;
  }, [timeOfDay]);
  
  // Sync game state with ref for animation loop access
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);
  
  // Chef behavior: Go to stove when cooking starts
  useEffect(() => {
    const cookingStove = gameState.stoves.find(s => s.state === 'cooking');
    const chef = chefStateRef.current;
    
    // If a stove is cooking and chef has no task, send chef there
    if (cookingStove && !chef.task && !chef.carryingPlate && gameStateRef.current) {
      const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'cook', stoveId: cookingStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'cooking').length]);
  
  // Chef behavior: Pick up ready food
  useEffect(() => {
    const readyStove = gameState.stoves.find(s => s.state === 'ready');
    const chef = chefStateRef.current;
    
    // If food is ready and chef isn't already carrying or picking up
    if (readyStove && !chef.carryingPlate && (!chef.task || chef.task.type === 'cook') && gameStateRef.current) {
      const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'pickup', stoveId: readyStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'ready').length]);
  
  // Sync sound state with global audio setting
  useEffect(() => {
    audioEnabled = soundEnabled;
  }, [soundEnabled]);
  
  // Sync individual sound toggles with global
  useEffect(() => {
    soundTogglesGlobal = { ...soundToggles };
  }, [soundToggles]);
  
  // Update chef avatar when customization changes
  useEffect(() => {
    if (chefRef.current && sceneRef2.current) {
      // Save chef position and state
      const oldPosition = chefRef.current.position.clone();
      const oldRotation = chefRef.current.rotation.y;
      
      // Remove old chef
      sceneRef2.current.remove(chefRef.current);
      
      // Create new chef with updated avatar options
      const newChef = createChef(gameState.avatar);
      newChef.position.copy(oldPosition);
      newChef.rotation.y = oldRotation;
      
      // Add to scene
      sceneRef2.current.add(newChef);
      chefRef.current = newChef;
    }
  }, [gameState.avatar]);
  
  // Avatar preview mini-scene
  useEffect(() => {
    if (!showAvatarCustomize || !avatarPreviewRef.current) return;
    
    const canvas = avatarPreviewRef.current;
    const width = 180;
    const height = 220;
    
    // Create mini renderer
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);
    
    // Create mini scene
    const scene = new THREE.Scene();
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
    camera.position.set(0, 1, 3.5);
    camera.lookAt(0, 0.7, 0);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 3, 2);
    scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(-2, 2, -2);
    scene.add(backLight);
    
    // Create chef preview
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, 0);
    scene.add(chef);
    
    // Store for cleanup
    avatarPreviewSceneRef.current = { renderer, scene, camera, chef };
    
    // Animation loop for gentle rotation
    let animationId;
    let rotation = 0;
    
    const animate = () => {
      rotation += 0.01;
      chef.rotation.y = Math.sin(rotation) * 0.5; // Gentle sway
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      cancelAnimationFrame(animationId);
      renderer.dispose();
    };
  }, [showAvatarCustomize, gameState.avatar]);
  
  // Mouse wheel zoom
  useEffect(() => {
    const handleWheel = (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.1 : -0.1;
      setZoomLevel(prev => Math.max(0.5, Math.min(1.5, prev + delta)));
    };
    
    const container = containerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
      return () => container.removeEventListener('wheel', handleWheel);
    }
  }, []);
  
  // Right-click drag to rotate camera
  const handleMouseDown = (e) => {
    if (e.button === 2) { // Right click
      e.preventDefault();
      setIsDragging(true);
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
    }
  };
  
  const handleMouseMove = (e) => {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX.current;
      const deltaY = e.clientY - lastMouseY.current;
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
      
      // Horizontal rotation (inverted for natural "grab and drag" feel)
      setCameraAngle(prev => prev - deltaX * 0.01);
      
      // Vertical rotation (inverted: drag up = look from above, drag down = look from ground)
      setCameraPitch(prev => Math.max(0.15, Math.min(1.4, prev - deltaY * 0.01)));
    }
    
    // Update decoration preview position
    if (placingDecoration && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const decorType = DECORATIONS[placingDecoration];
        const isWallDecor = decorType.category === 'wall';
        
        // Calculate world position
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Check if valid placement
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        const validPlacement = isWallDecor ? inCafe : inDiningArea;
        
        // Update preview visibility based on valid placement
        previewDecorationRef.current.visible = validPlacement;
        
        if (validPlacement) {
          if (isWallDecor) {
            // Position on nearest wall
            const distToBack = gridZ;
            const distToLeft = gridX;
            const distToRight = GRID.width - 1 - gridX;
            const minDist = Math.min(distToBack, distToLeft, distToRight);
            
            if (minDist === distToBack) {
              previewDecorationRef.current.position.set(worldX, 0, -GRID.height / 2 + 0.3);
              previewDecorationRef.current.rotation.y = 0;
            } else if (minDist === distToLeft) {
              previewDecorationRef.current.position.set(-GRID.width / 2 + 0.3, 0, worldZ);
              previewDecorationRef.current.rotation.y = Math.PI / 2;
            } else {
              previewDecorationRef.current.position.set(GRID.width / 2 - 0.3, 0, worldZ);
              previewDecorationRef.current.rotation.y = -Math.PI / 2;
            }
          } else {
            previewDecorationRef.current.position.set(worldX, 0, worldZ);
            previewDecorationRef.current.rotation.y = 0;
          }
        }
      }
    }
    
    // Update equipment preview position
    if (placingEquipment && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Check if valid placement
        let validPlacement = false;
        if (placingEquipment === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove;
        } else if (placingEquipment === 'counter') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          validPlacement = inKitchen && notOnStove && notOnCounter;
        } else if (placingEquipment === 'table') {
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnDecor = !gameState.decorations.some(d => d.gridX === gridX && d.gridZ === gridZ);
          validPlacement = inDining && notOnTable && notOnDecor;
        }
        
        previewDecorationRef.current.visible = validPlacement;
        if (validPlacement) {
          previewDecorationRef.current.position.set(worldX, 0, worldZ);
        }
      }
    }
  };
  
  const handleMouseUp = (e) => {
    if (e.button === 2) {
      setIsDragging(false);
    }
  };
  
  const handleContextMenu = (e) => {
    e.preventDefault(); // Prevent right-click menu
  };
  
  // Check for level up
  const currentLevelXp = XP_LEVELS[gameState.level] || Infinity;
  useEffect(() => {
    if (gameState.xp >= currentLevelXp && gameState.level < XP_LEVELS.length) {
      dispatch({ type: 'LEVEL_UP' });
      setShowLevelUp(true);
      SFX.levelUp();
      setTimeout(() => setShowLevelUp(false), 3000);
    }
  }, [gameState.xp, currentLevelXp, gameState.level]);
  
  // Check for achievements
  const unlockAchievement = (id) => {
    if (!gameState.achievements.includes(id)) {
      dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: { achievementId: id } });
      const ach = ACHIEVEMENTS[id];
      setShowAchievement({ id, name: ach.name, icon: ach.icon, description: ach.description, reward: ach.reward });
      SFX.achievement();
      setTimeout(() => setShowAchievement(null), 4000);
    }
  };
  
  useEffect(() => {
    const { stats, achievements, stoves, tables, decorations, level } = gameState;
    
    // First Dish - Cook your first meal
    if (stats.dishesCooked >= 1 && !achievements.includes('firstDish')) {
      unlockAchievement('firstDish');
      return; // Only one achievement at a time
    }
    
    // First Customer - Serve your first customer
    if (stats.customersServed >= 1 && !achievements.includes('firstCustomer')) {
      unlockAchievement('firstCustomer');
      return;
    }
    
    // Busy Kitchen - All 3 stoves cooking
    const cookingStoves = stoves.filter(s => s.state === 'cooking').length;
    if (cookingStoves >= 3 && stoves.length >= 3 && !achievements.includes('busyKitchen')) {
      unlockAchievement('busyKitchen');
      return;
    }
    
    // Full House - All tables have customers
    const tablesWithCustomers = tables.filter(t => t.customer).length;
    if (tablesWithCustomers >= tables.length && tables.length >= 8 && !achievements.includes('fullHouse')) {
      unlockAchievement('fullHouse');
      return;
    }
    
    // Big Spender - Spend 5,000 coins total
    if (stats.totalSpent >= 5000 && !achievements.includes('bigSpender')) {
      unlockAchievement('bigSpender');
      return;
    }
    
    // Interior Designer - Place 5 decorations
    if (decorations.length >= 5 && !achievements.includes('decorator')) {
      unlockAchievement('decorator');
      return;
    }
    
    // Speedy Chef - Serve 10 customers in one session
    if (stats.customersServedSession >= 10 && !achievements.includes('speedyChef')) {
      unlockAchievement('speedyChef');
      return;
    }
    
    // Rising Chef - Reach level 5
    if (level >= 5 && !achievements.includes('chef')) {
      unlockAchievement('chef');
      return;
    }
    
    // Master Chef - Reach level 10
    if (level >= 10 && !achievements.includes('masterChef')) {
      unlockAchievement('masterChef');
      return;
    }
    
    // Cafe Mogul - Earn 10,000 coins total
    if (stats.totalEarned >= 10000 && !achievements.includes('mogul')) {
      unlockAchievement('mogul');
      return;
    }
    
    // Growing Business - Own 3 stoves and 10 tables
    if (stoves.length >= 3 && tables.length >= 10 && !achievements.includes('expansion')) {
      unlockAchievement('expansion');
      return;
    }
  }, [gameState.stats, gameState.stoves, gameState.tables, gameState.decorations, gameState.level, gameState.achievements]);
  
  // Night Owl achievement - needs timeOfDay check
  useEffect(() => {
    if (timeOfDay >= 22 || timeOfDay < 5) {
      // It's night time (10 PM - 5 AM)
      const recentlyServed = gameState.stats.customersServedSession > 0;
      if (recentlyServed && !gameState.achievements.includes('nightOwl')) {
        // Check if we just served someone
        const tablesEating = gameState.tables.filter(t => t.customer?.state === 'eating');
        if (tablesEating.length > 0) {
          unlockAchievement('nightOwl');
        }
      }
    }
  }, [timeOfDay, gameState.stats.customersServedSession, gameState.tables, gameState.achievements]);
  
  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current) return;
    
    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xADD8E6); // Light sky blue that blends with grass
    sceneRef.current = scene;
    
    // Orthographic camera (isometric view)
    const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
    const frustumSize = 8;
    const camera = new THREE.OrthographicCamera(
      -frustumSize * aspect, frustumSize * aspect,
      frustumSize, -frustumSize,
      0.1, 1000
    );
    camera.position.set(10, 10, 10);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    sceneRef2.current = scene;
    
    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    ambientLightRef.current = ambient;
    
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(8, 15, 8);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 100;
    sun.shadow.camera.left = -30;
    sun.shadow.camera.right = 30;
    sun.shadow.camera.top = 30;
    sun.shadow.camera.bottom = -30;
    scene.add(sun);
    sunLightRef.current = sun;
    
    // Clear material refs
    windowMaterialsRef.current = [];
    lampMaterialsRef.current = [];
    interiorLightsRef.current = [];
    streetLightsRef.current = [];
    
    // Create static environment (passes refs to store materials)
    createFloor(scene);
    createWalls(scene, windowMaterialsRef);
    createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef);
    
    // Add wall sconces for interior lighting (warm, cozy, on walls)
    // GRID is 16x14, so walls are at: x = ¬±8, z = -7 (back) to +7 (front)
    // Back wall windows at x: -5, -1.5, 2, 5.5
    // Right wall windows at z: -2, 2, 6
    const wallSconcePositions = [
      // Back wall sconces - BETWEEN windows (windows at -5, -1.5, 2, 5.5)
      { x: -3.25, y: 2.2, z: -6.3, onBack: true },  // Between -5 and -1.5
      { x: 0.25, y: 2.2, z: -6.3, onBack: true },   // Between -1.5 and 2
      { x: 3.75, y: 2.2, z: -6.3, onBack: true },   // Between 2 and 5.5
      // Right wall sconces - BETWEEN windows (windows at z: -2, 2, 6)
      { x: 7.3, y: 2.2, z: -4.5, onRight: true },   // Before first window
      { x: 7.3, y: 2.2, z: 0, onRight: true },      // Between -2 and 2
      { x: 7.3, y: 2.2, z: 4, onRight: true },      // Between 2 and 6
      // Left wall sconces (no windows on left wall)
      { x: -7.3, y: 2.2, z: -2, onLeft: true },
      { x: -7.3, y: 2.2, z: 3, onLeft: true },
    ];
    
    wallSconcePositions.forEach(pos => {
      // Sconce fixture (small warm bracket)
      const sconceGeo = new THREE.BoxGeometry(0.15, 0.25, 0.1);
      const sconceMat = new THREE.MeshStandardMaterial({ 
        color: 0xD4A574, // Brass/bronze color
        emissive: 0xFFAA55,
        emissiveIntensity: 0
      });
      const sconce = new THREE.Mesh(sconceGeo, sconceMat);
      sconce.position.set(pos.x, pos.y, pos.z);
      scene.add(sconce);
      lampMaterialsRef.current.push(sconceMat);
      
      // Small glowing bulb
      const bulbGeo = new THREE.SphereGeometry(0.08, 6, 4);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xFFF5E0,
        emissive: 0xFFDD88,
        emissiveIntensity: 0
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.set(
        pos.x + (pos.onRight ? -0.15 : pos.onLeft ? 0.15 : 0),
        pos.y,
        pos.z + (pos.onBack ? 0.15 : 0)
      );
      scene.add(bulb);
      lampMaterialsRef.current.push(bulbMat);
      
      // Warm point light from sconce
      const light = new THREE.PointLight(0xFFAA55, 0, 6, 2); // Warm orange, range 6
      light.position.set(
        pos.x + (pos.onRight ? -0.3 : pos.onLeft ? 0.3 : 0),
        pos.y,
        pos.z + (pos.onBack ? 0.3 : 0)
      );
      scene.add(light);
      interiorLightsRef.current.push(light);
    });
    
    // Invisible center light for general interior illumination (warm like sconces)
    const centerLight = new THREE.PointLight(0xFFAA55, 0, 10, 2); // Warm orange like sconces
    centerLight.position.set(0, 2.5, 3); // Center of dining area
    scene.add(centerLight);
    interiorLightsRef.current.push(centerLight);
    
    // Exterior lights around back/sides of cafe
    const exteriorLightPositions = [
      { x: -5, z: -GRID.height / 2 - 2 },  // Back left
      { x: 5, z: -GRID.height / 2 - 2 },   // Back right
      { x: -GRID.width / 2 - 2, z: -3 },   // Left side
      { x: -GRID.width / 2 - 2, z: 3 },    // Left side
      { x: GRID.width / 2 + 2, z: -3 },    // Right side  
      { x: GRID.width / 2 + 2, z: 3 },     // Right side
    ];
    
    exteriorLightPositions.forEach(pos => {
      const extLight = new THREE.PointLight(0xFFE4B5, 0, 10, 2); // Warm, invisible
      extLight.position.set(pos.x, 2.5, pos.z);
      scene.add(extLight);
      streetLightsRef.current.push(extLight);
    });
    
    // Create chef avatar
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, -4); // Start in kitchen
    scene.add(chef);
    chefRef.current = chef;
    sceneRef2.current = scene; // Store scene reference for avatar updates
    chefStateRef.current = {
      targetX: 0,
      targetZ: -4,
      currentX: 0,
      currentZ: -4,
      idleTime: 0,
      state: 'idle',
      task: null,
      carryingPlate: false,
      waypoints: [],
    };
    
    // Animation loop
    let animationId;
    let currentZoom = 1; // Smooth zoom value
    const baseFrustumSize = 8;
    let lastProjectionUpdate = 0;
    const PROJECTION_UPDATE_INTERVAL = 16; // ~60fps for UI updates
    
    function animate() {
      animationId = requestAnimationFrame(animate);
      const time = Date.now();
      
      // Update camera position based on angle and pitch (spherical coordinates)
      const yaw = cameraAngleRef.current;
      const pitch = cameraPitchRef.current;
      const distance = 20; // Distance from center
      
      // Spherical to Cartesian conversion
      camera.position.x = Math.sin(yaw) * Math.cos(pitch) * distance;
      camera.position.z = Math.cos(yaw) * Math.cos(pitch) * distance;
      camera.position.y = Math.sin(pitch) * distance;
      camera.lookAt(0, 0, 0);
      
      // Smooth camera zoom
      const targetZoom = zoomLevelRef.current;
      const zoomDiff = targetZoom - currentZoom;
      if (Math.abs(zoomDiff) > 0.01) {
        currentZoom += zoomDiff * 0.15; // Smooth interpolation
        const newFrustumSize = baseFrustumSize * currentZoom;
        const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
        camera.left = -newFrustumSize * aspect;
        camera.right = newFrustumSize * aspect;
        camera.top = newFrustumSize;
        camera.bottom = -newFrustumSize;
        camera.updateProjectionMatrix();
      }
      
      // === DAY/NIGHT CYCLE ===
      const tod = timeOfDayRef.current;
      
      // Calculate lighting based on time of day
      // 0-5: night, 5-7: dawn, 7-17: day, 17-19: dusk, 19-24: night
      let skyColor, ambientColor, ambientIntensity, sunIntensity, sunColor;
      let windowGlow = 0;
      let lampGlow = 0.2;
      
      if (tod >= 5 && tod < 7) {
        // Dawn - orange/pink transition
        const t = (tod - 5) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0x1a1a3a), // night
          new THREE.Color(0xFFB347), // dawn orange
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0x2a2a4a),
          new THREE.Color(0xffeedd),
          t
        );
        ambientIntensity = 0.3 + t * 0.2;
        sunIntensity = t * 0.5;
        sunColor = new THREE.Color(0xFFAA77);
        windowGlow = (1 - t) * 0.7;
        lampGlow = 1.2 - t * 1.2; // Lights fade off as sun rises
      } else if (tod >= 7 && tod < 17) {
        // Day - bright but not blinding
        const midday = 1 - Math.abs(tod - 12) / 5; // peaks at noon
        skyColor = new THREE.Color(0xADD8E6); // light blue
        ambientColor = new THREE.Color(0xffffff);
        ambientIntensity = 0.4 + midday * 0.1; // Reduced from 0.5+0.15
        sunIntensity = 0.5 + midday * 0.15; // Reduced from 0.7+0.2
        sunColor = new THREE.Color(0xffffff);
        windowGlow = 0;
        lampGlow = 0; // Lights off during day
      } else if (tod >= 17 && tod < 19) {
        // Dusk - orange/purple transition
        const t = (tod - 17) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0xFFB347), // dusk orange
          new THREE.Color(0x4a3a6a), // purple
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0xffeedd),
          new THREE.Color(0x6a5a8a),
          t
        );
        ambientIntensity = 0.5 - t * 0.2;
        sunIntensity = 0.5 - t * 0.4;
        sunColor = new THREE.Color(0xFF7744);
        windowGlow = t * 0.7;
        lampGlow = 0.2 + t * 1.0; // Lights come on during dusk
      } else {
        // Night - dark blue, cozy sconce lighting
        skyColor = new THREE.Color(0x1a1a3a);
        ambientColor = new THREE.Color(0x3a3a5a); // Cool blue ambient
        ambientIntensity = 0.3; // Base visibility
        sunIntensity = 0.1; // Faint moonlight
        sunColor = new THREE.Color(0x8888aa);
        windowGlow = 0.7;
        lampGlow = 1.2; // Sconces nice and warm
      }
      
      // Apply lighting changes
      if (ambientLightRef.current) {
        ambientLightRef.current.color.copy(ambientColor);
        ambientLightRef.current.intensity = ambientIntensity;
      }
      if (sunLightRef.current) {
        sunLightRef.current.color.copy(sunColor);
        sunLightRef.current.intensity = sunIntensity;
        // Disable shadows at night so interior lights can illuminate properly
        sunLightRef.current.castShadow = sunIntensity > 0.2;
      }
      if (sceneRef2.current) {
        sceneRef2.current.background = skyColor;
      }
      
      // Update window glow (warm yellow at night)
      windowMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFDD88);
        mat.emissiveIntensity = windowGlow;
      });
      
      // Update lamp/sconce glow (warm orange)
      lampMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFAA55); // Warm orange
        mat.emissiveIntensity = lampGlow * 0.6;
      });
      
      // Update interior wall sconces (warm cozy glow - not too bright)
      const interiorIntensity = lampGlow * 1.0; // Reduced from 1.5
      interiorLightsRef.current.forEach(light => {
        light.intensity = interiorIntensity;
      });
      
      // Update street lamp lights
      const streetIntensity = lampGlow * 1.5;
      streetLightsRef.current.forEach(light => {
        light.intensity = streetIntensity;
      });
      
      // Animate customers (bobbing)
      Object.values(objectsRef.current.customers).forEach(customerGroup => {
        if (customerGroup) {
          customerGroup.position.y = Math.sin(time * 0.005) * 0.03;
        }
      });
      
      // Animate chef avatar
      if (chefRef.current) {
        const chef = chefStateRef.current;
        const speed = 0.03;
        
        // Move towards target
        const dx = chef.targetX - chef.currentX;
        const dz = chef.targetZ - chef.currentZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Update plate visibility
        const plateObj = chefRef.current.getObjectByName('plate');
        if (plateObj) {
          plateObj.visible = chef.carryingPlate;
        }
        
        if (dist > 0.1) {
          // Walking
          chef.state = 'walking';
          chef.currentX += (dx / dist) * speed;
          chef.currentZ += (dz / dist) * speed;
          
          // Face movement direction
          chefRef.current.rotation.y = Math.atan2(dx, dz);
          
          // Walking bob animation
          chefRef.current.position.y = Math.abs(Math.sin(time * 0.015)) * 0.08;
        } else {
          // Arrived at destination
          chef.state = 'idle';
          
          // Check if there are more waypoints
          if (chef.waypoints && chef.waypoints.length > 0) {
            const next = chef.waypoints.shift();
            chef.targetX = next.x;
            chef.targetZ = next.z;
            chef.state = 'walking';
            return; // Continue to next waypoint
          }
          
          // Handle task completion
          if (chef.task) {
            if (chef.task.type === 'deliver') {
              // Arrived at counter - drop off plate
              chef.carryingPlate = false;
              chef.task = null;
            } else if (chef.task.type === 'pickup') {
              // Arrived at stove - pick up plate
              chef.carryingPlate = true;
              // Now go to counter
              const counters = gameStateRef.current.counters;
              if (counters.length > 0) {
                const counter = counters[0];
                const counterWorldX = counter.gridX - GRID.width / 2 + 0.5;
                const counterWorldZ = counter.gridZ - GRID.height / 2 + 0.5;
                // Use pathfinding for delivery
                chef.waypoints = [];
                chef.targetX = counterWorldX;
                chef.targetZ = counterWorldZ;
                chef.task = { type: 'deliver', counterId: counter.id };
              } else {
                chef.task = null;
              }
            } else if (chef.task.type === 'cook') {
              // Arrived at stove to cook - just hang out nearby
              chef.task = null;
            } else if (chef.task.type === 'serve') {
              // Arrived at table - done
              chef.task = null;
            } else {
              chef.task = null;
            }
            chef.idleTime = 0;
          } else {
            chef.idleTime += 1;
          }
          
          // Gentle idle bob
          chefRef.current.position.y = Math.sin(time * 0.003) * 0.02;
          
          // Pick new target after idling (only if no task)
          if (!chef.task && chef.idleTime > 120) { // ~2 seconds at 60fps
            chef.idleTime = 0;
            
            // Prioritize going to active stoves or ready food
            const stoves = gameStateRef.current.stoves;
            const cookingStove = stoves.find(s => s.state === 'cooking');
            const readyStove = stoves.find(s => s.state === 'ready');
            
            if (readyStove && !chef.carryingPlate) {
              // Go pick up ready food
              const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
              chef.targetX = stoveWorldX;
              chef.targetZ = stoveWorldZ + 0.5; // Stand in front
              chef.waypoints = [];
              chef.task = { type: 'pickup', stoveId: readyStove.id };
            } else if (cookingStove) {
              // Hang out near cooking stove
              const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
              chef.targetX = stoveWorldX + (Math.random() - 0.5);
              chef.targetZ = stoveWorldZ + 0.8; // Stand in front
              chef.waypoints = [];
            } else {
              // Stay in kitchen area when idle (don't wander into dining)
              chef.targetX = (Math.random() - 0.5) * 8; // Kitchen area x
              chef.targetZ = -5 + Math.random() * 1.5; // Kitchen area z (behind divider)
              chef.waypoints = [];
            }
          }
        }
        
        // Update position
        chefRef.current.position.x = chef.currentX;
        chefRef.current.position.z = chef.currentZ;
      }
      
      // Animate steam particles
      Object.values(objectsRef.current.steamParticles).forEach(steamGroup => {
        animateSteamParticles(steamGroup);
      });
      
      // Animate sparkle particles
      Object.values(objectsRef.current.sparkleParticles).forEach(sparkleGroup => {
        animateSparkleParticles(sparkleGroup, time);
      });
      
      // Animate purchase bounce-in effect
      const animatePurchase = (obj) => {
        if (obj && obj.userData && obj.userData.animateIn) {
          const { startTime, duration } = obj.userData.animateIn;
          const elapsed = time - startTime;
          const progress = Math.min(1, elapsed / duration);
          
          if (progress < 1) {
            // Elastic ease-out for bouncy effect
            const elasticOut = (t) => {
              const p = 0.4;
              return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
            };
            const scale = elasticOut(progress);
            obj.scale.setScalar(scale);
          } else {
            obj.scale.setScalar(1);
            delete obj.userData.animateIn;
          }
        }
      };
      
      Object.values(objectsRef.current.stoves).forEach(animatePurchase);
      Object.values(objectsRef.current.counters).forEach(animatePurchase);
      Object.values(objectsRef.current.tables).forEach(animatePurchase);
      Object.values(objectsRef.current.decorations).forEach(animatePurchase);
      
      // Update projected positions for UI overlays
      const newPositions = {};
      const tempVec = new THREE.Vector3();
      
      const projectWorldToScreen = (worldX, worldY, worldZ) => {
        tempVec.set(worldX, worldY, worldZ);
        tempVec.project(camera);
        return {
          x: (tempVec.x * 0.5 + 0.5) * 100,
          y: (-tempVec.y * 0.5 + 0.5) * 100
        };
      };
      
      // Project stove positions
      Object.entries(objectsRef.current.stoves).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`stove_${id}`] = pos;
        }
      });
      
      // Project counter positions
      Object.entries(objectsRef.current.counters).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`counter_${id}`] = pos;
        }
      });
      
      // Project table positions
      Object.entries(objectsRef.current.tables).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`table_${id}`] = pos;
        }
      });
      
      setProjectedPositions(newPositions);
      
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle resize
    function handleResize() {
      if (!containerRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      const newAspect = width / height;
      
      camera.left = -frustumSize * newAspect;
      camera.right = frustumSize * newAspect;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    window.addEventListener('resize', handleResize);
    
    // Mark scene as ready (triggers object creation)
    setSceneReady(true);
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
      setSceneReady(false);
    };
  }, []);
  
  // Update 3D objects when game state changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene || !sceneReady) return;
    
    // Cleanup: Remove 3D objects that no longer exist in state
    const stoveIds = new Set(gameState.stoves.map(s => s.id));
    Object.keys(objectsRef.current.stoves).forEach(id => {
      if (!stoveIds.has(id)) {
        scene.remove(objectsRef.current.stoves[id]);
        delete objectsRef.current.stoves[id];
        // Also cleanup associated particles
        if (objectsRef.current.steamParticles[id]) {
          scene.remove(objectsRef.current.steamParticles[id]);
          delete objectsRef.current.steamParticles[id];
        }
        if (objectsRef.current.sparkleParticles[id]) {
          scene.remove(objectsRef.current.sparkleParticles[id]);
          delete objectsRef.current.sparkleParticles[id];
        }
      }
    });
    
    const counterIds = new Set(gameState.counters.map(c => c.id));
    Object.keys(objectsRef.current.counters).forEach(id => {
      if (!counterIds.has(id)) {
        scene.remove(objectsRef.current.counters[id]);
        delete objectsRef.current.counters[id];
        if (objectsRef.current.counterFood[id]) {
          scene.remove(objectsRef.current.counterFood[id]);
          delete objectsRef.current.counterFood[id];
        }
      }
    });
    
    const tableIds = new Set(gameState.tables.map(t => t.id));
    Object.keys(objectsRef.current.tables).forEach(id => {
      if (!tableIds.has(id)) {
        scene.remove(objectsRef.current.tables[id]);
        delete objectsRef.current.tables[id];
        if (objectsRef.current.customers[id]) {
          scene.remove(objectsRef.current.customers[id]);
          delete objectsRef.current.customers[id];
        }
      }
    });
    
    // Update stoves
    gameState.stoves.forEach(stove => {
      let stoveObj = objectsRef.current.stoves[stove.id];
      if (!stoveObj) {
        stoveObj = createStove(stove.gridX, stove.gridZ);
        stoveObj.userData = { type: 'stove', id: stove.id };
        scene.add(stoveObj);
        objectsRef.current.stoves[stove.id] = stoveObj;
        
        // Check if this is a new purchase (bought within last 500ms)
        const recentPurchase = newPurchases.find(p => p.type === 'stove' && Date.now() - p.time < 500);
        if (recentPurchase) {
          stoveObj.scale.setScalar(0);
          stoveObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Update burner colors based on state
      const burnerColor = stove.state === 'cooking' ? COLORS.stove.burnerOn : 
                          stove.state === 'ready' ? COLORS.readyGlow :
                          stove.state === 'spoiled' ? COLORS.dangerGlow : COLORS.stove.burnerOff;
      stoveObj.children.forEach(child => {
        if (child.name === 'burner') {
          child.material.color.setHex(burnerColor);
          child.material.emissive = new THREE.Color(stove.state === 'cooking' ? 0x441111 : 0x000000);
        }
      });
      
      // Handle steam particles
      const existingSteam = objectsRef.current.steamParticles[stove.id];
      if (stove.state === 'cooking' && !existingSteam) {
        // Add steam particles
        const steam = createSteamParticles();
        steam.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(steam);
        objectsRef.current.steamParticles[stove.id] = steam;
      } else if (stove.state !== 'cooking' && existingSteam) {
        // Remove steam particles
        scene.remove(existingSteam);
        delete objectsRef.current.steamParticles[stove.id];
      }
      
      // Handle sparkle particles for ready food
      const existingSparkle = objectsRef.current.sparkleParticles[stove.id];
      if (stove.state === 'ready' && !existingSparkle) {
        // Add sparkle particles
        const sparkle = createSparkleParticles();
        sparkle.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(sparkle);
        objectsRef.current.sparkleParticles[stove.id] = sparkle;
      } else if (stove.state !== 'ready' && existingSparkle) {
        // Remove sparkle particles
        scene.remove(existingSparkle);
        delete objectsRef.current.sparkleParticles[stove.id];
      }
    });
    
    // Update counters
    gameState.counters.forEach(counter => {
      let counterObj = objectsRef.current.counters[counter.id];
      if (!counterObj) {
        counterObj = createCounter(counter.gridX, counter.gridZ);
        counterObj.userData = { type: 'counter', id: counter.id };
        scene.add(counterObj);
        objectsRef.current.counters[counter.id] = counterObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'counter' && Date.now() - p.time < 500);
        if (recentPurchase) {
          counterObj.scale.setScalar(0);
          counterObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle food on counter
      const existingFood = objectsRef.current.counterFood[counter.id];
      const hasFood = counter.dishes.length > 0;
      
      if (hasFood && !existingFood) {
        // Add food visual
        const foodGroup = new THREE.Group();
        const dish = counter.dishes[0];
        const food = createFoodPlate(dish.recipe);
        food.position.y = 0.85;
        foodGroup.add(food);
        
        // Add serving count indicator (stack of plates effect)
        const totalServings = counter.dishes.reduce((sum, d) => sum + d.servings, 0);
        if (totalServings > 10) {
          const extraPlate = createFoodPlate(dish.recipe);
          extraPlate.position.set(0.18, 0.85, 0.12);
          extraPlate.scale.setScalar(0.8);
          foodGroup.add(extraPlate);
        }
        if (totalServings > 30) {
          const extraPlate2 = createFoodPlate(dish.recipe);
          extraPlate2.position.set(-0.18, 0.85, -0.12);
          extraPlate2.scale.setScalar(0.7);
          foodGroup.add(extraPlate2);
        }
        
        foodGroup.position.set(
          counter.gridX - GRID.width / 2 + 0.5,
          0,
          counter.gridZ - GRID.height / 2 + 0.5
        );
        foodGroup.userData = { recipe: dish.recipe };
        scene.add(foodGroup);
        objectsRef.current.counterFood[counter.id] = foodGroup;
      } else if (!hasFood && existingFood) {
        // Remove food visual
        scene.remove(existingFood);
        delete objectsRef.current.counterFood[counter.id];
      } else if (hasFood && existingFood) {
        // Update food visual if recipe changed
        const currentRecipe = counter.dishes[0]?.recipe;
        if (existingFood.userData?.recipe !== currentRecipe) {
          scene.remove(existingFood);
          delete objectsRef.current.counterFood[counter.id];
          // Will be recreated next frame
        }
      }
    });
    
    // Update tables
    gameState.tables.forEach(table => {
      let tableObj = objectsRef.current.tables[table.id];
      if (!tableObj) {
        tableObj = createTable(table.gridX, table.gridZ);
        tableObj.userData = { type: 'table', id: table.id };
        scene.add(tableObj);
        objectsRef.current.tables[table.id] = tableObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'table' && Date.now() - p.time < 500);
        if (recentPurchase) {
          tableObj.scale.setScalar(0);
          tableObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle customer at table
      const existingCustomer = objectsRef.current.customers[table.id];
      if (table.customer && !existingCustomer) {
        const customer = createCustomer(table.customer.colorIndex);
        customer.position.set(
          table.gridX - GRID.width / 2 + 0.5,
          0,
          table.gridZ - GRID.height / 2 + 0.5 - 0.3
        );
        customer.userData = { type: 'customer', tableId: table.id };
        scene.add(customer);
        objectsRef.current.customers[table.id] = customer;
      } else if (!table.customer && existingCustomer) {
        scene.remove(existingCustomer);
        delete objectsRef.current.customers[table.id];
      }
    });
    
    // Update decorations
    const currentDecorIds = new Set(gameState.decorations.map(d => d.id));
    
    // Remove decorations that no longer exist
    Object.entries(objectsRef.current.decorations).forEach(([id, obj]) => {
      if (!currentDecorIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.decorations[id];
      }
    });
    
    // Add new decorations
    gameState.decorations.forEach(decor => {
      if (!objectsRef.current.decorations[decor.id]) {
        const decorType = DECORATIONS[decor.type];
        const worldX = decor.gridX - GRID.width / 2 + 0.5;
        const worldZ = decor.gridZ - GRID.height / 2 + 0.5;
        
        const decorObj = createDecoration(decor.type, worldX, worldZ);
        decorObj.userData = { type: 'decoration', id: decor.id, decorType: decor.type };
        
        // Wall decorations go on the nearest wall
        if (decorType.category === 'wall') {
          // Determine which wall is closest based on grid position
          const distToBack = decor.gridZ; // Distance to back wall (z=0)
          const distToLeft = decor.gridX; // Distance to left wall (x=0)
          const distToRight = GRID.width - 1 - decor.gridX; // Distance to right wall
          
          const minDist = Math.min(distToBack, distToLeft, distToRight);
          
          if (minDist === distToBack) {
            // Back wall
            decorObj.position.set(decor.gridX - GRID.width / 2 + 0.5, 0, -GRID.height / 2 + 0.3);
            decorObj.rotation.y = 0;
          } else if (minDist === distToLeft) {
            // Left wall
            decorObj.position.set(-GRID.width / 2 + 0.3, 0, decor.gridZ - GRID.height / 2 + 0.5);
            decorObj.rotation.y = Math.PI / 2;
          } else {
            // Right wall
            decorObj.position.set(GRID.width / 2 - 0.3, 0, decor.gridZ - GRID.height / 2 + 0.5);
            decorObj.rotation.y = -Math.PI / 2;
          }
        }
        
        scene.add(decorObj);
        objectsRef.current.decorations[decor.id] = decorObj;
        
        // If it's a floor lamp, hook up its material and light for night glow
        if (decor.type === 'floorLamp') {
          if (decorObj.userData.lampMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.lampMaterial);
          }
          if (decorObj.userData.bulbMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.bulbMaterial);
          }
          if (decorObj.userData.lampLight) {
            interiorLightsRef.current.push(decorObj.userData.lampLight);
          }
        }
        
        // Bounce-in animation
        decorObj.scale.setScalar(0);
        decorObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
      }
    });
  }, [gameState, newPurchases, sceneReady]);
  
  // Create/destroy preview decoration when placement mode changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene) return;
    
    // Remove existing preview
    if (previewDecorationRef.current) {
      scene.remove(previewDecorationRef.current);
      previewDecorationRef.current = null;
    }
    
    // Create new preview if placing decoration
    if (placingDecoration) {
      const preview = createDecoration(placingDecoration, 0, 0);
      // Make it semi-transparent
      preview.traverse(child => {
        if (child.isMesh && child.material) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
        }
      });
      preview.visible = false; // Hidden until mouse moves over valid area
      scene.add(preview);
      previewDecorationRef.current = preview;
    }
    
    // Create new preview if placing equipment
    if (placingEquipment) {
      let preview;
      if (placingEquipment === 'stove') {
        preview = createStove(0, 0);
      } else if (placingEquipment === 'counter') {
        preview = createCounter(0, 0);
      } else if (placingEquipment === 'table') {
        preview = createTable(0, 0);
      }
      
      if (preview) {
        // Make it semi-transparent
        preview.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.5;
          }
        });
        preview.visible = false;
        scene.add(preview);
        previewDecorationRef.current = preview;
      }
    }
    
    return () => {
      if (previewDecorationRef.current && scene) {
        scene.remove(previewDecorationRef.current);
        previewDecorationRef.current = null;
      }
    };
  }, [placingDecoration, placingEquipment]);
  
  // Game tick - update timers, spawn customers, etc.
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
      
      // Progress time of day (1 real second = 2 game minutes, full day = 12 real minutes)
      setTimeOfDay(prev => {
        const newTime = prev + (2 / 60); // Add 2 minutes per second
        return newTime >= 24 ? newTime - 24 : newTime;
      });
      
      // Check cooking timers
      gameState.stoves.forEach(stove => {
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          
          if (elapsed >= recipe.cookTime) {
            dispatch({ type: 'FINISH_COOKING', payload: { stoveId: stove.id } });
            SFX.foodReady();
          }
        } else if (stove.state === 'ready' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          
          if (elapsed >= recipe.cookTime * 2.2) {
            dispatch({ type: 'SPOIL_FOOD', payload: { stoveId: stove.id } });
            SFX.foodSpoiled();
          }
        }
      });
      
      // Update customer patience & spawn new customers
      gameState.tables.forEach(table => {
        if (table.customer) {
          if (table.customer.state === 'waiting') {
            const elapsed = (Date.now() - table.customer.spawnTime) / 1000;
            const newPatience = Math.max(0, 100 - elapsed * 2);
            
            if (newPatience <= 0) {
              // Start angry leaving animation
              dispatch({ type: 'START_LEAVING_ANGRY', payload: { tableId: table.id } });
            } else if (Math.abs(newPatience - table.customer.patience) > 1) {
              dispatch({ type: 'UPDATE_CUSTOMER_PATIENCE', payload: { tableId: table.id, patience: newPatience } });
            }
          } else if (table.customer.state === 'eating') {
            const elapsed = (Date.now() - table.customer.eatStartTime) / 1000;
            if (elapsed >= 4) {
              // Start happy leaving animation
              dispatch({ type: 'START_LEAVING_HAPPY', payload: { tableId: table.id } });
              
              // Spawn flying coin from table position
              const screenPos = projectedPositions[`table_${table.id}`] || { x: 50, y: 50 };
              setFlyingCoins(prev => [...prev, {
                id: Date.now(),
                startX: screenPos.x,
                startY: screenPos.y,
                startTime: Date.now(),
              }]);
            }
          } else if (table.customer.state === 'leavingHappy') {
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_HAPPY', payload: { tableId: table.id } });
              SFX.customerHappy();
              SFX.coinEarn();
              // Trigger coin pop effect
              setCoinPop(true);
              setTimeout(() => setCoinPop(false), 300);
            }
          } else if (table.customer.state === 'leavingAngry') {
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_ANGRY', payload: { tableId: table.id } });
              SFX.customerAngry();
            }
          }
        }
      });
      
      // Spawn customers at empty tables (minimum 1% chance, scales with buzz)
      const emptyTables = gameState.tables.filter(t => !t.customer);
      const spawnChance = Math.max(0.01, 0.02 * (gameState.buzz / 50)); // Minimum 1% spawn rate
      if (emptyTables.length > 0 && Math.random() < spawnChance) {
        const randomTable = emptyTables[Math.floor(Math.random() * emptyTables.length)];
        dispatch({ type: 'SPAWN_CUSTOMER', payload: { tableId: randomTable.id } });
        SFX.customerArrive();
      }
      
      // Auto-serve customers if enabled - only when chef walks near the table
      if (autoServe && chefStateRef.current) {
        const chefX = chefStateRef.current.currentX;
        const chefZ = chefStateRef.current.currentZ;
        
        // Find waiting customers and available food
        const waitingTables = gameState.tables.filter(t => t.customer && t.customer.state === 'waiting');
        const countersWithFood = gameState.counters.filter(c => c.dishes && c.dishes.length > 0);
        
        if (waitingTables.length > 0 && countersWithFood.length > 0) {
          // Find nearest waiting table to chef
          let nearestTable = null;
          let nearestDist = Infinity;
          
          for (const table of waitingTables) {
            const tableWorldX = table.gridX - GRID.width / 2 + 0.5;
            const tableWorldZ = table.gridZ - GRID.height / 2 + 0.5;
            const dx = chefX - tableWorldX;
            const dz = chefZ - tableWorldZ;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            // Serve if chef is within 1.5 units of the table
            if (distance < 1.5) {
              const counter = countersWithFood[0];
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId: table.id, counterId: counter.id } });
              SFX.customerServed();
              nearestTable = null; // Already served, don't redirect
              break;
            }
            
            if (distance < nearestDist) {
              nearestDist = distance;
              nearestTable = table;
            }
          }
          
          // Direct chef to walk towards nearest waiting customer (with pathfinding)
          if (nearestTable && chefStateRef.current.state === 'idle' && !chefStateRef.current.task) {
            const tableWorldX = nearestTable.gridX - GRID.width / 2 + 0.5;
            const tableWorldZ = nearestTable.gridZ - GRID.height / 2 + 0.5;
            setChefTargetWithPath(tableWorldX, tableWorldZ, { type: 'serve', tableId: nearestTable.id });
          }
        }
      }
      
      // Clean up finished flying coins
      setFlyingCoins(prev => prev.filter(coin => {
        const elapsed = (Date.now() - coin.startTime) / 1000;
        return elapsed < 1; // Keep for 1 second
      }));
      
      // Clean up old purchase records
      setNewPurchases(prev => prev.filter(p => Date.now() - p.time < 1000));
    }, 100);
    
    return () => clearInterval(interval);
  }, [gameState, autoServe]);
  
  // Handle clicks
  const handleClick = (e) => {
    if (!containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Handle decoration placement mode
    if (placingDecoration) {
      // Raycast against the floor to find placement position
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        // Convert world position to grid position
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Check bounds (inside cafe)
        const decorType = DECORATIONS[placingDecoration];
        const isWallDecor = decorType.category === 'wall';
        
        // For wall decorations, allow anywhere inside cafe and determine wall by position
        // For floor decorations, dining area only (gridZ >= 4)
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        
        const validPlacement = isWallDecor ? inCafe : inDiningArea;
        
        if (validPlacement && gameState.coins >= decorType.cost) {
          dispatch({ 
            type: 'PLACE_DECORATION', 
            payload: { decorationType: placingDecoration, gridX, gridZ } 
          });
          SFX.purchase();
          setPlacingDecoration(null);
        }
      }
      return;
    }
    
    // Handle equipment placement mode
    if (placingEquipment) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Validate placement based on equipment type
        let validPlacement = false;
        let actionType = '';
        let cost = 0;
        
        if (placingEquipment === 'stove') {
          // Stoves go in kitchen (gridZ 0-2), and not on counter row
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove && gameState.stoves.length < 3;
          actionType = 'BUY_STOVE';
          cost = 500;
        } else if (placingEquipment === 'counter') {
          // Counters go in kitchen (gridZ 0-2)
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          validPlacement = inKitchen && notOnStove && notOnCounter && gameState.counters.length < 3;
          actionType = 'BUY_COUNTER';
          cost = 400;
        } else if (placingEquipment === 'table') {
          // Tables go in dining area (gridZ >= 4)
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnDecor = !gameState.decorations.some(d => d.gridX === gridX && d.gridZ === gridZ);
          validPlacement = inDining && notOnTable && notOnDecor && gameState.tables.length < 15;
          actionType = 'BUY_TABLE';
          cost = 300;
        }
        
        if (validPlacement && gameState.coins >= cost) {
          dispatch({ type: actionType, payload: { gridX, gridZ } });
          SFX.purchase();
          setNewPurchases(prev => [...prev, { type: placingEquipment, time: Date.now() }]);
          setPlacingEquipment(null);
        }
      }
      return;
    }
    
    const allObjects = [
      ...Object.values(objectsRef.current.stoves),
      ...Object.values(objectsRef.current.counters),
      ...Object.values(objectsRef.current.tables),
      ...Object.values(objectsRef.current.customers),
    ].filter(Boolean);
    
    const intersects = raycasterRef.current.intersectObjects(allObjects, true);
    
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && !obj.userData?.type) {
        obj = obj.parent;
      }
      
      if (obj?.userData) {
        const { type, id, tableId } = obj.userData;
        
        if (type === 'stove') {
          const stove = gameState.stoves.find(s => s.id === id);
          if (stove.state === 'empty') {
            setSelectedStove(id);
          } else if (stove.state === 'ready') {
            const counter = gameState.counters.find(c => c.dishes.length < 5);
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: id, counterId: counter.id } });
              SFX.serveToCounter();
            }
          } else if (stove.state === 'spoiled') {
            dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: id } });
          }
        } else if (type === 'customer') {
          const table = gameState.tables.find(t => t.id === tableId);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        } else if (type === 'table') {
          // Also allow clicking on tables to serve customers!
          const table = gameState.tables.find(t => t.id === id);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId: id, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        }
      }
    }
  };
  
  const handleRecipeSelect = (recipeKey) => {
    if (selectedStove) {
      dispatch({ type: 'START_COOKING', payload: { stoveId: selectedStove, recipeKey } });
      SFX.cookStart();
      setSelectedStove(null);
    }
  };
  
  // Export save - generate JSON for copying
  const handleExportSave = () => {
    const saveData = {
      version: 4, // Updated version for avatar customization
      timestamp: Date.now(),
      gameState: {
        coins: gameState.coins,
        xp: gameState.xp,
        level: gameState.level,
        buzz: gameState.buzz,
        avatar: gameState.avatar, // Save avatar customization
        stats: gameState.stats,
        achievements: gameState.achievements,
        // Save full stove state (cooking items will finish immediately on load since time passed)
        stoves: gameState.stoves.map(s => ({ 
          id: s.id, 
          gridX: s.gridX, 
          gridZ: s.gridZ, 
          state: s.state,
          recipe: s.recipe,
          startTime: s.startTime,
          servingsLeft: s.servingsLeft,
        })),
        // Save counter dishes
        counters: gameState.counters.map(c => ({ 
          id: c.id, 
          gridX: c.gridX, 
          gridZ: c.gridZ, 
          dishes: c.dishes,
        })),
        // Save tables (customers will be cleared since they're transient)
        tables: gameState.tables.map(t => ({ 
          id: t.id, gridX: t.gridX, gridZ: t.gridZ, customer: null 
        })),
        // Save decorations
        decorations: gameState.decorations.map(d => ({
          id: d.id, type: d.type, gridX: d.gridX, gridZ: d.gridZ
        })),
      },
      // Save audio settings
      audioSettings: {
        masterEnabled: soundEnabled,
        soundToggles: soundToggles,
      },
    };
    
    const json = JSON.stringify(saveData);
    setSaveTextArea(json);
    setShowExportText(true);
    setSaveMessage({ type: 'success', text: 'Save generated! Copy the text below.' });
  };
  
  // Import save from textarea
  const handleImportSave = () => {
    try {
      if (!saveTextArea.trim()) {
        throw new Error('Paste save data first');
      }
      
      const saveData = JSON.parse(saveTextArea);
      
      // Validate save data
      if (!saveData.version || !saveData.gameState) {
        throw new Error('Invalid save format');
      }
      
      const gs = saveData.gameState;
      if (typeof gs.coins !== 'number' || typeof gs.level !== 'number') {
        throw new Error('Invalid save data');
      }
      
      // Load the save via dispatch
      dispatch({ type: 'LOAD_SAVE', payload: gs });
      
      // Restore audio settings if present
      if (saveData.audioSettings) {
        if (typeof saveData.audioSettings.masterEnabled === 'boolean') {
          setSoundEnabled(saveData.audioSettings.masterEnabled);
          audioEnabled = saveData.audioSettings.masterEnabled;
        }
        if (saveData.audioSettings.soundToggles) {
          const loadedToggles = { ...soundToggles, ...saveData.audioSettings.soundToggles };
          setSoundToggles(loadedToggles);
          Object.assign(soundTogglesGlobal, loadedToggles);
        }
      }
      
      setSaveMessage({ type: 'success', text: 'Game loaded successfully!' });
      setSaveTextArea('');
      setShowExportText(false);
      setTimeout(() => {
        setShowSettings(false);
        setSaveMessage(null);
      }, 1500);
    } catch (err) {
      setSaveMessage({ type: 'error', text: 'Failed: ' + err.message });
    }
  };
  
  // Calculate XP progress
  const prevLevelXp = XP_LEVELS[gameState.level - 1] || 0;
  const xpProgress = ((gameState.xp - prevLevelXp) / (currentLevelXp - prevLevelXp)) * 100;
  
  // Get total food available
  const totalFood = gameState.counters.reduce((sum, c) => sum + c.dishes.reduce((s, d) => s + d.servings, 0), 0);
  
  return (
    <div style={{ width: '100%', height: '100vh', position: 'relative', fontFamily: "'Segoe UI', sans-serif", overflow: 'hidden' }}>
      {/* CSS Animations */}
      <style>{`
        @keyframes pulse {
          0%, 100% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.05); }
        }
        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes jumpOut {
          0% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
          30% { transform: translateX(-50%) translateY(-20px) scale(1.2); opacity: 1; }
          100% { transform: translateX(-50%) translateY(-40px) scale(0.5); opacity: 0; }
        }
        @keyframes stomp {
          0%, 100% { transform: translateX(-50%) translateY(0) rotate(0deg); }
          25% { transform: translateX(-50%) translateY(2px) rotate(-5deg); }
          75% { transform: translateX(-50%) translateY(2px) rotate(5deg); }
        }
        @keyframes coinPop {
          0% { transform: scale(1); }
          50% { transform: scale(1.3); }
          100% { transform: scale(1); }
        }
        @keyframes coinFly {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(0.5); opacity: 0.8; }
        }
        @keyframes bounceIn {
          0% { transform: scale(0.5); opacity: 0; }
          60% { transform: scale(1.1); opacity: 1; }
          100% { transform: scale(1); }
        }
        @keyframes slideDown {
          0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
          60% { transform: translateX(-50%) translateY(5px); opacity: 1; }
          100% { transform: translateX(-50%) translateY(0); }
        }
      `}</style>
      
      {/* 3D Canvas */}
      <div 
        ref={containerRef} 
        onClick={handleClick}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onContextMenu={handleContextMenu}
        style={{ 
          width: '100%', 
          height: '100%', 
          cursor: isDragging ? 'grabbing' : 'pointer' 
        }}
      />
      
      {/* Header UI - Stats Only */}
      <div style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        padding: '12px 20px',
        background: 'linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        alignItems: 'center',
        gap: '15px',
        color: 'white',
      }}>
        {/* Cafe Name & Level */}
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '24px' }}>‚òï</span>
          <div>
            <div style={{ fontWeight: 'bold', fontSize: '18px' }}>Elly's Cafe</div>
            <div style={{ fontSize: '12px', opacity: 0.8 }}>Level {gameState.level}</div>
          </div>
        </div>
        
        {/* XP Bar */}
        <div style={{ flex: 1, maxWidth: '180px' }}>
          <div style={{ fontSize: '11px', marginBottom: '4px' }}>XP: {gameState.xp} / {currentLevelXp}</div>
          <div style={{ background: 'rgba(255,255,255,0.2)', borderRadius: '10px', height: '8px', overflow: 'hidden' }}>
            <div style={{ 
              width: `${Math.min(100, xpProgress)}%`, 
              height: '100%', 
              background: `linear-gradient(90deg, ${COLORS.ui.purple}, ${COLORS.ui.blue})`,
              borderRadius: '10px',
              transition: 'width 0.3s ease',
            }} />
          </div>
        </div>
        
        {/* Coins */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(255,215,0,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(255,215,0,0.3)',
          animation: coinPop ? 'coinPop 0.3s ease-out' : 'none',
        }}>
          <span style={{ fontSize: '18px' }}>ü™ô</span>
          <span style={{ fontWeight: 'bold', color: COLORS.ui.gold }}>{gameState.coins.toLocaleString()}</span>
        </div>
        
        {/* Buzz Rating */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(34,197,94,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(34,197,94,0.3)',
        }}>
          <span style={{ fontSize: '16px' }}>‚≠ê</span>
          <span style={{ fontWeight: 'bold', color: '#22c55e' }}>{gameState.buzz}</span>
        </div>
        
        {/* Food Ready */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(139,69,19,0.3)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(139,69,19,0.4)',
        }}>
          <span style={{ fontSize: '16px' }}>üçΩÔ∏è</span>
          <span style={{ fontWeight: 'bold' }}>{totalFood}</span>
        </div>
        
        {/* Spacer */}
        <div style={{ flex: 1 }} />
        
        {/* Time Display */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(0,0,0,0.3)',
          padding: '6px 12px',
          borderRadius: '20px',
        }}>
          <span style={{ fontSize: '16px' }}>
            {timeOfDay >= 5 && timeOfDay < 7 ? 'üåÖ' : 
             timeOfDay >= 7 && timeOfDay < 17 ? '‚òÄÔ∏è' : 
             timeOfDay >= 17 && timeOfDay < 19 ? 'üåá' : 'üåô'}
          </span>
          <span style={{ fontWeight: 'bold', fontSize: '13px' }}>
            {Math.floor(timeOfDay % 12 || 12)}:{String(Math.floor((timeOfDay % 1) * 60)).padStart(2, '0')} 
            {timeOfDay >= 12 ? ' PM' : ' AM'}
          </span>
        </div>
        
        {/* Auto-Serve Toggle */}
        <button
          onClick={() => setAutoServe(!autoServe)}
          style={{
            background: autoServe ? 'rgba(34, 197, 94, 0.4)' : 'rgba(0,0,0,0.3)',
            border: autoServe ? '1px solid rgba(34, 197, 94, 0.6)' : '1px solid rgba(255,255,255,0.2)',
            padding: '6px 10px',
            borderRadius: '20px',
            color: 'white',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '5px',
            fontSize: '12px',
          }}
          title={autoServe ? 'Chef is auto-serving customers' : 'Click to enable auto-serve'}
        >
          <span>üßë‚Äçüç≥</span>
          <span style={{ 
            width: '8px', 
            height: '8px', 
            borderRadius: '50%', 
            background: autoServe ? '#4ade80' : 'rgba(255,255,255,0.3)',
            boxShadow: autoServe ? '0 0 6px #4ade80' : 'none',
          }}></span>
        </button>
      </div>
      
      {/* Bottom Right Button Cluster */}
      <div style={{
        position: 'absolute',
        bottom: '20px',
        right: '20px',
        display: 'flex',
        flexDirection: 'column',
        gap: '8px',
        alignItems: 'flex-end',
      }}>
        {/* Camera Controls - Compact */}
        <div style={{
          display: 'flex',
          gap: '4px',
          background: 'rgba(0,0,0,0.5)',
          padding: '4px',
          borderRadius: '20px',
        }}>
          <button onClick={() => setCameraAngle(prev => prev + Math.PI/6)} style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: 'none', padding: '6px 10px', borderRadius: '15px', cursor: 'pointer' }} title="Rotate Left">‚Ü∫</button>
          <button onClick={() => { setCameraAngle(Math.PI / 4); setCameraPitch(0.6); }} style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: 'none', padding: '6px 10px', borderRadius: '15px', cursor: 'pointer', fontSize: '12px' }} title="Reset View">‚åÇ</button>
          <button onClick={() => setCameraAngle(prev => prev - Math.PI/6)} style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: 'none', padding: '6px 10px', borderRadius: '15px', cursor: 'pointer' }} title="Rotate Right">‚Üª</button>
          <div style={{ width: '1px', background: 'rgba(255,255,255,0.3)', margin: '4px 2px' }} />
          <button onClick={() => setZoomLevel(Math.max(0.5, zoomLevel - 0.25))} style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: 'none', padding: '6px 8px', borderRadius: '15px', cursor: zoomLevel > 0.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel > 0.5 ? 1 : 0.5 }} title="Zoom In">+</button>
          <button onClick={() => setZoomLevel(Math.min(1.5, zoomLevel + 0.25))} style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: 'none', padding: '6px 8px', borderRadius: '15px', cursor: zoomLevel < 1.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel < 1.5 ? 1 : 0.5 }} title="Zoom Out">-</button>
        </div>
        
        {/* Action Buttons Row */}
        <div style={{
          display: 'flex',
          gap: '8px',
        }}>
          {/* Shop Button */}
          <button
            onClick={() => setShowShop(true)}
            style={{
              background: COLORS.ui.green,
              color: 'white',
              border: 'none',
              padding: '10px 16px',
              borderRadius: '12px',
              fontWeight: 'bold',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            }}
          >
            üõí Shop
          </button>
          
          {/* Trophy Button */}
          <button
            onClick={() => setShowTrophies(true)}
            style={{
              background: 'linear-gradient(135deg, #9333ea, #7c3aed)',
              color: 'white',
              border: 'none',
              padding: '10px 14px',
              borderRadius: '12px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            }}
            title="Achievements"
          >
            üèÜ <span style={{ fontSize: '12px' }}>{gameState.achievements.length}/{Object.keys(ACHIEVEMENTS).length}</span>
          </button>
          
          {/* Settings/Save Button */}
          <button
            onClick={() => setShowSettings(true)}
            style={{
              background: 'rgba(255,255,255,0.15)',
              color: 'white',
              border: '1px solid rgba(255,255,255,0.2)',
              padding: '10px 14px',
              borderRadius: '12px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              backdropFilter: 'blur(4px)',
              boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            }}
            title="Save/Load Game"
          >
            üíæ
          </button>
          
          {/* Audio Settings Button */}
          <button
            onClick={() => setShowAudioSettings(true)}
            style={{
              background: soundEnabled ? 'rgba(59, 130, 246, 0.3)' : 'rgba(0,0,0,0.5)',
              color: 'white',
              border: '1px solid rgba(255,255,255,0.2)',
              padding: '10px 14px',
              borderRadius: '12px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              backdropFilter: 'blur(4px)',
              boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            }}
            title="Audio Settings"
          >
            {soundEnabled ? 'üîä' : 'üîá'}
          </button>
          
          {/* Avatar Customize Button */}
          <button
            onClick={() => setShowAvatarCustomize(true)}
            style={{
              background: 'linear-gradient(135deg, #F472B6, #EC4899)',
              color: 'white',
              border: 'none',
              padding: '10px 14px',
              borderRadius: '12px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
              boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            }}
            title="Customize Avatar"
          >
            üë©‚Äçüç≥
          </button>
        </div>
      </div>
      
      {/* Stove Status Indicators - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.stoves.map(stove => {
        const screenPos = projectedPositions[`stove_${stove.id}`];
        if (!screenPos) return null;
        
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (currentTime - stove.startTime) / 1000;
          const progress = Math.min(100, (elapsed / recipe.cookTime) * 100);
          const remaining = Math.max(0, recipe.cookTime - elapsed);
          
          return (
            <div key={stove.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              background: 'rgba(0,0,0,0.8)',
              padding: '6px 10px',
              borderRadius: '8px',
              color: 'white',
              fontSize: '11px',
              textAlign: 'center',
            }}>
              <div>{recipe.icon} {recipe.name}</div>
              <div style={{ 
                background: 'rgba(255,255,255,0.2)', 
                borderRadius: '4px', 
                height: '4px', 
                marginTop: '4px',
                overflow: 'hidden',
              }}>
                <div style={{ 
                  width: `${progress}%`, 
                  height: '100%', 
                  background: COLORS.ui.green,
                  transition: 'width 0.1s linear',
                }} />
              </div>
              <div style={{ marginTop: '2px', opacity: 0.8 }}>{Math.ceil(remaining)}s</div>
            </div>
          );
        }
        
        if (stove.state === 'ready') {
          const recipe = RECIPES[stove.recipe];
          const handleServeToCounter = () => {
            const counter = gameState.counters.find(c => c.dishes.length < 5);
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: stove.id, counterId: counter.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleServeToCounter}
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: COLORS.ui.green,
                padding: '8px 14px',
                borderRadius: '10px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                boxShadow: '0 2px 10px rgba(34, 197, 94, 0.5)',
                animation: 'pulse 1s infinite',
                border: 'none',
                cursor: 'pointer',
              }}>
              <div>{recipe.icon} READY!</div>
              <div style={{ fontSize: '10px', opacity: 0.9 }}>Click to serve ({stove.servingsLeft})</div>
            </button>
          );
        }
        
        if (stove.state === 'spoiled') {
          const handleClean = () => {
            if (gameState.coins >= 15) {
              dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: stove.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleClean}
              disabled={gameState.coins < 15}
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: COLORS.ui.red,
                padding: '8px 14px',
                borderRadius: '10px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                boxShadow: '0 2px 10px rgba(239, 68, 68, 0.5)',
                border: 'none',
                cursor: gameState.coins >= 15 ? 'pointer' : 'not-allowed',
                opacity: gameState.coins >= 15 ? 1 : 0.7,
              }}>
              <div>üóëÔ∏è SPOILED!</div>
              <div style={{ fontSize: '10px', opacity: 0.9 }}>Click to clean (15ü™ô)</div>
            </button>
          );
        }
        
        return null;
      })}
      
      {/* Counter Food Labels - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.counters.map(counter => {
        if (counter.dishes.length === 0) return null;
        const screenPos = projectedPositions[`counter_${counter.id}`];
        if (!screenPos) return null;
        const totalServings = counter.dishes.reduce((sum, d) => sum + d.servings, 0);
        const mainDish = counter.dishes[0];
        const recipe = RECIPES[mainDish.recipe];
        
        return (
          <div key={counter.id} style={{
            position: 'absolute',
            left: `${screenPos.x}%`,
            top: `${screenPos.y}%`,
            transform: 'translate(-50%, -100%)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
          }}>
            <div style={{
              background: 'rgba(46, 139, 87, 0.9)',
              padding: '4px 8px',
              borderRadius: '6px',
              color: 'white',
              fontSize: '11px',
              textAlign: 'center',
            }}>
              {recipe.icon} {totalServings}
            </div>
            <button
              onClick={() => setTrashConfirm({ counterId: counter.id, recipeName: recipe.name, servings: totalServings, icon: recipe.icon })}
              style={{
                background: 'rgba(239, 68, 68, 0.9)',
                border: 'none',
                borderRadius: '4px',
                padding: '3px 5px',
                cursor: 'pointer',
                fontSize: '10px',
                color: 'white',
              }}
              title={`Trash ${totalServings} ${recipe.name}`}
            >
              üóëÔ∏è
            </button>
          </div>
        );
      })}
      
      {/* Customer Status Indicators - CLICKABLE - hidden while dragging */}
      {!isDragging && gameState.tables.map(table => {
        if (!table.customer) return null;
        const screenPos = projectedPositions[`table_${table.id}`];
        if (!screenPos) return null;
        
        if (table.customer.state === 'waiting') {
          const patience = table.customer.patience;
          const barColor = patience > 60 ? COLORS.ui.green : patience > 30 ? '#eab308' : COLORS.ui.red;
          const hasFood = totalFood > 0;
          
          // Dynamic emoji based on patience
          const emoji = patience > 60 ? 'üòä' : patience > 30 ? 'üòê' : 'üò†';
          
          const handleServe = () => {
            if (hasFood) {
              const counter = gameState.counters.find(c => c.dishes.length > 0);
              if (counter) {
                dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId: table.id, counterId: counter.id } });
                SFX.customerServed();
              }
            }
          };
          
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              textAlign: 'center',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: '2px',
            }}>
              {/* Always show emoji */}
              <div style={{ 
                fontSize: '22px', 
                transition: 'transform 0.2s ease',
                transform: patience < 30 ? 'scale(1.2)' : 'scale(1)',
                filter: patience < 30 ? 'drop-shadow(0 0 4px red)' : 'none',
              }}>{emoji}</div>
              
              {/* SERVE button when food available */}
              {hasFood && (
                <button
                  onClick={handleServe}
                  style={{
                    background: COLORS.ui.green,
                    color: 'white',
                    border: 'none',
                    padding: '4px 10px',
                    borderRadius: '6px',
                    fontWeight: 'bold',
                    fontSize: '11px',
                    cursor: 'pointer',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
                  }}
                >
                  üçΩÔ∏è SERVE
                </button>
              )}
              
              {/* Patience bar */}
              <div style={{ 
                width: '50px',
                background: 'rgba(0,0,0,0.5)', 
                borderRadius: '4px', 
                height: '6px',
                overflow: 'hidden',
              }}>
                <div style={{ 
                  width: `${patience}%`, 
                  height: '100%', 
                  background: barColor,
                  transition: 'width 0.1s linear, background 0.3s ease',
                }} />
              </div>
            </div>
          );
        }
        
        if (table.customer.state === 'eating') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              textAlign: 'center',
              animation: 'bounce 0.5s infinite',
            }}>
              <div style={{ fontSize: '24px' }}>üòãüç¥</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingHappy') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              textAlign: 'center',
              animation: 'jumpOut 0.8s ease-out forwards',
            }}>
              <div style={{ fontSize: '28px' }}>üòÑ</div>
              <div style={{ fontSize: '14px', color: COLORS.ui.green, fontWeight: 'bold', textShadow: '0 1px 2px rgba(0,0,0,0.5)' }}>+$</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingAngry') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              textAlign: 'center',
              animation: 'stomp 0.2s ease-in-out 4',
            }}>
              <div style={{ fontSize: '28px' }}>üò°</div>
              <div style={{ fontSize: '14px', color: COLORS.ui.red, fontWeight: 'bold', textShadow: '0 1px 2px rgba(0,0,0,0.5)' }}>-‚≠ê</div>
            </div>
          );
        }
        
        return null;
      })}
      
      {/* Flying Coins Animation */}
      {flyingCoins.filter(coin => {
        const elapsed = (currentTime - coin.startTime) / 1000;
        return elapsed < 0.85; // Keep coins that haven't finished
      }).map(coin => {
        const elapsed = (currentTime - coin.startTime) / 1000;
        const duration = 0.8;
        const progress = Math.min(1, elapsed / duration);
        
        // Ease out curve for smooth deceleration
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        // Calculate position (fly from table to header coin area)
        const targetX = 42; // Approximate header coin position %
        const targetY = 3;  // Top of screen %
        const currentX = coin.startX + (targetX - coin.startX) * easeOut;
        const currentY = coin.startY + (targetY - coin.startY) * easeOut;
        
        // Arc effect - rise up in an arc
        const arcHeight = -12 * Math.sin(progress * Math.PI);
        
        return (
          <div
            key={coin.id}
            style={{
              position: 'absolute',
              left: `${currentX}%`,
              top: `${currentY + arcHeight}%`,
              transform: 'translate(-50%, -50%)',
              fontSize: '24px',
              pointerEvents: 'none',
              zIndex: 200,
              opacity: 1 - progress * 0.3,
              filter: `drop-shadow(0 2px 4px rgba(0,0,0,0.3))`,
            }}
          >
            ü™ô
          </div>
        );
      })}
      
      {/* Stats Footer */}
      <div style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: '10px 20px',
        background: 'linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        justifyContent: 'center',
        gap: '30px',
        color: 'white',
        fontSize: '13px',
      }}>
        <div>üç≥ Dishes: {gameState.stats.dishesCooked}</div>
        <div>üòä Served: {gameState.stats.customersServed}</div>
        <div>üí∞ Earned: ${gameState.stats.totalEarned}</div>
      </div>
      
      {/* Recipe Selection Modal */}
      {selectedStove && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 100,
        }} onClick={() => setSelectedStove(null)}>
          <div style={{
            background: 'white',
            borderRadius: '16px',
            padding: '20px',
            maxWidth: '450px',
            width: '90%',
            maxHeight: '80vh',
            overflow: 'auto',
          }} onClick={e => e.stopPropagation()}>
            <h2 style={{ margin: '0 0 15px', textAlign: 'center' }}>üìñ Recipe Book</h2>
            <div style={{ display: 'grid', gap: '10px' }}>
              {Object.entries(RECIPES).map(([key, recipe]) => {
                const totalRevenue = recipe.servings * recipe.revenue;
                const profit = totalRevenue - recipe.cost;
                const profitPercent = ((profit / recipe.cost) * 100).toFixed(0);
                const isUnlocked = recipe.level <= gameState.level;
                const canAfford = gameState.coins >= recipe.cost;
                
                if (!isUnlocked) {
                  return (
                    <div
                      key={key}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '12px',
                        padding: '12px',
                        border: '2px dashed #ccc',
                        borderRadius: '10px',
                        background: '#f9f9f9',
                        opacity: 0.7,
                      }}
                    >
                      <div style={{ position: 'relative' }}>
                        <span style={{ fontSize: '32px', filter: 'grayscale(1) brightness(1.2)' }}>{recipe.icon}</span>
                        <span style={{ 
                          position: 'absolute', 
                          bottom: -2, 
                          right: -2, 
                          fontSize: '16px',
                          background: '#666',
                          borderRadius: '50%',
                          padding: '2px',
                        }}>üîí</span>
                      </div>
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: 'bold', color: '#666' }}>{recipe.name}</div>
                        <div style={{ fontSize: '12px', color: '#999' }}>
                          üîì Unlocks at Level {recipe.level}
                        </div>
                      </div>
                      <div style={{ 
                        background: '#eee', 
                        padding: '4px 10px', 
                        borderRadius: '12px',
                        fontSize: '12px',
                        color: '#666',
                      }}>
                        Lv.{recipe.level}
                      </div>
                    </div>
                  );
                }
                
                const isNew = recipe.level === gameState.level && recipe.level > 1;
                
                return (
                  <button
                    key={key}
                    onClick={() => handleRecipeSelect(key)}
                    disabled={!canAfford}
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '12px',
                      padding: '12px',
                      border: `2px solid ${isNew ? '#f59e0b' : canAfford ? '#22c55e' : '#e0e0e0'}`,
                      borderRadius: '10px',
                      background: isNew ? '#fffbeb' : canAfford ? '#f0fdf4' : '#f5f5f5',
                      cursor: canAfford ? 'pointer' : 'not-allowed',
                      opacity: canAfford ? 1 : 0.6,
                      textAlign: 'left',
                      transition: 'all 0.2s ease',
                      position: 'relative',
                    }}
                  >
                    {isNew && (
                      <div style={{
                        position: 'absolute',
                        top: -8,
                        right: -8,
                        background: '#f59e0b',
                        color: 'white',
                        fontSize: '10px',
                        fontWeight: 'bold',
                        padding: '2px 6px',
                        borderRadius: '8px',
                        animation: 'pulse 1s infinite',
                      }}>
                        NEW!
                      </div>
                    )}
                    <span style={{ fontSize: '36px' }}>{recipe.icon}</span>
                    <div style={{ flex: 1 }}>
                      <div style={{ fontWeight: 'bold', fontSize: '15px' }}>{recipe.name}</div>
                      <div style={{ fontSize: '12px', color: '#666', marginTop: '2px' }}>
                        ‚è±Ô∏è {recipe.cookTime}s ‚Ä¢ üçΩÔ∏è {recipe.servings} servings
                      </div>
                      <div style={{ 
                        fontSize: '11px', 
                        color: '#888', 
                        marginTop: '4px',
                        display: 'flex',
                        gap: '8px',
                        flexWrap: 'wrap',
                      }}>
                        <span>üíµ ${recipe.revenue}/serving</span>
                        <span>üìä ${totalRevenue} total</span>
                      </div>
                    </div>
                    <div style={{ textAlign: 'right', minWidth: '80px' }}>
                      <div style={{ fontWeight: 'bold', color: '#d97706', fontSize: '14px' }}>
                        ü™ô {recipe.cost}
                      </div>
                      <div style={{ 
                        fontSize: '12px', 
                        color: profit > 0 ? '#22c55e' : '#ef4444',
                        fontWeight: 'bold',
                      }}>
                        {profit > 0 ? 'üìà' : 'üìâ'} ${profit} profit
                      </div>
                      <div style={{ fontSize: '10px', color: '#8b5cf6', marginTop: '2px' }}>
                        ‚≠ê +{recipe.xp} XP
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
            <div style={{ 
              marginTop: '15px', 
              padding: '10px', 
              background: '#f0f9ff', 
              borderRadius: '8px',
              fontSize: '11px',
              color: '#0369a1',
              textAlign: 'center',
            }}>
              üí° Tip: Higher profit dishes take longer to cook but earn more per batch!
            </div>
          </div>
        </div>
      )}
      
      {/* Decoration Placement Mode UI - Only when shop is closed */}
      {placingDecoration && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #e8f5e9, #c8e6c9)',
          borderTop: '3px solid #4CAF50',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {DECORATIONS[placingDecoration].icon}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#2e7d32' }}>
              Placing: {DECORATIONS[placingDecoration].name}
            </div>
            <div style={{ fontSize: '13px', color: '#558b2f' }}>
              {DECORATIONS[placingDecoration].category === 'wall' 
                ? 'Click near any wall to hang'
                : 'Click on the dining floor to place'}
            </div>
          </div>
          <button
            onClick={() => setPlacingDecoration(null)}
            style={{
              background: '#f44336',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            ‚úï Cancel
          </button>
        </div>
      )}
      
      {/* Equipment Placement Mode UI - Only when shop is closed */}
      {placingEquipment && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #fff3e0, #ffe0b2)',
          borderTop: '3px solid #FF9800',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {placingEquipment === 'stove' ? 'üî•' : placingEquipment === 'counter' ? 'üçΩÔ∏è' : 'ü™ë'}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#e65100' }}>
              Placing: {placingEquipment === 'stove' ? 'Stove' : placingEquipment === 'counter' ? 'Counter' : 'Table'}
            </div>
            <div style={{ fontSize: '13px', color: '#f57c00' }}>
              {placingEquipment === 'table' 
                ? 'Click in the DINING area (wood floor)'
                : 'Click in the KITCHEN area (white tiles)'}
            </div>
          </div>
          <button
            onClick={() => setPlacingEquipment(null)}
            style={{
              background: '#f44336',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            ‚úï Cancel
          </button>
        </div>
      )}
      
      {/* Shop Bottom Bar - Cafe World Style */}
      {showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #f5e6d3, #e8d4be)',
          borderTop: '3px solid #8B4513',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.3)',
        }}>
          {/* Category Tabs */}
          <div style={{
            display: 'flex',
            gap: '5px',
            padding: '8px 10px 0',
            borderBottom: '2px solid #d4c4a8',
          }}>
            {[
              { id: 'equipment', icon: 'üî•', label: 'Equipment' },
              { id: 'tables', icon: 'ü™ë', label: 'Tables' },
              { id: 'decor', icon: 'üå∏', label: 'Decor' },
            ].map(cat => (
              <button
                key={cat.id}
                onClick={() => setShopCategory(cat.id)}
                style={{
                  padding: '8px 16px',
                  border: 'none',
                  borderRadius: '8px 8px 0 0',
                  background: shopCategory === cat.id ? '#fff' : 'transparent',
                  cursor: 'pointer',
                  fontWeight: shopCategory === cat.id ? 'bold' : 'normal',
                  color: shopCategory === cat.id ? '#8B4513' : '#666',
                  borderBottom: shopCategory === cat.id ? '2px solid #fff' : 'none',
                  marginBottom: '-2px',
                  fontSize: '14px',
                }}
              >
                {cat.icon} {cat.label}
              </button>
            ))}
            
            {/* Close button */}
            <button
              onClick={() => {
                setShowShop(false);
                setPlacingEquipment(null);
                setPlacingDecoration(null);
              }}
              style={{
                marginLeft: 'auto',
                padding: '8px 16px',
                border: 'none',
                borderRadius: '8px',
                background: '#4CAF50',
                color: 'white',
                cursor: 'pointer',
                fontWeight: 'bold',
                fontSize: '16px',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
              }}
            >
              ‚úì Done
            </button>
          </div>
          
          {/* Placement Hint - shown when an item is selected */}
          {(placingEquipment || placingDecoration) && (
            <div style={{
              background: '#e8f5e9',
              padding: '8px 15px',
              textAlign: 'center',
              borderTop: '1px solid #c8e6c9',
              color: '#2e7d32',
              fontSize: '13px',
              fontWeight: 'bold',
            }}>
              {placingEquipment === 'stove' || placingEquipment === 'counter'
                ? 'üëÜ Click in the KITCHEN area to place'
                : 'üëÜ Click in the DINING area to place'}
              {' ‚Ä¢ '}
              <span style={{ fontWeight: 'normal' }}>Click item again to deselect, or Done when finished</span>
            </div>
          )}
          
          {/* Items Row */}
          <div style={{
            display: 'flex',
            gap: '10px',
            padding: '15px',
            overflowX: 'auto',
            background: 'rgba(255, 248, 240, 0.95)',
          }}>
            {/* Equipment Category */}
            {shopCategory === 'equipment' && (
              <>
                <div
                  onClick={() => {
                    if (gameState.coins >= 500 && gameState.stoves.length < 3) {
                      setPlacingEquipment(placingEquipment === 'stove' ? null : 'stove');
                      setPlacingDecoration(null);
                    }
                  }}
                  style={{
                    minWidth: '100px',
                    padding: '10px',
                    border: placingEquipment === 'stove' ? '3px solid #4CAF50' : '2px solid #ddd',
                    borderRadius: '10px',
                    background: placingEquipment === 'stove' ? '#e8f5e9' : (gameState.coins >= 500 && gameState.stoves.length < 3 ? '#fffaf5' : '#f0f0f0'),
                    cursor: gameState.coins >= 500 && gameState.stoves.length < 3 ? 'pointer' : 'not-allowed',
                    opacity: gameState.coins >= 500 && gameState.stoves.length < 3 ? 1 : 0.5,
                    textAlign: 'center',
                    transition: 'all 0.15s',
                    transform: placingEquipment === 'stove' ? 'scale(1.05)' : 'scale(1)',
                  }}
                >
                  <div style={{ fontSize: '36px', marginBottom: '5px' }}>üî•</div>
                  <div style={{ fontSize: '12px', fontWeight: 'bold' }}>Stove</div>
                  <div style={{ fontSize: '10px', color: '#666' }}>{gameState.stoves.length}/3</div>
                  <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô 500</div>
                </div>
                
                <div
                  onClick={() => {
                    if (gameState.coins >= 400 && gameState.counters.length < 3) {
                      setPlacingEquipment(placingEquipment === 'counter' ? null : 'counter');
                      setPlacingDecoration(null);
                    }
                  }}
                  style={{
                    minWidth: '100px',
                    padding: '10px',
                    border: placingEquipment === 'counter' ? '3px solid #4CAF50' : '2px solid #ddd',
                    borderRadius: '10px',
                    background: placingEquipment === 'counter' ? '#e8f5e9' : (gameState.coins >= 400 && gameState.counters.length < 3 ? '#fffaf5' : '#f0f0f0'),
                    cursor: gameState.coins >= 400 && gameState.counters.length < 3 ? 'pointer' : 'not-allowed',
                    opacity: gameState.coins >= 400 && gameState.counters.length < 3 ? 1 : 0.5,
                    textAlign: 'center',
                    transition: 'all 0.15s',
                    transform: placingEquipment === 'counter' ? 'scale(1.05)' : 'scale(1)',
                  }}
                >
                  <div style={{ fontSize: '36px', marginBottom: '5px' }}>üçΩÔ∏è</div>
                  <div style={{ fontSize: '12px', fontWeight: 'bold' }}>Counter</div>
                  <div style={{ fontSize: '10px', color: '#666' }}>{gameState.counters.length}/3</div>
                  <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô 400</div>
                </div>
              </>
            )}
            
            {/* Tables Category */}
            {shopCategory === 'tables' && (
              <div
                onClick={() => {
                  if (gameState.coins >= 300 && gameState.tables.length < 15) {
                    setPlacingEquipment(placingEquipment === 'table' ? null : 'table');
                    setPlacingDecoration(null);
                  }
                }}
                style={{
                  minWidth: '100px',
                  padding: '10px',
                  border: placingEquipment === 'table' ? '3px solid #4CAF50' : '2px solid #ddd',
                  borderRadius: '10px',
                  background: placingEquipment === 'table' ? '#e8f5e9' : (gameState.coins >= 300 && gameState.tables.length < 15 ? '#fffaf5' : '#f0f0f0'),
                  cursor: gameState.coins >= 300 && gameState.tables.length < 15 ? 'pointer' : 'not-allowed',
                  opacity: gameState.coins >= 300 && gameState.tables.length < 15 ? 1 : 0.5,
                  textAlign: 'center',
                  transition: 'all 0.15s',
                  transform: placingEquipment === 'table' ? 'scale(1.05)' : 'scale(1)',
                }}
              >
                <div style={{ fontSize: '36px', marginBottom: '5px' }}>ü™ë</div>
                <div style={{ fontSize: '12px', fontWeight: 'bold' }}>Table</div>
                <div style={{ fontSize: '10px', color: '#666' }}>{gameState.tables.length}/15</div>
                <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô 300</div>
              </div>
            )}
            
            {/* Decor Category */}
            {shopCategory === 'decor' && (
              <>
                {Object.entries(DECORATIONS).map(([key, decor]) => (
                  <div
                    key={key}
                    onClick={() => {
                      if (gameState.coins >= decor.cost) {
                        setPlacingDecoration(placingDecoration === key ? null : key);
                        setPlacingEquipment(null);
                      }
                    }}
                    style={{
                      minWidth: '100px',
                      padding: '10px',
                      border: placingDecoration === key ? '3px solid #4CAF50' : '2px solid #ddd',
                      borderRadius: '10px',
                      background: placingDecoration === key ? '#e8f5e9' : (gameState.coins >= decor.cost ? '#fffaf5' : '#f0f0f0'),
                      cursor: gameState.coins >= decor.cost ? 'pointer' : 'not-allowed',
                      opacity: gameState.coins >= decor.cost ? 1 : 0.5,
                      textAlign: 'center',
                      transition: 'all 0.15s',
                      transform: placingDecoration === key ? 'scale(1.05)' : 'scale(1)',
                    }}
                  >
                    <div style={{ fontSize: '36px', marginBottom: '5px' }}>{decor.icon}</div>
                    <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{decor.name}</div>
                    <div style={{ fontSize: '10px', color: '#22c55e' }}>+{decor.buzz} Buzz</div>
                    <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {decor.cost}</div>
                  </div>
                ))}
              </>
            )}
          </div>
        </div>
      )}
      
      {/* Settings/Save Modal */}
      {showSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 100,
        }} onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}>
          <div style={{
            background: 'white',
            borderRadius: '16px',
            padding: '20px',
            maxWidth: '400px',
            width: '90%',
          }} onClick={e => e.stopPropagation()}>
            <h2 style={{ margin: '0 0 15px', textAlign: 'center' }}>üíæ Save / Load</h2>
            
            {saveMessage && (
              <div style={{
                marginBottom: '15px',
                padding: '10px',
                borderRadius: '8px',
                background: saveMessage.type === 'success' ? '#dcfce7' : '#fef2f2',
                color: saveMessage.type === 'success' ? '#166534' : '#991b1b',
                textAlign: 'center',
                fontSize: '14px',
              }}>
                {saveMessage.type === 'success' ? '‚úÖ' : '‚ùå'} {saveMessage.text}
              </div>
            )}
            
            <div style={{ display: 'grid', gap: '10px' }}>
              <button
                onClick={handleExportSave}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '12px',
                  border: '2px solid #22c55e',
                  borderRadius: '10px',
                  background: '#f0fdf4',
                  cursor: 'pointer',
                }}
              >
                <span style={{ fontSize: '24px' }}>üì§</span>
                <div style={{ flex: 1, textAlign: 'left' }}>
                  <div style={{ fontWeight: 'bold' }}>Export Save</div>
                  <div style={{ fontSize: '11px', color: '#666' }}>Generate save data to copy</div>
                </div>
              </button>
              
              {showExportText && (
                <div style={{ position: 'relative' }}>
                  <textarea
                    value={saveTextArea}
                    readOnly
                    onClick={(e) => e.target.select()}
                    style={{
                      width: '100%',
                      height: '60px',
                      padding: '8px',
                      border: '2px solid #22c55e',
                      borderRadius: '8px',
                      fontFamily: 'monospace',
                      fontSize: '10px',
                      resize: 'none',
                      background: '#f0fdf4',
                    }}
                  />
                  <div style={{ fontSize: '11px', color: '#666', marginTop: '4px' }}>
                    üëÜ Click to select, then Ctrl+C / Cmd+C to copy
                  </div>
                </div>
              )}
              
              <div style={{ borderTop: '1px solid #e0e0e0', margin: '5px 0' }} />
              
              <div style={{ fontSize: '12px', color: '#666', textAlign: 'center' }}>
                To load: paste save data below, then click Import
              </div>
              
              <textarea
                value={showExportText ? '' : saveTextArea}
                onChange={(e) => { setSaveTextArea(e.target.value); setShowExportText(false); }}
                placeholder="Paste your save data here..."
                style={{
                  width: '100%',
                  height: '60px',
                  padding: '8px',
                  border: '2px solid #3b82f6',
                  borderRadius: '8px',
                  fontFamily: 'monospace',
                  fontSize: '10px',
                  resize: 'none',
                }}
              />
              
              <button
                onClick={handleImportSave}
                disabled={!saveTextArea.trim() || showExportText}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  padding: '12px',
                  border: 'none',
                  borderRadius: '10px',
                  background: (!saveTextArea.trim() || showExportText) ? '#e0e0e0' : '#3b82f6',
                  color: 'white',
                  cursor: (!saveTextArea.trim() || showExportText) ? 'not-allowed' : 'pointer',
                  fontWeight: 'bold',
                }}
              >
                <span>üì•</span> Import Save
              </button>
            </div>
            
            <div style={{
              marginTop: '15px',
              padding: '10px',
              background: '#f8fafc',
              borderRadius: '8px',
              fontSize: '11px',
              color: '#64748b',
            }}>
              <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>üìä Current Progress:</div>
              <div>Level {gameState.level} ‚Ä¢ {gameState.coins.toLocaleString()} coins ‚Ä¢ {gameState.stats.customersServed} served</div>
              <div>{gameState.stoves.length} stoves ‚Ä¢ {gameState.counters.length} counters ‚Ä¢ {gameState.tables.length} tables</div>
            </div>
            
            <button
              onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}
              style={{
                width: '100%',
                marginTop: '15px',
                padding: '10px',
                border: 'none',
                borderRadius: '8px',
                background: '#f0f0f0',
                cursor: 'pointer',
              }}
            >
              Close
            </button>
          </div>
        </div>
      )}
      
      {/* Level Up Celebration */}
      {showLevelUp && (() => {
        const unlockedRecipe = Object.values(RECIPES).find(r => r.level === gameState.level);
        return (
          <div style={{
            position: 'absolute',
            inset: 0,
            background: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 100,
            animation: 'fadeIn 0.3s ease',
          }}>
            <div style={{
              background: 'linear-gradient(135deg, #ffd700, #ffec8b)',
              borderRadius: '20px',
              padding: '30px 50px',
              textAlign: 'center',
              boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
              animation: 'bounceIn 0.5s ease',
            }}>
              <div style={{ fontSize: '48px', marginBottom: '10px' }}>üéâ</div>
              <h2 style={{ margin: '0 0 10px', color: '#8b4513' }}>Level Up!</h2>
              <div style={{ fontSize: '36px', fontWeight: 'bold', color: '#8b4513' }}>Level {gameState.level}</div>
              <div style={{ marginTop: '10px', color: '#a0522d' }}>+1000 coins bonus!</div>
              {unlockedRecipe && (
                <div style={{ 
                  marginTop: '15px', 
                  padding: '10px 15px',
                  background: 'rgba(255,255,255,0.5)',
                  borderRadius: '10px',
                }}>
                  <div style={{ fontSize: '12px', color: '#666' }}>üîì New Recipe Unlocked!</div>
                  <div style={{ fontSize: '24px', marginTop: '5px' }}>
                    {unlockedRecipe.icon} {unlockedRecipe.name}
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      })()}
      
      {/* Achievement Unlocked Popup */}
      {showAchievement && (
        <div style={{
          position: 'absolute',
          top: '100px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'linear-gradient(135deg, #9333ea, #7c3aed)',
          borderRadius: '15px',
          padding: '20px 30px',
          textAlign: 'center',
          boxShadow: '0 8px 32px rgba(147, 51, 234, 0.4)',
          zIndex: 110,
          animation: 'slideDown 0.5s ease',
          border: '2px solid rgba(255,255,255,0.3)',
        }}>
          <div style={{ fontSize: '14px', color: 'rgba(255,255,255,0.8)', marginBottom: '5px' }}>
            üèÜ Achievement Unlocked!
          </div>
          <div style={{ fontSize: '36px', marginBottom: '5px' }}>{showAchievement.icon}</div>
          <div style={{ fontSize: '20px', fontWeight: 'bold', color: 'white', marginBottom: '5px' }}>
            {showAchievement.name}
          </div>
          <div style={{ fontSize: '12px', color: 'rgba(255,255,255,0.7)', marginBottom: '8px' }}>
            {showAchievement.description}
          </div>
          <div style={{ 
            fontSize: '14px', 
            color: '#ffd700', 
            fontWeight: 'bold',
            background: 'rgba(0,0,0,0.2)',
            padding: '4px 12px',
            borderRadius: '10px',
            display: 'inline-block',
          }}>
            +{showAchievement.reward} ü™ô
          </div>
        </div>
      )}
      
      {/* Trophies Panel */}
      {showTrophies && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1a1a2e, #16213e)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '500px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: '#ffd700', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>üèÜ</span> Achievements
              </h2>
              <button
                onClick={() => setShowTrophies(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            <div style={{ 
              color: 'rgba(255,255,255,0.6)', 
              marginBottom: '15px',
              fontSize: '14px',
            }}>
              {gameState.achievements.length} of {Object.keys(ACHIEVEMENTS).length} unlocked
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
              {Object.values(ACHIEVEMENTS).map(ach => {
                const unlocked = gameState.achievements.includes(ach.id);
                return (
                  <div key={ach.id} style={{
                    background: unlocked 
                      ? 'linear-gradient(135deg, rgba(147, 51, 234, 0.3), rgba(124, 58, 237, 0.2))'
                      : 'rgba(255,255,255,0.05)',
                    borderRadius: '12px',
                    padding: '12px 15px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '12px',
                    border: unlocked ? '1px solid rgba(147, 51, 234, 0.5)' : '1px solid rgba(255,255,255,0.1)',
                    opacity: unlocked ? 1 : 0.5,
                  }}>
                    <div style={{ 
                      fontSize: '28px',
                      filter: unlocked ? 'none' : 'grayscale(1)',
                    }}>
                      {ach.icon}
                    </div>
                    <div style={{ flex: 1 }}>
                      <div style={{ 
                        color: unlocked ? 'white' : 'rgba(255,255,255,0.5)', 
                        fontWeight: 'bold',
                        fontSize: '14px',
                      }}>
                        {ach.name}
                      </div>
                      <div style={{ 
                        color: 'rgba(255,255,255,0.5)', 
                        fontSize: '12px',
                      }}>
                        {ach.description}
                      </div>
                    </div>
                    <div style={{ 
                      color: unlocked ? '#ffd700' : 'rgba(255,255,255,0.3)',
                      fontSize: '12px',
                      fontWeight: 'bold',
                    }}>
                      {unlocked ? '‚úì' : `+${ach.reward} ü™ô`}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}
      
      {/* Audio Settings Panel */}
      {showAudioSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '450px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>üîä</span> Audio Settings
              </h2>
              <button
                onClick={() => setShowAudioSettings(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            {/* Master Toggle */}
            <div style={{
              background: soundEnabled ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255,255,255,0.05)',
              borderRadius: '12px',
              padding: '12px 15px',
              marginBottom: '15px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              border: soundEnabled ? '1px solid rgba(34, 197, 94, 0.4)' : '1px solid rgba(255,255,255,0.1)',
            }}>
              <div style={{ color: 'white', fontWeight: 'bold' }}>üîä Master Volume</div>
              <button
                onClick={() => setSoundEnabled(!soundEnabled)}
                style={{
                  background: soundEnabled ? '#22c55e' : '#666',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '6px 16px',
                  color: 'white',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                }}
              >
                {soundEnabled ? 'ON' : 'OFF'}
              </button>
            </div>
            
            <div style={{ color: 'rgba(255,255,255,0.5)', fontSize: '12px', marginBottom: '10px' }}>
              Individual Sounds (click üîà to preview)
            </div>
            
            {/* Individual Sound Toggles */}
            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
              {[
                { key: 'cooking', name: 'Cooking Sizzle', icon: 'üî•', sfx: () => SFX.cookStart() },
                { key: 'foodReady', name: 'Food Ready', icon: '‚ú®', sfx: () => SFX.foodReady() },
                { key: 'foodSpoiled', name: 'Food Spoiled', icon: 'üí®', sfx: () => SFX.foodSpoiled() },
                { key: 'customerArrive', name: 'Customer Arrives', icon: 'üö™', sfx: () => SFX.customerArrive() },
                { key: 'customerServed', name: 'Customer Served', icon: 'üçΩÔ∏è', sfx: () => SFX.customerServed() },
                { key: 'customerHappy', name: 'Customer Happy', icon: 'üòä', sfx: () => SFX.customerHappy() },
                { key: 'customerAngry', name: 'Customer Angry', icon: 'üò†', sfx: () => SFX.customerAngry() },
                { key: 'coins', name: 'Coins', icon: 'üí∞', sfx: () => SFX.coinEarn() },
                { key: 'purchase', name: 'Purchase', icon: 'üõí', sfx: () => SFX.purchase() },
                { key: 'levelUp', name: 'Level Up', icon: 'üéâ', sfx: () => SFX.levelUp() },
                { key: 'achievement', name: 'Achievement', icon: 'üèÜ', sfx: () => SFX.achievement() },
              ].map(sound => (
                <div key={sound.key} style={{
                  background: 'rgba(255,255,255,0.05)',
                  borderRadius: '10px',
                  padding: '10px 12px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '10px',
                  border: '1px solid rgba(255,255,255,0.1)',
                }}>
                  <span style={{ fontSize: '18px', width: '24px' }}>{sound.icon}</span>
                  <span style={{ flex: 1, color: 'white', fontSize: '13px' }}>{sound.name}</span>
                  
                  {/* Sample Button - works even if sound is toggled off, for testing */}
                  <button
                    onClick={() => {
                      if (soundEnabled) {
                        // Temporarily enable this sound for preview
                        const oldValue = soundTogglesGlobal[sound.key];
                        soundTogglesGlobal[sound.key] = true;
                        sound.sfx();
                        // Restore after sounds complete
                        setTimeout(() => { soundTogglesGlobal[sound.key] = oldValue; }, 1500);
                      }
                    }}
                    style={{
                      background: 'rgba(59, 130, 246, 0.3)',
                      border: 'none',
                      borderRadius: '6px',
                      padding: '4px 8px',
                      color: 'white',
                      cursor: soundEnabled ? 'pointer' : 'not-allowed',
                      fontSize: '12px',
                      opacity: soundEnabled ? 1 : 0.4,
                    }}
                    title="Preview sound"
                  >
                    üîà
                  </button>
                  
                  {/* Toggle Button */}
                  <button
                    onClick={() => {
                      const newValue = !soundToggles[sound.key];
                      soundTogglesGlobal[sound.key] = newValue; // Sync immediately
                      setSoundToggles(prev => ({ ...prev, [sound.key]: newValue }));
                    }}
                    style={{
                      background: soundToggles[sound.key] ? '#22c55e' : '#666',
                      border: 'none',
                      borderRadius: '12px',
                      padding: '4px 10px',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '10px',
                      fontWeight: 'bold',
                      minWidth: '40px',
                    }}
                  >
                    {soundToggles[sound.key] ? 'ON' : 'OFF'}
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
      
      {/* Avatar Customization Panel */}
      {showAvatarCustomize && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.8)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 130,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '650px',
            maxHeight: '85vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>{gameState.avatar.gender === 'female' ? 'üë©‚Äçüç≥' : 'üë®‚Äçüç≥'}</span> Customize Your Chef
              </h2>
              <button
                onClick={() => setShowAvatarCustomize(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            {/* Main content: Preview + Options side by side */}
            <div style={{ display: 'flex', gap: '25px', flexWrap: 'wrap' }}>
              
              {/* Left: Preview */}
              <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 100%)',
                borderRadius: '16px',
                padding: '15px',
                minWidth: '180px',
              }}>
                <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '8px' }}>Preview</div>
                <canvas 
                  ref={avatarPreviewRef}
                  width={180}
                  height={220}
                  style={{
                    borderRadius: '12px',
                    background: 'radial-gradient(circle at 50% 80%, #4a6741 0%, #2d3a29 100%)',
                  }}
                />
                
                {/* Gender Toggle */}
                <div style={{ marginTop: '15px', width: '100%' }}>
                  <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '11px', marginBottom: '6px', textAlign: 'center' }}>
                    Gender
                  </div>
                  <div style={{ display: 'flex', gap: '6px' }}>
                    {AVATAR_OPTIONS.genders.map(g => (
                      <button
                        key={g.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'gender', value: g.id } })}
                        style={{
                          flex: 1,
                          padding: '8px',
                          borderRadius: '10px',
                          border: 'none',
                          background: gameState.avatar.gender === g.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.gender === g.id ? 'bold' : 'normal',
                          fontSize: '14px',
                        }}
                      >
                        {g.icon} {g.name}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              
              {/* Right: Options */}
              <div style={{ flex: 1, minWidth: '280px' }}>
                {/* Skin Tone */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üé® Skin Tone
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.skinTones.map(skin => (
                      <button
                        key={skin.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'skinTone', value: skin.id } })}
                        style={{
                          width: '38px',
                          height: '38px',
                          borderRadius: '8px',
                          border: gameState.avatar.skinTone === skin.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${skin.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.skinTone === skin.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={skin.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üíá Hair Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairColors.map(hair => (
                      <button
                        key={hair.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairColor', value: hair.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '50%',
                          border: gameState.avatar.hairColor === hair.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${hair.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.hairColor === hair.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={hair.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Style */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ‚úÇÔ∏è Hair Style
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairStyles.map(style => (
                      <button
                        key={style.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairStyle', value: style.id } })}
                        style={{
                          padding: '6px 12px',
                          borderRadius: '16px',
                          border: 'none',
                          background: gameState.avatar.hairStyle === style.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.hairStyle === style.id ? 'bold' : 'normal',
                          fontSize: '12px',
                        }}
                      >
                        {style.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {/* Apron Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üëï Apron Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.apronColors.map(apron => (
                      <button
                        key={apron.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'apronColor', value: apron.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.apronColor === apron.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${apron.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.apronColor === apron.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={apron.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Outfit Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ü•º Chef Coat Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.outfitColors.map(outfit => (
                      <button
                        key={outfit.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'outfitColor', value: outfit.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.outfitColor === outfit.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${outfit.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.outfitColor === outfit.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={outfit.name}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Done Button */}
            <button
              onClick={() => setShowAvatarCustomize(false)}
              style={{
                width: '100%',
                padding: '14px',
                borderRadius: '12px',
                border: 'none',
                background: 'linear-gradient(135deg, #F472B6, #EC4899)',
                color: 'white',
                fontSize: '16px',
                fontWeight: 'bold',
                cursor: 'pointer',
                marginTop: '15px',
              }}
            >
              ‚ú® Done!
            </button>
          </div>
        </div>
      )}
      
      {/* Instructions */}
      <div style={{
        position: 'absolute',
        bottom: '50px',
        left: '20px',
        background: 'rgba(0,0,0,0.6)',
        padding: '10px 15px',
        borderRadius: '10px',
        color: 'white',
        fontSize: '11px',
        maxWidth: '200px',
      }}>
        <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>How to Play:</div>
        <div>‚Ä¢ Click stove ‚Üí pick recipe</div>
        <div>‚Ä¢ Click green READY! ‚Üí serve to counter</div>
        <div>‚Ä¢ Click SERVE button ‚Üí feed customer</div>
        <div>‚Ä¢ Keep customers happy! ‚≠ê</div>
      </div>
      
      {/* Trash Confirmation Modal */}
      {trashConfirm && (
        <div style={{
          position: 'absolute',
          top: 0, left: 0, right: 0, bottom: 0,
          background: 'rgba(0,0,0,0.6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 150,
        }} onClick={() => setTrashConfirm(null)}>
          <div style={{
            background: 'white',
            padding: '24px',
            borderRadius: '16px',
            textAlign: 'center',
            maxWidth: '300px',
            boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
          }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: '48px', marginBottom: '12px' }}>üóëÔ∏è</div>
            <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>
              Trash Food?
            </div>
            <div style={{ fontSize: '14px', color: '#666', marginBottom: '20px' }}>
              Throw away {trashConfirm.servings} {trashConfirm.icon} {trashConfirm.recipeName}?
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={() => setTrashConfirm(null)}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: '2px solid #ccc',
                  background: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  dispatch({ type: 'TRASH_COUNTER', payload: { counterId: trashConfirm.counterId } });
                  setTrashConfirm(null);
                }}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: 'none',
                  background: '#ef4444',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                üóëÔ∏è Trash
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Toast Notification */}
      {saveMessage && !showSettings && (
        <div style={{
          position: 'absolute',
          top: '80px',
          left: '50%',
          transform: 'translateX(-50%)',
          padding: '12px 24px',
          borderRadius: '8px',
          background: saveMessage.type === 'success' ? '#22c55e' : '#ef4444',
          color: 'white',
          fontWeight: 'bold',
          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
          zIndex: 200,
          animation: 'fadeIn 0.3s ease-out',
        }}>
          {saveMessage.type === 'success' ? '‚úÖ' : '‚ùå'} {saveMessage.text}
        </div>
      )}
    </div>
  );
}

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<CafeWorld3D />);
  </script>
</body>
</html>
