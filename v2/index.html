<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cafe World 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    @keyframes bounce {
      0% { transform: scale(0); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @keyframes coinFloat {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Scrollbar styling */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; }
    ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.3); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.5); }
  </style>
  
  <!-- React and ReactDOM -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Babel for JSX transformation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    // React hooks from global React
    const { useEffect, useRef, useReducer, useState, useCallback, useMemo } = React;
    

// ============================================
// CONSTANTS & CONFIG
// ============================================
const COLORS = {
  floor: { wood: 0xd4a574, kitchen: 0xe8e8e8, tile1: 0xf5e6d3, tile2: 0xe8d4b8 },
  walls: { cream: 0xfff5e6, trim: 0x8b4513, window: 0x87ceeb },
  roof: { tiles: 0xb45309 },
  stove: { body: 0x505050, burnerOff: 0x2a2a2a, burnerOn: 0xff4444, door: 0x1a1a1a },
  counter: { top: 0xfafafa, cabinet: 0x2e8b57 },
  table: { wood: 0x8b4513, cloth: 0xdc3545 },
  chair: { wood: 0xa0522d },
  customer: [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da],
  ui: {
    gold: '#ffd700',
    green: '#22c55e',
    red: '#ef4444',
    blue: '#3b82f6',
    purple: '#8b5cf6',
  },
  readyGlow: 0x22c55e,
  warningGlow: 0xeab308,
  dangerGlow: 0xef4444,
  grass: 0x7cad7c,
};

// ============================================
// AUDIO SYSTEM
// ============================================
let audioContext = null;
let audioEnabled = true;
let soundTogglesGlobal = {
  cooking: true,
  foodReady: true,
  foodSpoiled: true,
  customerArrive: true,
  customerServed: true,
  customerHappy: true,
  customerAngry: true,
  coins: true,
  levelUp: true,
  purchase: true,
  achievement: true,
};

function getAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Resume if suspended (browsers require user interaction)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  return audioContext;
}

// Simple synth sound generator
function playTone(frequency, duration, type = 'sine', volume = 0.3, decay = true) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
    
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    if (decay) {
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    }
    
    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + duration);
  } catch (e) {
    // Audio not supported or blocked
  }
}

// Create noise for sizzle effects
function playNoise(duration, volume = 0.1, filterFreq = 3000) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const bufferSize = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Fill with white noise
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    
    // Filter to make it sound more like sizzling
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = filterFreq;
    filter.Q.value = 1;
    
    const gainNode = ctx.createGain();
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    
    noise.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    noise.start();
    noise.stop(ctx.currentTime + duration);
  } catch (e) {}
}

// Metallic coin clink sound
function playCoinClink(delay = 0) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const time = ctx.currentTime + delay;
    
    // High metallic frequencies for coin sound
    const frequencies = [2500, 3500, 4200];
    
    frequencies.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      // Quick pitch bend down for metallic quality
      osc.frequency.exponentialRampToValueAtTime(freq * 0.7, time + 0.08);
      
      // Quick attack, fast decay for "clink"
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.12 - i * 0.03, time + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
      
      osc.start(time);
      osc.stop(time + 0.12);
    });
  } catch (e) {}
}

// Sound effects
const SFX = {
  // Cooking start - sizzle/grill sound
  cookStart: () => {
    if (!audioEnabled || !soundTogglesGlobal.cooking) return;
    // Initial "fwoosh" of putting food on grill
    playNoise(0.15, 0.2, 2000);
    // Followed by sizzling
    setTimeout(() => {
      playNoise(0.3, 0.12, 4000);
      playNoise(0.25, 0.08, 5000);
    }, 100);
    setTimeout(() => {
      playNoise(0.2, 0.06, 3500);
    }, 250);
  },
  
  // Food ready - pleasant ding (like a kitchen timer)
  foodReady: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodReady) return;
    // Bell-like ding
    playTone(1200, 0.3, 'sine', 0.25);
    playTone(2400, 0.2, 'sine', 0.1); // Harmonic
    setTimeout(() => {
      playTone(1200, 0.25, 'sine', 0.15);
      playTone(2400, 0.15, 'sine', 0.05);
    }, 180);
  },
  
  // Food spoiled - buzzer/sad sound
  foodSpoiled: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodSpoiled) return;
    playTone(180, 0.3, 'sawtooth', 0.15);
    playTone(175, 0.3, 'sawtooth', 0.1); // Slight detune for dissonance
    setTimeout(() => {
      playTone(140, 0.35, 'sawtooth', 0.12);
      playTone(138, 0.35, 'sawtooth', 0.08);
    }, 200);
  },
  
  // Customer arrives - door chime / bell
  customerArrive: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerArrive) return;
    playTone(880, 0.2, 'sine', 0.15);
    playTone(1760, 0.15, 'sine', 0.08); // Harmonic
    setTimeout(() => playTone(1100, 0.25, 'sine', 0.12), 120);
  },
  
  // Customer served - plate down sound
  customerServed: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    // Soft thud + clink
    playTone(200, 0.08, 'sine', 0.2);
    setTimeout(() => {
      playTone(800, 0.06, 'triangle', 0.1);
      playTone(1200, 0.05, 'triangle', 0.05);
    }, 30);
  },
  
  // Customer leaves happy - cheerful
  customerHappy: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerHappy) return;
    playTone(523, 0.12, 'sine', 0.15);
    setTimeout(() => playTone(659, 0.12, 'sine', 0.15), 80);
    setTimeout(() => playTone(784, 0.18, 'sine', 0.12), 160);
  },
  
  // Customer leaves angry - negative sound
  customerAngry: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerAngry) return;
    playTone(200, 0.2, 'sawtooth', 0.12);
    setTimeout(() => playTone(150, 0.25, 'sawtooth', 0.08), 150);
  },
  
  // Coin earned - actual coin clink sounds!
  coinEarn: () => {
    if (!audioEnabled || !soundTogglesGlobal.coins) return;
    playCoinClink(0);
    playCoinClink(0.08); // Second coin for "ka-ching"
  },
  
  // Level up fanfare!
  levelUp: () => {
    if (!audioEnabled || !soundTogglesGlobal.levelUp) return;
    const notes = [523, 659, 784, 1047]; // C E G C
    notes.forEach((freq, i) => {
      setTimeout(() => playTone(freq, 0.22, 'sine', 0.2), i * 100);
    });
    // Triumphant chord + coin shower
    setTimeout(() => {
      playTone(523, 0.5, 'sine', 0.15);
      playTone(659, 0.5, 'sine', 0.12);
      playTone(784, 0.5, 'sine', 0.12);
      playTone(1047, 0.5, 'sine', 0.15);
      // Coin sounds
      playCoinClink(0.1);
      playCoinClink(0.2);
      playCoinClink(0.35);
    }, 420);
  },
  
  // UI click
  click: () => {
    playTone(800, 0.04, 'sine', 0.08);
  },
  
  // Purchase - cash register style
  purchase: () => {
    if (!audioEnabled || !soundTogglesGlobal.purchase) return;
    // Register "ka-ching"
    playCoinClink(0);
    setTimeout(() => {
      playTone(600, 0.08, 'sine', 0.12);
      playTone(750, 0.1, 'sine', 0.1);
    }, 80);
    playCoinClink(0.15);
  },
  
  // Serve food to counter - plate sound
  serveToCounter: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    playTone(300, 0.06, 'sine', 0.15);
    setTimeout(() => {
      playTone(600, 0.05, 'triangle', 0.08);
    }, 40);
  },
  
  // Achievement unlocked - triumphant!
  achievement: () => {
    if (!audioEnabled || !soundTogglesGlobal.achievement) return;
    // Magical sparkle + fanfare
    playTone(880, 0.15, 'sine', 0.2);
    playTone(1760, 0.1, 'sine', 0.1);
    setTimeout(() => {
      playTone(1100, 0.15, 'sine', 0.2);
      playTone(2200, 0.1, 'sine', 0.08);
    }, 100);
    setTimeout(() => {
      playTone(1320, 0.2, 'sine', 0.18);
      playTone(2640, 0.12, 'sine', 0.06);
      playCoinClink(0.05);
    }, 200);
    setTimeout(() => {
      playCoinClink(0);
      playCoinClink(0.08);
    }, 350);
  },
  
  // Error/invalid placement - short buzz
  error: () => {
    if (!audioEnabled) return;
    playTone(220, 0.12, 'sawtooth', 0.15);
    playTone(200, 0.12, 'sawtooth', 0.1);
  },
};

const GRID = { width: 16, height: 14 };
const TILE_SIZE = 1;

// Door position - where customers enter/exit (front center of cafe)
const DOOR_POSITION = { 
  gridX: 8,  // Center of cafe
  gridZ: GRID.height - 1,  // Front edge of cafe floor (grid coord 13)
  worldX: 0,  // Center in world coords
  worldZ: GRID.height / 2 - 0.5  // Front of cafe in world coords
};

const RECIPES = {
  // Level 1 - Quick starters (15-30 sec)
  burger: { name: 'Burger', icon: 'üçî', cost: 25, servings: 13, revenue: 4, cookTime: 15, xp: 7, level: 1 },
  salad: { name: 'Salad', icon: 'ü•ó', cost: 50, servings: 25, revenue: 4, cookTime: 30, xp: 14, level: 1 },
  
  // Level 2-3 - Basic dishes (45-90 sec)
  soup: { name: 'Soup', icon: 'üç≤', cost: 100, servings: 40, revenue: 5, cookTime: 60, xp: 35, level: 2 },
  pancakes: { name: 'Pancakes', icon: 'ü•û', cost: 150, servings: 50, revenue: 5, cookTime: 90, xp: 50, level: 2 },
  cake: { name: 'Cake', icon: 'üéÇ', cost: 200, servings: 60, revenue: 6, cookTime: 120, xp: 70, level: 3 },
  tacos: { name: 'Tacos', icon: 'üåÆ', cost: 175, servings: 55, revenue: 5, cookTime: 90, xp: 55, level: 3 },
  
  // Level 4-5 - Intermediate (3-6 min)
  pizza: { name: 'Pizza', icon: 'üçï', cost: 300, servings: 80, revenue: 6, cookTime: 180, xp: 90, level: 4 },
  pasta: { name: 'Pasta', icon: 'üçù', cost: 350, servings: 90, revenue: 6, cookTime: 240, xp: 110, level: 4 },
  chicken: { name: 'Roast Chicken', icon: 'üçó', cost: 500, servings: 120, revenue: 7, cookTime: 300, xp: 150, level: 5 },
  ramen: { name: 'Ramen', icon: 'üçú', cost: 450, servings: 100, revenue: 7, cookTime: 360, xp: 165, level: 5 },
  
  // Level 6-7 - Advanced (8-15 min)
  sushi: { name: 'Sushi Platter', icon: 'üç£', cost: 700, servings: 150, revenue: 8, cookTime: 480, xp: 220, level: 6 },
  curry: { name: 'Curry', icon: 'üçõ', cost: 600, servings: 130, revenue: 7, cookTime: 540, xp: 200, level: 6 },
  steak: { name: 'Steak Dinner', icon: 'ü•©', cost: 900, servings: 180, revenue: 9, cookTime: 600, xp: 280, level: 7 },
  lobster: { name: 'Lobster', icon: 'ü¶û', cost: 1100, servings: 200, revenue: 10, cookTime: 720, xp: 340, level: 7 },
  
  // Level 8-9 - Expert (15-30 min)
  paella: { name: 'Paella', icon: 'ü•ò', cost: 1300, servings: 250, revenue: 10, cookTime: 900, xp: 420, level: 8 },
  dimsum: { name: 'Dim Sum', icon: 'ü•ü', cost: 1000, servings: 220, revenue: 9, cookTime: 1080, xp: 380, level: 8 },
  bbqRibs: { name: 'BBQ Ribs', icon: 'üçñ', cost: 1500, servings: 280, revenue: 11, cookTime: 1200, xp: 500, level: 9 },
  crabBisque: { name: 'Crab Bisque', icon: 'ü¶Ä', cost: 1800, servings: 300, revenue: 12, cookTime: 1500, xp: 580, level: 9 },
  
  // Level 10-12 - Master Chef (30-60 min)
  weddingCake: { name: 'Wedding Cake', icon: 'üéÇ', cost: 2500, servings: 400, revenue: 14, cookTime: 1800, xp: 750, level: 10 },
  beef: { name: 'Beef Wellington', icon: 'ü•©', cost: 3000, servings: 450, revenue: 15, cookTime: 2400, xp: 900, level: 10 },
  feastPlatter: { name: 'Grand Feast', icon: 'üç±', cost: 4000, servings: 600, revenue: 16, cookTime: 3000, xp: 1100, level: 11 },
  turkeyDinner: { name: 'Turkey Dinner', icon: 'ü¶É', cost: 5000, servings: 800, revenue: 18, cookTime: 3600, xp: 1400, level: 12 },
};

// Dish Mastery System - Cook dishes multiple times to earn bonuses
// Each dish tracks how many times it's been successfully cooked
const MASTERY_LEVELS = {
  1: { 
    name: 'Apprentice', 
    cooksRequired: 10, 
    plateColor: 0x87CEEB, // Light blue plate
    bonus: 'servings', // +5% more servings
    bonusAmount: 0.05,
    description: '+5% Servings'
  },
  2: { 
    name: 'Journeyman', 
    cooksRequired: 25, 
    plateColor: 0x4169E1, // Dark blue plate
    bonus: 'xp', // +5% more XP
    bonusAmount: 0.05,
    description: '+5% XP'
  },
  3: { 
    name: 'Master', 
    cooksRequired: 50, 
    plateColor: 0xFFD700, // Gold plate
    bonus: 'speed', // +5% faster cooking
    bonusAmount: 0.05,
    description: '+5% Faster'
  },
};

// Helper function to get mastery level for a dish
const getMasteryLevel = (dishMastery, recipeKey) => {
  const mastery = dishMastery?.[recipeKey] || { cooked: 0 };
  if (mastery.cooked >= MASTERY_LEVELS[3].cooksRequired) return 3;
  if (mastery.cooked >= MASTERY_LEVELS[2].cooksRequired) return 2;
  if (mastery.cooked >= MASTERY_LEVELS[1].cooksRequired) return 1;
  return 0;
};

// Helper function to get the plate color for a dish based on mastery
const getMasteryPlateColor = (dishMastery, recipeKey) => {
  const level = getMasteryLevel(dishMastery, recipeKey);
  if (level === 0) return 0xFFFFF0; // Default ivory plate
  return MASTERY_LEVELS[level].plateColor;
};

// Helper function to calculate cook time with mastery bonus
const getCookTimeWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let cookTime = recipe.cookTime;
  // Level 3 mastery gives 5% faster cooking (stacks with previous levels)
  if (level >= 3) {
    cookTime = Math.floor(cookTime * (1 - MASTERY_LEVELS[3].bonusAmount));
  }
  return cookTime;
};

// Helper function to calculate servings with mastery bonus
const getServingsWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let servings = recipe.servings;
  // Level 1+ mastery gives 5% more servings
  if (level >= 1) {
    servings = Math.floor(servings * (1 + MASTERY_LEVELS[1].bonusAmount));
  }
  return servings;
};

// Helper function to calculate XP with mastery bonus
const getXPWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let xp = recipe.xp;
  // Level 2+ mastery gives 5% more XP
  if (level >= 2) {
    xp = Math.floor(xp * (1 + MASTERY_LEVELS[2].bonusAmount));
  }
  return xp;
};

const XP_LEVELS = [0, 120, 280, 520, 840, 1240, 1720, 2280, 2920, 3640, 4440, 5400, 6500];

// Helper function to format time display (e.g., "5m 30s", "1h 15m")
const formatTimeDisplay = (seconds) => {
  seconds = Math.ceil(seconds);
  if (seconds < 60) {
    return `${seconds}s`;
  } else if (seconds < 3600) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
  } else {
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
  }
};

// Table styles for variety
const TABLE_STYLES = {
  // === BASIC TABLES (300-1000ü™ô) ===
  square: { 
    name: 'Classic Red', icon: 'üü•', cost: 300, shape: 'square',
    woodColor: 0x8B4513, clothColor: 0xDC143C, chairColor: 0x8B4513,
  },
  basicWood: { 
    name: 'Basic Wood', icon: 'ü™µ', cost: 500, shape: 'square',
    woodColor: 0xA0522D, clothColor: null, chairColor: 0xA0522D,
  },
  oak: { 
    name: 'Oak', icon: 'üü§', cost: 750, shape: 'square',
    woodColor: 0xDEB887, clothColor: null, chairColor: 0xDEB887,
  },
  modernBlack: { 
    name: 'Modern Black', icon: '‚¨õ', cost: 800, shape: 'square',
    woodColor: 0x1a1a1a, clothColor: null, chairColor: 0x2d2d2d,
  },
  whiteElegant: { 
    name: 'White Elegant', icon: '‚¨ú', cost: 1000, shape: 'square',
    woodColor: 0xFAFAFA, clothColor: 0xFFFFFF, chairColor: 0xF5F5F5,
  },
  mahogany: { 
    name: 'Mahogany', icon: 'üü´', cost: 1000, shape: 'square',
    woodColor: 0x420D09, clothColor: null, chairColor: 0x420D09,
  },
  
  // === MID-RANGE TABLES (1500-3500ü™ô) ===
  rusticFarm: { 
    name: 'Rustic Farm', icon: 'üåæ', cost: 1500, shape: 'square',
    woodColor: 0x8B7355, clothColor: 0xF5DEB3, chairColor: 0x8B7355,
  },
  redDiner: { 
    name: 'Red Diner', icon: 'üî¥', cost: 2000, shape: 'square',
    woodColor: 0xC0C0C0, clothColor: 0xCC0000, chairColor: 0xCC0000,
  },
  checkeredPicnic: { 
    name: 'Checkered', icon: 'üß∫', cost: 2500, shape: 'square',
    woodColor: 0xDEB887, clothColor: 0xDC143C, chairColor: 0xDEB887,
    pattern: 'checkered',
  },
  darkCherry: { 
    name: 'Dark Cherry', icon: 'üçí', cost: 2500, shape: 'square',
    woodColor: 0x3D0C02, clothColor: 0x800020, chairColor: 0x3D0C02,
  },
  blueOcean: { 
    name: 'Blue Ocean', icon: 'üîµ', cost: 3000, shape: 'square',
    woodColor: 0xF5F5F5, clothColor: 0x1E90FF, chairColor: 0xF5F5F5,
  },
  marble: { 
    name: 'Marble', icon: 'ü™®', cost: 3500, shape: 'square',
    woodColor: 0xE8E8E8, clothColor: null, chairColor: 0x2F4F4F,
    material: 'marble',
  },
  
  // === PREMIUM TABLES (5000-15000ü™ô) ===
  pinkRomantic: { 
    name: 'Pink Romantic', icon: 'üíó', cost: 5000, shape: 'square',
    woodColor: 0xFFFFFF, clothColor: 0xFFB6C1, chairColor: 0xFFB6C1,
  },
  greenGarden: { 
    name: 'Garden Green', icon: 'üåø', cost: 5500, shape: 'square',
    woodColor: 0xF5F5DC, clothColor: 0x228B22, chairColor: 0x2E8B57,
  },
  executive: { 
    name: 'Executive', icon: 'üíº', cost: 7500, shape: 'square',
    woodColor: 0x2F1810, clothColor: null, chairColor: 0x1a1a1a,
    material: 'polished',
  },
  premiumWhite: { 
    name: 'Premium White', icon: '‚ú®', cost: 8000, shape: 'square',
    woodColor: 0xFFFFF0, clothColor: 0xFFFACD, chairColor: 0xFFFFF0,
  },
  goldLuxury: { 
    name: 'Gold Luxury', icon: 'üëë', cost: 12000, shape: 'square',
    woodColor: 0xFFD700, clothColor: 0x800020, chairColor: 0xFFD700,
  },
  luxuryPink: { 
    name: 'Luxury Pink', icon: 'üíñ', cost: 15000, shape: 'square',
    woodColor: 0xFFF0F5, clothColor: 0xFF69B4, chairColor: 0xFFB6C1,
  },
};

// Chair styles for mix-and-match seating
const CHAIR_STYLES = {
  // === BASIC CHAIRS (100-400ü™ô) ===
  basicWood: {
    name: 'Basic Wood', icon: 'ü™ë', cost: 100,
    color: 0xA0522D, seatColor: null, // null = same as frame
  },
  oak: {
    name: 'Oak Chair', icon: 'ü™µ', cost: 150,
    color: 0xDEB887, seatColor: null,
  },
  darkWood: {
    name: 'Dark Wood', icon: 'üü§', cost: 200,
    color: 0x8B4513, seatColor: null,
  },
  white: {
    name: 'White Chair', icon: '‚¨ú', cost: 250,
    color: 0xF5F5F5, seatColor: null,
  },
  black: {
    name: 'Black Chair', icon: '‚¨õ', cost: 250,
    color: 0x2D2D2D, seatColor: null,
  },
  
  // === CUSHIONED CHAIRS (400-1000ü™ô) ===
  redCushion: {
    name: 'Red Cushion', icon: 'üî¥', cost: 400,
    color: 0x8B4513, seatColor: 0xDC143C,
  },
  blueCushion: {
    name: 'Blue Cushion', icon: 'üîµ', cost: 400,
    color: 0x8B4513, seatColor: 0x1E90FF,
  },
  greenCushion: {
    name: 'Green Cushion', icon: 'üü¢', cost: 400,
    color: 0x8B4513, seatColor: 0x228B22,
  },
  pinkCushion: {
    name: 'Pink Cushion', icon: 'üíó', cost: 500,
    color: 0xF5F5F5, seatColor: 0xFFB6C1,
  },
  
  // === PREMIUM CHAIRS (1000-3000ü™ô) ===
  velvetRed: {
    name: 'Velvet Red', icon: 'üç∑', cost: 1000,
    color: 0x420D09, seatColor: 0x800020,
  },
  velvetBlue: {
    name: 'Velvet Blue', icon: 'üíé', cost: 1000,
    color: 0x1a1a1a, seatColor: 0x191970,
  },
  goldFrame: {
    name: 'Gold Frame', icon: 'üëë', cost: 2000,
    color: 0xFFD700, seatColor: 0x800020,
  },
  executive: {
    name: 'Executive', icon: 'üíº', cost: 2500,
    color: 0x1a1a1a, seatColor: 0x2F2F2F,
    hasArmrests: true,
  },
  luxuryWhite: {
    name: 'Luxury White', icon: '‚ú®', cost: 3000,
    color: 0xFFFFF0, seatColor: 0xFFFACD,
  },
};

// Helper: Get chair tile position based on table position and rotation
// Used for LEGACY tables that have built-in chairs
// Rotation: 0=chair left, 1=chair up, 2=chair right, 3=chair down
const getChairTile = (tableGridX, tableGridZ, rotation) => {
  // Must match visual positioning: x' = -offset*cos(Œ∏), z' = +offset*sin(Œ∏)
  const offsets = [
    [-1, 0],  // Rotation 0: chair to the left (X-1)
    [0, 1],   // Rotation 1: chair in front/down (Z+1) - toward camera
    [1, 0],   // Rotation 2: chair to the right (X+1)
    [0, -1],  // Rotation 3: chair behind/up (Z-1) - toward back
  ];
  const [dx, dz] = offsets[rotation % 4];
  return { gridX: tableGridX + dx, gridZ: tableGridZ + dz };
};

// Helper: Get all tiles occupied by a table
// New tables occupy only 1 tile (the table itself)
// Legacy tables with hasBuiltInChair=true occupy 2 tiles
const getTableTiles = (table) => {
  // New tables (no built-in chair) occupy only 1 tile
  if (!table.hasBuiltInChair) {
    return [{ gridX: table.gridX, gridZ: table.gridZ, type: 'table' }];
  }
  // Legacy tables occupy 2 tiles (table + chair)
  const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
  return [
    { gridX: table.gridX, gridZ: table.gridZ, type: 'table' },
    { gridX: chairTile.gridX, gridZ: chairTile.gridZ, type: 'chair' },
  ];
};

// Helper: Find a chair adjacent to a table position
// Returns the chair object if found, null otherwise
const findChairForTable = (table, chairs) => {
  // First, check for explicitly linked chairs (new system)
  const linkedChair = chairs.find(c => c.linkedTableId === table.id);
  if (linkedChair) return linkedChair;
  
  // Fallback for old saves: check all 4 adjacent tiles for a chair facing this table
  const adjacentOffsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  for (const [dx, dz] of adjacentOffsets) {
    const chair = chairs.find(c => 
      c.gridX === table.gridX + dx && 
      c.gridZ === table.gridZ + dz &&
      !c.linkedTableId // Only unlinked chairs for fallback
    );
    if (chair) {
      // Check if chair is facing the table
      const facingTile = getChairFacingTile(chair.gridX, chair.gridZ, chair.rotation || 0);
      if (facingTile.gridX === table.gridX && facingTile.gridZ === table.gridZ) {
        return chair;
      }
    }
  }
  return null;
};

// Helper: Get the tile position a chair is facing based on its rotation
const getChairFacingTile = (gridX, gridZ, rotation) => {
  // Chair rotation: 0=faces +Z, 1=faces +X, 2=faces -Z, 3=faces -X
  // In THREE.js, positive rotation.y is counter-clockwise from above
  switch (rotation % 4) {
    case 0: return { gridX, gridZ: gridZ + 1 };      // Faces +Z (south)
    case 1: return { gridX: gridX + 1, gridZ };      // Faces +X (east)
    case 2: return { gridX, gridZ: gridZ - 1 };      // Faces -Z (north)
    case 3: return { gridX: gridX - 1, gridZ };      // Faces -X (west)
    default: return { gridX, gridZ: gridZ + 1 };
  }
};

// Helper: Find a table at a specific grid position
const findTableAtPosition = (tables, gridX, gridZ) => {
  return tables.find(t => t.gridX === gridX && t.gridZ === gridZ);
};

// Helper: Check if a table already has a chair linked to it
const isTableLinkedToChair = (chairs, tableId) => {
  return chairs.some(c => c.linkedTableId === tableId);
};

// Helper: Get the table a chair is adjacent to
const findTableForChair = (chair, tables) => {
  const adjacentOffsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  for (const [dx, dz] of adjacentOffsets) {
    const table = tables.find(t => 
      t.gridX === chair.gridX + dx && 
      t.gridZ === chair.gridZ + dz
    );
    if (table) return table;
  }
  return null;
};

// Helper: Calculate chair rotation to face the table
const getChairRotationForTable = (chairGridX, chairGridZ, tableGridX, tableGridZ) => {
  const dx = tableGridX - chairGridX;
  const dz = tableGridZ - chairGridZ;
  // Return rotation so chair faces the table
  if (dx > 0) return 1;  // Table is to the right, face right (-X direction)
  if (dx < 0) return 3;  // Table is to the left, face left (+X direction)
  if (dz > 0) return 0;  // Table is forward, face forward (+Z direction)
  if (dz < 0) return 2;  // Table is behind, face back (-Z direction)
  return 0; // Default
};

// ============================================
// TILE OCCUPANCY SYSTEM (Story 8.4)
// ============================================
// All rotatable objects use: 0=front faces +Z, 1=front faces -X, 2=front faces -Z, 3=front faces +X
// "Front" is where NPCs stand to interact with the object

// Direction offsets for each rotation
const DIRECTION_OFFSETS = [
  [0, 1],   // Rotation 0: front faces +Z (toward camera/dining area)
  [-1, 0],  // Rotation 1: front faces -X (toward left)
  [0, -1],  // Rotation 2: front faces -Z (toward back/kitchen)
  [1, 0],   // Rotation 3: front faces +X (toward right)
];

// Get the tile where an NPC should stand to interact with an object
const getInteractionTile = (objectType, gridX, gridZ, rotation = 0) => {
  const [dx, dz] = DIRECTION_OFFSETS[rotation % 4];
  
  switch (objectType) {
    case 'stove':
      // Chef stands in front of stove to cook
      return { gridX: gridX + dx, gridZ: gridZ + dz };
    case 'counter':
      // Customer stands in front of counter to get food
      return { gridX: gridX + dx, gridZ: gridZ + dz };
    case 'table':
      // Customer sits in chair (handled by getChairTile)
      return getChairTile(gridX, gridZ, rotation);
    default:
      return { gridX, gridZ };
  }
};

// Get all tiles an object occupies (blocks movement)
const getObjectTiles = (objectType, gridX, gridZ, rotation = 0, hasBuiltInChair = false) => {
  switch (objectType) {
    case 'stove':
      return [{ gridX, gridZ, type: 'stove' }];
    case 'counter':
      return [{ gridX, gridZ, type: 'counter' }];
    case 'table':
      // New tables (no built-in chair) occupy 1 tile
      if (!hasBuiltInChair) {
        return [{ gridX, gridZ, type: 'table' }];
      }
      // Legacy tables with built-in chair occupy 2 tiles
      const chairTile = getChairTile(gridX, gridZ, rotation);
      return [
        { gridX, gridZ, type: 'table' },
        { gridX: chairTile.gridX, gridZ: chairTile.gridZ, type: 'chair' },
      ];
    case 'chair':
      // Standalone chairs occupy 1 tile
      return [{ gridX, gridZ, type: 'chair' }];
    case 'decoration':
      return [{ gridX, gridZ, type: 'decoration' }];
    default:
      return [{ gridX, gridZ, type: objectType }];
  }
};

// Create tile key for map lookups
const getTileKey = (gridX, gridZ) => `${gridX},${gridZ}`;

// Build complete occupancy map from game state
const buildOccupancyMap = (state) => {
  const map = new Map(); // key: "x,z", value: { type, id, rotation }
  
  // Add stoves
  state.stoves.forEach(stove => {
    const key = getTileKey(stove.gridX, stove.gridZ);
    map.set(key, { type: 'stove', id: stove.id, rotation: stove.rotation || 0 });
  });
  
  // Add counters
  state.counters.forEach(counter => {
    const key = getTileKey(counter.gridX, counter.gridZ);
    map.set(key, { type: 'counter', id: counter.id, rotation: counter.rotation || 0 });
  });
  
  // Add tables (new tables = 1 tile, legacy tables with built-in chairs = 2 tiles)
  state.tables.forEach(table => {
    const tiles = getTableTiles(table);
    tiles.forEach(tile => {
      const key = getTileKey(tile.gridX, tile.gridZ);
      map.set(key, { type: tile.type, id: table.id, rotation: table.rotation || 0 });
    });
  });
  
  // Add standalone chairs (separate from tables)
  if (state.chairs) {
    state.chairs.forEach(chair => {
      const key = getTileKey(chair.gridX, chair.gridZ);
      map.set(key, { type: 'chair', id: chair.id, chairStyle: chair.style, rotation: chair.rotation || 0 });
    });
  }
  
  // Add floor decorations that block movement (not rugs - you can walk on those!)
  state.decorations.forEach(decor => {
    const decorType = DECORATIONS[decor.type];
    // Only add to occupancy if it's a floor decoration AND it blocks movement
    // blocksMovement defaults to true for backward compatibility (old decorations without the property)
    if (decorType && decorType.category === 'floor' && decorType.blocksMovement !== false) {
      const key = getTileKey(decor.gridX, decor.gridZ);
      map.set(key, { type: 'decoration', id: decor.id, decorType: decor.type });
    }
  });
  
  // Add dividers (always block pathfinding)
  if (state.dividers) {
    state.dividers.forEach(divider => {
      const key = getTileKey(divider.gridX, divider.gridZ);
      map.set(key, { type: 'divider', id: divider.id, dividerType: divider.type, rotation: divider.rotation || 0 });
    });
  }
  
  return map;
};

// Check if a tile is occupied
const isTileOccupied = (occupancyMap, gridX, gridZ) => {
  return occupancyMap.has(getTileKey(gridX, gridZ));
};

// Check if a tile is walkable (not occupied by blocking object)
const isTileWalkable = (occupancyMap, gridX, gridZ, gridWidth, gridHeight) => {
  // Out of bounds
  if (gridX < 0 || gridX >= gridWidth || gridZ < 0 || gridZ >= gridHeight) {
    return false;
  }
  // Check occupancy
  return !isTileOccupied(occupancyMap, gridX, gridZ);
};

// Get the most urgent waiting customer (lowest patience = most urgent, or longest wait time)
// Returns the table with the customer who should be served next
const getMostUrgentCustomer = (tables) => {
  const waitingTables = tables.filter(t => t.customer?.state === 'waiting');
  if (waitingTables.length === 0) return null;
  
  // Sort by patience (lowest first = most urgent)
  // If patience is equal, sort by spawnTime (earliest first = waited longest)
  waitingTables.sort((a, b) => {
    const patienceA = a.customer.patience ?? 100;
    const patienceB = b.customer.patience ?? 100;
    
    // Lower patience = higher priority
    if (patienceA !== patienceB) {
      return patienceA - patienceB;
    }
    
    // If patience is equal, earlier spawn time = higher priority
    const spawnA = a.customer.spawnTime ?? Date.now();
    const spawnB = b.customer.spawnTime ?? Date.now();
    return spawnA - spawnB;
  });
  
  return waitingTables[0];
};

// A* Pathfinding Algorithm
// Returns array of {gridX, gridZ} tiles from start to end, or null if no path
const findPath = (occupancyMap, startX, startZ, endX, endZ, gridWidth, gridHeight) => {
  // If start or end is out of bounds, return null
  if (startX < 0 || startX >= gridWidth || startZ < 0 || startZ >= gridHeight ||
      endX < 0 || endX >= gridWidth || endZ < 0 || endZ >= gridHeight) {
    return null;
  }
  
  // If end tile is occupied, find nearest walkable tile
  let targetX = endX;
  let targetZ = endZ;
  if (isTileOccupied(occupancyMap, endX, endZ)) {
    // Search adjacent tiles for walkable one
    const adjacent = [
      { x: endX, z: endZ + 1 }, // Front
      { x: endX, z: endZ - 1 }, // Back
      { x: endX - 1, z: endZ }, // Left
      { x: endX + 1, z: endZ }, // Right
    ];
    let found = false;
    for (const adj of adjacent) {
      if (isTileWalkable(occupancyMap, adj.x, adj.z, gridWidth, gridHeight)) {
        targetX = adj.x;
        targetZ = adj.z;
        found = true;
        break;
      }
    }
    if (!found) return null; // No walkable tiles near destination
  }
  
  // A* implementation
  const openSet = [];
  const closedSet = new Set();
  const cameFrom = new Map();
  const gScore = new Map();
  const fScore = new Map();
  
  const getKey = (x, z) => `${x},${z}`;
  const heuristic = (x1, z1, x2, z2) => Math.abs(x1 - x2) + Math.abs(z1 - z2); // Manhattan distance
  
  const startKey = getKey(startX, startZ);
  gScore.set(startKey, 0);
  fScore.set(startKey, heuristic(startX, startZ, targetX, targetZ));
  openSet.push({ x: startX, z: startZ, f: fScore.get(startKey) });
  
  // Directions: 4-way movement (no diagonals for cleaner paths)
  const directions = [
    { dx: 0, dz: 1 },  // Down (+Z)
    { dx: 0, dz: -1 }, // Up (-Z)
    { dx: 1, dz: 0 },  // Right (+X)
    { dx: -1, dz: 0 }, // Left (-X)
  ];
  
  let iterations = 0;
  const maxIterations = gridWidth * gridHeight * 2; // Prevent infinite loops
  
  while (openSet.length > 0 && iterations < maxIterations) {
    iterations++;
    
    // Find node with lowest fScore
    openSet.sort((a, b) => a.f - b.f);
    const current = openSet.shift();
    const currentKey = getKey(current.x, current.z);
    
    // Reached destination?
    if (current.x === targetX && current.z === targetZ) {
      // Reconstruct path
      const path = [];
      let key = currentKey;
      while (key) {
        const [x, z] = key.split(',').map(Number);
        path.unshift({ gridX: x, gridZ: z });
        key = cameFrom.get(key);
      }
      return path;
    }
    
    closedSet.add(currentKey);
    
    // Check neighbors
    for (const dir of directions) {
      const nx = current.x + dir.dx;
      const nz = current.z + dir.dz;
      const neighborKey = getKey(nx, nz);
      
      // Skip if already evaluated
      if (closedSet.has(neighborKey)) continue;
      
      // Skip if not walkable (unless it's the target tile - we already validated it)
      if (nx !== targetX || nz !== targetZ) {
        if (!isTileWalkable(occupancyMap, nx, nz, gridWidth, gridHeight)) continue;
      }
      
      const tentativeG = gScore.get(currentKey) + 1;
      
      // Is this a better path?
      if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
        cameFrom.set(neighborKey, currentKey);
        gScore.set(neighborKey, tentativeG);
        const f = tentativeG + heuristic(nx, nz, targetX, targetZ);
        fScore.set(neighborKey, f);
        
        // Add to open set if not already there
        if (!openSet.some(n => n.x === nx && n.z === nz)) {
          openSet.push({ x: nx, z: nz, f });
        }
      }
    }
  }
  
  // No path found
  return null;
};

// Get rotation angle in radians for 3D rendering
const getRotationAngle = (rotation) => {
  return (rotation % 4) * (Math.PI / 2); // 0, 90, 180, 270 degrees
};

// Decoration types for cafe customization
const DECORATIONS = {
  // Plants - all block movement (you can't walk through a potted plant!)
  plant: { name: 'Potted Plant', icon: 'ü™¥', cost: 100, buzz: 2, category: 'floor', blocksMovement: true },
  plant2: { name: 'Tall Plant', icon: 'üåø', cost: 175, buzz: 2, category: 'floor', blocksMovement: true },
  cactus: { name: 'Cactus', icon: 'üåµ', cost: 125, buzz: 2, category: 'floor', blocksMovement: true },
  flowers: { name: 'Flower Bouquet', icon: 'üíê', cost: 150, buzz: 3, category: 'floor', blocksMovement: true },
  tulips: { name: 'Pink Tulips', icon: 'üå∑', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  sunflower: { name: 'Sunflower Pot', icon: 'üåª', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  
  // Lighting - floor lamps and candle tables block movement
  floorLamp: { name: 'Floor Lamp', icon: 'ü™î', cost: 150, buzz: 2, category: 'floor', blocksMovement: true },
  candleTable: { name: 'Candle Table', icon: 'üïØÔ∏è', cost: 125, buzz: 3, category: 'floor', blocksMovement: true },
  fairyLights: { name: 'Fairy Lights', icon: '‚ú®', cost: 300, buzz: 5, category: 'wall' },
  
  // Floor items - RUGS are walkable! You walk ON them, not around them
  rug: { name: 'Cozy Rug', icon: 'üü´', cost: 200, buzz: 3, category: 'floor', blocksMovement: false },
  pinkRug: { name: 'Pink Rug', icon: 'ü©∑', cost: 250, buzz: 4, category: 'floor', blocksMovement: false },
  
  // Wall decor - walls don't block floor movement
  window: { name: 'Window', icon: 'ü™ü', cost: 200, buzz: 3, category: 'wall' },
  picture: { name: 'Wall Art', icon: 'üñºÔ∏è', cost: 250, buzz: 3, category: 'wall' },
  clock: { name: 'Wall Clock', icon: 'üïê', cost: 175, buzz: 2, category: 'wall' },
  heart: { name: 'Heart Sign', icon: '‚ù§Ô∏è', cost: 200, buzz: 4, category: 'wall' },
  star: { name: 'Star Decor', icon: '‚≠ê', cost: 225, buzz: 4, category: 'wall' },
  menu: { name: 'Menu Board', icon: 'üìã', cost: 300, buzz: 5, category: 'wall' },
  
  // Special items - all large items that block movement
  jukebox: { name: 'Jukebox', icon: 'üéµ', cost: 500, buzz: 8, category: 'floor', blocksMovement: true },
  aquarium: { name: 'Aquarium', icon: 'üê†', cost: 600, buzz: 10, category: 'floor', blocksMovement: true },
  fountain: { name: 'Mini Fountain', icon: '‚õ≤', cost: 450, buzz: 7, category: 'floor', blocksMovement: true },
  cakeDisplay: { name: 'Cake Display', icon: 'üéÇ', cost: 350, buzz: 6, category: 'floor', blocksMovement: true },
  gumball: { name: 'Gumball Machine', icon: 'üî¥', cost: 275, buzz: 5, category: 'floor', blocksMovement: true },
  
  // Cute stuff - small items on display stands that block movement
  teddyBear: { name: 'Teddy Bear', icon: 'üß∏', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  balloons: { name: 'Balloons', icon: 'üéà', cost: 150, buzz: 3, category: 'floor', blocksMovement: true },
  giftBox: { name: 'Gift Box', icon: 'üéÅ', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  
  // Plushie Collection! üß∏ - all plushies are on display stands and block movement
  catPlush: { name: 'Cat Plushie', icon: 'üê±', cost: 225, buzz: 4, category: 'floor', blocksMovement: true },
  dogPlush: { name: 'Dog Plushie', icon: 'üê∂', cost: 225, buzz: 4, category: 'floor', blocksMovement: true },
  bunnyPlush: { name: 'Bunny Plushie', icon: 'üê∞', cost: 250, buzz: 5, category: 'floor', blocksMovement: true },
  pandaPlush: { name: 'Panda Plushie', icon: 'üêº', cost: 300, buzz: 5, category: 'floor', blocksMovement: true },
  penguinPlush: { name: 'Penguin Plushie', icon: 'üêß', cost: 250, buzz: 5, category: 'floor', blocksMovement: true },
  unicornPlush: { name: 'Unicorn Plushie', icon: 'ü¶Ñ', cost: 400, buzz: 7, category: 'floor', blocksMovement: true },
  pigPlush: { name: 'Pig Plushie', icon: 'üê∑', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  frogPlush: { name: 'Frog Plushie', icon: 'üê∏', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  duckPlush: { name: 'Duck Plushie', icon: 'ü¶Ü', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  owlPlush: { name: 'Owl Plushie', icon: 'ü¶â', cost: 275, buzz: 5, category: 'floor', blocksMovement: true },
};

// Dividers - short barriers that block pathfinding but are low enough to see over
const DIVIDERS = {
  ropeStanchion: { name: 'Rope Stanchion', icon: 'üé™', cost: 75, buzz: 1 },
  lowRailing: { name: 'Low Railing', icon: 'üöß', cost: 100, buzz: 1 },
  planterDivider: { name: 'Planter Divider', icon: 'üåø', cost: 150, buzz: 3 },
};

// Doors - customer entry/exit points, placed on walls
const DOORS = {
  basicDoor: { 
    name: 'Basic Door', 
    icon: 'üö™', 
    cost: 300, 
    buzz: 2,
    frameColor: 0x8B4513,  // Brown wood frame
    doorColor: 0xA0522D,   // Sienna door
  },
  glassDoor: { 
    name: 'Glass Door', 
    icon: 'üö™', 
    cost: 500, 
    buzz: 4,
    frameColor: 0x404040,  // Dark metal frame
    doorColor: 0x87CEEB,   // Light blue glass
    isGlass: true,
  },
};

// Wallpapers - interior wall styles
const WALLPAPERS = {
  // Solid colors
  cream: {
    name: 'Cream',
    icon: 'üè†',
    cost: 0,
    buzz: 0,
    color: 0xF5F5DC,
    pattern: 'solid',
  },
  cerulean: {
    name: 'Cerulean Blue',
    icon: 'üíô',
    cost: 500,
    buzz: 2,
    color: 0x007BA7,
    pattern: 'solid',
  },
  burgundy: {
    name: 'Burgundy',
    icon: '‚ù§Ô∏è',
    cost: 500,
    buzz: 2,
    color: 0x800020,
    pattern: 'solid',
  },
  lushGreen: {
    name: 'Lush Green',
    icon: 'üíö',
    cost: 500,
    buzz: 2,
    color: 0x228B22,
    pattern: 'solid',
  },
  pink: {
    name: 'Pink',
    icon: 'ü©∑',
    cost: 500,
    buzz: 2,
    color: 0xFFB6C1,
    pattern: 'solid',
  },
  orange: {
    name: 'Orange',
    icon: 'üß°',
    cost: 500,
    buzz: 2,
    color: 0xFF8C00,
    pattern: 'solid',
  },
  stormy: {
    name: 'Stormy Gray',
    icon: 'üåßÔ∏è',
    cost: 500,
    buzz: 2,
    color: 0x708090,
    pattern: 'solid',
  },
  // Stripe patterns
  blueStripes: {
    name: 'Blue Stripes',
    icon: 'üîµ',
    cost: 1000,
    buzz: 4,
    color: 0xADD8E6,
    stripeColor: 0x4169E1,
    pattern: 'stripes',
  },
  greenStripes: {
    name: 'Green Stripes',
    icon: 'üü¢',
    cost: 1000,
    buzz: 4,
    color: 0x98FB98,
    stripeColor: 0x228B22,
    pattern: 'stripes',
  },
  pinkStripes: {
    name: 'Pink Stripes',
    icon: 'ü©∑',
    cost: 1000,
    buzz: 4,
    color: 0xFFE4E1,
    stripeColor: 0xFF69B4,
    pattern: 'stripes',
  },
  // Textured patterns
  smoothBrick: {
    name: 'Smooth Brick',
    icon: 'üß±',
    cost: 2000,
    buzz: 6,
    color: 0xB22222,
    pattern: 'brick',
  },
  stoneWall: {
    name: 'Stone Wall',
    icon: 'ü™®',
    cost: 2000,
    buzz: 6,
    color: 0x808080,
    pattern: 'stone',
  },
  woodPaneling: {
    name: 'Wood Paneling',
    icon: 'ü™µ',
    cost: 2500,
    buzz: 8,
    color: 0x8B4513,
    pattern: 'wood',
  },
};

// Achievements system
const ACHIEVEMENTS = {
  firstDish: {
    id: 'firstDish',
    name: 'First Dish',
    description: 'Cook your first meal',
    icon: 'üç≥',
    reward: 100,
  },
  firstCustomer: {
    id: 'firstCustomer',
    name: 'First Customer',
    description: 'Serve your first customer',
    icon: 'üòä',
    reward: 100,
  },
  busyKitchen: {
    id: 'busyKitchen',
    name: 'Busy Kitchen',
    description: 'Have all 3 stoves cooking at once',
    icon: 'üî•',
    reward: 250,
  },
  fullHouse: {
    id: 'fullHouse',
    name: 'Full House',
    description: 'Fill all tables with customers',
    icon: 'ü™ë',
    reward: 500,
  },
  bigSpender: {
    id: 'bigSpender',
    name: 'Big Spender',
    description: 'Spend 5,000 coins total',
    icon: 'üí∏',
    reward: 300,
  },
  decorator: {
    id: 'decorator',
    name: 'Interior Designer',
    description: 'Place 5 decorations',
    icon: 'üé®',
    reward: 200,
  },
  speedyChef: {
    id: 'speedyChef',
    name: 'Speedy Chef',
    description: 'Serve 10 customers in one session',
    icon: '‚ö°',
    reward: 300,
  },
  chef: {
    id: 'chef',
    name: 'Rising Chef',
    description: 'Reach level 5',
    icon: 'üë®‚Äçüç≥',
    reward: 500,
  },
  masterChef: {
    id: 'masterChef',
    name: 'Master Chef',
    description: 'Reach level 10',
    icon: 'üëë',
    reward: 1000,
  },
  mogul: {
    id: 'mogul',
    name: 'Cafe Mogul',
    description: 'Earn 10,000 coins total',
    icon: 'üí∞',
    reward: 1000,
  },
  expansion: {
    id: 'expansion',
    name: 'Growing Business',
    description: 'Own 3 stoves and 10 tables',
    icon: 'üìà',
    reward: 500,
  },
  nightOwl: {
    id: 'nightOwl',
    name: 'Night Owl',
    description: 'Serve a customer after 10 PM',
    icon: 'üåô',
    reward: 150,
  },
};

// ============================================
// INITIAL GAME STATE
// ============================================
// ============================================
// AVATAR CUSTOMIZATION OPTIONS
// ============================================
const AVATAR_OPTIONS = {
  genders: [
    { id: 'female', name: 'Female', icon: 'üë©‚Äçüç≥' },
    { id: 'male', name: 'Male', icon: 'üë®‚Äçüç≥' },
  ],
  skinTones: [
    { id: 'light', name: 'Light', color: 0xFFDBAC },
    { id: 'fair', name: 'Fair', color: 0xF5D0B5 },
    { id: 'medium', name: 'Medium', color: 0xD4A574 },
    { id: 'tan', name: 'Tan', color: 0xC68642 },
    { id: 'brown', name: 'Brown', color: 0x8D5524 },
    { id: 'dark', name: 'Dark', color: 0x5C3A21 },
  ],
  hairColors: [
    { id: 'black', name: 'Black', color: 0x1a1a1a },
    { id: 'brown', name: 'Brown', color: 0x4a3728 },
    { id: 'auburn', name: 'Auburn', color: 0x8B4513 },
    { id: 'blonde', name: 'Blonde', color: 0xD4A76A },
    { id: 'ginger', name: 'Ginger', color: 0xB85C38 },
    { id: 'gray', name: 'Gray', color: 0x888888 },
    { id: 'white', name: 'White', color: 0xE8E8E8 },
    { id: 'pink', name: 'Pink', color: 0xFF69B4 },
    { id: 'blue', name: 'Blue', color: 0x4169E1 },
    { id: 'purple', name: 'Purple', color: 0x9370DB },
  ],
  hairStyles: [
    { id: 'short', name: 'Short' },
    { id: 'bun', name: 'Bun' },
    { id: 'ponytail', name: 'Ponytail' },
    { id: 'long', name: 'Long' },
    { id: 'none', name: 'Bald' },
  ],
  apronColors: [
    { id: 'lightBlue', name: 'Light Blue', color: 0x87CEEB },
    { id: 'pink', name: 'Pink', color: 0xFFB6C1 },
    { id: 'mint', name: 'Mint', color: 0x98FF98 },
    { id: 'yellow', name: 'Yellow', color: 0xFFE66D },
    { id: 'lavender', name: 'Lavender', color: 0xE6E6FA },
    { id: 'coral', name: 'Coral', color: 0xFF7F7F },
    { id: 'white', name: 'White', color: 0xFFFFFF },
    { id: 'red', name: 'Red', color: 0xE74C3C },
  ],
  outfitColors: [
    { id: 'white', name: 'Classic White', color: 0xFFFFFF },
    { id: 'cream', name: 'Cream', color: 0xFFFDD0 },
    { id: 'black', name: 'Black', color: 0x2D2D2D },
    { id: 'navy', name: 'Navy', color: 0x1E3A5F },
    { id: 'burgundy', name: 'Burgundy', color: 0x800020 },
    { id: 'forest', name: 'Forest Green', color: 0x228B22 },
  ],
};

const initialState = {
  coins: 100000,
  xp: 0,
  level: 1,
  buzz: 50, // Starts at 50, not 0!
  
  // Waiter - delivers food from counters to customers
  waiter: {
    state: 'idle', // idle, walking_to_counter, walking_to_table, pacing, returning
    gridX: 10, gridZ: 1, // Start in front of counters (counters are at gridZ 0)
    targetCounterId: null,
    targetTableId: null,
    carryingFood: null, // { recipe } when carrying food
    path: [],
    walkProgress: 0,
  },
  
  // Avatar customization
  avatar: {
    gender: 'female',
    skinTone: 'light',
    hairColor: 'brown',
    hairStyle: 'short',
    apronColor: 'lightBlue',
    outfitColor: 'white',
  },
  
  stoves: [
    // Back left corner - rotation 0 = front faces +Z (toward dining area)
    { id: 'stove-1', gridX: 1, gridZ: 0, rotation: 0, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
    { id: 'stove-2', gridX: 3, gridZ: 0, rotation: 0, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
  ],
  
  counters: [
    // Back wall right side - rotation 0 = front faces +Z (customers approach from dining area)
    { id: 'counter-1', gridX: 9, gridZ: 0, rotation: 0, dishes: [] },
    { id: 'counter-2', gridX: 11, gridZ: 0, rotation: 0, dishes: [] },
    { id: 'counter-3', gridX: 13, gridZ: 0, rotation: 0, dishes: [] },
  ],
  
  tables: [
    // Tables now occupy only their own tile (1 tile each)
    // Chairs are placed separately and must be adjacent for customers to sit
    // Row 1
    { id: 'table-1', gridX: 3, gridZ: 5, style: 'square', rotation: 0, customer: null },
    { id: 'table-2', gridX: 7, gridZ: 5, style: 'basicWood', rotation: 0, customer: null },
    { id: 'table-3', gridX: 11, gridZ: 5, style: 'oak', rotation: 0, customer: null },
    // Row 2
    { id: 'table-4', gridX: 4, gridZ: 8, style: 'square', rotation: 0, customer: null },
    { id: 'table-5', gridX: 8, gridZ: 8, style: 'basicWood', rotation: 0, customer: null },
    { id: 'table-6', gridX: 12, gridZ: 8, style: 'oak', rotation: 0, customer: null },
    // Row 3
    { id: 'table-7', gridX: 3, gridZ: 11, style: 'square', rotation: 0, customer: null },
    { id: 'table-8', gridX: 7, gridZ: 11, style: 'basicWood', rotation: 0, customer: null },
  ],
  
  // Separate chairs - must be placed adjacent to tables and facing them
  // Rotation: 0=faces +Z, 1=faces +X, 2=faces -Z, 3=faces -X
  // Each chair has linkedTableId to connect it to its table
  chairs: [
    // Row 1 - chairs to the left of tables (facing +X toward table)
    { id: 'chair-1', gridX: 2, gridZ: 5, style: 'redCushion', rotation: 1, linkedTableId: 'table-1' },
    { id: 'chair-2', gridX: 6, gridZ: 5, style: 'basicWood', rotation: 1, linkedTableId: 'table-2' },
    { id: 'chair-3', gridX: 10, gridZ: 5, style: 'oak', rotation: 1, linkedTableId: 'table-3' },
    // Row 2 - chairs to the right of tables (facing -X toward table)
    { id: 'chair-4', gridX: 5, gridZ: 8, style: 'redCushion', rotation: 3, linkedTableId: 'table-4' },
    { id: 'chair-5', gridX: 9, gridZ: 8, style: 'basicWood', rotation: 3, linkedTableId: 'table-5' },
    { id: 'chair-6', gridX: 13, gridZ: 8, style: 'oak', rotation: 3, linkedTableId: 'table-6' },
    // Row 3 - chairs to the left
    { id: 'chair-7', gridX: 2, gridZ: 11, style: 'redCushion', rotation: 1, linkedTableId: 'table-7' },
    { id: 'chair-8', gridX: 6, gridZ: 11, style: 'basicWood', rotation: 1, linkedTableId: 'table-8' },
  ],
  
  stats: {
    dishesCooked: 0,
    customersServed: 0,
    totalEarned: 0,
    totalSpent: 0,
    customersServedSession: 0, // Resets each session
  },
  
  // Dish Mastery - tracks how many times each dish has been cooked
  // Structure: { burger: { cooked: 15 }, salad: { cooked: 8 }, ... }
  dishMastery: {},
  
  achievements: [], // Array of unlocked achievement IDs
  
  decorations: [], // Player-placed decorations
  dividers: [], // Player-placed dividers (block pathfinding)
  doors: [], // Player-placed doors (customer entry/exit points)
  wallpaper: 'cream', // Default interior wallpaper style (for unpainted segments)
  paintedSegments: [], // Individual painted segments: [{ wall: 'back', position: 0, wallpaper: 'cerulean' }, ...]
  paintedVersion: 0, // Increments on every paint change to trigger updates
  
  nextCustomerId: 1,
};

// ============================================
// GAME REDUCER
// ============================================
function gameReducer(state, action) {
  switch (action.type) {
    case 'START_COOKING': {
      const { stoveId, recipeKey } = action.payload;
      const recipe = RECIPES[recipeKey];
      if (state.coins < recipe.cost) return state;
      
      // Apply mastery bonus to servings (Level 1+ gives +5% servings)
      const masteryServings = getServingsWithMastery(state.dishMastery, recipeKey);
      
      return {
        ...state,
        coins: state.coins - recipe.cost,
        stats: {
          ...state.stats,
          totalSpent: state.stats.totalSpent + recipe.cost,
        },
        stoves: state.stoves.map(s => 
          s.id === stoveId 
            ? { ...s, state: 'cooking', recipe: recipeKey, startTime: Date.now(), servingsLeft: masteryServings }
            : s
        ),
      };
    }
    
    case 'FINISH_COOKING': {
      const { stoveId } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      const recipeKey = stove?.recipe;
      
      // Update mastery tracking for this dish
      const currentMastery = state.dishMastery[recipeKey] || { cooked: 0 };
      const newMastery = { ...currentMastery, cooked: currentMastery.cooked + 1 };
      
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'ready' } : s
        ),
        stats: { ...state.stats, dishesCooked: state.stats.dishesCooked + 1 },
        dishMastery: {
          ...state.dishMastery,
          [recipeKey]: newMastery,
        },
      };
    }
    
    case 'SPOIL_FOOD': {
      const { stoveId } = action.payload;
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'spoiled' } : s
        ),
      };
    }
    
    case 'SERVE_TO_COUNTER': {
      const { stoveId, counterId } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      if (!stove || stove.state !== 'ready') return state;
      
      const counter = state.counters.find(c => c.id === counterId);
      
      // Counter can only have one dish type - check if empty or same recipe
      if (counter.dishes.length > 0 && counter.dishes[0].recipe !== stove.recipe) {
        return state; // Can't mix recipes on same counter
      }
      
      // Apply mastery bonus to XP (Level 2+ gives +5% XP)
      const masteryXP = getXPWithMastery(state.dishMastery, stove.recipe);
      
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
        counters: state.counters.map(c => {
          if (c.id !== counterId) return c;
          
          if (c.dishes.length > 0) {
            // Stack onto existing dish of same recipe
            return { 
              ...c, 
              dishes: [{ ...c.dishes[0], servings: c.dishes[0].servings + stove.servingsLeft }] 
            };
          } else {
            // Add new dish
            return { ...c, dishes: [{ recipe: stove.recipe, servings: stove.servingsLeft }] };
          }
        }),
        xp: state.xp + masteryXP,
      };
    }
    
    case 'CLEAN_STOVE': {
      const { stoveId } = action.payload;
      if (state.coins < 15) return state;
      return {
        ...state,
        coins: state.coins - 15,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
      };
    }
    
    case 'SPAWN_CUSTOMER': {
      const { tableId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table) return state;
      
      // Find the chair adjacent to this table (required for seating)
      const chair = findChairForTable(table, state.chairs || []);
      if (!chair) return state; // No chair = no customer can sit here
      
      // Generate fully random appearance for variety (no more clones!)
      const appearance = {
        skinTone: Math.floor(Math.random() * 8),      // 8 skin tones
        shirtColor: Math.floor(Math.random() * 14),   // 14 shirt colors
        pantsColor: Math.floor(Math.random() * 10),   // 10 pants colors
        hairColor: Math.floor(Math.random() * 10),    // 10 hair colors
        hairStyle: Math.floor(Math.random() * 6),     // 6 hair styles
        shoeColor: Math.floor(Math.random() * 6),     // 6 shoe colors
        isMale: Math.random() > 0.5,                  // 50/50 gender presentation
        // Accessories (30% chance each)
        hat: Math.random() < 0.3 ? Math.floor(Math.random() * 5) : null,      // 5 hat types
        glasses: Math.random() < 0.25 ? Math.floor(Math.random() * 3) : null, // 3 glasses types
        accessory: Math.random() < 0.15 ? Math.floor(Math.random() * 4) : null, // 4 extra accessories
      };
      
      // Find entry point - use placed door if available, otherwise use default
      let entryGridX, entryGridZ;
      if (state.doors && state.doors.length > 0) {
        // Use a random door if multiple exist
        const door = state.doors[Math.floor(Math.random() * state.doors.length)];
        const entryPoint = getDoorEntryPoint(door);
        entryGridX = entryPoint.gridX;
        entryGridZ = entryPoint.gridZ;
      } else {
        // Fall back to default door position
        entryGridX = DOOR_POSITION.gridX;
        entryGridZ = DOOR_POSITION.gridZ;
      }
      
      // Calculate path from door to the chair position (not the old built-in chair tile)
      const occupancyMap = buildOccupancyMap(state);
      // Remove the chair tile from occupancy so pathfinding can reach it
      occupancyMap.delete(getTileKey(chair.gridX, chair.gridZ));
      const path = findPath(occupancyMap, entryGridX, entryGridZ, 
        chair.gridX, chair.gridZ, GRID.width, GRID.height);
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { 
                id: state.nextCustomerId, 
                patience: 100, 
                state: 'entering',  // Start at door, walking to table
                appearance,
                colorIndex: 0,
                spawnTime: Date.now(),
                targetCounterId: null,
                walkProgress: 0,
                hasFood: false,
                // Path from door to chair
                path: path || [],
                pathIndex: 0,
                // Store positions for rendering
                currentGridX: entryGridX,
                currentGridZ: entryGridZ,
                // Store door entry for exit path
                doorGridX: entryGridX,
                doorGridZ: entryGridZ,
                tableX: table.gridX,
                tableZ: table.gridZ,
                // Store chair info for rendering and pathfinding
                chairId: chair.id,
                chairX: chair.gridX,
                chairZ: chair.gridZ,
              } }
            : t
        ),
        nextCustomerId: state.nextCustomerId + 1,
      };
    }
    
    case 'CUSTOMER_REACHED_SEAT': {
      // Customer walked from door to their table, now they sit and wait
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer?.state === 'entering'
            ? { ...t, customer: { ...t.customer, state: 'waiting', walkProgress: 0, path: [], pathIndex: 0 } }
            : t
        ),
      };
    }
    
    case 'START_LEAVING': {
      // Customer finished eating (happy) or gave up (angry), now walks to door
      const { tableId, happy } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) return state;
      
      // Use the door they entered through, or find an exit door
      let exitGridX = table.customer.doorGridX;
      let exitGridZ = table.customer.doorGridZ;
      
      // If no stored door position, find one
      if (exitGridX === undefined || exitGridZ === undefined) {
        if (state.doors && state.doors.length > 0) {
          const door = state.doors[0];
          const exitPoint = getDoorEntryPoint(door);
          exitGridX = exitPoint.gridX;
          exitGridZ = exitPoint.gridZ;
        } else {
          exitGridX = DOOR_POSITION.gridX;
          exitGridZ = DOOR_POSITION.gridZ;
        }
      }
      
      // Calculate path from chair back to door
      // Use stored chair position if available, otherwise fall back to getChairTile for legacy saves
      let chairGridX, chairGridZ;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX = table.customer.chairX;
        chairGridZ = table.customer.chairZ;
      } else {
        const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX = chairTile.gridX;
        chairGridZ = chairTile.gridZ;
      }
      const occupancyMap = buildOccupancyMap(state);
      // Remove the chair tile from occupancy so pathfinding can start from there
      occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
      const path = findPath(occupancyMap, chairGridX, chairGridZ,
        exitGridX, exitGridZ, GRID.width, GRID.height);
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { 
                ...t.customer, 
                state: 'leaving',
                leavingHappy: happy,
                walkProgress: 0, 
                path: path || [], 
                pathIndex: 0,
                leaveStartTime: Date.now(),
              } }
            : t
        ),
        // Give coins/buzz immediately for happy customers
        coins: happy ? state.coins : state.coins,
        buzz: happy ? Math.min(105, state.buzz + 2) : Math.max(0, state.buzz - 3),
      };
    }
    
    case 'CUSTOMER_LEFT': {
      // Customer reached the door and exits
      const { tableId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const wasHappy = table?.customer?.leavingHappy;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        stats: wasHappy 
          ? { ...state.stats, customersServed: state.stats.customersServed + 1 }
          : { ...state.stats, customersLost: (state.stats.customersLost || 0) + 1 },
      };
    }
    
    case 'CUSTOMER_WALK_TO_COUNTER': {
      const { tableId, counterId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const counter = state.counters.find(c => c.id === counterId);
      
      if (!table || !table.customer || table.customer.state !== 'waiting' || !counter) {
        return state;
      }
      
      // Calculate path from customer's seat (chair tile) to counter's interaction tile
      // Use stored chair position if available, otherwise fall back for legacy saves
      let chairGridX, chairGridZ;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX = table.customer.chairX;
        chairGridZ = table.customer.chairZ;
      } else {
        const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX = chairTile.gridX;
        chairGridZ = chairTile.gridZ;
      }
      const counterInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
      
      // Build occupancy map (exclude the table's own tiles since customer is leaving)
      const occupancyMap = buildOccupancyMap(state);
      // Remove the customer's chair tile from occupancy (they can walk from their seat)
      occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
      // Also remove table tile
      occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
      
      // Find path
      const path = findPath(occupancyMap, chairGridX, chairGridZ, 
        counterInteraction.gridX, counterInteraction.gridZ, GRID.width, GRID.height);
      
      // If no path found, customer stays waiting (don't block forever)
      if (!path || path.length === 0) {
        console.log('No path found to counter, customer waits');
        return state;
      }
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { ...t.customer, state: 'walking_to_counter', targetCounterId: counterId, walkProgress: 0, path, pathIndex: 0 } }
            : t
        ),
      };
    }
    
    case 'CUSTOMER_REACHED_COUNTER': {
      const { tableId, counterId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const counter = state.counters.find(c => c.id === counterId);
      
      if (!table || !table.customer) return state;
      
      // If no food at this counter, check other counters or send customer back to waiting
      if (!counter || counter.dishes.length === 0) {
        // Try to find another counter with food
        const otherCounter = state.counters.find(c => c.dishes.length > 0);
        if (otherCounter) {
          // Calculate path to other counter
          const currentInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
          const otherInteraction = getInteractionTile('counter', otherCounter.gridX, otherCounter.gridZ, otherCounter.rotation || 0);
          
          const occupancyMap = buildOccupancyMap(state);
          const tableTiles = getTableTiles(table);
          tableTiles.forEach(tile => occupancyMap.delete(getTileKey(tile.gridX, tile.gridZ)));
          
          const path = findPath(occupancyMap, currentInteraction.gridX, currentInteraction.gridZ,
            otherInteraction.gridX, otherInteraction.gridZ, GRID.width, GRID.height);
          
          return {
            ...state,
            tables: state.tables.map(t =>
              t.id === tableId && t.customer
                ? { ...t, customer: { ...t.customer, targetCounterId: otherCounter.id, walkProgress: 0, path: path || [], pathIndex: 0 } }
                : t
            ),
          };
        }
        // No food anywhere - go back to seat and wait
        const currentInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
        
        // Use stored chair position if available
        let chairGridX, chairGridZ;
        if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
          chairGridX = table.customer.chairX;
          chairGridZ = table.customer.chairZ;
        } else {
          const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
          chairGridX = chairTile.gridX;
          chairGridZ = chairTile.gridZ;
        }
        
        const occupancyMap = buildOccupancyMap(state);
        occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
        occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
        
        const path = findPath(occupancyMap, currentInteraction.gridX, currentInteraction.gridZ,
          chairGridX, chairGridZ, GRID.width, GRID.height);
        
        return {
          ...state,
          tables: state.tables.map(t =>
            t.id === tableId && t.customer
              ? { ...t, customer: { ...t.customer, state: 'walking_to_table', walkProgress: 0, targetCounterId: null, path: path || [], pathIndex: 0, hasFood: false } }
              : t
          ),
        };
      }
      
      const dish = counter.dishes[0];
      const recipe = RECIPES[dish.recipe];
      const newServings = dish.servings - 1;
      
      // Calculate path back to seat
      const counterInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
      
      // Use stored chair position if available
      let chairGridX2, chairGridZ2;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX2 = table.customer.chairX;
        chairGridZ2 = table.customer.chairZ;
      } else {
        const chairTile2 = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX2 = chairTile2.gridX;
        chairGridZ2 = chairTile2.gridZ;
      }
      
      const occupancyMap = buildOccupancyMap(state);
      occupancyMap.delete(getTileKey(chairGridX2, chairGridZ2));
      occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
      
      const path = findPath(occupancyMap, counterInteraction.gridX, counterInteraction.gridZ,
        chairGridX2, chairGridZ2, GRID.width, GRID.height);
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 ? [{ ...dish, servings: newServings }] : [] }
            : c
        ),
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'walking_to_table', walkProgress: 0, hasFood: true, path: path || [], pathIndex: 0 } }
            : t
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          customersServed: state.stats.customersServed + 1,
          totalEarned: state.stats.totalEarned + recipe.revenue,
        },
      };
    }
    
    case 'CUSTOMER_REACHED_TABLE': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', walkProgress: 0, eatStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'UPDATE_WALK_PROGRESS': {
      const { tableId, progress } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, walkProgress: progress } }
            : t
        ),
      };
    }
    
    case 'UPDATE_CUSTOMER_PATIENCE': {
      const { tableId, patience } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, patience } }
            : t
        ),
      };
    }
    
    case 'SERVE_CUSTOMER': {
      const { tableId, counterId } = action.payload;
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter || counter.dishes.length === 0) return state;
      
      const dish = counter.dishes[0];
      const recipe = RECIPES[dish.recipe];
      const newServings = dish.servings - 1;
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 ? [{ ...dish, servings: newServings }, ...c.dishes.slice(1)] : c.dishes.slice(1) }
            : c
        ),
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'TRASH_COUNTER': {
      const { counterId } = action.payload;
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId ? { ...c, dishes: [] } : c
        ),
      };
    }
    
    case 'CUSTOMER_LEAVE_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.min(105, state.buzz + 2),
        stats: { ...state.stats, customersServed: state.stats.customersServed + 1 },
      };
    }
    
    case 'CUSTOMER_LEAVE_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.max(0, state.buzz - 5),
      };
    }
    
    // ============ WAITER ACTIONS ============
    // Simple: idle ‚Üí walking_to_counter ‚Üí walking_to_table ‚Üí idle
    
    case 'WAITER_GO_TO_COUNTER': {
      const { counterId, tableId, path } = action.payload;
      if (!path || path.length === 0) return state;
      
      return {
        ...state,
        waiter: {
          ...state.waiter,
          state: 'walking_to_counter',
          targetCounterId: counterId,
          targetTableId: tableId, // Remember which customer we're serving
          path,
          pathIndex: 0,
          walkProgress: 0,
        },
      };
    }
    
    case 'WAITER_PICKUP_AND_GO': {
      // Waiter reached counter, pick up ONE serving and start walking to table
      const { counterId, tableId, pathToTable } = action.payload;
      
      // Guard: must be walking_to_counter
      if (state.waiter.state !== 'walking_to_counter') return state;
      
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter || counter.dishes.length === 0 || !pathToTable || pathToTable.length === 0) {
        // No food or no path, go idle
        return {
          ...state,
          waiter: { ...state.waiter, state: 'idle', path: [], carryingFood: null },
        };
      }
      
      // Take ONE serving (same logic as SERVE_CUSTOMER)
      const dish = counter.dishes[0];
      const newServings = dish.servings - 1;
      const finalCounterTile = state.waiter.path[state.waiter.path.length - 1];
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 
                ? [{ ...dish, servings: newServings }, ...c.dishes.slice(1)] 
                : c.dishes.slice(1) }
            : c
        ),
        waiter: {
          ...state.waiter,
          state: 'walking_to_table',
          gridX: finalCounterTile?.x ?? state.waiter.gridX,
          gridZ: finalCounterTile?.z ?? state.waiter.gridZ,
          carryingFood: { recipe: dish.recipe },
          path: pathToTable,
          pathIndex: 0,
          walkProgress: 0,
        },
      };
    }
    
    case 'WAITER_SERVE_CUSTOMER': {
      // Waiter reached table, give food to customer
      const { tableId } = action.payload;
      
      // Guard: must be walking_to_table and carrying food
      if (state.waiter.state !== 'walking_to_table' || !state.waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiter: { ...state.waiter, state: 'idle', path: [], carryingFood: null },
        };
      }
      
      const recipe = RECIPES[state.waiter.carryingFood.recipe];
      const finalTile = state.waiter.path[state.waiter.path.length - 1];
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiter: {
          ...state.waiter,
          state: 'idle', // Just go idle where we are
          gridX: finalTile?.x ?? state.waiter.gridX,
          gridZ: finalTile?.z ?? state.waiter.gridZ,
          carryingFood: null,
          targetCounterId: null,
          targetTableId: null,
          path: [],
          pathIndex: 0,
          walkProgress: 0,
        },
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'WAITER_UPDATE_POSITION': {
      const { gridX, gridZ, walkProgress } = action.payload;
      return {
        ...state,
        waiter: {
          ...state.waiter,
          gridX: gridX ?? state.waiter.gridX,
          gridZ: gridZ ?? state.waiter.gridZ,
          walkProgress: walkProgress ?? state.waiter.walkProgress,
        },
      };
    }
    
    case 'WAITER_START_PACING': {
      const { path } = action.payload;
      return {
        ...state,
        waiter: {
          ...state.waiter,
          state: 'pacing',
          path: path || [],
          walkProgress: 0,
        },
      };
    }
    
    case 'WAITER_GO_IDLE': {
      return {
        ...state,
        waiter: {
          ...state.waiter,
          state: 'idle',
          path: [],
          walkProgress: 0,
        },
      };
    }
    
    case 'WAITER_SERVE_AND_RETURN': {
      const { tableId, finalX, finalZ, returnPath } = action.payload;
      
      // Guard: must be walking_to_table and carrying food
      if (state.waiter.state !== 'walking_to_table' || !state.waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiter: { ...state.waiter, state: 'idle', path: [], carryingFood: null, gridX: finalX, gridZ: finalZ },
        };
      }
      
      const recipe = RECIPES[state.waiter.carryingFood.recipe];
      
      // Check if we have a valid return path (at least 2 tiles to walk)
      const hasValidPath = returnPath && returnPath.length >= 2;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiter: {
          ...state.waiter,
          state: hasValidPath ? 'returning' : 'idle', // Only walk if we have a path
          gridX: finalX, // Stay at table position - will be updated as we walk
          gridZ: finalZ,
          carryingFood: null,
          targetCounterId: null,
          targetTableId: null,
          path: hasValidPath ? returnPath : [],
          walkProgress: 0,
        },
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'WAITER_SERVE_AND_CONTINUE': {
      // Serve current customer AND immediately start walking to next counter (no idle wait!)
      const { tableId, finalX, finalZ, nextCounterId, nextTableId, pathToCounter } = action.payload;
      
      // Guard: must be walking_to_table and carrying food
      if (state.waiter.state !== 'walking_to_table' || !state.waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiter: { ...state.waiter, state: 'idle', path: [], carryingFood: null, gridX: finalX, gridZ: finalZ },
        };
      }
      
      const recipe = RECIPES[state.waiter.carryingFood.recipe];
      const hasValidPath = pathToCounter && pathToCounter.length >= 1;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiter: {
          ...state.waiter,
          // Go DIRECTLY to walking_to_counter - skip idle/returning entirely!
          state: hasValidPath ? 'walking_to_counter' : 'idle',
          gridX: finalX,
          gridZ: finalZ,
          carryingFood: null, // Just delivered, not carrying
          targetCounterId: nextCounterId,
          targetTableId: nextTableId,
          path: hasValidPath ? pathToCounter : [],
          walkProgress: 0,
        },
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'START_LEAVING_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingHappy', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'START_LEAVING_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingAngry', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'LEVEL_UP': {
      return {
        ...state,
        level: state.level + 1,
        coins: state.coins + 1000,
      };
    }
    
    case 'BUY_STOVE': {
      const { gridX, gridZ, rotation = 0, free = false } = action.payload || {};
      if (!free && state.coins < 500) return state;
      if (state.stoves.length >= 8) return state; // Max 8 stoves
      
      // Check position not already taken by anything
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      if (stoveTaken || counterTaken || tableTaken || decorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - 500,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + 500 },
        stoves: [...state.stoves, { id: `stove-${Date.now()}`, gridX, gridZ, rotation, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 }],
      };
    }
    
    case 'BUY_TABLE': {
      const { gridX, gridZ, style = 'round', rotation = 0, free = false } = action.payload || {};
      const tableStyle = TABLE_STYLES[style] || TABLE_STYLES.round;
      const cost = tableStyle.cost;
      
      if (!free && state.coins < cost) return state;
      if (state.tables.length >= 15) return state;
      
      // New tables only occupy 1 tile (the table itself)
      // Chairs are placed separately
      const newTableTile = { gridX, gridZ };
      
      // Check tile isn't occupied by existing tables
      const tableTaken = state.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
      
      // Check tile isn't occupied by chairs
      const chairTaken = (state.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
      
      // Check tile isn't occupied by decorations
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      
      // Check tile isn't occupied by stoves/counters
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      
      // Check dividers
      const dividerTaken = (state.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
      
      if (tableTaken || chairTaken || decorTaken || stoveTaken || counterTaken || dividerTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        tables: [...state.tables, { id: `table-${Date.now()}`, gridX, gridZ, style, rotation, customer: null }],
      };
    }
    
    case 'BUY_CHAIR': {
      const { gridX, gridZ, style = 'basicWood', rotation = 0, linkedTableId = null, free = false } = action.payload || {};
      const chairStyle = CHAIR_STYLES[style] || CHAIR_STYLES.basicWood;
      const cost = chairStyle.cost;
      
      if (!free && state.coins < cost) return state;
      
      // Max chairs = same as max tables (15)
      if ((state.chairs || []).length >= 15) return state;
      
      // Check tile isn't already occupied
      const chairTaken = (state.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
      const tableTaken = state.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const dividerTaken = (state.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
      
      if (chairTaken || tableTaken || decorTaken || stoveTaken || counterTaken || dividerTaken) return state;
      
      // Validate linked table exists and isn't already linked to another chair
      if (linkedTableId) {
        const linkedTable = state.tables.find(t => t.id === linkedTableId);
        if (!linkedTable) return state; // Table doesn't exist
        const tableAlreadyLinked = (state.chairs || []).some(c => c.linkedTableId === linkedTableId);
        if (tableAlreadyLinked) return state; // Table already has a chair
      }
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        chairs: [...(state.chairs || []), { id: `chair-${Date.now()}`, gridX, gridZ, style, rotation, linkedTableId }],
      };
    }
    
    case 'REMOVE_CHAIR': {
      const { chairId, noRefund = false } = action.payload;
      const chair = (state.chairs || []).find(c => c.id === chairId);
      if (!chair) return state;
      
      const chairStyleData = CHAIR_STYLES[chair.style] || CHAIR_STYLES.basicWood;
      const refund = noRefund ? 0 : Math.floor(chairStyleData.cost * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        chairs: (state.chairs || []).filter(c => c.id !== chairId),
      };
    }
    
    case 'ROTATE_CHAIR': {
      const { chairId } = action.payload;
      return {
        ...state,
        chairs: (state.chairs || []).map(c =>
          c.id === chairId ? { ...c, rotation: ((c.rotation || 0) + 1) % 4 } : c
        ),
      };
    }
    
    case 'BUY_COUNTER': {
      const { gridX, gridZ, rotation = 0, free = false } = action.payload || {};
      if (!free && state.coins < 400) return state;
      if (state.counters.length >= 6) return state; // Max 6 counters
      
      // Check position not already taken by anything
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      if (counterTaken || stoveTaken || tableTaken || decorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - 400,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + 400 },
        counters: [...state.counters, { id: `counter-${Date.now()}`, gridX, gridZ, rotation, dishes: [] }],
      };
    }
    
    case 'PLACE_DECORATION': {
      const { decorationType, gridX, gridZ, rotation = 0, free = false } = action.payload;
      const decor = DECORATIONS[decorationType];
      if (!decor || (!free && state.coins < decor.cost)) return state;
      
      // Check if position is already taken by anything (floor decorations only)
      if (decor.category !== 'wall') {
        const decorTaken = state.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const tableTaken = state.tables.some(t => {
          const tiles = getTableTiles(t);
          return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
        });
        const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        if (decorTaken || tableTaken || stoveTaken || counterTaken) return state;
      }
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - decor.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + decor.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + decor.buzz),
        decorations: [...state.decorations, {
          id: `decor-${Date.now()}`,
          type: decorationType,
          gridX,
          gridZ,
          rotation,
        }],
      };
    }
    
    case 'REMOVE_DECORATION': {
      const { decorationId, noRefund = false } = action.payload;
      const decor = state.decorations.find(d => d.id === decorationId);
      if (!decor) return state;
      const decorType = DECORATIONS[decor.type];
      const refund = noRefund ? 0 : Math.floor(decorType.cost * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - decorType.buzz),
        decorations: state.decorations.filter(d => d.id !== decorationId),
      };
    }
    
    case 'PLACE_DIVIDER': {
      const { dividerType, gridX, gridZ, rotation = 0, free = false } = action.payload;
      const divider = DIVIDERS[dividerType];
      if (!divider || (!free && state.coins < divider.cost)) return state;
      
      // Check if position is already taken
      const dividerTaken = state.dividers.some(d => d.gridX === gridX && d.gridZ === gridZ);
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      if (dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - divider.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + divider.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + divider.buzz),
        dividers: [...state.dividers, {
          id: `divider-${Date.now()}`,
          type: dividerType,
          gridX,
          gridZ,
          rotation: rotation % 2, // Only 0 or 1 (0¬∞ or 90¬∞)
        }],
      };
    }
    
    case 'REMOVE_DIVIDER': {
      const { dividerId, noRefund = false } = action.payload;
      const divider = state.dividers.find(d => d.id === dividerId);
      if (!divider) return state;
      const dividerType = DIVIDERS[divider.type];
      const refund = noRefund ? 0 : Math.floor(dividerType.cost * 0.5);
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - dividerType.buzz),
        dividers: state.dividers.filter(d => d.id !== dividerId),
      };
    }
    
    case 'PLACE_DOOR': {
      const { doorType, wall, wallPosition, free = false } = action.payload;
      const door = DOORS[doorType];
      if (!door || (!free && state.coins < door.cost)) return state;
      
      // Check if position is already taken by another door
      const doorTaken = state.doors.some(d => d.wall === wall && d.wallPosition === wallPosition);
      if (doorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - door.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + door.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + door.buzz),
        doors: [...state.doors, {
          id: `door-${Date.now()}`,
          type: doorType,
          wall,           // 'back', 'left', or 'right'
          wallPosition,   // Position along the wall (0 to wall length)
        }],
      };
    }
    
    case 'REMOVE_DOOR': {
      const { doorId, noRefund = false } = action.payload;
      const door = state.doors.find(d => d.id === doorId);
      if (!door) return state;
      const doorType = DOORS[door.type];
      const refund = noRefund ? 0 : Math.floor(doorType.cost * 0.5);
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - doorType.buzz),
        doors: state.doors.filter(d => d.id !== doorId),
      };
    }
    
    case 'CHANGE_WALLPAPER': {
      const { wallpaperType } = action.payload;
      const wallpaper = WALLPAPERS[wallpaperType];
      if (!wallpaper) return state;
      
      // If same wallpaper, no change needed
      if (state.wallpaper === wallpaperType) return state;
      
      // Check if player can afford it
      if (state.coins < wallpaper.cost) return state;
      
      // Get old wallpaper buzz to remove
      const oldWallpaper = WALLPAPERS[state.wallpaper] || WALLPAPERS.cream;
      
      return {
        ...state,
        coins: state.coins - wallpaper.cost,
        buzz: Math.min(100, Math.max(0, state.buzz - oldWallpaper.buzz + wallpaper.buzz)),
        wallpaper: wallpaperType,
        paintedSegments: [], // Clear individual paints when setting base wallpaper
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + wallpaper.cost },
      };
    }
    
    case 'PAINT_SEGMENT': {
      const { wall, position, wallpaperType } = action.payload;
      const wallpaper = WALLPAPERS[wallpaperType];
      if (!wallpaper) return state;
      
      // Check if this segment already has this wallpaper
      const existingPaint = (state.paintedSegments || []).find(
        p => p.wall === wall && p.position === position
      );
      if (existingPaint && existingPaint.wallpaper === wallpaperType) return state;
      
      // Check if player can afford it
      if (state.coins < wallpaper.cost) return state;
      
      // Remove any existing paint for this segment
      const otherPaints = (state.paintedSegments || []).filter(
        p => !(p.wall === wall && p.position === position)
      );
      
      // Add new paint
      const newPaints = [...otherPaints, { wall, position, wallpaper: wallpaperType }];
      
      return {
        ...state,
        coins: state.coins - wallpaper.cost,
        paintedSegments: newPaints,
        paintedVersion: (state.paintedVersion || 0) + 1, // Increment version to trigger updates
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + wallpaper.cost },
      };
    }
    
    case 'REMOVE_STOVE': {
      const { stoveId, noRefund = false } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      if (!stove) return state;
      if (!noRefund && state.stoves.length <= 1) return state; // Must keep at least 1 stove (not when moving)
      const refund = noRefund ? 0 : Math.floor(500 * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        stoves: state.stoves.filter(s => s.id !== stoveId),
      };
    }
    
    case 'REMOVE_COUNTER': {
      const { counterId, noRefund = false } = action.payload;
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter) return state;
      if (!noRefund && state.counters.length <= 1) return state; // Must keep at least 1 counter (not when moving)
      const refund = noRefund ? 0 : Math.floor(400 * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        counters: state.counters.filter(c => c.id !== counterId),
      };
    }
    
    case 'REMOVE_TABLE': {
      const { tableId, noRefund = false } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table) return state;
      if (!noRefund && state.tables.length <= 1) return state; // Must keep at least 1 table (not when moving)
      if (table.customer) return state; // Can't remove table with customer
      const tableStyleData = TABLE_STYLES[table.style] || TABLE_STYLES.round;
      const refund = noRefund ? 0 : Math.floor(tableStyleData.cost * 0.5); // 50% refund based on table cost
      
      // Also remove any chair linked to this table
      const linkedChair = (state.chairs || []).find(c => c.linkedTableId === tableId);
      let chairRefund = 0;
      if (linkedChair && !noRefund) {
        const chairStyleData = CHAIR_STYLES[linkedChair.style] || CHAIR_STYLES.basicWood;
        chairRefund = Math.floor(chairStyleData.cost * 0.5);
      }
      
      return {
        ...state,
        coins: state.coins + refund + chairRefund,
        tables: state.tables.filter(t => t.id !== tableId),
        chairs: (state.chairs || []).filter(c => c.linkedTableId !== tableId),
      };
    }
    
    case 'ROTATE_TABLE': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, rotation: ((t.rotation || 0) + 1) % 4 } : t
        ),
      };
    }
    
    case 'LOAD_SAVE': {
      const gs = action.payload;
      const now = Date.now();
      
      // Process stoves - cooking becomes ready, ready gets fresh spoil timer
      const loadedStoves = (gs.stoves || state.stoves).map(s => {
        if (s.state === 'cooking') {
          // Food finished cooking while you were away!
          return { ...s, state: 'ready', startTime: now };
        }
        if (s.state === 'ready') {
          // Reset spoil timer so it doesn't immediately spoil
          return { ...s, startTime: now };
        }
        return s;
      });
      
      // Load tables first (needed for chair migration)
      const loadedTables = (gs.tables || state.tables).map(t => ({ 
        ...t, 
        style: t.style || 'round', 
        rotation: t.rotation || 0 
      }));
      
      // Migrate old chairs: add linkedTableId if missing
      // For each chair without a link, check if it faces a table and link them
      const loadedChairs = (gs.chairs || state.chairs || []).map(c => ({ 
        ...c, 
        style: c.style || 'basicWood', 
        rotation: c.rotation || 0 
      }));
      
      // Track which tables are already linked
      const linkedTableIds = new Set(loadedChairs.filter(c => c.linkedTableId).map(c => c.linkedTableId));
      
      // For chairs without linkedTableId, try to auto-link based on facing direction
      const migratedChairs = loadedChairs.map(chair => {
        if (chair.linkedTableId) return chair; // Already linked
        
        // Calculate which tile this chair faces
        const rotation = chair.rotation || 0;
        let facingX = chair.gridX;
        let facingZ = chair.gridZ;
        switch (rotation % 4) {
          case 0: facingZ = chair.gridZ + 1; break; // Faces +Z
          case 1: facingX = chair.gridX + 1; break; // Faces +X
          case 2: facingZ = chair.gridZ - 1; break; // Faces -Z
          case 3: facingX = chair.gridX - 1; break; // Faces -X
        }
        
        // Find table at facing position
        const facingTable = loadedTables.find(t => t.gridX === facingX && t.gridZ === facingZ);
        if (facingTable && !linkedTableIds.has(facingTable.id)) {
          linkedTableIds.add(facingTable.id);
          return { ...chair, linkedTableId: facingTable.id };
        }
        
        return chair;
      });
      
      return {
        ...state,
        coins: gs.coins || 5000,
        xp: gs.xp || 0,
        level: gs.level || 1,
        buzz: gs.buzz || 50,
        avatar: gs.avatar || state.avatar, // Load avatar customization
        stats: {
          dishesCooked: gs.stats?.dishesCooked || 0,
          customersServed: gs.stats?.customersServed || 0,
          totalEarned: gs.stats?.totalEarned || 0,
          totalSpent: gs.stats?.totalSpent || 0,
          customersServedSession: 0, // Reset session stats on load
        },
        dishMastery: gs.dishMastery || {}, // Load dish mastery progress
        achievements: gs.achievements || [],
        stoves: loadedStoves.map(s => ({ ...s, rotation: s.rotation || 0 })),
        counters: (gs.counters || state.counters).map(c => ({ ...c, rotation: c.rotation || 0 })),
        tables: loadedTables,
        chairs: migratedChairs,
        waiter: { // Reset waiter to idle on load
          state: 'idle',
          gridX: 10, gridZ: 1, // In front of counters
          targetCounterId: null,
          targetTableId: null,
          carryingFood: null,
          path: [],
          walkProgress: 0,
        },
        decorations: gs.decorations || [],
        dividers: gs.dividers || [],
        doors: gs.doors || [],
        wallpaper: gs.wallpaper || 'cream',
        paintedSegments: gs.paintedSegments || [],
        paintedVersion: gs.paintedVersion || 0,
      };
    }
    
    case 'UPDATE_AVATAR': {
      const { field, value } = action.payload;
      return {
        ...state,
        avatar: {
          ...state.avatar,
          [field]: value,
        },
      };
    }
    
    case 'UNLOCK_ACHIEVEMENT': {
      const { achievementId } = action.payload;
      // Don't unlock if already unlocked
      if (state.achievements.includes(achievementId)) return state;
      
      const achievement = ACHIEVEMENTS[achievementId];
      if (!achievement) return state;
      
      return {
        ...state,
        achievements: [...state.achievements, achievementId],
        coins: state.coins + achievement.reward,
        stats: { ...state.stats, totalEarned: state.stats.totalEarned + achievement.reward },
      };
    }
    
    default:
      return state;
  }
}

// ============================================
// 3D OBJECT CREATION HELPERS
// ============================================
function createVoxelBox(width, height, depth, color, x = 0, y = 0, z = 0) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function createFloor(scene) {
  // Kitchen floor (white tiles) - rows 0-2
  for (let x = 0; x < GRID.width; x++) {
    for (let z = 0; z < 3; z++) {
      const isLight = (x + z) % 2 === 0;
      const tile = createVoxelBox(
        TILE_SIZE * 0.98, 0.1, TILE_SIZE * 0.98,
        isLight ? 0xffffff : 0xe8e8e8,
        x - GRID.width / 2 + 0.5, 0, z - GRID.height / 2 + 0.5
      );
      tile.receiveShadow = true;
      scene.add(tile);
    }
  }
  
  // Dining floor (warm wood) - rows 3 to end
  for (let x = 0; x < GRID.width; x++) {
    for (let z = 3; z < GRID.height; z++) {
      const isLight = (x + z) % 2 === 0;
      const tile = createVoxelBox(
        TILE_SIZE * 0.98, 0.1, TILE_SIZE * 0.98,
        isLight ? COLORS.floor.tile1 : COLORS.floor.tile2,
        x - GRID.width / 2 + 0.5, 0, z - GRID.height / 2 + 0.5
      );
      tile.receiveShadow = true;
      scene.add(tile);
    }
  }
}

function createWalls(scene, windowMaterialsRef, wallSegmentsRef, doorPositions = [], wallpaperType = 'cream', paintedSegments = []) {
  // Create segmented walls - each segment is 1 tile wide
  // This allows us to remove segments where doors are placed
  // Each segment can have its own wallpaper color
  
  const wallHeight = 3;
  const wallThickness = 0.3;
  const segmentWidth = 1.1;  // Overlap to hide seams between segments
  
  // Get default wallpaper settings
  const defaultWallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const defaultInteriorColor = defaultWallpaper.color;
  const exteriorMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 }); // Warm taupe/stucco
  
  // Helper to get wallpaper for a specific segment
  const getSegmentWallpaper = (wall, position) => {
    const paint = paintedSegments.find(p => p.wall === wall && p.position === position);
    if (paint) {
      return WALLPAPERS[paint.wallpaper] || defaultWallpaper;
    }
    return defaultWallpaper;
  };
  
  // Initialize wall segments storage
  if (wallSegmentsRef) {
    wallSegmentsRef.current = {
      back: [],
      left: [],
      right: [],
      stripes: [], // For stripe pattern overlays
      patterns: [], // For brick/stone/wood pattern meshes
    };
  }
  
  // Helper to check if a door exists at this wall position
  const hasDoorAt = (wall, position) => {
    return doorPositions.some(d => d.wall === wall && Math.abs(d.wallPosition - position) < 0.5);
  };
  
  // Helper to create pattern overlays for a single wall segment
  const createSegmentPatterns = (segmentWallpaper, wallType, segmentX, segmentZ, segmentWidth) => {
    const patterns = [];
    const pattern = segmentWallpaper.pattern;
    
    if (pattern === 'stripes' && segmentWallpaper.stripeColor) {
      // Vertical stripes on this segment
      const stripeMat = new THREE.MeshLambertMaterial({ color: segmentWallpaper.stripeColor });
      const stripeWidth = 0.06;
      const stripeDepth = 0.02;
      const stripeSpacing = 0.25;
      
      for (let offset = -0.3; offset <= 0.3; offset += stripeSpacing) {
        let stripe;
        
        if (wallType === 'back') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeWidth, wallHeight - 0.1, stripeDepth),
            stripeMat
          );
          stripe.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + stripeDepth / 2);
        } else if (wallType === 'left') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
            stripeMat
          );
          stripe.position.set(-GRID.width / 2 + stripeDepth / 2, wallHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
            stripeMat
          );
          stripe.position.set(GRID.width / 2 - stripeDepth / 2, wallHeight / 2, segmentZ + offset);
        }
        
        if (stripe) {
          scene.add(stripe);
          patterns.push(stripe);
        }
      }
    }
    
    if (pattern === 'brick') {
      // Horizontal mortar lines for brick pattern
      const mortarMat = new THREE.MeshLambertMaterial({ color: 0xD3D3D3 });
      const mortarHeight = 0.025;
      const mortarDepth = 0.02;
      const brickRowHeight = 0.25;
      
      for (let y = brickRowHeight; y < wallHeight; y += brickRowHeight) {
        let mortar;
        
        if (wallType === 'back') {
          // Back wall: mortar runs along X axis - use slight overlap for seamless look
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 1.05, mortarHeight, mortarDepth),
            mortarMat
          );
          mortar.position.set(segmentX, y, -GRID.height / 2 + mortarDepth / 2);
        } else if (wallType === 'left') {
          // Left wall: mortar runs along Z axis, protrudes along +X
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
            mortarMat
          );
          mortar.position.set(-GRID.width / 2 + mortarDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          // Right wall: mortar runs along Z axis, protrudes along -X
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
            mortarMat
          );
          mortar.position.set(GRID.width / 2 - mortarDepth / 2, y, segmentZ);
        }
        
        if (mortar) {
          scene.add(mortar);
          patterns.push(mortar);
        }
      }
      
      // Vertical mortar lines (staggered)
      const verticalSpacing = 0.35;
      let row = 0;
      for (let y = 0; y < wallHeight; y += brickRowHeight) {
        const offsetAmt = (row % 2 === 0) ? 0 : verticalSpacing / 2;
        for (let offset = -0.4 + offsetAmt; offset <= 0.4; offset += verticalSpacing) {
          let vMortar;
          
          if (wallType === 'back') {
            // Back wall: vertical mortar at X offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarHeight, brickRowHeight * 0.9, mortarDepth),
              mortarMat
            );
            vMortar.position.set(segmentX + offset, y + brickRowHeight / 2, -GRID.height / 2 + mortarDepth / 2);
          } else if (wallType === 'left') {
            // Left wall: vertical mortar at Z offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
              mortarMat
            );
            vMortar.position.set(-GRID.width / 2 + mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
          } else if (wallType === 'right') {
            // Right wall: vertical mortar at Z offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
              mortarMat
            );
            vMortar.position.set(GRID.width / 2 - mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
          }
          
          if (vMortar) {
            scene.add(vMortar);
            patterns.push(vMortar);
          }
        }
        row++;
      }
    }
    
    if (pattern === 'wood') {
      // Vertical grooves for wood paneling
      const grooveMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
      const grooveWidth = 0.02;
      const grooveDepth = 0.015;
      const grooveSpacing = 0.3;
      
      for (let offset = -0.35; offset <= 0.35; offset += grooveSpacing) {
        let groove;
        
        if (wallType === 'back') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveWidth, wallHeight - 0.1, grooveDepth),
            grooveMat
          );
          groove.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + grooveDepth / 2);
        } else if (wallType === 'left') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
            grooveMat
          );
          groove.position.set(-GRID.width / 2 + grooveDepth / 2, wallHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
            grooveMat
          );
          groove.position.set(GRID.width / 2 - grooveDepth / 2, wallHeight / 2, segmentZ + offset);
        }
        
        if (groove) {
          scene.add(groove);
          patterns.push(groove);
        }
      }
    }
    
    if (pattern === 'stone') {
      // Irregular stone pattern with horizontal and staggered vertical lines
      const stoneMat = new THREE.MeshLambertMaterial({ color: 0x505050 });
      const lineDepth = 0.015;
      const lineWidth = 0.03;
      const rowHeight = 0.5;
      
      // Horizontal lines - use full segment width (with slight overlap) for seamless look
      for (let y = rowHeight; y < wallHeight; y += rowHeight) {
        let hLine;
        
        if (wallType === 'back') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 1.05, lineWidth, lineDepth),
            stoneMat
          );
          hLine.position.set(segmentX, y, -GRID.height / 2 + lineDepth / 2);
        } else if (wallType === 'left') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
            stoneMat
          );
          hLine.position.set(-GRID.width / 2 + lineDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
            stoneMat
          );
          hLine.position.set(GRID.width / 2 - lineDepth / 2, y, segmentZ);
        }
        
        if (hLine) {
          scene.add(hLine);
          patterns.push(hLine);
        }
      }
      
      // Staggered vertical lines
      let row = 0;
      for (let y = 0; y < wallHeight; y += rowHeight) {
        const offsetAmt = (row % 2 === 0) ? 0.15 : -0.15;
        let vLine;
        
        if (wallType === 'back') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineWidth, rowHeight * 0.9, lineDepth),
            stoneMat
          );
          vLine.position.set(segmentX + offsetAmt, y + rowHeight / 2, -GRID.height / 2 + lineDepth / 2);
        } else if (wallType === 'left') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
            stoneMat
          );
          vLine.position.set(-GRID.width / 2 + lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
        } else if (wallType === 'right') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
            stoneMat
          );
          vLine.position.set(GRID.width / 2 - lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
        }
        
        if (vLine) {
          scene.add(vLine);
          patterns.push(vLine);
        }
        row++;
      }
    }
    
    return patterns;
  };
  
  // Helper to create a wall segment with proper face materials (per-segment color)
  // BoxGeometry face order: +X, -X, +Y, -Y, +Z, -Z (right, left, top, bottom, front, back)
  const createWallSegment = (width, height, depth, x, y, z, wallType, segmentPosition) => {
    const geo = new THREE.BoxGeometry(width, height, depth);
    
    // Get this segment's wallpaper color
    const segmentWallpaper = getSegmentWallpaper(wallType, segmentPosition);
    const interiorMat = new THREE.MeshLambertMaterial({ color: segmentWallpaper.color });
    
    let materials;
    if (wallType === 'back') {
      // Back wall: +Z face is interior (faces into cafe), -Z is exterior
      materials = [
        interiorMat,  // +X (right edge)
        interiorMat,  // -X (left edge)
        interiorMat,  // +Y (top)
        interiorMat,  // -Y (bottom)
        interiorMat,  // +Z (interior - faces into cafe)
        exteriorMat,  // -Z (exterior - faces outside)
      ];
    } else if (wallType === 'left') {
      // Left wall: +X face is interior, -X is exterior
      materials = [
        interiorMat,  // +X (interior - faces into cafe)
        exteriorMat,  // -X (exterior - faces outside)
        interiorMat,  // +Y (top) - cream
        interiorMat,  // -Y (bottom) - cream
        interiorMat,  // +Z (front edge) - cream
        interiorMat,  // -Z (back edge) - cream
      ];
    } else if (wallType === 'right') {
      // Right wall: -X face is interior, +X is exterior
      materials = [
        exteriorMat,  // +X (exterior - faces outside)
        interiorMat,  // -X (interior - faces into cafe)
        interiorMat,  // +Y (top) - cream
        interiorMat,  // -Y (bottom) - cream
        interiorMat,  // +Z (front edge) - cream
        interiorMat,  // -Z (back edge) - cream
      ];
    } else {
      // Default/corner - all interior color
      materials = [interiorMat, interiorMat, interiorMat, interiorMat, interiorMat, interiorMat];
    }
    
    const mesh = new THREE.Mesh(geo, materials);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    // Create pattern overlays for this segment if it has a pattern
    // The segment span is different for each wall type:
    // - Back wall: span is along X (width parameter)
    // - Left/Right walls: span is along Z (depth parameter)
    const segmentX = x;
    const segmentZ = z;
    const segmentSpan = (wallType === 'back') ? width : depth;
    const patternMeshes = createSegmentPatterns(segmentWallpaper, wallType, segmentX, segmentZ, segmentSpan);
    if (patternMeshes.length > 0 && wallSegmentsRef) {
      wallSegmentsRef.current.patterns.push(...patternMeshes);
    }
    
    return mesh;
  };
  
  // Back wall segments (along X axis, at Z = -GRID.height/2)
  for (let x = 0; x < GRID.width; x++) {
    if (hasDoorAt('back', x)) continue;
    
    const segment = createWallSegment(
      segmentWidth, wallHeight, wallThickness,
      x - GRID.width / 2 + 0.5,
      wallHeight / 2,
      -GRID.height / 2 - wallThickness / 2,
      'back',
      x  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'back', position: x };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.back.push({ position: x, mesh: segment });
    }
  }
  
  // Left wall segments (along Z axis, at X = -GRID.width/2)
  for (let z = 0; z < GRID.height; z++) {
    if (hasDoorAt('left', z)) continue;
    
    const segment = createWallSegment(
      wallThickness, wallHeight, segmentWidth,
      -GRID.width / 2 - wallThickness / 2,
      wallHeight / 2,
      z - GRID.height / 2 + 0.5,
      'left',
      z  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'left', position: z };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.left.push({ position: z, mesh: segment });
    }
  }
  
  // Right wall segments (along Z axis, at X = GRID.width/2)
  for (let z = 0; z < GRID.height; z++) {
    if (hasDoorAt('right', z)) continue;
    
    const segment = createWallSegment(
      wallThickness, wallHeight, segmentWidth,
      GRID.width / 2 + wallThickness / 2,
      wallHeight / 2,
      z - GRID.height / 2 + 0.5,
      'right',
      z  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'right', position: z };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.right.push({ position: z, mesh: segment });
    }
  }
  
  // Corner pieces - use default wallpaper color
  const cornerSize = wallThickness;
  
  // Back-left corner
  const blCorner = createVoxelBox(cornerSize, wallHeight, cornerSize, defaultInteriorColor,
    -GRID.width / 2 - cornerSize / 2, wallHeight / 2, -GRID.height / 2 - cornerSize / 2);
  scene.add(blCorner);
  
  // Back-right corner
  const brCorner = createVoxelBox(cornerSize, wallHeight, cornerSize, defaultInteriorColor,
    GRID.width / 2 + cornerSize / 2, wallHeight / 2, -GRID.height / 2 - cornerSize / 2);
  scene.add(brCorner);
  
  // Pattern overlays are now created per-segment in createWallSegment()
}

// Function to rebuild walls when doors or wallpaper changes
function rebuildWalls(scene, wallSegmentsRef, doorPositions, wallpaperType = 'cream', paintedSegments = []) {
  // Remove all existing wall segments
  if (wallSegmentsRef.current) {
    ['back', 'left', 'right'].forEach(wall => {
      (wallSegmentsRef.current[wall] || []).forEach(seg => {
        if (seg.mesh) scene.remove(seg.mesh);
      });
    });
    
    // Remove stripe overlays
    (wallSegmentsRef.current.stripes || []).forEach(stripe => {
      scene.remove(stripe);
    });
    
    // Remove pattern overlays
    (wallSegmentsRef.current.patterns || []).forEach(pattern => {
      scene.remove(pattern);
    });
  }
  
  // Also remove corner pieces (they have no userData.wall)
  const cornersToRemove = [];
  scene.children.forEach(child => {
    if (child.isMesh && child.geometry?.type === 'BoxGeometry' && !child.userData?.wall) {
      // Check if it looks like a wall corner (small box at wall height)
      if (child.position.y > 1 && child.position.y < 2) {
        const atCorner = (
          (Math.abs(child.position.x - (-GRID.width/2 - 0.15)) < 0.3 || 
           Math.abs(child.position.x - (GRID.width/2 + 0.15)) < 0.3) &&
          Math.abs(child.position.z - (-GRID.height/2 - 0.15)) < 0.3
        );
        if (atCorner) cornersToRemove.push(child);
      }
    }
  });
  cornersToRemove.forEach(c => scene.remove(c));
  
  // Recreate walls with new door positions, wallpaper, and painted segments
  createWalls(scene, null, wallSegmentsRef, doorPositions, wallpaperType, paintedSegments);
}

function createTree(scene, x, z, scale = 1) {
  // Trunk
  const trunkGeo = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 1.5 * scale, 8);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.set(x, 0.75 * scale, z);
  trunk.castShadow = true;
  scene.add(trunk);
  
  // Foliage layers (stacked cones for a fuller look)
  const foliageColors = [0x228B22, 0x2E8B2E, 0x32CD32];
  for (let i = 0; i < 3; i++) {
    const foliageGeo = new THREE.ConeGeometry(1.2 * scale - i * 0.2, 1.5 * scale - i * 0.2, 8);
    const foliageMat = new THREE.MeshLambertMaterial({ color: foliageColors[i % 3] });
    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
    foliage.position.set(x, 1.8 * scale + i * 0.6 * scale, z);
    foliage.castShadow = true;
    scene.add(foliage);
  }
}

function createBush(scene, x, z, scale = 1) {
  const bushGeo = new THREE.SphereGeometry(0.5 * scale, 8, 6);
  const bushMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
  const bush = new THREE.Mesh(bushGeo, bushMat);
  bush.position.set(x, 0.3 * scale, z);
  bush.scale.y = 0.7; // Flatten a bit
  bush.castShadow = true;
  scene.add(bush);
}

// ============================================
// DECORATION CREATION FUNCTIONS
// ============================================
function createDecoration(type, x, z, rotation = 0) {
  const group = new THREE.Group();
  group.position.set(x, 0, z);
  
  // Apply rotation (0-3 maps to 0, 90, 180, 270 degrees)
  group.rotation.y = rotation * (Math.PI / 2);
  
  switch (type) {
    case 'plant': {
      // Terracotta pot
      const potGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.25, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.125;
      pot.castShadow = true;
      group.add(pot);
      
      // Plant leaves (small sphere cluster)
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 5), leafMat);
      leaf1.position.set(0, 0.35, 0);
      leaf1.castShadow = true;
      group.add(leaf1);
      const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 5), leafMat);
      leaf2.position.set(0.08, 0.45, 0.05);
      group.add(leaf2);
      const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 5), leafMat);
      leaf3.position.set(-0.06, 0.42, -0.04);
      group.add(leaf3);
      break;
    }
    
    case 'plant2': {
      // Tall plant in white pot
      const potGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.35, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xF5F5DC });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.175;
      pot.castShadow = true;
      group.add(pot);
      
      // Tall leaves
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      for (let i = 0; i < 5; i++) {
        const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.5, 4), leafMat);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(Math.cos(angle) * 0.08, 0.55, Math.sin(angle) * 0.08);
        leaf.rotation.x = -0.2;
        leaf.rotation.z = Math.cos(angle) * 0.3;
        group.add(leaf);
      }
      break;
    }
    
    case 'cactus': {
      // Small pot
      const potGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.1;
      pot.castShadow = true;
      group.add(pot);
      
      // Cactus body
      const cactusMat = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8), cactusMat);
      body.position.y = 0.4;
      body.castShadow = true;
      group.add(body);
      
      // Arms
      const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.2, 6), cactusMat);
      arm1.position.set(0.12, 0.45, 0);
      arm1.rotation.z = -0.8;
      group.add(arm1);
      break;
    }
    
    case 'floorLamp': {
      // Base
      const baseGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 8);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.025;
      group.add(base);
      
      // Pole
      const poleGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.2, 8);
      const poleMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = 0.65;
      group.add(pole);
      
      // Lamp shade - cream colored, glows at night
      const shadeGeo = new THREE.CylinderGeometry(0.15, 0.28, 0.35, 8, 1, true);
      const shadeMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFF8DC, 
        emissive: 0xFFAA55,
        emissiveIntensity: 0.1, // Slight glow even during day
        side: THREE.DoubleSide
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.position.y = 1.2;
      group.add(shade);
      group.userData.lampMaterial = shadeMat; // Store for night glow
      
      // Bulb inside
      const bulbGeo = new THREE.SphereGeometry(0.08, 8, 6);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xFFFFAA,
        emissive: 0xFFDD88,
        emissiveIntensity: 0.2
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.y = 1.1;
      group.add(bulb);
      group.userData.bulbMaterial = bulbMat;
      
      // Point light for the lamp
      const lampLight = new THREE.PointLight(0xFFAA55, 0.3, 5, 2); // Slight glow during day
      lampLight.position.y = 1.1;
      group.add(lampLight);
      group.userData.lampLight = lampLight; // Store for night intensity
      break;
    }
    
    case 'rug': {
      // Oval rug - raised above floor tiles (tiles are 0.1 thick at y=0)
      const rugGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.04, 16);
      const rugMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.y = 0.08; // Above the 0.1 thick floor tiles
      rug.scale.set(1, 1, 0.6); // Make oval
      rug.receiveShadow = true;
      group.add(rug);
      
      // Inner pattern
      const innerGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.045, 16);
      const innerMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.position.y = 0.09;
      inner.scale.set(1, 1, 0.6);
      group.add(inner);
      break;
    }
    
    case 'window': {
      // Window frame
      const frameGeo = new THREE.BoxGeometry(1.5, 1.5, 0.1);
      const frameMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.trim });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.castShadow = true;
      group.add(frame);
      
      // Window glass (sky blue, slightly inset)
      const glassGeo = new THREE.BoxGeometry(1.2, 1.2, 0.08);
      const glassMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.window });
      const glass = new THREE.Mesh(glassGeo, glassMat);
      glass.position.y = 1.8;
      glass.position.z = 0.02;
      group.add(glass);
      
      // Window cross dividers
      const dividerMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.trim });
      const hDivider = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.12), dividerMat);
      hDivider.position.set(0, 1.8, 0.03);
      group.add(hDivider);
      const vDivider = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.2, 0.12), dividerMat);
      vDivider.position.set(0, 1.8, 0.03);
      group.add(vDivider);
      break;
    }
    
    case 'picture': {
      // Wall art frame - larger and more visible
      const frameGeo = new THREE.BoxGeometry(1.0, 0.8, 0.08);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.castShadow = true;
      group.add(frame);
      
      // Canvas with random color for variety
      const colors = [0x87CEEB, 0xFFB6C1, 0x98FB98, 0xDDA0DD, 0xF0E68C, 0xFFDAB9];
      const canvasGeo = new THREE.BoxGeometry(0.8, 0.6, 0.09);
      const canvasMat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
      const canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.y = 1.8;
      group.add(canvas);
      break;
    }
    
    case 'flowers': {
      // Vase
      const vaseGeo = new THREE.CylinderGeometry(0.12, 0.08, 0.3, 8);
      const vaseMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const vase = new THREE.Mesh(vaseGeo, vaseMat);
      vase.position.y = 0.15;
      group.add(vase);
      
      // Flowers
      const flowerColors = [0xFF69B4, 0xFFB6C1, 0xFF1493, 0xFFC0CB, 0xFFFFFF];
      for (let i = 0; i < 7; i++) {
        const flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 6, 5),
          new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] })
        );
        const angle = (i / 7) * Math.PI * 2;
        const radius = 0.1 + Math.random() * 0.08;
        flower.position.set(Math.cos(angle) * radius, 0.4 + Math.random() * 0.15, Math.sin(angle) * radius);
        group.add(flower);
      }
      // Stems
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      for (let i = 0; i < 5; i++) {
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.2, 4), stemMat);
        stem.position.set((Math.random() - 0.5) * 0.1, 0.35, (Math.random() - 0.5) * 0.1);
        group.add(stem);
      }
      break;
    }
    
    case 'tulips': {
      // Pink pot
      const potGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.1;
      group.add(pot);
      
      // Tulip flowers
      const tulipMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * 0.06;
        const z = Math.sin(angle) * 0.06;
        // Stem
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.35, 4), stemMat);
        stem.position.set(x, 0.35, z);
        group.add(stem);
        // Tulip head
        const tulip = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), tulipMat);
        tulip.scale.set(0.8, 1.2, 0.8);
        tulip.position.set(x, 0.55, z);
        group.add(tulip);
      }
      break;
    }
    
    case 'sunflower': {
      // Terracotta pot
      const potGeo = new THREE.CylinderGeometry(0.18, 0.14, 0.25, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.125;
      group.add(pot);
      
      // Tall stem
      const stemGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.8, 6);
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.6;
      group.add(stem);
      
      // Sunflower head
      const centerGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.06, 12);
      const centerMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const center = new THREE.Mesh(centerGeo, centerMat);
      center.position.y = 1.0;
      center.rotation.x = Math.PI / 8;
      group.add(center);
      
      // Petals
      const petalMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      for (let i = 0; i < 12; i++) {
        const petal = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.18), petalMat);
        const angle = (i / 12) * Math.PI * 2;
        petal.position.set(Math.cos(angle) * 0.2, 1.0, Math.sin(angle) * 0.2);
        petal.rotation.y = -angle;
        petal.rotation.x = Math.PI / 8;
        group.add(petal);
      }
      break;
    }
    
    case 'candleTable': {
      // Small round table
      const tableGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.04, 12);
      const tableMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const table = new THREE.Mesh(tableGeo, tableMat);
      table.position.y = 0.5;
      group.add(table);
      
      // Table leg
      const legGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.5, 8);
      const leg = new THREE.Mesh(legGeo, tableMat);
      leg.position.y = 0.25;
      group.add(leg);
      
      // Candle
      const candleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 8);
      const candleMat = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
      const candle = new THREE.Mesh(candleGeo, candleMat);
      candle.position.y = 0.6;
      group.add(candle);
      
      // Flame
      const flameGeo = new THREE.ConeGeometry(0.02, 0.06, 6);
      const flameMat = new THREE.MeshStandardMaterial({ color: 0xFFA500, emissive: 0xFF6600, emissiveIntensity: 0.8 });
      const flame = new THREE.Mesh(flameGeo, flameMat);
      flame.position.y = 0.7;
      group.add(flame);
      
      // Light
      const candleLight = new THREE.PointLight(0xFFA500, 0.5, 3, 2);
      candleLight.position.y = 0.7;
      group.add(candleLight);
      break;
    }
    
    case 'fairyLights': {
      // String of lights on wall
      const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const wireGeo = new THREE.BoxGeometry(1.5, 0.02, 0.02);
      const wire = new THREE.Mesh(wireGeo, wireMat);
      wire.position.y = 2.0;
      group.add(wire);
      
      // Bulbs along the wire with actual glow
      const bulbColors = [0xFF69B4, 0x87CEEB, 0x98FB98, 0xFFD700, 0xDDA0DD];
      for (let i = 0; i < 7; i++) {
        const color = bulbColors[i % bulbColors.length];
        const bulbGeo = new THREE.SphereGeometry(0.04, 6, 5);
        const bulbMat = new THREE.MeshStandardMaterial({ 
          color: color,
          emissive: color,
          emissiveIntensity: 0.8
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        const xPos = -0.6 + i * 0.2;
        const yPos = 2.0 - Math.sin(i * 0.5) * 0.1;
        bulb.position.set(xPos, yPos, 0.05);
        group.add(bulb);
        
        // Add actual point light every other bulb for performance
        if (i % 2 === 0) {
          const light = new THREE.PointLight(color, 0.4, 2.5, 2);
          light.position.set(xPos, yPos, 0.1);
          group.add(light);
        }
      }
      
      // Add a soft ambient fill light for overall glow
      const ambientGlow = new THREE.PointLight(0xFFB6C1, 0.3, 4, 2);
      ambientGlow.position.set(0, 1.8, 0.3);
      group.add(ambientGlow);
      break;
    }
    
    case 'pinkRug': {
      // Pink heart-inspired rug
      const rugGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.04, 16);
      const rugMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.y = 0.08;
      group.add(rug);
      
      // Inner pattern (white)
      const innerGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.045, 16);
      const innerMat = new THREE.MeshLambertMaterial({ color: 0xFFF0F5 });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.position.y = 0.09;
      group.add(inner);
      break;
    }
    
    case 'clock': {
      // Wall clock
      const clockGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 24);
      const clockMat = new THREE.MeshLambertMaterial({ color: 0xFFFAF0 });
      const clock = new THREE.Mesh(clockGeo, clockMat);
      clock.position.y = 1.8;
      clock.rotation.x = Math.PI / 2;
      group.add(clock);
      
      // Frame
      const frameGeo = new THREE.TorusGeometry(0.35, 0.04, 8, 24);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.position.z = 0.04;
      group.add(frame);
      
      // Clock hands
      const handMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const hourHand = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.15, 0.02), handMat);
      hourHand.position.set(0, 1.85, 0.06);
      hourHand.rotation.z = 0.5;
      group.add(hourHand);
      const minHand = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.22, 0.02), handMat);
      minHand.position.set(0, 1.9, 0.06);
      minHand.rotation.z = -0.8;
      group.add(minHand);
      break;
    }
    
    case 'heart': {
      // Heart-shaped wall decoration
      const heartMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      // Left lobe
      const lobe1 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), heartMat);
      lobe1.position.set(-0.12, 1.9, 0);
      group.add(lobe1);
      // Right lobe
      const lobe2 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), heartMat);
      lobe2.position.set(0.12, 1.9, 0);
      group.add(lobe2);
      // Bottom point
      const point = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.35, 12), heartMat);
      point.position.set(0, 1.6, 0);
      point.rotation.z = Math.PI;
      group.add(point);
      break;
    }
    
    case 'star': {
      // Star decoration
      const starMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 });
      // Center
      const center = new THREE.Mesh(new THREE.OctahedronGeometry(0.15, 0), starMat);
      center.position.y = 1.8;
      center.rotation.z = Math.PI / 4;
      group.add(center);
      // Points
      for (let i = 0; i < 5; i++) {
        const point = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.25, 6), starMat);
        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
        point.position.set(Math.cos(angle) * 0.2, 1.8 + Math.sin(angle) * 0.2, 0.05);
        point.rotation.z = angle + Math.PI / 2;
        group.add(point);
      }
      break;
    }
    
    case 'menu': {
      // Menu board
      const boardGeo = new THREE.BoxGeometry(0.9, 1.1, 0.06);
      const boardMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const board = new THREE.Mesh(boardGeo, boardMat);
      board.position.y = 1.7;
      group.add(board);
      
      // Frame
      const frameGeo = new THREE.BoxGeometry(1.0, 1.2, 0.04);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.7;
      frame.position.z = -0.02;
      group.add(frame);
      
      // Text lines (simplified as white bars)
      const lineMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 5; i++) {
        const line = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.06, 0.01), lineMat);
        line.position.set(0, 2.0 - i * 0.18, 0.04);
        group.add(line);
      }
      break;
    }
    
    case 'jukebox': {
      // Main body
      const bodyGeo = new THREE.BoxGeometry(0.6, 1.2, 0.5);
      const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);
      
      // Curved top
      const topGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16, 1, false, 0, Math.PI);
      const topMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = 1.35;
      top.rotation.z = Math.PI / 2;
      top.rotation.y = Math.PI / 2;
      group.add(top);
      
      // Display window
      const windowGeo = new THREE.BoxGeometry(0.4, 0.3, 0.1);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, emissive: 0x4169E1, emissiveIntensity: 0.3 });
      const window = new THREE.Mesh(windowGeo, windowMat);
      window.position.set(0, 0.9, 0.25);
      group.add(window);
      
      // Buttons
      const buttonMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 3; i++) {
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.05, 8), buttonMat);
        btn.position.set(-0.12 + i * 0.12, 0.5, 0.28);
        btn.rotation.x = Math.PI / 2;
        group.add(btn);
      }
      break;
    }
    
    case 'aquarium': {
      // Glass tank
      const tankGeo = new THREE.BoxGeometry(0.8, 0.6, 0.4);
      const tankMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });
      const tank = new THREE.Mesh(tankGeo, tankMat);
      tank.position.y = 0.5;
      group.add(tank);
      
      // Water inside
      const waterGeo = new THREE.BoxGeometry(0.75, 0.5, 0.35);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, transparent: true, opacity: 0.5 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.position.y = 0.45;
      group.add(water);
      
      // Fish (simple colored spheres)
      const fishColors = [0xFF6347, 0xFFD700, 0xFF69B4];
      for (let i = 0; i < 3; i++) {
        const fish = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), new THREE.MeshLambertMaterial({ color: fishColors[i] }));
        fish.scale.set(1.5, 1, 0.6);
        fish.position.set(-0.2 + i * 0.2, 0.4 + Math.random() * 0.2, (Math.random() - 0.5) * 0.2);
        group.add(fish);
      }
      
      // Stand
      const standGeo = new THREE.BoxGeometry(0.85, 0.2, 0.45);
      const standMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.1;
      group.add(stand);
      break;
    }
    
    case 'fountain': {
      // Basin
      const basinGeo = new THREE.CylinderGeometry(0.4, 0.35, 0.15, 16);
      const basinMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const basin = new THREE.Mesh(basinGeo, basinMat);
      basin.position.y = 0.075;
      group.add(basin);
      
      // Water in basin
      const waterGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.1, 16);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, transparent: true, opacity: 0.6 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.position.y = 0.1;
      group.add(water);
      
      // Center spout
      const spoutGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8);
      const spout = new THREE.Mesh(spoutGeo, basinMat);
      spout.position.y = 0.35;
      group.add(spout);
      
      // Water jet (cone)
      const jetGeo = new THREE.ConeGeometry(0.05, 0.3, 8);
      const jetMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7 });
      const jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.y = 0.65;
      group.add(jet);
      break;
    }
    
    case 'cakeDisplay': {
      // Glass dome stand
      const standGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.1, 16);
      const standMat = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.05;
      group.add(stand);
      
      // Cake
      const cakeGeo = new THREE.CylinderGeometry(0.2, 0.22, 0.2, 16);
      const cakeMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const cake = new THREE.Mesh(cakeGeo, cakeMat);
      cake.position.y = 0.2;
      group.add(cake);
      
      // Frosting top
      const frostGeo = new THREE.CylinderGeometry(0.22, 0.2, 0.05, 16);
      const frostMat = new THREE.MeshLambertMaterial({ color: 0xFFF0F5 });
      const frost = new THREE.Mesh(frostGeo, frostMat);
      frost.position.y = 0.32;
      group.add(frost);
      
      // Cherry on top
      const cherryGeo = new THREE.SphereGeometry(0.04, 8, 6);
      const cherryMat = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const cherry = new THREE.Mesh(cherryGeo, cherryMat);
      cherry.position.y = 0.38;
      group.add(cherry);
      
      // Glass dome
      const domeGeo = new THREE.SphereGeometry(0.3, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
      const domeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.25 });
      const dome = new THREE.Mesh(domeGeo, domeMat);
      dome.position.y = 0.1;
      group.add(dome);
      break;
    }
    
    case 'gumball': {
      // Base
      const baseGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.15, 12);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.075;
      group.add(base);
      
      // Stand
      const standGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.3, 8);
      const standMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.3;
      group.add(stand);
      
      // Globe
      const globeGeo = new THREE.SphereGeometry(0.25, 16, 12);
      const globeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.4 });
      const globe = new THREE.Mesh(globeGeo, globeMat);
      globe.position.y = 0.7;
      group.add(globe);
      
      // Gumballs inside
      const gumColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF69B4, 0xFFA500];
      for (let i = 0; i < 15; i++) {
        const gum = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 6, 5),
          new THREE.MeshLambertMaterial({ color: gumColors[i % gumColors.length] })
        );
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const r = 0.1 + Math.random() * 0.1;
        gum.position.set(
          Math.sin(phi) * Math.cos(theta) * r,
          0.65 + Math.cos(phi) * r,
          Math.sin(phi) * Math.sin(theta) * r
        );
        group.add(gum);
      }
      
      // Top cap
      const capGeo = new THREE.CylinderGeometry(0.12, 0.15, 0.1, 12);
      const cap = new THREE.Mesh(capGeo, baseMat);
      cap.position.y = 0.98;
      group.add(cap);
      break;
    }
    
    case 'teddyBear': {
      const bearMat = new THREE.MeshLambertMaterial({ color: 0xD2691E });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 8), bearMat);
      body.position.y = 0.2;
      body.scale.set(1, 1.1, 0.9);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), bearMat);
      head.position.y = 0.45;
      group.add(head);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), bearMat);
      ear1.position.set(-0.1, 0.55, 0);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), bearMat);
      ear2.position.set(0.1, 0.55, 0);
      group.add(ear2);
      // Snout
      const snoutMat = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), snoutMat);
      snout.position.set(0, 0.42, 0.1);
      group.add(snout);
      // Nose
      const noseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), noseMat);
      nose.position.set(0, 0.44, 0.15);
      group.add(nose);
      // Eyes
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      eye1.position.set(-0.05, 0.48, 0.1);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      eye2.position.set(0.05, 0.48, 0.1);
      group.add(eye2);
      // Arms
      const arm1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 5), bearMat);
      arm1.scale.set(1, 1.5, 1);
      arm1.position.set(-0.18, 0.25, 0.05);
      group.add(arm1);
      const arm2 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 5), bearMat);
      arm2.scale.set(1, 1.5, 1);
      arm2.position.set(0.18, 0.25, 0.05);
      group.add(arm2);
      break;
    }
    
    case 'balloons': {
      // String anchor
      const anchorGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 8);
      const anchorMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const anchor = new THREE.Mesh(anchorGeo, anchorMat);
      anchor.position.y = 0.025;
      group.add(anchor);
      
      // Balloons
      const balloonColors = [0xFF69B4, 0x87CEEB, 0x98FB98, 0xFFD700, 0xDDA0DD];
      const stringMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 5; i++) {
        // String
        const string = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.8 + i * 0.1, 4), stringMat);
        const xOff = (i - 2) * 0.15;
        string.position.set(xOff, 0.4 + i * 0.05, 0);
        group.add(string);
        
        // Balloon
        const balloon = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 10, 8),
          new THREE.MeshLambertMaterial({ color: balloonColors[i] })
        );
        balloon.scale.set(1, 1.3, 1);
        balloon.position.set(xOff, 0.9 + i * 0.1, 0);
        group.add(balloon);
      }
      break;
    }
    
    case 'giftBox': {
      // Box
      const boxGeo = new THREE.BoxGeometry(0.3, 0.25, 0.3);
      const boxMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = 0.125;
      group.add(box);
      
      // Ribbon vertical
      const ribbonMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.26, 0.31), ribbonMat);
      ribbon1.position.y = 0.125;
      group.add(ribbon1);
      
      // Ribbon horizontal
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(0.31, 0.05, 0.31), ribbonMat);
      ribbon2.position.y = 0.2;
      group.add(ribbon2);
      
      // Bow
      const bow1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), ribbonMat);
      bow1.scale.set(1.5, 0.8, 0.5);
      bow1.position.set(-0.08, 0.3, 0);
      group.add(bow1);
      const bow2 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), ribbonMat);
      bow2.scale.set(1.5, 0.8, 0.5);
      bow2.position.set(0.08, 0.3, 0);
      group.add(bow2);
      const bowCenter = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), ribbonMat);
      bowCenter.position.set(0, 0.3, 0);
      group.add(bowCenter);
      break;
    }
    
    // ===== PLUSHIE COLLECTION =====
    
    case 'catPlush': {
      const catMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 }); // Orange tabby
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), catMat);
      body.position.y = 0.15;
      body.scale.set(1, 0.9, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), catMat);
      head.position.set(0, 0.32, 0.08);
      group.add(head);
      // Ears
      const earMat = new THREE.MeshLambertMaterial({ color: 0xFFB347 });
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 4), earMat);
      ear1.position.set(-0.07, 0.42, 0.08);
      ear1.rotation.z = -0.2;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 4), earMat);
      ear2.position.set(0.07, 0.42, 0.08);
      ear2.rotation.z = 0.2;
      group.add(ear2);
      // Face
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      nose.position.set(0, 0.3, 0.18);
      group.add(nose);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.34, 0.16);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.34, 0.16);
      group.add(eye2);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.015, 0.2, 6), catMat);
      tail.position.set(0, 0.15, -0.18);
      tail.rotation.x = 0.5;
      group.add(tail);
      break;
    }
    
    case 'dogPlush': {
      const dogMat = new THREE.MeshLambertMaterial({ color: 0xD2691E }); // Brown
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.16, 10, 8), dogMat);
      body.position.y = 0.16;
      body.scale.set(1.1, 0.9, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 10, 8), dogMat);
      head.position.set(0, 0.34, 0.06);
      group.add(head);
      // Snout
      const snoutMat = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), snoutMat);
      snout.scale.set(1, 0.7, 1.2);
      snout.position.set(0, 0.3, 0.15);
      group.add(snout);
      // Ears (floppy)
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), dogMat);
      ear1.scale.set(0.5, 1, 0.3);
      ear1.position.set(-0.12, 0.35, 0.02);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), dogMat);
      ear2.scale.set(0.5, 1, 0.3);
      ear2.position.set(0.12, 0.35, 0.02);
      group.add(ear2);
      // Nose
      const noseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), noseMat);
      nose.position.set(0, 0.31, 0.2);
      group.add(nose);
      // Eyes
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      eye1.position.set(-0.045, 0.37, 0.14);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      eye2.position.set(0.045, 0.37, 0.14);
      group.add(eye2);
      break;
    }
    
    case 'bunnyPlush': {
      const bunnyMat = new THREE.MeshLambertMaterial({ color: 0xFFFAFA }); // White
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), bunnyMat);
      body.position.y = 0.14;
      body.scale.set(0.9, 1, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), bunnyMat);
      head.position.set(0, 0.32, 0.05);
      group.add(head);
      // Long ears (using cylinders with rounded ends via spheres)
      const earMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      // Left ear
      const ear1 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.18, 8), bunnyMat);
      ear1.position.set(-0.05, 0.5, 0);
      ear1.rotation.z = -0.15;
      group.add(ear1);
      const ear1Top = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), bunnyMat);
      ear1Top.position.set(-0.05, 0.59, -0.01);
      group.add(ear1Top);
      const ear1Inner = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.12, 6), earMat);
      ear1Inner.position.set(-0.05, 0.5, 0.02);
      ear1Inner.rotation.z = -0.15;
      group.add(ear1Inner);
      // Right ear
      const ear2 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.18, 8), bunnyMat);
      ear2.position.set(0.05, 0.5, 0);
      ear2.rotation.z = 0.15;
      group.add(ear2);
      const ear2Top = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), bunnyMat);
      ear2Top.position.set(0.05, 0.59, -0.01);
      group.add(ear2Top);
      const ear2Inner = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.12, 6), earMat);
      ear2Inner.position.set(0.05, 0.5, 0.02);
      ear2Inner.rotation.z = 0.15;
      group.add(ear2Inner);
      // Face
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      nose.position.set(0, 0.3, 0.14);
      group.add(nose);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.035, 0.34, 0.12);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.035, 0.34, 0.12);
      group.add(eye2);
      // Fluffy tail
      const tail = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), bunnyMat);
      tail.position.set(0, 0.12, -0.15);
      group.add(tail);
      break;
    }
    
    case 'pandaPlush': {
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
      const blackMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.16, 10, 8), whiteMat);
      body.position.y = 0.16;
      body.scale.set(1, 0.95, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), whiteMat);
      head.position.set(0, 0.36, 0.04);
      group.add(head);
      // Ears (black)
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), blackMat);
      ear1.position.set(-0.1, 0.48, 0);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), blackMat);
      ear2.position.set(0.1, 0.48, 0);
      group.add(ear2);
      // Eye patches (black)
      const patch1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), blackMat);
      patch1.scale.set(1.2, 0.9, 0.5);
      patch1.position.set(-0.055, 0.38, 0.1);
      group.add(patch1);
      const patch2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), blackMat);
      patch2.scale.set(1.2, 0.9, 0.5);
      patch2.position.set(0.055, 0.38, 0.1);
      group.add(patch2);
      // Eyes (white dots on patches)
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeWhite);
      eye1.position.set(-0.05, 0.38, 0.13);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeWhite);
      eye2.position.set(0.05, 0.38, 0.13);
      group.add(eye2);
      // Nose
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), blackMat);
      nose.position.set(0, 0.33, 0.13);
      group.add(nose);
      break;
    }
    
    case 'penguinPlush': {
      const blackMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
      const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), blackMat);
      body.position.y = 0.16;
      body.scale.set(0.85, 1.1, 0.75);
      group.add(body);
      // White belly
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), whiteMat);
      belly.position.set(0, 0.14, 0.05);
      belly.scale.set(0.8, 1, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), blackMat);
      head.position.set(0, 0.32, 0);
      group.add(head);
      // White face
      const face = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), whiteMat);
      face.position.set(0, 0.3, 0.06);
      face.scale.set(1.2, 0.8, 0.5);
      group.add(face);
      // Beak
      const beak = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.05, 6), orangeMat);
      beak.position.set(0, 0.29, 0.1);
      beak.rotation.x = Math.PI / 2;
      group.add(beak);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeMat);
      eye1.position.set(-0.03, 0.33, 0.08);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeMat);
      eye2.position.set(0.03, 0.33, 0.08);
      group.add(eye2);
      // Feet
      const foot1 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.06), orangeMat);
      foot1.position.set(-0.05, 0.01, 0.04);
      group.add(foot1);
      const foot2 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.06), orangeMat);
      foot2.position.set(0.05, 0.01, 0.04);
      group.add(foot2);
      break;
    }
    
    case 'unicornPlush': {
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFAFA });
      const pinkMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const goldMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), whiteMat);
      body.position.y = 0.15;
      body.scale.set(1.1, 0.9, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), whiteMat);
      head.position.set(0, 0.32, 0.08);
      group.add(head);
      // Horn (golden)
      const horn = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.15, 8), goldMat);
      horn.position.set(0, 0.45, 0.08);
      horn.rotation.x = -0.1;
      group.add(horn);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), whiteMat);
      ear1.position.set(-0.06, 0.42, 0.04);
      ear1.rotation.z = -0.3;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), whiteMat);
      ear2.position.set(0.06, 0.42, 0.04);
      ear2.rotation.z = 0.3;
      group.add(ear2);
      // Mane (rainbow-ish pink/purple)
      const maneMat = new THREE.MeshLambertMaterial({ color: 0xDDA0DD });
      for (let i = 0; i < 5; i++) {
        const mane = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 5), i % 2 === 0 ? pinkMat : maneMat);
        mane.position.set(0, 0.38 - i * 0.04, -0.02 - i * 0.02);
        group.add(mane);
      }
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.34, 0.15);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.34, 0.15);
      group.add(eye2);
      // Tail (fluffy rainbow)
      const tail = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), pinkMat);
      tail.scale.set(0.6, 1, 0.6);
      tail.position.set(0, 0.12, -0.18);
      group.add(tail);
      break;
    }
    
    case 'pigPlush': {
      const pinkMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const darkPink = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), pinkMat);
      body.position.y = 0.15;
      body.scale.set(1.1, 0.9, 0.9);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), pinkMat);
      head.position.set(0, 0.32, 0.06);
      group.add(head);
      // Snout
      const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.04, 8), darkPink);
      snout.position.set(0, 0.28, 0.15);
      snout.rotation.x = Math.PI / 2;
      group.add(snout);
      // Nostrils
      const nostrilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nostril1 = new THREE.Mesh(new THREE.SphereGeometry(0.01, 4, 4), nostrilMat);
      nostril1.position.set(-0.02, 0.28, 0.17);
      group.add(nostril1);
      const nostril2 = new THREE.Mesh(new THREE.SphereGeometry(0.01, 4, 4), nostrilMat);
      nostril2.position.set(0.02, 0.28, 0.17);
      group.add(nostril2);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.06, 4), pinkMat);
      ear1.position.set(-0.08, 0.42, 0.02);
      ear1.rotation.z = -0.5;
      ear1.rotation.x = 0.3;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.06, 4), pinkMat);
      ear2.position.set(0.08, 0.42, 0.02);
      ear2.rotation.z = 0.5;
      ear2.rotation.x = 0.3;
      group.add(ear2);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.35, 0.13);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.35, 0.13);
      group.add(eye2);
      // Curly tail
      const tail = new THREE.Mesh(new THREE.TorusGeometry(0.03, 0.01, 6, 8, Math.PI * 1.5), pinkMat);
      tail.position.set(0, 0.15, -0.16);
      tail.rotation.y = Math.PI / 2;
      group.add(tail);
      break;
    }
    
    case 'frogPlush': {
      const greenMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const lightGreen = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), greenMat);
      body.position.y = 0.12;
      body.scale.set(1.1, 0.8, 0.9);
      group.add(body);
      // Belly
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), lightGreen);
      belly.position.set(0, 0.1, 0.05);
      belly.scale.set(0.9, 0.7, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), greenMat);
      head.position.set(0, 0.24, 0.04);
      head.scale.set(1.1, 0.9, 1);
      group.add(head);
      // Big eyes (bulging)
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const eyeBall1 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), eyeWhite);
      eyeBall1.position.set(-0.06, 0.32, 0.08);
      group.add(eyeBall1);
      const eyeBall2 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), eyeWhite);
      eyeBall2.position.set(0.06, 0.32, 0.08);
      group.add(eyeBall2);
      const pupilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const pupil1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil1.position.set(-0.06, 0.32, 0.12);
      group.add(pupil1);
      const pupil2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil2.position.set(0.06, 0.32, 0.12);
      group.add(pupil2);
      // Smile
      const smile = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.008, 6, 8, Math.PI), pupilMat);
      smile.position.set(0, 0.2, 0.1);
      smile.rotation.x = Math.PI;
      group.add(smile);
      break;
    }
    
    case 'duckPlush': {
      const yellowMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), yellowMat);
      body.position.y = 0.14;
      body.scale.set(1, 0.9, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), yellowMat);
      head.position.set(0, 0.3, 0.06);
      group.add(head);
      // Beak
      const beak = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.025, 0.08), orangeMat);
      beak.position.set(0, 0.27, 0.14);
      group.add(beak);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.035, 0.33, 0.12);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.035, 0.33, 0.12);
      group.add(eye2);
      // Wing bumps
      const wing1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), yellowMat);
      wing1.scale.set(0.5, 0.8, 1);
      wing1.position.set(-0.12, 0.14, 0);
      group.add(wing1);
      const wing2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), yellowMat);
      wing2.scale.set(0.5, 0.8, 1);
      wing2.position.set(0.12, 0.14, 0);
      group.add(wing2);
      break;
    }
    
    case 'owlPlush': {
      const brownMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const tanMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), brownMat);
      body.position.y = 0.16;
      body.scale.set(0.9, 1.1, 0.8);
      group.add(body);
      // Belly pattern
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.09, 10, 8), tanMat);
      belly.position.set(0, 0.14, 0.06);
      belly.scale.set(0.9, 1, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), brownMat);
      head.position.set(0, 0.34, 0.02);
      group.add(head);
      // Ear tufts
      const tuft1 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), brownMat);
      tuft1.position.set(-0.08, 0.45, 0);
      tuft1.rotation.z = -0.2;
      group.add(tuft1);
      const tuft2 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), brownMat);
      tuft2.position.set(0.08, 0.45, 0);
      tuft2.rotation.z = 0.2;
      group.add(tuft2);
      // Big eyes
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFE0 });
      const eyeBall1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), eyeWhite);
      eyeBall1.position.set(-0.045, 0.36, 0.1);
      group.add(eyeBall1);
      const eyeBall2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), eyeWhite);
      eyeBall2.position.set(0.045, 0.36, 0.1);
      group.add(eyeBall2);
      const pupilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const pupil1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil1.position.set(-0.045, 0.36, 0.13);
      group.add(pupil1);
      const pupil2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil2.position.set(0.045, 0.36, 0.13);
      group.add(pupil2);
      // Beak
      const beakMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      const beak = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.04, 4), beakMat);
      beak.position.set(0, 0.32, 0.12);
      beak.rotation.x = Math.PI / 2;
      group.add(beak);
      break;
    }
    
    default:
      break;
  }
  
  return group;
}

// Create 3D divider models - short barriers that block pathfinding
function createDivider(type, x, z, rotation = 0) {
  const group = new THREE.Group();
  group.position.set(x, 0, z);
  group.rotation.y = rotation * (Math.PI / 2); // 0 or 90 degrees
  
  switch (type) {
    case 'ropeStanchion': {
      // Two posts with velvet rope between them - full tile width
      const postMat = new THREE.MeshLambertMaterial({ color: 0xB8860B }); // Gold posts
      const ropeMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Dark red rope
      
      // Left post (at edge of tile)
      const post1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.7, 8), postMat);
      post1.position.set(-0.45, 0.35, 0);
      post1.castShadow = true;
      group.add(post1);
      
      // Post top ball
      const ball1 = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6), postMat);
      ball1.position.set(-0.45, 0.72, 0);
      group.add(ball1);
      
      // Right post (at edge of tile)
      const post2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.7, 8), postMat);
      post2.position.set(0.45, 0.35, 0);
      post2.castShadow = true;
      group.add(post2);
      
      // Post top ball
      const ball2 = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6), postMat);
      ball2.position.set(0.45, 0.72, 0);
      group.add(ball2);
      
      // Rope (full width)
      const ropeGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 8);
      const rope = new THREE.Mesh(ropeGeo, ropeMat);
      rope.position.set(0, 0.55, 0);
      rope.rotation.z = Math.PI / 2;
      group.add(rope);
      
      // Rope sag (small sphere in middle for visual sag effect)
      const sag = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 5), ropeMat);
      sag.position.set(0, 0.50, 0);
      group.add(sag);
      break;
    }
    
    case 'lowRailing': {
      // Simple wooden railing - full tile width, taller
      const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      
      // Two posts at tile edges
      const post1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.65, 0.08), woodMat);
      post1.position.set(-0.46, 0.325, 0);
      post1.castShadow = true;
      group.add(post1);
      
      const post2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.65, 0.08), woodMat);
      post2.position.set(0.46, 0.325, 0);
      post2.castShadow = true;
      group.add(post2);
      
      // Top rail (full width)
      const topRail = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.07, 0.07), woodMat);
      topRail.position.set(0, 0.62, 0);
      topRail.castShadow = true;
      group.add(topRail);
      
      // Middle rail
      const midRail = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.05, 0.05), woodMat);
      midRail.position.set(0, 0.35, 0);
      group.add(midRail);
      
      // Bottom rail
      const bottomRail = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.05, 0.05), woodMat);
      bottomRail.position.set(0, 0.12, 0);
      group.add(bottomRail);
      break;
    }
    
    case 'planterDivider': {
      // Long planter box with greenery - full tile width, taller
      const boxMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const greenMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      
      // Planter box (full tile width)
      const box = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.35, 0.35), boxMat);
      box.position.set(0, 0.175, 0);
      box.castShadow = true;
      group.add(box);
      
      // Soil
      const soilMat = new THREE.MeshLambertMaterial({ color: 0x3D2817 });
      const soil = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.06, 0.27), soilMat);
      soil.position.set(0, 0.38, 0);
      group.add(soil);
      
      // Plants - small bushes across full width
      for (let i = -0.35; i <= 0.35; i += 0.175) {
        const bush = new THREE.Mesh(new THREE.SphereGeometry(0.14, 6, 5), greenMat);
        bush.position.set(i, 0.52, 0);
        bush.scale.set(1, 0.9, 0.9);
        group.add(bush);
      }
      
      // Some variety - taller plants
      const tallPlant1 = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.3, 6), greenMat);
      tallPlant1.position.set(-0.2, 0.65, 0);
      group.add(tallPlant1);
      
      const tallPlant2 = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.3, 6), greenMat);
      tallPlant2.position.set(0.25, 0.65, 0);
      group.add(tallPlant2);
      break;
    }
    
    default:
      break;
  }
  
  return group;
}

// Create pattern overlays for a door header (wall section above door)
// This is separate from wall segment patterns because headers have different dimensions
function createDoorHeaderPatterns(scene, wallpaperType, wall, wallPosition) {
  const wallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const pattern = wallpaper.pattern;
  if (!pattern) return []; // No pattern for solid colors
  
  const patterns = [];
  const doorHeight = 2.2;
  const wallHeight = 3;
  const headerHeight = wallHeight - doorHeight; // 0.8
  const segmentWidth = 1.0; // Header is 1 unit wide
  
  // Calculate header center position based on wall
  let headerX, headerZ, zOffset, xOffset;
  if (wall === 'back') {
    headerX = wallPosition - GRID.width / 2 + 0.5;
    headerZ = -GRID.height / 2;
    zOffset = 0.02; // Pattern protrudes into cafe
    xOffset = 0;
  } else if (wall === 'left') {
    headerX = -GRID.width / 2;
    headerZ = wallPosition - GRID.height / 2 + 0.5;
    xOffset = 0.02;
    zOffset = 0;
  } else if (wall === 'right') {
    headerX = GRID.width / 2;
    headerZ = wallPosition - GRID.height / 2 + 0.5;
    xOffset = -0.02;
    zOffset = 0;
  }
  
  if (pattern === 'stripes' && wallpaper.stripeColor) {
    const stripeMat = new THREE.MeshLambertMaterial({ color: wallpaper.stripeColor });
    const stripeWidth = 0.06;
    const stripeDepth = 0.02;
    const stripeSpacing = 0.25;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    const stripeHeight = wallHeight - headerMinY - 0.05;
    const stripeY = headerMinY + stripeHeight / 2;
    
    for (let offset = -0.3; offset <= 0.3; offset += stripeSpacing) {
      let stripe;
      
      if (wall === 'back') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeWidth, stripeHeight, stripeDepth),
          stripeMat
        );
        stripe.position.set(headerX + offset, stripeY, headerZ + zOffset);
      } else if (wall === 'left') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, stripeHeight, stripeWidth),
          stripeMat
        );
        stripe.position.set(headerX + xOffset, stripeY, headerZ + offset);
      } else if (wall === 'right') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, stripeHeight, stripeWidth),
          stripeMat
        );
        stripe.position.set(headerX + xOffset, stripeY, headerZ + offset);
      }
      
      if (stripe) {
        scene.add(stripe);
        patterns.push(stripe);
      }
    }
  }
  
  if (pattern === 'brick') {
    const mortarMat = new THREE.MeshLambertMaterial({ color: 0xD3D3D3 });
    const mortarHeight = 0.025;
    const mortarDepth = 0.02;
    const brickRowHeight = 0.25;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    
    // Horizontal mortar lines - use same absolute Y grid as wall segments
    // Wall segments place mortar at: brickRowHeight, 2*brickRowHeight, 3*brickRowHeight...
    // Find first mortar line that's above our minimum Y
    const firstRow = Math.ceil(headerMinY / brickRowHeight);
    for (let rowNum = firstRow; rowNum * brickRowHeight < wallHeight; rowNum++) {
      const y = rowNum * brickRowHeight;
      let mortar;
      
      if (wall === 'back') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, mortarHeight, mortarDepth),
          mortarMat
        );
        mortar.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (mortar) {
        scene.add(mortar);
        patterns.push(mortar);
      }
    }
    
    // Vertical mortar lines - use same absolute Y grid and row stagger as wall segments
    const verticalSpacing = 0.35;
    const firstVertRow = Math.ceil(headerMinY / brickRowHeight);
    for (let rowNum = firstVertRow; rowNum * brickRowHeight < wallHeight; rowNum++) {
      const y = rowNum * brickRowHeight;
      const vHeight = Math.min(brickRowHeight * 0.9, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger pattern based on absolute row number (same as wall segments)
      const offsetAmt = (rowNum % 2 === 0) ? 0 : verticalSpacing / 2;
      for (let offset = -0.4 + offsetAmt; offset <= 0.4; offset += verticalSpacing) {
        let vMortar;
        
        if (wall === 'back') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarHeight, vHeight, mortarDepth),
            mortarMat
          );
          vMortar.position.set(headerX + offset, y + vHeight / 2, headerZ + zOffset);
        } else if (wall === 'left') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, vHeight, mortarHeight),
            mortarMat
          );
          vMortar.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        } else if (wall === 'right') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, vHeight, mortarHeight),
            mortarMat
          );
          vMortar.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        }
        
        if (vMortar) {
          scene.add(vMortar);
          patterns.push(vMortar);
        }
      }
    }
  }
  
  if (pattern === 'wood') {
    const grooveMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
    const grooveWidth = 0.02;
    const grooveDepth = 0.015;
    const grooveSpacing = 0.3;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    const grooveHeight = wallHeight - headerMinY - 0.05;
    const grooveY = headerMinY + grooveHeight / 2;
    
    for (let offset = -0.35; offset <= 0.35; offset += grooveSpacing) {
      let groove;
      
      if (wall === 'back') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveWidth, grooveHeight, grooveDepth),
          grooveMat
        );
        groove.position.set(headerX + offset, grooveY, headerZ + zOffset);
      } else if (wall === 'left') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, grooveHeight, grooveWidth),
          grooveMat
        );
        groove.position.set(headerX + xOffset, grooveY, headerZ + offset);
      } else if (wall === 'right') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, grooveHeight, grooveWidth),
          grooveMat
        );
        groove.position.set(headerX + xOffset, grooveY, headerZ + offset);
      }
      
      if (groove) {
        scene.add(groove);
        patterns.push(groove);
      }
    }
  }
  
  if (pattern === 'stone') {
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x505050 });
    const lineDepth = 0.015;
    const lineWidth = 0.03;
    const rowHeight = 0.5;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    
    // Horizontal lines - use full width (with slight overlap) for seamless look
    const firstRow = Math.ceil(headerMinY / rowHeight);
    for (let rowNum = firstRow; rowNum * rowHeight < wallHeight; rowNum++) {
      const y = rowNum * rowHeight;
      let hLine;
      
      if (wall === 'back') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, lineWidth, lineDepth),
          stoneMat
        );
        hLine.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (hLine) {
        scene.add(hLine);
        patterns.push(hLine);
      }
    }
    
    // Staggered vertical lines - use same absolute row numbers for stagger
    const firstVertRow = Math.ceil(headerMinY / rowHeight);
    for (let rowNum = firstVertRow; rowNum * rowHeight < wallHeight; rowNum++) {
      const y = rowNum * rowHeight;
      const vHeight = Math.min(rowHeight * 0.9, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger based on absolute row number (same as wall segments)
      const offsetAmt = (rowNum % 2 === 0) ? 0.15 : -0.15;
      let vLine;
      
      if (wall === 'back') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineWidth, vHeight, lineDepth),
          stoneMat
        );
        vLine.position.set(headerX + offsetAmt, y + vHeight / 2, headerZ + zOffset);
      } else if (wall === 'left') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, vHeight, lineWidth),
          stoneMat
        );
        vLine.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offsetAmt);
      } else if (wall === 'right') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, vHeight, lineWidth),
          stoneMat
        );
        vLine.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offsetAmt);
      }
      
      if (vLine) {
        scene.add(vLine);
        patterns.push(vLine);
      }
    }
  }
  
  return patterns;
}

// Create a door for wall placement
function createDoor(type, wall, wallPosition, wallpaperType = 'cream') {
  const group = new THREE.Group();
  const doorType = DOORS[type] || DOORS.basicDoor;
  
  // Get wallpaper color for header
  const wallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const interiorColor = wallpaper.color;
  
  const frameMat = new THREE.MeshLambertMaterial({ color: doorType.frameColor });
  const doorMat = new THREE.MeshLambertMaterial({ 
    color: doorType.doorColor,
    transparent: doorType.isGlass || false,
    opacity: doorType.isGlass ? 0.4 : 1,
    side: doorType.isGlass ? THREE.DoubleSide : THREE.FrontSide,
  });
  // Slightly darker shade for panel insets (solid doors only)
  const panelMat = new THREE.MeshLambertMaterial({ 
    color: new THREE.Color(doorType.doorColor).multiplyScalar(0.8).getHex(),
  });
  
  // Door dimensions
  const doorWidth = 0.85;
  const doorHeight = 2.2;
  const frameWidth = 0.07;
  const frameDepth = 0.32;
  const wallThickness = 0.3;
  const wallHeight = 3;
  const panelThickness = 0.05;
  
  // Wall section above door - dual-sided like wall segments, using wallpaper color
  const headerHeight = wallHeight - doorHeight;
  const interiorWallMat = new THREE.MeshLambertMaterial({ color: interiorColor });
  const exteriorWallMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 }); // Taupe exterior
  
  // Header with dual-sided materials (wallpaper color inside, taupe outside)
  // BoxGeometry face order: +X, -X, +Y, -Y, +Z, -Z
  const headerMaterials = [
    interiorWallMat, // +X edge
    interiorWallMat, // -X edge  
    interiorWallMat, // +Y top
    interiorWallMat, // -Y bottom
    interiorWallMat, // +Z interior (faces into cafe)
    exteriorWallMat, // -Z exterior (faces outside)
  ];
  const header = new THREE.Mesh(
    new THREE.BoxGeometry(1.0, headerHeight, wallThickness),
    headerMaterials
  );
  header.position.set(0, doorHeight + headerHeight / 2, 0);
  header.castShadow = true;
  // Add userData so the header can be painted like a wall segment
  header.userData = { wall: wall, position: wallPosition, isDoorHeader: true };
  group.add(header);
  
  // Door frame - simple clean frame around opening
  // Left frame
  const leftFrame = new THREE.Mesh(
    new THREE.BoxGeometry(frameWidth, doorHeight, frameDepth),
    frameMat
  );
  leftFrame.position.set(-doorWidth / 2 - frameWidth / 2, doorHeight / 2, 0);
  leftFrame.castShadow = true;
  group.add(leftFrame);
  
  // Right frame
  const rightFrame = new THREE.Mesh(
    new THREE.BoxGeometry(frameWidth, doorHeight, frameDepth),
    frameMat
  );
  rightFrame.position.set(doorWidth / 2 + frameWidth / 2, doorHeight / 2, 0);
  rightFrame.castShadow = true;
  group.add(rightFrame);
  
  // Side wall fillers - dual-sided to fill gaps between door frame and wall segments
  // The wall opening is 1.0 wide, door + frame is ~0.99, so we need thin fillers
  const fillerWidth = (1.0 - doorWidth - frameWidth * 2) / 2 + 0.02; // Slight overlap
  const fillerMaterials = [
    interiorWallMat, // +X
    interiorWallMat, // -X
    interiorWallMat, // +Y
    interiorWallMat, // -Y
    interiorWallMat, // +Z interior
    exteriorWallMat, // -Z exterior
  ];
  
  // Left filler
  const leftFiller = new THREE.Mesh(
    new THREE.BoxGeometry(fillerWidth, doorHeight, wallThickness),
    fillerMaterials
  );
  leftFiller.position.set(-0.5 + fillerWidth / 2, doorHeight / 2, 0);
  group.add(leftFiller);
  
  // Right filler
  const rightFiller = new THREE.Mesh(
    new THREE.BoxGeometry(fillerWidth, doorHeight, wallThickness),
    fillerMaterials
  );
  rightFiller.position.set(0.5 - fillerWidth / 2, doorHeight / 2, 0);
  group.add(rightFiller);
  
  // Top frame
  const topFrame = new THREE.Mesh(
    new THREE.BoxGeometry(doorWidth + frameWidth * 2, frameWidth, frameDepth),
    frameMat
  );
  topFrame.position.set(0, doorHeight + frameWidth / 2, 0);
  topFrame.castShadow = true;
  group.add(topFrame);
  
  // Bottom threshold
  const threshold = new THREE.Mesh(
    new THREE.BoxGeometry(doorWidth + frameWidth * 2, 0.03, frameDepth + 0.05),
    frameMat
  );
  threshold.position.set(0, 0.015, 0.025);
  group.add(threshold);
  
  // Handle material (silver/chrome)
  const handleMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
  
  // Create door panel
  const doorPivot = new THREE.Group();
  doorPivot.name = 'doorPivot';
  doorPivot.position.set(-doorWidth / 2, 0, 0);  // Pivot at left edge of door opening
  
  // Panel should fill the frame opening completely
  const panelWidth = doorWidth;  // Full width - no gap
  const panelHeight = doorHeight - 0.05;
  
  // Main door slab
  const slab = new THREE.Mesh(
    new THREE.BoxGeometry(panelWidth, panelHeight, panelThickness),
    doorMat
  );
  slab.position.set(panelWidth / 2, panelHeight / 2 + 0.025, 0);
  slab.castShadow = true;
  doorPivot.add(slab);
  
  if (doorType.isGlass) {
    // Glass door - horizontal bar handle on BOTH sides
    // Front handle (inside cafe)
    const frontHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, 0.02, 0.03),
      handleMat
    );
    frontHandle.position.set(panelWidth - 0.18, doorHeight / 2, panelThickness / 2 + 0.02);
    doorPivot.add(frontHandle);
    
    // Back handle (outside cafe)
    const backHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, 0.02, 0.03),
      handleMat
    );
    backHandle.position.set(panelWidth - 0.18, doorHeight / 2, -panelThickness / 2 - 0.02);
    doorPivot.add(backHandle);
    
    // Handle mounting brackets
    const bracketMat = handleMat;
    const bracket1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.05), bracketMat);
    bracket1.position.set(panelWidth - 0.08, doorHeight / 2, panelThickness / 2 + 0.01);
    doorPivot.add(bracket1);
    const bracket2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.05), bracketMat);
    bracket2.position.set(panelWidth - 0.28, doorHeight / 2, panelThickness / 2 + 0.01);
    doorPivot.add(bracket2);
    
  } else {
    // Solid door - add decorative panels
    const insetPanelWidth = panelWidth - 0.1;
    const topPanelHeight = panelHeight * 0.4;
    const bottomPanelHeight = panelHeight * 0.3;
    
    // Top inset panel
    const topPanel = new THREE.Mesh(
      new THREE.BoxGeometry(insetPanelWidth, topPanelHeight, 0.01),
      panelMat
    );
    topPanel.position.set(panelWidth / 2, panelHeight - topPanelHeight / 2 - 0.15, panelThickness / 2 + 0.005);
    doorPivot.add(topPanel);
    
    // Bottom inset panel
    const bottomPanel = new THREE.Mesh(
      new THREE.BoxGeometry(insetPanelWidth, bottomPanelHeight, 0.01),
      panelMat
    );
    bottomPanel.position.set(panelWidth / 2, bottomPanelHeight / 2 + 0.15, panelThickness / 2 + 0.005);
    doorPivot.add(bottomPanel);
    
    // Vertical bar push handle (like commercial doors)
    const handleLength = 0.3;
    const pushHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.02, handleLength, 0.03),
      handleMat
    );
    pushHandle.position.set(panelWidth - 0.1, doorHeight / 2, panelThickness / 2 + 0.025);
    doorPivot.add(pushHandle);
    
    // Handle mounting brackets
    const topBracket = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.02, 0.04), handleMat);
    topBracket.position.set(panelWidth - 0.1, doorHeight / 2 + handleLength / 2 - 0.02, panelThickness / 2 + 0.01);
    doorPivot.add(topBracket);
    const bottomBracket = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.02, 0.04), handleMat);
    bottomBracket.position.set(panelWidth - 0.1, doorHeight / 2 - handleLength / 2 + 0.02, panelThickness / 2 + 0.01);
    doorPivot.add(bottomBracket);
  }
  
  group.add(doorPivot);
  
  // Welcome mat
  const matGeo = new THREE.BoxGeometry(0.5, 0.02, 0.3);
  const matMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
  const welcomeMat = new THREE.Mesh(matGeo, matMat);
  welcomeMat.position.set(0, 0.01, 0.3);
  group.add(welcomeMat);
  
  // Store door state for animation
  group.userData.isOpen = false;
  group.userData.openAmount = 0; // 0 = closed, 1 = fully open
  group.userData.isDouble = doorType.isDouble || false;
  
  // Position based on wall - must match exactly where wall segments are placed
  // Wall segments are at: x/z position + wallThickness/2 offset from grid edge
  let worldX, worldZ, rotation;
  
  if (wall === 'back') {
    worldX = wallPosition - GRID.width / 2 + 0.5;
    worldZ = -GRID.height / 2 - wallThickness / 2;  // Match wall segment Z position
    rotation = 0;
  } else if (wall === 'left') {
    worldX = -GRID.width / 2 - wallThickness / 2;   // Match wall segment X position
    worldZ = wallPosition - GRID.height / 2 + 0.5;
    rotation = Math.PI / 2;
  } else if (wall === 'right') {
    worldX = GRID.width / 2 + wallThickness / 2;    // Match wall segment X position
    worldZ = wallPosition - GRID.height / 2 + 0.5;
    rotation = -Math.PI / 2;
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = rotation;
  
  // Store grid position for proximity checks
  group.userData.wall = wall;
  group.userData.wallPosition = wallPosition;
  
  return group;
}

// Helper function to get door entry point in grid coordinates
function getDoorEntryPoint(door) {
  let gridX, gridZ;
  
  if (door.wall === 'back') {
    gridX = door.wallPosition;
    gridZ = 0; // Just inside the back wall
  } else if (door.wall === 'left') {
    gridX = 0; // Just inside the left wall
    gridZ = door.wallPosition;
  } else if (door.wall === 'right') {
    gridX = GRID.width - 1; // Just inside the right wall
    gridZ = door.wallPosition;
  }
  
  return { gridX, gridZ };
}

function createLampPost(scene, x, z, lampMaterialsRef, streetLightsRef) {
  // Pole
  const poleGeo = new THREE.CylinderGeometry(0.05, 0.08, 2.5, 8);
  const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.set(x, 1.25, z);
  scene.add(pole);
  
  // Lamp head - use StandardMaterial for dynamic emissive
  const lampGeo = new THREE.SphereGeometry(0.2, 8, 6);
  const lampMat = new THREE.MeshStandardMaterial({ 
    color: 0xFFF8DC, 
    emissive: 0xFFE4B5, 
    emissiveIntensity: 0.2 
  });
  const lamp = new THREE.Mesh(lampGeo, lampMat);
  lamp.position.set(x, 2.6, z);
  scene.add(lamp);
  if (lampMaterialsRef) lampMaterialsRef.current.push(lampMat);
  
  // Add actual point light for the lamp
  const pointLight = new THREE.PointLight(0xFFE4B5, 0, 15, 1); // intensity 0 initially, range 15, decay 1
  pointLight.position.set(x, 2.4, z);
  scene.add(pointLight);
  if (streetLightsRef) streetLightsRef.current.push(pointLight);
}

function createBench(scene, x, z, rotation = 0) {
  const group = new THREE.Group();
  
  // Seat
  const seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
  const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const seat = new THREE.Mesh(seatGeo, woodMat);
  seat.position.y = 0.4;
  group.add(seat);
  
  // Back
  const backGeo = new THREE.BoxGeometry(1.2, 0.5, 0.08);
  const back = new THREE.Mesh(backGeo, woodMat);
  back.position.set(0, 0.65, -0.18);
  group.add(back);
  
  // Legs
  const legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
  const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  [-0.5, 0.5].forEach(xOff => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(xOff, 0.2, 0);
    group.add(leg);
  });
  
  group.position.set(x, 0, z);
  group.rotation.y = rotation;
  group.castShadow = true;
  scene.add(group);
}

function createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef) {
  // Large grass ground
  const grassGeo = new THREE.PlaneGeometry(200, 200);
  const grassMat = new THREE.MeshStandardMaterial({ 
    color: 0x6CB06C,
    roughness: 0.9,
    metalness: 0
  });
  const grass = new THREE.Mesh(grassGeo, grassMat);
  grass.rotation.x = -Math.PI / 2;
  grass.position.y = -0.05;
  grass.receiveShadow = true;
  scene.add(grass);
  
  // Distant hills/mountains in the background
  const hillColors = [0x5B8C5B, 0x4A7A4A, 0x3D6B3D];
  
  // Back hills (behind kitchen)
  const hill1 = new THREE.Mesh(
    new THREE.ConeGeometry(15, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill1.position.set(-20, 2, -35);
  hill1.scale.y = 0.5;
  scene.add(hill1);
  
  const hill2 = new THREE.Mesh(
    new THREE.ConeGeometry(20, 12, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill2.position.set(5, 4, -40);
  hill2.scale.y = 0.5;
  scene.add(hill2);
  
  const hill3 = new THREE.Mesh(
    new THREE.ConeGeometry(18, 10, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[2] })
  );
  hill3.position.set(25, 3, -38);
  hill3.scale.y = 0.5;
  scene.add(hill3);
  
  // Side hills
  const hill4 = new THREE.Mesh(
    new THREE.ConeGeometry(12, 7, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill4.position.set(-35, 2, 0);
  hill4.scale.y = 0.5;
  scene.add(hill4);
  
  const hill5 = new THREE.Mesh(
    new THREE.ConeGeometry(14, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill5.position.set(35, 2.5, -5);
  hill5.scale.y = 0.5;
  scene.add(hill5);
  
  // Roads - horizontal road in front of cafe
  const roadMat = new THREE.MeshStandardMaterial({ 
    color: 0x3a3a3a,
    roughness: 0.95,
    metalness: 0
  });
  const frontRoad = new THREE.Mesh(new THREE.PlaneGeometry(100, 4), roadMat);
  frontRoad.rotation.x = -Math.PI / 2;
  frontRoad.position.set(0, -0.03, GRID.height / 2 + 4);
  frontRoad.receiveShadow = true;
  scene.add(frontRoad);
  
  // Road markings
  const markingMat = new THREE.MeshStandardMaterial({ 
    color: 0xDDDDDD,
    roughness: 0.8,
    metalness: 0
  });
  for (let i = -45; i < 45; i += 4) {
    const marking = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), markingMat);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(i, -0.02, GRID.height / 2 + 4);
    scene.add(marking);
  }
  
  // Side road
  const sideRoad = new THREE.Mesh(new THREE.PlaneGeometry(4, 60), roadMat);
  sideRoad.rotation.x = -Math.PI / 2;
  sideRoad.position.set(-GRID.width / 2 - 4, -0.03, 0);
  sideRoad.receiveShadow = true;
  scene.add(sideRoad);
  
  // Sidewalks - use StandardMaterial with high roughness to avoid glowing
  const sidewalkMat = new THREE.MeshStandardMaterial({ 
    color: 0x909090, // Darker gray
    roughness: 0.9,  // Very matte, no reflection
    metalness: 0
  });
  
  // Front sidewalk
  const frontSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(GRID.width + 4, 2), sidewalkMat);
  frontSidewalk.rotation.x = -Math.PI / 2;
  frontSidewalk.position.set(0, -0.04, GRID.height / 2 + 1.5);
  frontSidewalk.receiveShadow = true;
  scene.add(frontSidewalk);
  
  // Left sidewalk
  const leftSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(2, GRID.height + 4), sidewalkMat);
  leftSidewalk.rotation.x = -Math.PI / 2;
  leftSidewalk.position.set(-GRID.width / 2 - 1.5, -0.04, 0);
  leftSidewalk.receiveShadow = true;
  scene.add(leftSidewalk);
  
  // === CAFE EXTERIOR ===
  // Wall segments now have dual-sided materials - no additional exterior needed
  // Foundation and caps removed for cleaner look
  
  // === PARK BEHIND CAFE (kitchen side) ===
  
  // Pond behind the cafe
  const pondGeo = new THREE.CircleGeometry(3, 16);
  const pondMat = new THREE.MeshLambertMaterial({ color: 0x4A90D9 });
  const pond = new THREE.Mesh(pondGeo, pondMat);
  pond.rotation.x = -Math.PI / 2;
  pond.position.set(0, -0.02, -GRID.height / 2 - 8);
  scene.add(pond);
  
  // Pond edge stones
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const stoneGeo = new THREE.SphereGeometry(0.3, 6, 4);
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
    const stone = new THREE.Mesh(stoneGeo, stoneMat);
    stone.position.set(
      Math.cos(angle) * 3.2,
      0.1,
      -GRID.height / 2 - 8 + Math.sin(angle) * 3.2
    );
    stone.scale.y = 0.5;
    scene.add(stone);
  }
  
  // Trees around the cafe - left side
  createTree(scene, -GRID.width / 2 - 5, -GRID.height / 2 - 3, 1.2);
  createTree(scene, -GRID.width / 2 - 7, 2, 1);
  createTree(scene, -GRID.width / 2 - 5, GRID.height / 2 - 2, 0.9);
  
  // Trees - right side
  createTree(scene, GRID.width / 2 + 4, -GRID.height / 2 - 2, 1.1);
  createTree(scene, GRID.width / 2 + 6, 3, 1);
  createTree(scene, GRID.width / 2 + 4, GRID.height / 2, 0.8);
  
  // Trees across the street (front)
  createTree(scene, -10, GRID.height / 2 + 9, 1.3);
  createTree(scene, 0, GRID.height / 2 + 10, 1.1);
  createTree(scene, 10, GRID.height / 2 + 9, 1.2);
  createTree(scene, -18, GRID.height / 2 + 8, 0.9);
  createTree(scene, 18, GRID.height / 2 + 8, 0.9);
  
  // Trees behind cafe (park area)
  createTree(scene, -6, -GRID.height / 2 - 5, 1);
  createTree(scene, 6, -GRID.height / 2 - 5, 1);
  createTree(scene, -4, -GRID.height / 2 - 12, 1.3);
  createTree(scene, 5, -GRID.height / 2 - 13, 1.2);
  createTree(scene, -10, -GRID.height / 2 - 10, 0.9);
  createTree(scene, 10, -GRID.height / 2 - 9, 1);
  
  // Distant trees
  createTree(scene, -25, -20, 1.5);
  createTree(scene, -20, -25, 1.3);
  createTree(scene, 25, -18, 1.4);
  createTree(scene, 20, -22, 1.2);
  createTree(scene, -30, 10, 1.3);
  createTree(scene, 28, 8, 1.4);
  
  // Bushes near the cafe entrance
  createBush(scene, -GRID.width / 2 - 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, GRID.width / 2 + 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, -GRID.width / 2 - 1.5, GRID.height / 2 - 1, 0.6);
  createBush(scene, GRID.width / 2 + 1.5, GRID.height / 2 - 1, 0.6);
  
  // Bushes around the back/park
  createBush(scene, -GRID.width / 2 - 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, GRID.width / 2 + 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, -3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, 3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, -2, -GRID.height / 2 - 12, 0.8);
  createBush(scene, 2, -GRID.height / 2 - 11, 0.7);
  
  // Lamp posts
  createLampPost(scene, -GRID.width / 2 - 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, GRID.width / 2 + 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, -GRID.width / 2 - 7, -2, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, 0, -GRID.height / 2 - 5, lampMaterialsRef, streetLightsRef); // Park lamp
  
  // Benches in park area
  createBench(scene, -5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, 5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, -4, -GRID.height / 2 - 6, 0); // Behind cafe
  createBench(scene, 4, -GRID.height / 2 - 6, 0);  // Behind cafe
  
  // Small flower beds in front
  const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB, 0x00CED1, 0xFFA500];
  [-4, -2, 0, 2, 4].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.25, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff, 0.15, GRID.height / 2 + 1);
    flower.scale.y = 0.6;
    scene.add(flower);
  });
  
  // Flower bed behind cafe (near pond)
  [-2, -1, 0, 1, 2].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.2, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[(i + 2) % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff * 1.5, 0.12, -GRID.height / 2 - 4);
    flower.scale.y = 0.5;
    scene.add(flower);
  });
  
  // Picnic table in the back park
  const picnicGroup = new THREE.Group();
  const tableMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  
  // Table top
  const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), tableMat);
  tableTop.position.y = 0.6;
  picnicGroup.add(tableTop);
  
  // Benches
  const bench1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench1.position.set(0, 0.35, 0.5);
  picnicGroup.add(bench1);
  const bench2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench2.position.set(0, 0.35, -0.5);
  picnicGroup.add(bench2);
  
  // Legs
  const legMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
  [[-0.7, 0], [0.7, 0]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.8), legMat);
    leg.position.set(x, 0.3, z);
    picnicGroup.add(leg);
  });
  
  picnicGroup.position.set(8, 0, -GRID.height / 2 - 10);
  scene.add(picnicGroup);
}

function createStove(x, z, rotation = 0) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Main body
  const body = createVoxelBox(0.9, 0.8, 0.9, COLORS.stove.body, 0, 0.45, 0);
  group.add(body);
  
  // Stove top
  const top = createVoxelBox(0.95, 0.05, 0.95, 0x333333, 0, 0.88, 0);
  group.add(top);
  
  // Burners (2x2)
  for (let bx = -1; bx <= 1; bx += 2) {
    for (let bz = -1; bz <= 1; bz += 2) {
      const burner = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 0.02, 16),
        new THREE.MeshLambertMaterial({ color: COLORS.stove.burnerOff })
      );
      burner.position.set(bx * 0.2, 0.91, bz * 0.2);
      burner.name = 'burner';
      group.add(burner);
    }
  }
  
  // Oven door (front side - faces +Z by default)
  const door = createVoxelBox(0.6, 0.4, 0.05, COLORS.stove.door, 0, 0.25, 0.45);
  group.add(door);
  
  // Door handle
  const handle = createVoxelBox(0.3, 0.03, 0.03, 0x888888, 0, 0.35, 0.5);
  group.add(handle);
  
  group.position.set(worldX, 0, worldZ);
  // Apply rotation (0=front +Z, 1=front -X, 2=front -Z, 3=front +X)
  group.rotation.y = getRotationAngle(rotation);
  return group;
}

function createCounter(x, z, rotation = 0) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Cabinet base
  const cabinet = createVoxelBox(0.9, 0.7, 0.9, COLORS.counter.cabinet, 0, 0.35, 0);
  group.add(cabinet);
  
  // Counter top
  const top = createVoxelBox(1, 0.1, 1, COLORS.counter.top, 0, 0.75, 0);
  group.add(top);
  
  // Handles (front side - faces +Z by default)
  const handle1 = createVoxelBox(0.15, 0.03, 0.03, 0xffd700, -0.15, 0.35, 0.48);
  const handle2 = createVoxelBox(0.15, 0.03, 0.03, 0xffd700, 0.15, 0.35, 0.48);
  group.add(handle1, handle2);
  
  group.position.set(worldX, 0, worldZ);
  // Apply rotation (0=front +Z, 1=front -X, 2=front -Z, 3=front +X)
  group.rotation.y = getRotationAngle(rotation);
  return group;
}

function createTable(x, z, style = 'round', rotation = 0, hasBuiltInChair = false) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Get style properties (with fallbacks for backwards compatibility)
  const styleData = TABLE_STYLES[style] || TABLE_STYLES.round;
  const shape = styleData.shape || 'round';
  const woodColor = styleData.woodColor || COLORS.table.wood;
  const clothColor = styleData.clothColor; // Can be null for no cloth
  const chairColor = styleData.chairColor || COLORS.chair.wood;
  const pattern = styleData.pattern;
  const material = styleData.material;
  
  // Table fills the tile (0.9 units to leave small gap)
  if (shape === 'round') {
    // Round table - fills tile
    const tableTopMat = material === 'marble' 
      ? new THREE.MeshLambertMaterial({ color: woodColor })
      : new THREE.MeshLambertMaterial({ color: woodColor });
    
    const tableTop = new THREE.Mesh(
      new THREE.CylinderGeometry(0.42, 0.42, 0.08, 16),
      tableTopMat
    );
    tableTop.position.y = 0.6;
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Tablecloth (only if clothColor is specified)
    if (clothColor !== null) {
      const cloth = new THREE.Mesh(
        new THREE.CylinderGeometry(0.45, 0.48, 0.03, 16),
        new THREE.MeshLambertMaterial({ color: clothColor })
      );
      cloth.position.y = 0.56;
      group.add(cloth);
    }
    
    // Pedestal - use wood color
    const pedestal = createVoxelBox(0.14, 0.5, 0.14, woodColor, 0, 0.28, 0);
    group.add(pedestal);
    
    // Base
    const base = new THREE.Mesh(
      new THREE.CylinderGeometry(0.22, 0.28, 0.06, 16),
      new THREE.MeshLambertMaterial({ color: woodColor })
    );
    base.position.y = 0.03;
    group.add(base);
    
  } else if (shape === 'square') {
    // Square table - fills tile edge to edge
    const tableTop = createVoxelBox(0.9, 0.08, 0.9, woodColor, 0, 0.6, 0);
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Tablecloth (only if clothColor is specified)
    if (clothColor !== null) {
      if (pattern === 'checkered') {
        // Checkered pattern - create multiple squares
        const clothBase = createVoxelBox(0.92, 0.02, 0.92, clothColor, 0, 0.565, 0);
        group.add(clothBase);
        // Add white squares for checkered effect
        const squareSize = 0.22;
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if ((i + j) % 2 === 0) {
              const square = createVoxelBox(squareSize, 0.01, squareSize, 0xFFFFFF, 
                (i - 1.5) * squareSize, 0.57, (j - 1.5) * squareSize);
              group.add(square);
            }
          }
        }
      } else {
        const cloth = createVoxelBox(0.92, 0.03, 0.92, clothColor, 0, 0.56, 0);
        group.add(cloth);
      }
    }
    
    // Four legs at corners - use wood color
    const legPositions = [[-0.35, -0.35], [0.35, -0.35], [-0.35, 0.35], [0.35, 0.35]];
    legPositions.forEach(([lx, lz]) => {
      const leg = createVoxelBox(0.08, 0.55, 0.08, woodColor, lx, 0.28, lz);
      group.add(leg);
    });
  }
  
  // Chair close to table edge (in adjacent tile but tucked under)
  // Only add built-in chair for legacy tables (hasBuiltInChair flag)
  // New tables use separate standalone chairs
  if (hasBuiltInChair) {
    const chair = createChair(chairColor);
    // Position at -0.55 so chair is at table edge, customer legs tucked under
    chair.position.set(-0.55, 0, 0);
    chair.rotation.y = Math.PI / 2; // Face the table
    group.add(chair);
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = rotation * (Math.PI / 2); // 0, 90, 180, 270 degrees
  return group;
}

// Create a standalone chair (for mix-and-match system)
// Rotation: 0=faces +Z, 1=faces -X, 2=faces -Z, 3=faces +X
function createStandaloneChair(gridX, gridZ, style = 'basicWood', rotation = 0) {
  const group = new THREE.Group();
  const worldX = gridX - GRID.width / 2 + 0.5;
  const worldZ = gridZ - GRID.height / 2 + 0.5;
  
  // Get style properties
  const styleData = CHAIR_STYLES[style] || CHAIR_STYLES.basicWood;
  const frameColor = styleData.color || 0xA0522D;
  const seatColor = styleData.seatColor || frameColor; // Use frame color if no seat color
  const hasArmrests = styleData.hasArmrests || false;
  
  // Seat (with optional cushion color)
  const seat = createVoxelBox(0.35, 0.06, 0.35, seatColor, 0, 0.35, 0);
  seat.castShadow = true;
  group.add(seat);
  
  // Back frame
  const back = createVoxelBox(0.35, 0.4, 0.06, frameColor, 0, 0.58, -0.17);
  back.castShadow = true;
  group.add(back);
  
  // Back slats (decorative)
  for (let i = -1; i <= 1; i++) {
    const slat = createVoxelBox(0.04, 0.32, 0.03, frameColor, i * 0.1, 0.54, -0.14);
    group.add(slat);
  }
  
  // Four legs
  const legPositions = [[-0.13, -0.13], [0.13, -0.13], [-0.13, 0.13], [0.13, 0.13]];
  legPositions.forEach(([lx, lz]) => {
    const leg = createVoxelBox(0.05, 0.35, 0.05, frameColor, lx, 0.175, lz);
    group.add(leg);
  });
  
  // Armrests (for executive/premium styles)
  if (hasArmrests) {
    // Left armrest
    const leftArm = createVoxelBox(0.05, 0.05, 0.25, frameColor, -0.2, 0.45, 0);
    const leftSupport = createVoxelBox(0.04, 0.15, 0.04, frameColor, -0.2, 0.38, 0.08);
    group.add(leftArm);
    group.add(leftSupport);
    // Right armrest
    const rightArm = createVoxelBox(0.05, 0.05, 0.25, frameColor, 0.2, 0.45, 0);
    const rightSupport = createVoxelBox(0.04, 0.15, 0.04, frameColor, 0.2, 0.38, 0.08);
    group.add(rightArm);
    group.add(rightSupport);
  }
  
  group.position.set(worldX, 0, worldZ);
  // Chair rotation: 0=faces +Z, 1=faces -X, 2=faces -Z, 3=faces +X
  // The chair model has its back at -Z, so front naturally faces +Z at rotation 0
  group.rotation.y = rotation * (Math.PI / 2);
  return group;
}

function createChair(chairColor = COLORS.chair.wood) {
  const group = new THREE.Group();
  
  // Seat
  const seat = createVoxelBox(0.3, 0.05, 0.3, chairColor, 0, 0.35, 0);
  group.add(seat);
  
  // Back
  const back = createVoxelBox(0.3, 0.35, 0.05, chairColor, 0, 0.55, -0.15);
  group.add(back);
  
  // Legs
  const legPositions = [[-0.1, -0.1], [0.1, -0.1], [-0.1, 0.1], [0.1, 0.1]];
  legPositions.forEach(([lx, lz]) => {
    const leg = createVoxelBox(0.04, 0.32, 0.04, chairColor, lx, 0.16, lz);
    group.add(leg);
  });
  
  return group;
}

function createFoodPlate(recipeKey, plateColor = 0xFFFFF0) {
  const group = new THREE.Group();
  const recipe = RECIPES[recipeKey];
  
  // Plate color changes based on mastery level
  // Default: Ivory (0xFFFFF0)
  // Level 1: Light Blue (0x87CEEB)
  // Level 2: Royal Blue (0x4169E1)
  // Level 3: Gold (0xFFD700)
  const plate = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.32, 0.05, 16),
    new THREE.MeshLambertMaterial({ color: plateColor })
  );
  plate.position.y = 0;
  plate.castShadow = true;
  group.add(plate);
  
  // Food item colors for all recipes
  const foodColors = {
    // Level 1
    burger: 0x8B4513,
    salad: 0x228B22,
    // Level 2-3
    soup: 0xDAA520,
    pancakes: 0xDEB887,
    cake: 0xFFB6C1,
    tacos: 0xF4A460,
    // Level 4-5
    pizza: 0xFF6347,
    pasta: 0xFFE4B5,
    chicken: 0xD2691E,
    ramen: 0xFFDB58,
    // Level 6-7
    sushi: 0xFF6B6B,
    curry: 0xE59400,
    steak: 0x8B0000,
    lobster: 0xE74C3C,
    // Level 8-9
    paella: 0xFFD700,
    dimsum: 0xFFF8DC,
    bbqRibs: 0x5D3A1A,
    crabBisque: 0xFF7F50,
    // Level 10-12
    weddingCake: 0xFFF0F5,
    beef: 0x654321,
    feastPlatter: 0xDAA520,
    turkeyDinner: 0xCD853F,
  };
  
  const food = new THREE.Mesh(
    new THREE.SphereGeometry(0.18, 12, 12),
    new THREE.MeshLambertMaterial({ color: foodColors[recipeKey] || 0xffd700 })
  );
  food.scale.y = 0.5;
  food.position.y = 0.1;
  food.castShadow = true;
  group.add(food);
  
  // Add a little garnish/topping (varies by recipe type)
  const toppingColor = recipeKey.includes('salad') || recipeKey.includes('ramen') ? 0x00FF00 : 0xff0000;
  const topping = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 8, 8),
    new THREE.MeshLambertMaterial({ color: toppingColor })
  );
  topping.position.set(0, 0.18, 0);
  group.add(topping);
  
  return group;
}

function createSeatedCustomer(appearance = {}) {
  const group = new THREE.Group();
  
  // Use appearance object or generate defaults for backwards compatibility
  const isMale = appearance.isMale !== undefined ? appearance.isMale : Math.random() > 0.5;
  
  // Expanded skin tone palette (more diverse range)
  const skinTones = [
    0xffe5d4, // Very light
    0xffdbac, // Light
    0xf5d0c5, // Light rosy
    0xe8beac, // Medium light
    0xd4a574, // Medium tan
    0xc68642, // Medium brown
    0x8d5524, // Brown
    0x6b4423, // Dark brown
  ];
  const skinColor = skinTones[appearance.skinTone !== undefined ? appearance.skinTone % skinTones.length : Math.floor(Math.random() * skinTones.length)];
  
  // Expanded outfit/shirt colors (brighter, more variety)
  const outfitColors = [
    0x4a90d9, // Blue
    0xd94a4a, // Red
    0x4ad94a, // Green
    0xd9d94a, // Yellow
    0x9b4ad9, // Purple
    0xd94a9b, // Pink
    0x4ad9d9, // Cyan
    0xff6b35, // Orange
    0x2d5a27, // Forest green
    0x8b4513, // Brown
    0xf5f5dc, // Cream/beige
    0x191970, // Navy
    0x800020, // Burgundy
    0x40826d, // Teal
  ];
  const outfitColor = outfitColors[appearance.shirtColor !== undefined ? appearance.shirtColor % outfitColors.length : Math.floor(Math.random() * outfitColors.length)];
  
  // Expanded pants colors
  const pantsColors = [
    0x2d2d2d, // Dark gray
    0x1a1a4e, // Navy
    0x4a3728, // Brown
    0x2d4a2d, // Dark green
    0x4a2d4a, // Dark purple
    0x1a1a1a, // Black
    0x6b5b4f, // Taupe
    0x4a4a4a, // Medium gray
    0x5c4033, // Coffee
    0x3d3d6b, // Denim blue
  ];
  const pantsColor = pantsColors[appearance.pantsColor !== undefined ? appearance.pantsColor % pantsColors.length : Math.floor(Math.random() * pantsColors.length)];
  
  // Expanded hair colors
  const hairColors = [
    0x2c1810, // Dark brown
    0x4a3728, // Medium brown
    0x8b4513, // Light brown
    0x1a1a1a, // Black
    0xd4a574, // Blonde
    0xc41e3a, // Red/auburn
    0xffd700, // Platinum blonde
    0x808080, // Gray
    0x654321, // Chestnut
    0xffa07a, // Strawberry blonde
  ];
  const hairColor = hairColors[appearance.hairColor !== undefined ? appearance.hairColor % hairColors.length : Math.floor(Math.random() * hairColors.length)];
  
  // Shoe colors
  const shoeColors = [0x1a1a1a, 0x3d3d3d, 0x8b4513, 0x2d2d4a, 0x4a2d2d, 0xf5f5dc];
  const shoeColor = shoeColors[appearance.shoeColor !== undefined ? appearance.shoeColor % shoeColors.length : Math.floor(Math.random() * shoeColors.length)];
  
  // Hair style
  const hairStyle = appearance.hairStyle !== undefined ? appearance.hairStyle : Math.floor(Math.random() * 6);
  
  // Body dimensions vary by gender
  const bodyWidth = isMale ? 0.28 : 0.24;
  const bodyDepth = isMale ? 0.2 : 0.16;
  const shoulderWidth = isMale ? 0.32 : 0.26;
  
  // Upper legs (horizontal, sitting on chair)
  const leftUpperLeg = createVoxelBox(0.1, 0.08, 0.22, pantsColor, -0.08, 0.38, 0.05);
  const rightUpperLeg = createVoxelBox(0.1, 0.08, 0.22, pantsColor, 0.08, 0.38, 0.05);
  group.add(leftUpperLeg, rightUpperLeg);
  
  // Lower legs (hanging down from chair)
  const leftLowerLeg = createVoxelBox(0.08, 0.25, 0.08, pantsColor, -0.08, 0.15, 0.18);
  const rightLowerLeg = createVoxelBox(0.08, 0.25, 0.08, pantsColor, 0.08, 0.15, 0.18);
  group.add(leftLowerLeg, rightLowerLeg);
  
  // Feet/Shoes
  const leftFoot = createVoxelBox(0.08, 0.05, 0.12, shoeColor, -0.08, 0.025, 0.2);
  const rightFoot = createVoxelBox(0.08, 0.05, 0.12, shoeColor, 0.08, 0.025, 0.2);
  group.add(leftFoot, rightFoot);
  
  // Body/Torso (sitting upright)
  const body = createVoxelBox(bodyWidth, 0.32, bodyDepth, outfitColor, 0, 0.6, -0.02);
  body.castShadow = true;
  group.add(body);
  
  // Shoulders (wider for males)
  if (isMale) {
    const shoulders = createVoxelBox(shoulderWidth, 0.08, bodyDepth, outfitColor, 0, 0.74, -0.02);
    group.add(shoulders);
  }
  
  // Arms
  const armColor = isMale ? outfitColor : skinColor; // Males have sleeves, females may have sleeveless
  const leftArm = createVoxelBox(0.07, 0.2, 0.07, armColor, isMale ? -0.19 : -0.16, 0.54, 0.1);
  leftArm.rotation.x = -0.3;
  const rightArm = createVoxelBox(0.07, 0.2, 0.07, armColor, isMale ? 0.19 : 0.16, 0.54, 0.1);
  rightArm.rotation.x = -0.3;
  group.add(leftArm, rightArm);
  
  // Hands
  const leftHand = createVoxelBox(0.055, 0.055, 0.055, skinColor, isMale ? -0.19 : -0.16, 0.46, 0.2);
  const rightHand = createVoxelBox(0.055, 0.055, 0.055, skinColor, isMale ? 0.19 : 0.16, 0.46, 0.2);
  group.add(leftHand, rightHand);
  
  // Neck
  const neck = createVoxelBox(0.08, 0.06, 0.08, skinColor, 0, 0.8, 0);
  group.add(neck);
  
  // Head
  const head = createVoxelBox(0.2, 0.2, 0.2, skinColor, 0, 0.94, 0);
  head.castShadow = true;
  group.add(head);
  
  // Hair - different styles (6 options)
  if (hairStyle === 0) {
    // Short hair (male style)
    const hair = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.06, -0.01);
    group.add(hair);
  } else if (hairStyle === 1) {
    // Long hair (female style)
    const hairTop = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.06, -0.01);
    const hairBack = createVoxelBox(0.2, 0.25, 0.06, hairColor, 0, 0.9, -0.12);
    group.add(hairTop, hairBack);
  } else if (hairStyle === 2) {
    // Ponytail
    const hairTop = createVoxelBox(0.22, 0.06, 0.2, hairColor, 0, 1.06, 0);
    const ponytail = createVoxelBox(0.08, 0.15, 0.08, hairColor, 0, 0.95, -0.15);
    group.add(hairTop, ponytail);
  } else if (hairStyle === 3) {
    // Bald/very short
    const hairStubble = createVoxelBox(0.21, 0.03, 0.21, hairColor, 0, 1.05, 0);
    group.add(hairStubble);
  } else {
    // Curly/afro style
    const hairAfro = createVoxelBox(0.26, 0.12, 0.26, hairColor, 0, 1.08, 0);
    group.add(hairAfro);
  }
  
  // === ACCESSORIES ===
  const hatType = appearance.hat;
  const glassesType = appearance.glasses;
  const extraAccessory = appearance.accessory;
  
  // Hat colors
  const hatColors = [0xd94a4a, 0x4a90d9, 0x2d2d2d, 0xf5f5dc, 0x228B22, 0xffd700, 0xff69b4];
  const hatColor = hatColors[Math.floor(Math.random() * hatColors.length)];
  
  // Hats (rendered on top of head, may cover hair)
  if (hatType === 0) {
    // Baseball cap
    const capTop = createVoxelBox(0.24, 0.08, 0.24, hatColor, 0, 1.1, 0);
    const brim = createVoxelBox(0.22, 0.02, 0.12, hatColor, 0, 1.06, 0.14);
    group.add(capTop, brim);
  } else if (hatType === 1) {
    // Beanie
    const beanie = createVoxelBox(0.24, 0.12, 0.24, hatColor, 0, 1.1, 0);
    const beanieTop = createVoxelBox(0.16, 0.04, 0.16, hatColor, 0, 1.18, 0);
    group.add(beanie, beanieTop);
  } else if (hatType === 2) {
    // Sun hat / wide brim
    const hatTop = createVoxelBox(0.2, 0.1, 0.2, 0xf5deb3, 0, 1.12, 0);
    const brim = createVoxelBox(0.36, 0.02, 0.36, 0xf5deb3, 0, 1.08, 0);
    group.add(hatTop, brim);
  } else if (hatType === 3) {
    // Chef toque (rare customer who's also a chef!)
    const toqueBase = createVoxelBox(0.22, 0.06, 0.22, 0xffffff, 0, 1.08, 0);
    const toquePuff = createVoxelBox(0.2, 0.14, 0.2, 0xffffff, 0, 1.18, 0);
    group.add(toqueBase, toquePuff);
  } else if (hatType === 4) {
    // Headband
    const headband = createVoxelBox(0.24, 0.04, 0.24, hatColor, 0, 1.02, 0);
    group.add(headband);
  }
  
  // Glasses
  if (glassesType === 0) {
    // Regular glasses
    const leftLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, -0.05, 0.96, 0.1);
    leftLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const rightLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, 0.05, 0.96, 0.1);
    rightLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const bridge = createVoxelBox(0.04, 0.015, 0.02, 0x333333, 0, 0.96, 0.1);
    const leftArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, -0.09, 0.96, 0.05);
    const rightArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, 0.09, 0.96, 0.05);
    group.add(leftLens, rightLens, bridge, leftArm, rightArm);
  } else if (glassesType === 1) {
    // Sunglasses
    const leftLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, -0.05, 0.96, 0.1);
    const rightLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, 0.05, 0.96, 0.1);
    const bridge = createVoxelBox(0.04, 0.02, 0.02, 0x1a1a1a, 0, 0.96, 0.1);
    group.add(leftLens, rightLens, bridge);
  } else if (glassesType === 2) {
    // Round hipster glasses
    const frameColor = 0x8B4513;
    const leftFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, -0.05, 0.96, 0.1);
    const rightFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, 0.05, 0.96, 0.1);
    const bridge = createVoxelBox(0.03, 0.015, 0.015, frameColor, 0, 0.96, 0.1);
    group.add(leftFrame, rightFrame, bridge);
  }
  
  // Extra accessories
  if (extraAccessory === 0) {
    // Earrings (small spheres)
    const earringMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
    const leftEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    leftEarring.position.set(-0.11, 0.92, 0);
    const rightEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    rightEarring.position.set(0.11, 0.92, 0);
    group.add(leftEarring, rightEarring);
  } else if (extraAccessory === 1) {
    // Necklace
    const necklace = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.01, 6, 12),
      new THREE.MeshLambertMaterial({ color: 0xffd700 })
    );
    necklace.position.set(0, 0.76, 0.08);
    necklace.rotation.x = Math.PI / 2;
    group.add(necklace);
  } else if (extraAccessory === 2) {
    // Bow tie
    const bowCenter = createVoxelBox(0.03, 0.03, 0.02, 0xd94a4a, 0, 0.76, 0.1);
    const bowLeft = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, -0.04, 0.76, 0.1);
    const bowRight = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, 0.04, 0.76, 0.1);
    group.add(bowCenter, bowLeft, bowRight);
  } else if (extraAccessory === 3) {
    // Scarf
    const scarfColors = [0xd94a4a, 0x4a90d9, 0x4ad94a, 0xffd700, 0x9b4ad9];
    const scarfColor = scarfColors[Math.floor(Math.random() * scarfColors.length)];
    const scarfWrap = createVoxelBox(0.26, 0.06, 0.18, scarfColor, 0, 0.76, 0.02);
    const scarfHang = createVoxelBox(0.06, 0.15, 0.03, scarfColor, 0.08, 0.68, 0.12);
    group.add(scarfWrap, scarfHang);
  }
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.022, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.05, 0.96, 0.09);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.05, 0.96, 0.09);
  group.add(leftEye, rightEye);
  
  // Simple smile
  const smileGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.9, 0.09);
  smile.rotation.x = Math.PI;
  smile.rotation.z = Math.PI;
  group.add(smile);
  
  return group;
}

function createStandingCustomer(appearance = {}) {
  const group = new THREE.Group();
  
  // Use appearance object or generate defaults for backwards compatibility
  const isMale = appearance.isMale !== undefined ? appearance.isMale : Math.random() > 0.5;
  
  // Same expanded palettes as seated customer
  const skinTones = [
    0xffe5d4, 0xffdbac, 0xf5d0c5, 0xe8beac, 
    0xd4a574, 0xc68642, 0x8d5524, 0x6b4423
  ];
  const skinColor = skinTones[appearance.skinTone !== undefined ? appearance.skinTone % skinTones.length : Math.floor(Math.random() * skinTones.length)];
  
  const outfitColors = [
    0x4a90d9, 0xd94a4a, 0x4ad94a, 0xd9d94a, 0x9b4ad9, 0xd94a9b, 0x4ad9d9,
    0xff6b35, 0x2d5a27, 0x8b4513, 0xf5f5dc, 0x191970, 0x800020, 0x40826d
  ];
  const outfitColor = outfitColors[appearance.shirtColor !== undefined ? appearance.shirtColor % outfitColors.length : Math.floor(Math.random() * outfitColors.length)];
  
  const pantsColors = [
    0x2d2d2d, 0x1a1a4e, 0x4a3728, 0x2d4a2d, 0x4a2d4a,
    0x1a1a1a, 0x6b5b4f, 0x4a4a4a, 0x5c4033, 0x3d3d6b
  ];
  const pantsColor = pantsColors[appearance.pantsColor !== undefined ? appearance.pantsColor % pantsColors.length : Math.floor(Math.random() * pantsColors.length)];
  
  const hairColors = [
    0x2c1810, 0x4a3728, 0x8b4513, 0x1a1a1a, 0xd4a574,
    0xc41e3a, 0xffd700, 0x808080, 0x654321, 0xffa07a
  ];
  const hairColor = hairColors[appearance.hairColor !== undefined ? appearance.hairColor % hairColors.length : Math.floor(Math.random() * hairColors.length)];
  
  const shoeColors = [0x1a1a1a, 0x3d3d3d, 0x8b4513, 0x2d2d4a, 0x4a2d2d, 0xf5f5dc];
  const shoeColor = shoeColors[appearance.shoeColor !== undefined ? appearance.shoeColor % shoeColors.length : Math.floor(Math.random() * shoeColors.length)];
  
  const hairStyle = appearance.hairStyle !== undefined ? appearance.hairStyle : Math.floor(Math.random() * 6);
  
  const bodyWidth = isMale ? 0.28 : 0.24;
  const bodyDepth = isMale ? 0.2 : 0.16;
  const shoulderWidth = isMale ? 0.32 : 0.26;
  
  // Standing legs (vertical)
  const leftLeg = createVoxelBox(0.09, 0.35, 0.09, pantsColor, -0.08, 0.175, 0);
  const rightLeg = createVoxelBox(0.09, 0.35, 0.09, pantsColor, 0.08, 0.175, 0);
  group.add(leftLeg, rightLeg);
  
  // Feet/Shoes
  const leftFoot = createVoxelBox(0.09, 0.05, 0.14, shoeColor, -0.08, 0.025, 0.02);
  const rightFoot = createVoxelBox(0.09, 0.05, 0.14, shoeColor, 0.08, 0.025, 0.02);
  group.add(leftFoot, rightFoot);
  
  // Body/Torso (standing upright)
  const body = createVoxelBox(bodyWidth, 0.35, bodyDepth, outfitColor, 0, 0.55, 0);
  body.castShadow = true;
  group.add(body);
  
  // Shoulders (wider for males)
  if (isMale) {
    const shoulders = createVoxelBox(shoulderWidth, 0.08, bodyDepth, outfitColor, 0, 0.71, 0);
    group.add(shoulders);
  }
  
  // Arms (hanging at sides)
  const armColor = isMale ? outfitColor : skinColor;
  const leftArm = createVoxelBox(0.07, 0.25, 0.07, armColor, isMale ? -0.19 : -0.16, 0.48, 0);
  const rightArm = createVoxelBox(0.07, 0.25, 0.07, armColor, isMale ? 0.19 : 0.16, 0.48, 0);
  group.add(leftArm, rightArm);
  
  // Hands
  const leftHand = createVoxelBox(0.055, 0.06, 0.055, skinColor, isMale ? -0.19 : -0.16, 0.34, 0);
  const rightHand = createVoxelBox(0.055, 0.06, 0.055, skinColor, isMale ? 0.19 : 0.16, 0.34, 0);
  group.add(leftHand, rightHand);
  
  // Neck
  const neck = createVoxelBox(0.08, 0.06, 0.08, skinColor, 0, 0.78, 0);
  group.add(neck);
  
  // Head
  const head = createVoxelBox(0.2, 0.2, 0.2, skinColor, 0, 0.92, 0);
  head.castShadow = true;
  group.add(head);
  
  // Hair - same styles as seated (6 options)
  if (hairStyle === 0) {
    const hair = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.04, -0.01);
    group.add(hair);
  } else if (hairStyle === 1) {
    const hairTop = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.04, -0.01);
    const hairBack = createVoxelBox(0.2, 0.25, 0.06, hairColor, 0, 0.88, -0.12);
    group.add(hairTop, hairBack);
  } else if (hairStyle === 2) {
    const hairTop = createVoxelBox(0.22, 0.06, 0.2, hairColor, 0, 1.04, 0);
    const ponytail = createVoxelBox(0.08, 0.15, 0.08, hairColor, 0, 0.93, -0.15);
    group.add(hairTop, ponytail);
  } else if (hairStyle === 3) {
    const hairStubble = createVoxelBox(0.21, 0.03, 0.21, hairColor, 0, 1.03, 0);
    group.add(hairStubble);
  } else {
    const hairAfro = createVoxelBox(0.26, 0.12, 0.26, hairColor, 0, 1.06, 0);
    group.add(hairAfro);
  }
  
  // === ACCESSORIES (same as seated, adjusted Y positions for standing) ===
  const hatType = appearance.hat;
  const glassesType = appearance.glasses;
  const extraAccessory = appearance.accessory;
  
  // Hat colors
  const hatColors = [0xd94a4a, 0x4a90d9, 0x2d2d2d, 0xf5f5dc, 0x228B22, 0xffd700, 0xff69b4];
  const hatColor = hatColors[Math.floor(Math.random() * hatColors.length)];
  
  // Hats
  if (hatType === 0) {
    // Baseball cap
    const capTop = createVoxelBox(0.24, 0.08, 0.24, hatColor, 0, 1.08, 0);
    const brim = createVoxelBox(0.22, 0.02, 0.12, hatColor, 0, 1.04, 0.14);
    group.add(capTop, brim);
  } else if (hatType === 1) {
    // Beanie
    const beanie = createVoxelBox(0.24, 0.12, 0.24, hatColor, 0, 1.08, 0);
    const beanieTop = createVoxelBox(0.16, 0.04, 0.16, hatColor, 0, 1.16, 0);
    group.add(beanie, beanieTop);
  } else if (hatType === 2) {
    // Sun hat / wide brim
    const hatTop = createVoxelBox(0.2, 0.1, 0.2, 0xf5deb3, 0, 1.1, 0);
    const brim = createVoxelBox(0.36, 0.02, 0.36, 0xf5deb3, 0, 1.06, 0);
    group.add(hatTop, brim);
  } else if (hatType === 3) {
    // Chef toque
    const toqueBase = createVoxelBox(0.22, 0.06, 0.22, 0xffffff, 0, 1.06, 0);
    const toquePuff = createVoxelBox(0.2, 0.14, 0.2, 0xffffff, 0, 1.16, 0);
    group.add(toqueBase, toquePuff);
  } else if (hatType === 4) {
    // Headband
    const headband = createVoxelBox(0.24, 0.04, 0.24, hatColor, 0, 1.0, 0);
    group.add(headband);
  }
  
  // Glasses
  if (glassesType === 0) {
    // Regular glasses
    const leftLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, -0.05, 0.94, 0.1);
    leftLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const rightLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, 0.05, 0.94, 0.1);
    rightLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const bridge = createVoxelBox(0.04, 0.015, 0.02, 0x333333, 0, 0.94, 0.1);
    const leftArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, -0.09, 0.94, 0.05);
    const rightArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, 0.09, 0.94, 0.05);
    group.add(leftLens, rightLens, bridge, leftArm, rightArm);
  } else if (glassesType === 1) {
    // Sunglasses
    const leftLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, -0.05, 0.94, 0.1);
    const rightLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, 0.05, 0.94, 0.1);
    const bridge = createVoxelBox(0.04, 0.02, 0.02, 0x1a1a1a, 0, 0.94, 0.1);
    group.add(leftLens, rightLens, bridge);
  } else if (glassesType === 2) {
    // Round hipster glasses
    const frameColor = 0x8B4513;
    const leftFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, -0.05, 0.94, 0.1);
    const rightFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, 0.05, 0.94, 0.1);
    const bridge = createVoxelBox(0.03, 0.015, 0.015, frameColor, 0, 0.94, 0.1);
    group.add(leftFrame, rightFrame, bridge);
  }
  
  // Extra accessories
  if (extraAccessory === 0) {
    // Earrings
    const earringMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
    const leftEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    leftEarring.position.set(-0.11, 0.9, 0);
    const rightEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    rightEarring.position.set(0.11, 0.9, 0);
    group.add(leftEarring, rightEarring);
  } else if (extraAccessory === 1) {
    // Necklace
    const necklace = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.01, 6, 12),
      new THREE.MeshLambertMaterial({ color: 0xffd700 })
    );
    necklace.position.set(0, 0.73, 0.08);
    necklace.rotation.x = Math.PI / 2;
    group.add(necklace);
  } else if (extraAccessory === 2) {
    // Bow tie
    const bowCenter = createVoxelBox(0.03, 0.03, 0.02, 0xd94a4a, 0, 0.73, 0.1);
    const bowLeft = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, -0.04, 0.73, 0.1);
    const bowRight = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, 0.04, 0.73, 0.1);
    group.add(bowCenter, bowLeft, bowRight);
  } else if (extraAccessory === 3) {
    // Scarf
    const scarfColors = [0xd94a4a, 0x4a90d9, 0x4ad94a, 0xffd700, 0x9b4ad9];
    const scarfColor = scarfColors[Math.floor(Math.random() * scarfColors.length)];
    const scarfWrap = createVoxelBox(0.26, 0.06, 0.18, scarfColor, 0, 0.73, 0.02);
    const scarfHang = createVoxelBox(0.06, 0.15, 0.03, scarfColor, 0.08, 0.65, 0.12);
    group.add(scarfWrap, scarfHang);
  }
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.022, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.05, 0.94, 0.09);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.05, 0.94, 0.09);
  group.add(leftEye, rightEye);
  
  // Smile
  const smileGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.88, 0.09);
  smile.rotation.x = Math.PI;
  smile.rotation.z = Math.PI;
  group.add(smile);
  
  // Plate (for carrying food) - hidden by default, shown when hasPlate is true
  const plateGroup = new THREE.Group();
  plateGroup.name = 'carryPlate';
  
  const plate = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.16, 0.03, 12),
    new THREE.MeshLambertMaterial({ color: 0xffffff })
  );
  plate.position.y = 0;
  plateGroup.add(plate);
  
  // Food on plate
  const food = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 8, 6),
    new THREE.MeshLambertMaterial({ color: 0xCD853F })
  );
  food.position.y = 0.06;
  food.scale.y = 0.6;
  plateGroup.add(food);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front of customer, at hand height
  plateGroup.visible = false; // Hidden by default
  group.add(plateGroup);
  
  return group;
}

// Wrapper to create customer with specified pose and plate visibility
function createCustomer(appearance, pose = 'seated', hasPlate = false) {
  // Handle backwards compatibility - if appearance is a number, treat as colorIndex
  const appearanceObj = typeof appearance === 'number' ? {} : (appearance || {});
  const customer = pose === 'standing' ? createStandingCustomer(appearanceObj) : createSeatedCustomer(appearanceObj);
  
  // Show plate if carrying food
  if (pose === 'standing' && hasPlate) {
    const plateObj = customer.getObjectByName('carryPlate');
    if (plateObj) plateObj.visible = true;
  }
  
  return customer;
}

function createChef(avatarOptions = {}) {
  const group = new THREE.Group();
  
  // Get colors from options with defaults
  const gender = avatarOptions.gender || 'female';
  const skinTone = AVATAR_OPTIONS.skinTones.find(s => s.id === avatarOptions.skinTone) || AVATAR_OPTIONS.skinTones[0];
  const hairColor = AVATAR_OPTIONS.hairColors.find(h => h.id === avatarOptions.hairColor) || AVATAR_OPTIONS.hairColors[1];
  const apronColor = AVATAR_OPTIONS.apronColors.find(a => a.id === avatarOptions.apronColor) || AVATAR_OPTIONS.apronColors[0];
  const outfitColor = AVATAR_OPTIONS.outfitColors.find(o => o.id === avatarOptions.outfitColor) || AVATAR_OPTIONS.outfitColors[0];
  const hairStyle = avatarOptions.hairStyle || 'short';
  
  // Legs (dark pants)
  const leftLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, -0.08, 0.125, 0);
  const rightLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, 0.08, 0.125, 0);
  group.add(leftLeg, rightLeg);
  
  // Body (chef coat - customizable color)
  const bodyWidth = gender === 'female' ? 0.28 : 0.32;
  const body = createVoxelBox(bodyWidth, 0.4, 0.22, outfitColor.color, 0, 0.5, 0);
  group.add(body);
  
  // Apron (customizable color)
  const apron = createVoxelBox(0.26, 0.3, 0.05, apronColor.color, 0, 0.45, 0.1);
  group.add(apron);
  
  // Arms (same as outfit)
  const armOffset = gender === 'female' ? 0.20 : 0.24;
  const leftArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, -armOffset, 0.5, 0);
  const rightArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, armOffset, 0.5, 0);
  group.add(leftArm, rightArm);
  
  // Hands (skin color - customizable)
  const leftHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, -armOffset, 0.3, 0);
  const rightHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, armOffset, 0.3, 0);
  group.add(leftHand, rightHand);
  
  // Head (skin - customizable)
  const head = createVoxelBox(0.26, 0.26, 0.26, skinTone.color, 0, 0.93, 0);
  group.add(head);
  
  // Hair (customizable color and style)
  if (hairStyle !== 'none') {
    if (hairStyle === 'short') {
      // Short hair peeking from under hat
      const hair = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hair);
    } else if (hairStyle === 'bun') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Bun behind hat
      const bunGeo = new THREE.SphereGeometry(0.12, 8, 6);
      const bunMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const bun = new THREE.Mesh(bunGeo, bunMat);
      bun.position.set(0, 1.2, -0.15);
      group.add(bun);
    } else if (hairStyle === 'ponytail') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Ponytail
      const tailGeo = new THREE.CylinderGeometry(0.06, 0.04, 0.35, 8);
      const tailMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.position.set(0, 1.0, -0.2);
      tail.rotation.x = 0.5;
      group.add(tail);
    } else if (hairStyle === 'long') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Long flowing hair down both sides
      const longHairGeo = new THREE.BoxGeometry(0.08, 0.4, 0.1);
      const longHairMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const leftHair = new THREE.Mesh(longHairGeo, longHairMat);
      leftHair.position.set(-0.16, 0.75, -0.02);
      group.add(leftHair);
      const rightHair = new THREE.Mesh(longHairGeo, longHairMat);
      rightHair.position.set(0.16, 0.75, -0.02);
      group.add(rightHair);
      // Back hair
      const backHairGeo = new THREE.BoxGeometry(0.24, 0.35, 0.08);
      const backHair = new THREE.Mesh(backHairGeo, longHairMat);
      backHair.position.set(0, 0.78, -0.14);
      group.add(backHair);
    }
  }
  
  // Chef Hat (white toque)
  const hatBase = createVoxelBox(0.28, 0.08, 0.28, 0xffffff, 0, 1.1, 0);
  group.add(hatBase);
  const hatTop = createVoxelBox(0.24, 0.2, 0.24, 0xffffff, 0, 1.25, 0);
  group.add(hatTop);
  const hatPuff = createVoxelBox(0.26, 0.1, 0.26, 0xffffff, 0, 1.38, 0);
  group.add(hatPuff);
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.035, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3d2314 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 0.95, 0.12);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 0.95, 0.12);
  group.add(leftEye, rightEye);
  
  // Eyelashes for female
  if (gender === 'female') {
    const lashMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
    // Left eye lashes
    const leftLashGeo = new THREE.BoxGeometry(0.06, 0.01, 0.01);
    const leftLash = new THREE.Mesh(leftLashGeo, lashMat);
    leftLash.position.set(-0.07, 0.975, 0.13);
    group.add(leftLash);
    // Right eye lashes
    const rightLash = new THREE.Mesh(leftLashGeo, lashMat);
    rightLash.position.set(0.07, 0.975, 0.13);
    group.add(rightLash);
  }
  
  // Smile - happy face!
  const smileGeo = new THREE.TorusGeometry(0.05, 0.015, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0xcc6666 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.86, 0.13);
  smile.rotation.z = Math.PI; // Curve faces up = smile :)
  group.add(smile);
  
  // Plate (carried in front when delivering food) - initially hidden
  const plateGroup = new THREE.Group();
  plateGroup.name = 'plate';
  
  // White plate
  const plateGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.04, 12);
  const plateMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plateGroup.add(plate);
  
  // Food on plate (colorful dome)
  const foodGeo = new THREE.SphereGeometry(0.08, 8, 6);
  const foodMat = new THREE.MeshLambertMaterial({ color: 0xE67E22 }); // Orange/brown food
  const food = new THREE.Mesh(foodGeo, foodMat);
  food.position.y = 0.06;
  food.scale.y = 0.6; // Flatten slightly
  plateGroup.add(food);
  
  // Green garnish
  const garnishGeo = new THREE.SphereGeometry(0.03, 6, 4);
  const garnishMat = new THREE.MeshLambertMaterial({ color: 0x2ECC71 });
  const garnish = new THREE.Mesh(garnishGeo, garnishMat);
  garnish.position.set(0.05, 0.1, 0);
  plateGroup.add(garnish);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front of chef at waist height
  plateGroup.visible = false; // Hidden by default
  group.add(plateGroup);
  
  // Cast shadow
  group.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
    }
  });
  
  return group;
}

// Create a waiter character (standing, with apron, can carry plate)
function createWaiter(carryingPlate = false) {
  const group = new THREE.Group();
  
  // Waiter appearance - professional look
  const skinColor = 0xD2B48C; // Tan skin
  const uniformColor = 0x2d2d2d; // Dark uniform (vest/pants)
  const shirtColor = 0xFFFFFF; // White shirt
  const apronColor = 0x1a1a1a; // Black apron
  const hairColor = 0x2d1b0e; // Dark brown hair
  
  // Legs (dark pants)
  const leftLeg = createVoxelBox(0.1, 0.25, 0.1, uniformColor, -0.08, 0.125, 0);
  const rightLeg = createVoxelBox(0.1, 0.25, 0.1, uniformColor, 0.08, 0.125, 0);
  group.add(leftLeg, rightLeg);
  
  // Body (white shirt)
  const body = createVoxelBox(0.30, 0.4, 0.22, shirtColor, 0, 0.5, 0);
  group.add(body);
  
  // Vest (dark, over shirt)
  const vest = createVoxelBox(0.32, 0.35, 0.18, uniformColor, 0, 0.52, 0.03);
  group.add(vest);
  
  // Waist apron (black, short)
  const apron = createVoxelBox(0.28, 0.2, 0.05, apronColor, 0, 0.38, 0.12);
  group.add(apron);
  
  // Arms (white shirt sleeves)
  const leftArm = createVoxelBox(0.1, 0.3, 0.1, shirtColor, -0.22, 0.5, 0);
  const rightArm = createVoxelBox(0.1, 0.3, 0.1, shirtColor, 0.22, 0.5, 0);
  group.add(leftArm, rightArm);
  
  // Hands (skin)
  const leftHand = createVoxelBox(0.08, 0.1, 0.08, skinColor, -0.22, 0.3, 0);
  const rightHand = createVoxelBox(0.08, 0.1, 0.08, skinColor, 0.22, 0.3, 0);
  group.add(leftHand, rightHand);
  
  // Head (skin)
  const head = createVoxelBox(0.26, 0.26, 0.26, skinColor, 0, 0.93, 0);
  group.add(head);
  
  // Hair (short, neat)
  const hair = createVoxelBox(0.27, 0.12, 0.27, hairColor, 0, 1.02, -0.02);
  group.add(hair);
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.035, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3d2314 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 0.95, 0.12);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 0.95, 0.12);
  group.add(leftEye, rightEye);
  
  // Smile
  const smileGeo = new THREE.TorusGeometry(0.04, 0.01, 4, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.87, 0.13);
  smile.rotation.x = Math.PI;
  smile.rotation.z = Math.PI;
  group.add(smile);
  
  // Bow tie (black)
  const bowTie = createVoxelBox(0.12, 0.06, 0.04, 0x1a1a1a, 0, 0.72, 0.12);
  group.add(bowTie);
  
  // Carrying plate (only visible when carrying food)
  const plateGroup = new THREE.Group();
  plateGroup.name = 'carryPlate';
  
  // Plate
  const plateGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.03, 16);
  const plateMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plate.position.y = 0;
  plateGroup.add(plate);
  
  // Food on plate
  const foodGeo = new THREE.SphereGeometry(0.1, 8, 6);
  const foodMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
  const food = new THREE.Mesh(foodGeo, foodMat);
  food.position.y = 0.07;
  food.scale.y = 0.6;
  plateGroup.add(food);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front at waist height
  plateGroup.visible = carryingPlate;
  group.add(plateGroup);
  
  // Cast shadow
  group.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
    }
  });
  
  return group;
}

function createSteamParticles() {
  const group = new THREE.Group();
  const particleCount = 15;
  
  // Create particles as small white spheres
  const particleGeo = new THREE.SphereGeometry(0.04, 6, 6);
  const particleMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.7 
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(particleGeo, particleMat.clone());
    // Randomize initial position around stove top
    particle.position.set(
      (Math.random() - 0.5) * 0.4,
      0.9 + Math.random() * 0.5, // Start above stove
      (Math.random() - 0.5) * 0.4
    );
    // Store velocity and life data
    particle.userData = {
      velocityY: 0.01 + Math.random() * 0.02,
      velocityX: (Math.random() - 0.5) * 0.005,
      velocityZ: (Math.random() - 0.5) * 0.005,
      life: Math.random(), // Stagger initial life so they don't all reset at once
      maxLife: 1,
    };
    group.add(particle);
  }
  
  return group;
}

function animateSteamParticles(steamGroup) {
  if (!steamGroup) return;
  
  steamGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Move particle
    particle.position.y += data.velocityY;
    particle.position.x += data.velocityX;
    particle.position.z += data.velocityZ;
    
    // Update life
    data.life += 0.02;
    
    // Fade out as life increases
    particle.material.opacity = Math.max(0, 0.7 * (1 - data.life / data.maxLife));
    
    // Scale up slightly as it rises
    const scale = 1 + (data.life / data.maxLife) * 0.5;
    particle.scale.setScalar(scale);
    
    // Reset particle when life expires
    if (data.life >= data.maxLife) {
      particle.position.set(
        (Math.random() - 0.5) * 0.4,
        0.9,
        (Math.random() - 0.5) * 0.4
      );
      particle.material.opacity = 0.7;
      particle.scale.setScalar(1);
      data.life = 0;
      data.velocityY = 0.01 + Math.random() * 0.02;
      data.velocityX = (Math.random() - 0.5) * 0.005;
      data.velocityZ = (Math.random() - 0.5) * 0.005;
    }
  });
}

function createSparkleParticles() {
  const group = new THREE.Group();
  const particleCount = 8; // Fewer particles
  
  // Create sparkle particles as small gold spheres
  const particleGeo = new THREE.SphereGeometry(0.045, 6, 6);
  
  for (let i = 0; i < particleCount; i++) {
    const particleMat = new THREE.MeshBasicMaterial({ 
      color: 0xffd700, // Gold
      transparent: true, 
      opacity: 0.9 
    });
    const particle = new THREE.Mesh(particleGeo, particleMat);
    
    // Position in a ring around the stove top
    const angle = (i / particleCount) * Math.PI * 2;
    const radius = 0.3;
    particle.position.set(
      Math.cos(angle) * radius,
      1.0 + Math.random() * 0.15,
      Math.sin(angle) * radius
    );
    
    // Store animation data - MUCH slower speeds
    particle.userData = {
      baseAngle: angle,
      radius: radius,
      baseY: 1.0 + (i % 3) * 0.1, // Stagger heights
      phase: (i / particleCount) * Math.PI * 2, // Evenly staggered phase
    };
    group.add(particle);
  }
  
  return group;
}

function animateSparkleParticles(sparkleGroup, time) {
  if (!sparkleGroup) return;
  
  const slowTime = time * 0.001; // Convert to seconds, much slower
  
  sparkleGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Very slow orbit around center
    const angle = data.baseAngle + slowTime * 0.3; // Slow rotation
    particle.position.x = Math.cos(angle) * data.radius;
    particle.position.z = Math.sin(angle) * data.radius;
    
    // Gentle float up and down
    particle.position.y = data.baseY + Math.sin(slowTime * 1.5 + data.phase) * 0.08;
    
    // Gentle twinkle effect (opacity pulsing)
    particle.material.opacity = 0.6 + Math.sin(slowTime * 2 + data.phase) * 0.35;
    
    // Subtle scale pulsing
    const scale = 0.9 + Math.sin(slowTime * 1.8 + data.phase) * 0.2;
    particle.scale.setScalar(scale);
  });
}

// ============================================
// MAIN COMPONENT
// ============================================
function CafeWorld3D() {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const objectsRef = useRef({ stoves: {}, counters: {}, tables: {}, chairs: {}, customers: {}, counterFood: {}, tableFood: {}, steamParticles: {}, sparkleParticles: {}, decorations: {}, dividers: {} });
  const raycasterRef = useRef(new THREE.Raycaster());
  const mouseRef = useRef(new THREE.Vector2());
  const shopScrollRef = useRef(null); // For horizontal scroll in shop
  
  const [gameState, dispatch] = useReducer(gameReducer, initialState);
  const [selectedStove, setSelectedStove] = useState(null);
  const [cookbookPage, setCookbookPage] = useState(0);
  const [showShop, setShowShop] = useState(false);
  const [shopCategory, setShopCategory] = useState('equipment'); // 'equipment' or 'decor'
  const [shopScrollPos, setShopScrollPos] = useState({ left: 0, max: 0 }); // Track scroll position
  const [showLevelUp, setShowLevelUp] = useState(false);
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [flyingCoins, setFlyingCoins] = useState([]); // [{id, startX, startY, startTime}]
  const [coinPop, setCoinPop] = useState(false);
  const [newPurchases, setNewPurchases] = useState([]); // [{id, type, time}]
  const [showSettings, setShowSettings] = useState(false);
  const [saveMessage, setSaveMessage] = useState(null); // {type: 'success'|'error', text: '...'}
  const [saveTextArea, setSaveTextArea] = useState(''); // For manual copy/paste
  const [showExportText, setShowExportText] = useState(false);
  const [placingDecoration, setPlacingDecoration] = useState(null); // Decoration type being placed
  const [placingDivider, setPlacingDivider] = useState(null); // Divider type being placed
  const [placingDoor, setPlacingDoor] = useState(null); // Door type being placed
  const [placingWallpaper, setPlacingWallpaper] = useState(null); // Wallpaper type being placed
  const [isPaintingWalls, setIsPaintingWalls] = useState(false); // True when left-click dragging to paint walls
  const [placingEquipment, setPlacingEquipment] = useState(null); // 'stove', 'counter', 'table', or 'chair'
  const [placingTableStyle, setPlacingTableStyle] = useState('square'); // Table style for placement
  const [placingChairStyle, setPlacingChairStyle] = useState('basicWood'); // Chair style for placement
  const [placementRotation, setPlacementRotation] = useState(0); // 0, 1, 2, 3 = 0¬∞, 90¬∞, 180¬∞, 270¬∞
  const [placementLocked, setPlacementLocked] = useState(false); // Position locked, ready to rotate
  const [lockedPosition, setLockedPosition] = useState(null); // {gridX, gridZ} of locked position
  const [editMode, setEditMode] = useState(false); // Edit mode for deleting/moving objects
  const [selectedEditObject, setSelectedEditObject] = useState(null); // {type, id} - object selected in edit mode
  const [movingObject, setMovingObject] = useState(null); // {type, id, data} - object being moved
  const [autoServe, setAutoServe] = useState(false); // Auto-serve customers when food is ready
  const [soundEnabled, setSoundEnabled] = useState(true); // Audio toggle
  const [showCookbook, setShowCookbook] = useState(false); // Cookbook browse mode
  const [sceneReady, setSceneReady] = useState(false); // Scene initialization flag
  const [showAchievement, setShowAchievement] = useState(null); // Achievement popup {id, name, icon, reward}
  const [showTrophies, setShowTrophies] = useState(false); // Trophy panel
  const [showAudioSettings, setShowAudioSettings] = useState(false); // Audio settings panel
  const [showAvatarCustomize, setShowAvatarCustomize] = useState(false); // Avatar customization panel
  const [brightness, setBrightness] = useState(1.0); // Display brightness multiplier (0.5 - 1.5)
  const brightnessRef = useRef(1.0);
  const avatarPreviewRef = useRef(null); // Canvas for avatar preview
  const avatarPreviewSceneRef = useRef(null); // Three.js scene for preview
  
  // Individual sound toggles
  const [soundToggles, setSoundToggles] = useState({
    cooking: true,
    foodReady: true,
    foodSpoiled: true,
    customerArrive: true,
    customerServed: true,
    customerHappy: true,
    customerAngry: true,
    coins: true,
    levelUp: true,
    purchase: true,
    achievement: true,
  });
  const previewDecorationRef = useRef(null); // Ghost preview during placement
  const previewDividerRef = useRef(null); // Ghost preview for divider placement
  const [cameraAngle, setCameraAngle] = useState(Math.PI / 4); // Horizontal rotation in radians (start at 45¬∞)
  const cameraAngleRef = useRef(Math.PI / 4);
  const [cameraPitch, setCameraPitch] = useState(0.6); // Vertical angle (0.2 = low, 1.2 = high/top-down)
  const cameraPitchRef = useRef(0.6);
  const [zoomLevel, setZoomLevel] = useState(1); // 0.5 = zoomed in, 2 = zoomed out
  const zoomLevelRef = useRef(1);
  const [isDragging, setIsDragging] = useState(false);
  const lastMouseX = useRef(0);
  const lastMouseY = useRef(0);
  const lastPlacementGrid = useRef({ gridX: 0, gridZ: 0 }); // Track last grid position for rotation updates
  const [projectedPositions, setProjectedPositions] = useState({}); // {stove_1: {x, y}, table_2: {x, y}, etc}
  const [trashConfirm, setTrashConfirm] = useState(null); // {counterId, recipeName, servings} or null
  const [timeOfDay, setTimeOfDay] = useState(10); // 0-24 hours (starts at 10am)
  const timeOfDayRef = useRef(10);
  const ambientLightRef = useRef(null);
  const sunLightRef = useRef(null);
  const sceneRef2 = useRef(null); // For background updates
  const windowMaterialsRef = useRef([]); // Store window glass materials for night glow
  const wallSegmentsRef = useRef({ back: [], left: [], right: [] }); // Store wall segment references for door gaps
  const lampMaterialsRef = useRef([]); // Store lamp materials for night glow
  const interiorLightsRef = useRef([]); // Interior cafe lights
  const streetLightsRef = useRef([]); // Street lamp point lights
  const chefRef = useRef(null); // Chef avatar
  const gameStateRef = useRef(null); // Reference to current game state for animation loop
  const dispatchRef = useRef(null); // Reference to dispatch for animation loop
  const chefStateRef = useRef({
    targetX: 0,
    targetZ: 2,
    currentX: 0,
    currentZ: 2,
    idleTime: 0,
    state: 'idle', // 'idle', 'walking'
    task: null, // { type: 'cook', stoveId } or { type: 'deliver', stoveId } or { type: 'serve', tableId }
    carryingPlate: false, // true when carrying food to counter
    waypoints: [], // Array of {x, z} intermediate points to navigate around obstacles
    pendingServe: null, // { tableId, counterId } - set by animation loop, processed by game loop
  });
  
  // Pathfinding constants
  const DIVIDER_Z = -4; // Kitchen/dining divider z position in world coords
  const DOORWAY_X = 5.5; // Doorway gap position (right side)
  
  // Helper function to set chef target with proper A* pathfinding (same as customers)
  const setChefTargetWithPath = (targetX, targetZ, task = null) => {
    const chef = chefStateRef.current;
    const currentX = chef.currentX;
    const currentZ = chef.currentZ;
    
    // Convert world coordinates to grid coordinates
    const startGridX = Math.round(currentX + GRID.width / 2 - 0.5);
    const startGridZ = Math.round(currentZ + GRID.height / 2 - 0.5);
    const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
    const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
    
    // Build occupancy map from current game state
    const state = gameStateRef.current;
    const occupancyMap = buildOccupancyMap(state);
    
    // Find path using A* (same algorithm customers use)
    const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
    
    chef.waypoints = [];
    
    if (path && path.length > 1) {
      // Convert grid path back to world coordinates for waypoints
      // Skip first point (current position) and add rest as waypoints
      for (let i = 1; i < path.length; i++) {
        const worldX = path[i].gridX - GRID.width / 2 + 0.5;
        const worldZ = path[i].gridZ - GRID.height / 2 + 0.5;
        chef.waypoints.push({ x: worldX, z: worldZ });
      }
      
      // Start with first waypoint
      if (chef.waypoints.length > 0) {
        const first = chef.waypoints.shift();
        chef.targetX = first.x;
        chef.targetZ = first.z;
      }
    } else {
      // No path found or already at destination - try direct movement
      // (fallback for edge cases like standing on a decoration)
      chef.targetX = targetX;
      chef.targetZ = targetZ;
    }
    
    chef.task = task;
    chef.idleTime = 0;
  };
  
  // Keep ref in sync with state
  useEffect(() => {
    cameraAngleRef.current = cameraAngle;
  }, [cameraAngle]);
  
  
  useEffect(() => {
    cameraPitchRef.current = cameraPitch;
  }, [cameraPitch]);
  
  useEffect(() => {
    zoomLevelRef.current = zoomLevel;
  }, [zoomLevel]);
  
  useEffect(() => {
    timeOfDayRef.current = timeOfDay;
  }, [timeOfDay]);
  
  // Sync game state with ref for animation loop access
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);
  
  // Sync dispatch ref for animation loop access
  useEffect(() => {
    dispatchRef.current = dispatch;
  }, [dispatch]);
  
  // Chef behavior: Go to stove when cooking starts
  useEffect(() => {
    const cookingStove = gameState.stoves.find(s => s.state === 'cooking');
    const chef = chefStateRef.current;
    
    // If a stove is cooking and chef has no task, send chef there
    if (cookingStove && !chef.task && !chef.carryingPlate && gameStateRef.current) {
      const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'cook', stoveId: cookingStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'cooking').length]);
  
  // Chef behavior: Pick up ready food
  useEffect(() => {
    const readyStove = gameState.stoves.find(s => s.state === 'ready');
    const chef = chefStateRef.current;
    
    // If food is ready and chef isn't already carrying or picking up
    if (readyStove && !chef.carryingPlate && (!chef.task || chef.task.type === 'cook') && gameStateRef.current) {
      const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'pickup', stoveId: readyStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'ready').length]);
  
  // Sync sound state with global audio setting
  useEffect(() => {
    audioEnabled = soundEnabled;
  }, [soundEnabled]);
  
  // Sync individual sound toggles with global
  useEffect(() => {
    soundTogglesGlobal = { ...soundToggles };
  }, [soundToggles]);
  
  // Sync brightness ref with state
  useEffect(() => {
    brightnessRef.current = brightness;
  }, [brightness]);
  
  // Update chef avatar when customization changes
  useEffect(() => {
    if (chefRef.current && sceneRef2.current) {
      // Save chef position and state
      const oldPosition = chefRef.current.position.clone();
      const oldRotation = chefRef.current.rotation.y;
      
      // Remove old chef
      sceneRef2.current.remove(chefRef.current);
      
      // Create new chef with updated avatar options
      const newChef = createChef(gameState.avatar);
      newChef.position.copy(oldPosition);
      newChef.rotation.y = oldRotation;
      
      // Add to scene
      sceneRef2.current.add(newChef);
      chefRef.current = newChef;
    }
  }, [gameState.avatar]);
  
  // Avatar preview mini-scene
  useEffect(() => {
    if (!showAvatarCustomize || !avatarPreviewRef.current) return;
    
    const canvas = avatarPreviewRef.current;
    const width = 180;
    const height = 220;
    
    // Create mini renderer
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);
    
    // Create mini scene
    const scene = new THREE.Scene();
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
    camera.position.set(0, 1, 3.5);
    camera.lookAt(0, 0.7, 0);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 3, 2);
    scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(-2, 2, -2);
    scene.add(backLight);
    
    // Create chef preview
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, 0);
    scene.add(chef);
    
    // Store for cleanup
    avatarPreviewSceneRef.current = { renderer, scene, camera, chef };
    
    // Animation loop for gentle rotation
    let animationId;
    let rotation = 0;
    
    const animate = () => {
      rotation += 0.01;
      chef.rotation.y = Math.sin(rotation) * 0.5; // Gentle sway
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      cancelAnimationFrame(animationId);
      renderer.dispose();
    };
  }, [showAvatarCustomize, gameState.avatar]);
  
  // Reset shop scroll position when opening shop or changing category
  useEffect(() => {
    if (showShop && shopScrollRef.current) {
      shopScrollRef.current.scrollLeft = 0;
      setShopScrollPos({ left: 0, max: shopScrollRef.current.scrollWidth - shopScrollRef.current.clientWidth });
    }
  }, [showShop, shopCategory]);
  
  // Update shop scroll max after items render
  useEffect(() => {
    if (showShop && shopScrollRef.current) {
      const updateMax = () => {
        setShopScrollPos(prev => ({
          ...prev,
          max: shopScrollRef.current.scrollWidth - shopScrollRef.current.clientWidth
        }));
      };
      // Small delay to let items render
      setTimeout(updateMax, 100);
    }
  }, [showShop, shopCategory]);
  
  // Mouse wheel zoom (disabled during placement modes)
  useEffect(() => {
    const handleWheel = (e) => {
      // Skip zoom if in any placement/move mode - let rotation handler take over
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        return; // Don't zoom during placement
      }
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.1 : -0.1;
      setZoomLevel(prev => Math.max(0.5, Math.min(1.5, prev + delta)));
    };
    
    const container = containerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
      return () => container.removeEventListener('wheel', handleWheel);
    }
  }, [placingEquipment, placingDecoration, placingDivider, movingObject]);
  
  // Right-click drag to rotate camera
  const handleMouseDown = (e) => {
    if (e.button === 2) { // Right click - camera rotation
      e.preventDefault();
      setIsDragging(true);
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
    } else if (e.button === 0 && placingWallpaper) { // Left click with wallpaper selected
      e.preventDefault();
      setIsPaintingWalls(true);
      // Paint the first segment immediately
      paintWallAtMouse(e);
    }
  };
  
  // Helper function to paint wall segment at mouse position
  const paintWallAtMouse = (e) => {
    if (!placingWallpaper || !containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Raycast against all objects in the scene
    const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
    
    // Find the first wall segment or door header we hit
    // Wall segments have: { wall, position }
    // Door headers have: { wall, position, isDoorHeader }
    // Door GROUPS have: { wall, wallPosition } - we want to skip these!
    let hitWallSegment = null;
    for (const hit of intersects) {
      let obj = hit.object;
      while (obj && !(obj.userData?.wall && obj.userData?.position !== undefined)) {
        obj = obj.parent;
      }
      if (obj && obj.userData?.wall && obj.userData?.position !== undefined) {
        hitWallSegment = obj;
        break;
      }
    }
    
    if (hitWallSegment) {
      const wall = hitWallSegment.userData.wall;
      const wallPosition = hitWallSegment.userData.position;
      const wallpaper = WALLPAPERS[placingWallpaper];
      
      // Check if this segment already has this wallpaper
      const existingPaint = (gameStateRef.current.paintedSegments || []).find(
        p => p.wall === wall && p.position === wallPosition
      );
      const alreadyPainted = existingPaint && existingPaint.wallpaper === placingWallpaper;
      
      if (!alreadyPainted && (gameStateRef.current.coins >= wallpaper.cost || wallpaper.cost === 0)) {
        dispatch({ 
          type: 'PAINT_SEGMENT', 
          payload: { wall, position: wallPosition, wallpaperType: placingWallpaper } 
        });
        SFX.purchase();
      }
    }
  };
  
  const handleMouseMove = (e) => {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX.current;
      const deltaY = e.clientY - lastMouseY.current;
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
      
      // Horizontal rotation (inverted for natural "grab and drag" feel)
      setCameraAngle(prev => prev - deltaX * 0.01);
      
      // Vertical rotation (inverted: drag up = look from above, drag down = look from ground)
      // Minimum 0.3 prevents looking "under" the world
      setCameraPitch(prev => Math.max(0.3, Math.min(1.4, prev - deltaY * 0.01)));
    }
    
    // Paint wall segments while dragging with wallpaper selected
    if (isPaintingWalls && placingWallpaper) {
      paintWallAtMouse(e);
    }
    
    // Update decoration preview position
    if (placingDecoration && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const decorType = DECORATIONS[placingDecoration];
        const isWallDecor = decorType.category === 'wall';
        
        // Calculate world position
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Check if valid area
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
        const validArea = isWallDecor ? inCafe : inDiningArea;
        
        // Check for collisions (floor decorations only)
        let hasCollision = false;
        if (!isWallDecor && validArea) {
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const validPlacement = validArea && !hasCollision;
        
        // Always show preview, tint based on validity
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = 0.7;
            if (validPlacement) {
              // Restore original color
              if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              // Tint red for invalid
              child.material.color.setHex(0xFF0000);
            }
          }
        });
        
        if (isWallDecor) {
          // Position on nearest wall (walls are now at grid boundary)
          const distToBack = gridZ;
          const distToLeft = gridX;
          const distToRight = GRID.width - 1 - gridX;
          const minDist = Math.min(distToBack, distToLeft, distToRight);
          
          if (minDist === distToBack) {
            previewDecorationRef.current.position.set(worldX, 0, -GRID.height / 2 + 0.02);
            previewDecorationRef.current.rotation.y = 0;
          } else if (minDist === distToLeft) {
            previewDecorationRef.current.position.set(-GRID.width / 2 + 0.02, 0, worldZ);
            previewDecorationRef.current.rotation.y = Math.PI / 2;
          } else {
            previewDecorationRef.current.position.set(GRID.width / 2 - 0.02, 0, worldZ);
            previewDecorationRef.current.rotation.y = -Math.PI / 2;
          }
        } else {
          previewDecorationRef.current.position.set(worldX, 0, worldZ);
          previewDecorationRef.current.rotation.y = 0;
        }
      }
    }
    
    // Update divider preview position
    if (placingDivider && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Dividers can go anywhere inside cafe
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        
        // Check for collisions
        let hasCollision = false;
        if (inCafe) {
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const validPlacement = inCafe && !hasCollision;
        
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = 0.7;
            if (validPlacement) {
              if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              child.material.color.setHex(0xFF0000);
            }
          }
        });
        
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        previewDecorationRef.current.rotation.y = (placementRotation % 2) * (Math.PI / 2);
      }
    }
    
    // Update equipment preview position
    if (placingEquipment && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        // Use locked position if placement is locked, otherwise calculate from mouse
        const useLockedPos = placementLocked && lockedPosition;
        const gridX = useLockedPos ? lockedPosition.gridX : Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = useLockedPos ? lockedPosition.gridZ : Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Store grid position for rotation updates
        lastPlacementGrid.current = { gridX, gridZ };
        
        // Helper to check for floor decoration collision
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        
        // Check for divider collision
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        
        // Check if valid placement
        let validPlacement = false;
        if (placingEquipment === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'counter') {
          // Counters can be placed anywhere in the cafe (buffet style!)
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => {
            // Check both table tile and chair tile
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          validPlacement = inCafe && notOnStove && notOnCounter && notOnTable && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'table') {
          // New system: tables occupy 1 tile only
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'chair') {
          // Chairs must be placed facing a table that doesn't already have a chair
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          
          // Check if chair would face a table
          const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
          const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
          const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
          
          validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider && tableAvailable;
        }
        
        // Always show preview, tint based on validity
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        
        // Apply rotation for all equipment types
        previewDecorationRef.current.rotation.y = placementRotation * (Math.PI / 2);
        
        // Color based on placement validity and lock state
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = placementLocked ? 0.85 : 0.7; // More solid when locked
            if (validPlacement) {
              // Green tint when locked and ready to place, original color otherwise
              if (placementLocked) {
                child.material.color.setHex(0x88FF88); // Light green when locked
              } else if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              // Tint red for invalid
              child.material.color.setHex(0xFF0000);
            }
          }
        });
      }
    }
    
    // Update preview position when moving objects (edit mode)
    if (movingObject && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Helper to check collisions excluding the moving object
        const excludeId = movingObject.id;
        const hasCollision = (gx, gz, excludeType, excludeObjId) => {
          const decorTaken = gameState.decorations.some(d => {
            if (excludeType === 'decoration' && d.id === excludeObjId) return false;
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gx && d.gridZ === gz;
          });
          const dividerTaken = (gameState.dividers || []).some(d => {
            if (excludeType === 'divider' && d.id === excludeObjId) return false;
            return d.gridX === gx && d.gridZ === gz;
          });
          const tableTaken = gameState.tables.some(t => {
            if (excludeType === 'table' && t.id === excludeObjId) return false;
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gx && tile.gridZ === gz);
          });
          const stoveTaken = gameState.stoves.some(s => {
            if (excludeType === 'stove' && s.id === excludeObjId) return false;
            return s.gridX === gx && s.gridZ === gz;
          });
          const counterTaken = gameState.counters.some(c => {
            if (excludeType === 'counter' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          return decorTaken || dividerTaken || tableTaken || stoveTaken || counterTaken;
        };
        
        let validPlacement = false;
        
        if (movingObject.type === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          validPlacement = inKitchen && !hasCollision(gridX, gridZ, 'stove', excludeId);
        } else if (movingObject.type === 'counter') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'counter', excludeId);
        } else if (movingObject.type === 'table') {
          const chairTile = getChairTile(gridX, gridZ, placementRotation);
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const chairInDining = chairTile.gridX >= 0 && chairTile.gridX <= GRID.width - 1 && 
            chairTile.gridZ >= 4 && chairTile.gridZ <= GRID.height - 1;
          const tableClear = !hasCollision(gridX, gridZ, 'table', excludeId);
          const chairClear = !hasCollision(chairTile.gridX, chairTile.gridZ, 'table', excludeId);
          validPlacement = inDining && chairInDining && tableClear && chairClear;
        } else if (movingObject.type === 'decoration') {
          const decorType = DECORATIONS[movingObject.data.decorationType];
          const isWallDecor = decorType?.category === 'wall';
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
          const validArea = isWallDecor ? inCafe : inDiningArea;
          validPlacement = validArea && (isWallDecor || !hasCollision(gridX, gridZ, 'decoration', excludeId));
        } else if (movingObject.type === 'divider') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'divider', excludeId);
        }
        
        // Show preview
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        // Dividers only use 0 or 90 degrees
        const rotationAngle = movingObject.type === 'divider' 
          ? (placementRotation % 2) * (Math.PI / 2)
          : placementRotation * (Math.PI / 2);
        previewDecorationRef.current.rotation.y = rotationAngle;
        
        // Color based on validity
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = 0.7;
            if (validPlacement) {
              child.material.color.setHex(0x88FF88); // Green for valid
            } else {
              child.material.color.setHex(0xFF0000); // Red for invalid
            }
          }
        });
      }
    }
  };
  
  const handleMouseUp = (e) => {
    if (e.button === 2) {
      setIsDragging(false);
    } else if (e.button === 0) {
      // Stop painting walls on left-click release
      setIsPaintingWalls(false);
    }
  };
  
  const handleContextMenu = (e) => {
    e.preventDefault(); // Prevent right-click menu
    
    // Right-click cancels placement or moving
    if (placingEquipment || placingDecoration || movingObject) {
      setPlacingEquipment(null);
      setPlacingDecoration(null);
      setMovingObject(null);
      setPlacementLocked(false);
      setLockedPosition(null);
      setPlacementRotation(0);
    }
  };
  
  // Check for level up
  const currentLevelXp = XP_LEVELS[gameState.level] || Infinity;
  useEffect(() => {
    if (gameState.xp >= currentLevelXp && gameState.level < XP_LEVELS.length) {
      dispatch({ type: 'LEVEL_UP' });
      setShowLevelUp(true);
      SFX.levelUp();
      setTimeout(() => setShowLevelUp(false), 3000);
    }
  }, [gameState.xp, currentLevelXp, gameState.level]);
  
  // Check for achievements
  const unlockAchievement = (id) => {
    if (!gameState.achievements.includes(id)) {
      dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: { achievementId: id } });
      const ach = ACHIEVEMENTS[id];
      setShowAchievement({ id, name: ach.name, icon: ach.icon, description: ach.description, reward: ach.reward });
      SFX.achievement();
      setTimeout(() => setShowAchievement(null), 4000);
    }
  };
  
  useEffect(() => {
    const { stats, achievements, stoves, tables, decorations, level } = gameState;
    
    // First Dish - Cook your first meal
    if (stats.dishesCooked >= 1 && !achievements.includes('firstDish')) {
      unlockAchievement('firstDish');
      return; // Only one achievement at a time
    }
    
    // First Customer - Serve your first customer
    if (stats.customersServed >= 1 && !achievements.includes('firstCustomer')) {
      unlockAchievement('firstCustomer');
      return;
    }
    
    // Busy Kitchen - All 3 stoves cooking
    const cookingStoves = stoves.filter(s => s.state === 'cooking').length;
    if (cookingStoves >= 3 && stoves.length >= 3 && !achievements.includes('busyKitchen')) {
      unlockAchievement('busyKitchen');
      return;
    }
    
    // Full House - All tables have customers
    const tablesWithCustomers = tables.filter(t => t.customer).length;
    if (tablesWithCustomers >= tables.length && tables.length >= 8 && !achievements.includes('fullHouse')) {
      unlockAchievement('fullHouse');
      return;
    }
    
    // Big Spender - Spend 5,000 coins total
    if (stats.totalSpent >= 5000 && !achievements.includes('bigSpender')) {
      unlockAchievement('bigSpender');
      return;
    }
    
    // Interior Designer - Place 5 decorations
    if (decorations.length >= 5 && !achievements.includes('decorator')) {
      unlockAchievement('decorator');
      return;
    }
    
    // Speedy Chef - Serve 10 customers in one session
    if (stats.customersServedSession >= 10 && !achievements.includes('speedyChef')) {
      unlockAchievement('speedyChef');
      return;
    }
    
    // Rising Chef - Reach level 5
    if (level >= 5 && !achievements.includes('chef')) {
      unlockAchievement('chef');
      return;
    }
    
    // Master Chef - Reach level 10
    if (level >= 10 && !achievements.includes('masterChef')) {
      unlockAchievement('masterChef');
      return;
    }
    
    // Cafe Mogul - Earn 10,000 coins total
    if (stats.totalEarned >= 10000 && !achievements.includes('mogul')) {
      unlockAchievement('mogul');
      return;
    }
    
    // Growing Business - Own 3 stoves and 10 tables
    if (stoves.length >= 3 && tables.length >= 10 && !achievements.includes('expansion')) {
      unlockAchievement('expansion');
      return;
    }
  }, [gameState.stats, gameState.stoves, gameState.tables, gameState.decorations, gameState.level, gameState.achievements]);
  
  // Night Owl achievement - needs timeOfDay check
  useEffect(() => {
    if (timeOfDay >= 22 || timeOfDay < 5) {
      // It's night time (10 PM - 5 AM)
      const recentlyServed = gameState.stats.customersServedSession > 0;
      if (recentlyServed && !gameState.achievements.includes('nightOwl')) {
        // Check if we just served someone
        const tablesEating = gameState.tables.filter(t => t.customer?.state === 'eating');
        if (tablesEating.length > 0) {
          unlockAchievement('nightOwl');
        }
      }
    }
  }, [timeOfDay, gameState.stats.customersServedSession, gameState.tables, gameState.achievements]);
  
  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current) return;
    
    // Scene - background matches grass color so horizon is invisible
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6CB06C);
    sceneRef.current = scene;
    sceneRef2.current = scene;
    
    // Orthographic camera (isometric view)
    const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
    const frustumSize = 8;
    const camera = new THREE.OrthographicCamera(
      -frustumSize * aspect, frustumSize * aspect,
      frustumSize, -frustumSize,
      0.1, 1000
    );
    camera.position.set(10, 10, 10);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    ambientLightRef.current = ambient;
    
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(8, 15, 8);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 100;
    sun.shadow.camera.left = -30;
    sun.shadow.camera.right = 30;
    sun.shadow.camera.top = 30;
    sun.shadow.camera.bottom = -30;
    scene.add(sun);
    sunLightRef.current = sun;
    
    // Clear material refs
    windowMaterialsRef.current = [];
    lampMaterialsRef.current = [];
    interiorLightsRef.current = [];
    streetLightsRef.current = [];
    
    // Create static environment (passes refs to store materials)
    createFloor(scene);
    createWalls(scene, windowMaterialsRef, wallSegmentsRef, gameStateRef.current?.doors || [], gameStateRef.current?.wallpaper || 'cream', gameStateRef.current?.paintedSegments || []);
    createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef);
    
    // Interior lighting handled by ambient light - no invisible point lights needed
    
    // Exterior lights around back/sides of cafe
    const exteriorLightPositions = [
      { x: -5, z: -GRID.height / 2 - 2 },  // Back left
      { x: 5, z: -GRID.height / 2 - 2 },   // Back right
      { x: -GRID.width / 2 - 2, z: -3 },   // Left side
      { x: -GRID.width / 2 - 2, z: 3 },    // Left side
      { x: GRID.width / 2 + 2, z: -3 },    // Right side  
      { x: GRID.width / 2 + 2, z: 3 },     // Right side
    ];
    
    exteriorLightPositions.forEach(pos => {
      const extLight = new THREE.PointLight(0xFFE4B5, 0, 10, 2); // Warm, invisible
      extLight.position.set(pos.x, 2.5, pos.z);
      scene.add(extLight);
      streetLightsRef.current.push(extLight);
    });
    
    // Create chef avatar
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, -4); // Start in kitchen
    scene.add(chef);
    chefRef.current = chef;
    chefStateRef.current = {
      targetX: 0,
      targetZ: -4,
      currentX: 0,
      currentZ: -4,
      idleTime: 0,
      state: 'idle',
      task: null,
      carryingPlate: false,
      waypoints: [],
    };
    
    // Create waiter
    const waiterObj = createWaiter(false);
    const waiterHomeX = gameState.waiter.homeX - GRID.width / 2 + 0.5;
    const waiterHomeZ = gameState.waiter.homeZ - GRID.height / 2 + 0.5;
    waiterObj.position.set(waiterHomeX, 0, waiterHomeZ);
    scene.add(waiterObj);
    objectsRef.current.waiter = waiterObj;
    
    // Animation loop
    let animationId;
    let currentZoom = 1; // Smooth zoom value
    const baseFrustumSize = 8;
    let lastProjectionUpdate = 0;
    const PROJECTION_UPDATE_INTERVAL = 16; // ~60fps for UI updates
    
    function animate() {
      animationId = requestAnimationFrame(animate);
      const time = Date.now();
      
      // Update camera position based on angle and pitch (spherical coordinates)
      const yaw = cameraAngleRef.current;
      const pitch = cameraPitchRef.current;
      const distance = 20; // Distance from center
      
      // Spherical to Cartesian conversion
      camera.position.x = Math.sin(yaw) * Math.cos(pitch) * distance;
      camera.position.z = Math.cos(yaw) * Math.cos(pitch) * distance;
      camera.position.y = Math.sin(pitch) * distance;
      camera.lookAt(0, 0, 0);
      
      // Smooth camera zoom
      const targetZoom = zoomLevelRef.current;
      const zoomDiff = targetZoom - currentZoom;
      if (Math.abs(zoomDiff) > 0.01) {
        currentZoom += zoomDiff * 0.15; // Smooth interpolation
        const newFrustumSize = baseFrustumSize * currentZoom;
        const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
        camera.left = -newFrustumSize * aspect;
        camera.right = newFrustumSize * aspect;
        camera.top = newFrustumSize;
        camera.bottom = -newFrustumSize;
        camera.updateProjectionMatrix();
      }
      
      // === DAY/NIGHT CYCLE ===
      const tod = timeOfDayRef.current;
      
      // Calculate lighting based on time of day
      // 0-5: night, 5-7: dawn, 7-17: day, 17-19: dusk, 19-24: night
      let skyColor, ambientColor, ambientIntensity, sunIntensity, sunColor;
      let windowGlow = 0;
      let lampGlow = 0.2;
      
      if (tod >= 5 && tod < 7) {
        // Dawn - orange/pink transition
        const t = (tod - 5) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0x1a1a3a), // night
          new THREE.Color(0xFFB347), // dawn orange
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0x2a2a4a),
          new THREE.Color(0xffeedd),
          t
        );
        ambientIntensity = 0.3 + t * 0.2;
        sunIntensity = t * 0.5;
        sunColor = new THREE.Color(0xFFAA77);
        windowGlow = (1 - t) * 0.7;
        lampGlow = 1.2 - t * 1.2; // Lights fade off as sun rises
      } else if (tod >= 7 && tod < 17) {
        // Day - bright but not blinding
        const midday = 1 - Math.abs(tod - 12) / 5; // peaks at noon
        skyColor = new THREE.Color(0xADD8E6); // light blue
        ambientColor = new THREE.Color(0xffffff);
        ambientIntensity = 0.4 + midday * 0.1; // Reduced from 0.5+0.15
        sunIntensity = 0.5 + midday * 0.15; // Reduced from 0.7+0.2
        sunColor = new THREE.Color(0xffffff);
        windowGlow = 0;
        lampGlow = 0; // Lights off during day
      } else if (tod >= 17 && tod < 19) {
        // Dusk - orange/purple transition
        const t = (tod - 17) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0xFFB347), // dusk orange
          new THREE.Color(0x4a3a6a), // purple
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0xffeedd),
          new THREE.Color(0x6a5a8a),
          t
        );
        ambientIntensity = 0.5 - t * 0.2;
        sunIntensity = 0.5 - t * 0.4;
        sunColor = new THREE.Color(0xFF7744);
        windowGlow = t * 0.7;
        lampGlow = 0.2 + t * 1.0; // Lights come on during dusk
      } else {
        // Night - dark sky, interior cozy but not blinding
        skyColor = new THREE.Color(0x1a1a3a);
        ambientColor = new THREE.Color(0xffeedd); // Warm white
        ambientIntensity = 0.3; // Noticeably dimmer than day
        sunIntensity = 0.02; // Barely any moonlight
        sunColor = new THREE.Color(0x8888aa);
        windowGlow = 0.7;
        lampGlow = 1.2; // Floor lamps glow at night
      }
      
      // Apply lighting changes (with brightness multiplier)
      const bright = brightnessRef.current;
      if (ambientLightRef.current) {
        ambientLightRef.current.color.copy(ambientColor);
        ambientLightRef.current.intensity = ambientIntensity * bright;
      }
      if (sunLightRef.current) {
        sunLightRef.current.color.copy(sunColor);
        sunLightRef.current.intensity = sunIntensity * bright;
        // Disable shadows at night so interior lights can illuminate properly
        sunLightRef.current.castShadow = sunIntensity > 0.2;
      }
      if (sceneRef2.current) {
        // Background stays grass-colored (darkens at night)
        const grassBg = tod >= 19 || tod < 5 ? 0x3a5a3a : 0x6CB06C;
        sceneRef2.current.background.setHex(grassBg);
      }
      
      // Update window glow (warm yellow at night)
      windowMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFDD88);
        mat.emissiveIntensity = windowGlow * bright;
      });
      
      // Update lamp glow (warm orange) - floor lamps etc
      lampMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFAA55); // Warm orange
        mat.emissiveIntensity = lampGlow * 0.6 * bright;
      });
      
      // Interior ceiling lights are constant (set at creation, not updated)
      // But floor lamp LIGHTS still need to be updated for night glow
      const floorLampIntensity = lampGlow * 0.8 * bright;
      interiorLightsRef.current.forEach(light => {
        light.intensity = floorLampIntensity;
      });
      
      // Update street lamp lights
      const streetIntensity = lampGlow * 1.5 * bright;
      streetLightsRef.current.forEach(light => {
        light.intensity = streetIntensity;
      });
      
      // Customers sit still (no animation needed)
      
      // Animate chef avatar
      if (chefRef.current) {
        const chef = chefStateRef.current;
        const speed = 0.03;
        
        // Move towards target
        const dx = chef.targetX - chef.currentX;
        const dz = chef.targetZ - chef.currentZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Update plate visibility
        const plateObj = chefRef.current.getObjectByName('plate');
        if (plateObj) {
          plateObj.visible = chef.carryingPlate;
        }
        
        if (dist > 0.1) {
          // Walking
          chef.state = 'walking';
          chef.currentX += (dx / dist) * speed;
          chef.currentZ += (dz / dist) * speed;
          
          // Face movement direction
          chefRef.current.rotation.y = Math.atan2(dx, dz);
          
          // Walking bob animation
          chefRef.current.position.y = Math.abs(Math.sin(time * 0.015)) * 0.08;
        } else {
          // Arrived at destination
          chef.state = 'idle';
          
          // Check if there are more waypoints
          if (chef.waypoints && chef.waypoints.length > 0) {
            const next = chef.waypoints.shift();
            chef.targetX = next.x;
            chef.targetZ = next.z;
            chef.state = 'walking';
            return; // Continue to next waypoint
          }
          
          // Handle task completion
          if (chef.task) {
            if (chef.task.type === 'deliver') {
              // Arrived at counter from stove - drop off plate
              chef.carryingPlate = false;
              chef.task = null;
            } else if (chef.task.type === 'pickup' && chef.task.tableId) {
              // Auto-serve flow: Arrived at counter to pick up food for customer
              const counter = gameStateRef.current.counters.find(c => c.id === chef.task.counterId);
              const targetTable = gameStateRef.current.tables.find(t => t.id === chef.task.tableId);
              
              if (counter && counter.dishes.length > 0 && targetTable && targetTable.customer?.state === 'waiting') {
                chef.carryingPlate = true;
                
                // Pathfind to the customer's table
                const chairTile = getChairTile(targetTable.gridX, targetTable.gridZ, targetTable.rotation || 0);
                const tableWorldX = chairTile.gridX - GRID.width / 2 + 0.5;
                const tableWorldZ = chairTile.gridZ - GRID.height / 2 + 0.5;
                
                // Calculate path using A*
                const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
                const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
                const endGridX = chairTile.gridX;
                const endGridZ = chairTile.gridZ;
                const occupancyMap = buildOccupancyMap(gameStateRef.current);
                const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
                
                chef.waypoints = [];
                if (path && path.length > 1) {
                  for (let i = 1; i < path.length; i++) {
                    chef.waypoints.push({ 
                      x: path[i].gridX - GRID.width / 2 + 0.5, 
                      z: path[i].gridZ - GRID.height / 2 + 0.5 
                    });
                  }
                  const first = chef.waypoints.shift();
                  chef.targetX = first.x;
                  chef.targetZ = first.z;
                } else {
                  chef.targetX = tableWorldX;
                  chef.targetZ = tableWorldZ;
                }
                
                // Set task to serve at table
                chef.task = { type: 'serve', counterId: chef.task.counterId, tableId: chef.task.tableId };
              } else {
                // No food or customer left, cancel task
                chef.carryingPlate = false;
                chef.task = null;
              }
            } else if (chef.task.type === 'pickup') {
              // Old flow: Arrived at stove - pick up plate to take to counter
              chef.carryingPlate = true;
              // Now go to counter using pathfinding
              const counters = gameStateRef.current.counters;
              if (counters.length > 0) {
                const counter = counters[0];
                const counterWorldX = counter.gridX - GRID.width / 2 + 0.5;
                const counterWorldZ = counter.gridZ - GRID.height / 2 + 0.5;
                
                // Calculate path using A*
                const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
                const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
                const endGridX = Math.round(counterWorldX + GRID.width / 2 - 0.5);
                const endGridZ = Math.round(counterWorldZ + GRID.height / 2 - 0.5);
                const occupancyMap = buildOccupancyMap(gameStateRef.current);
                const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
                
                chef.waypoints = [];
                if (path && path.length > 1) {
                  for (let i = 1; i < path.length; i++) {
                    chef.waypoints.push({ 
                      x: path[i].gridX - GRID.width / 2 + 0.5, 
                      z: path[i].gridZ - GRID.height / 2 + 0.5 
                    });
                  }
                  const first = chef.waypoints.shift();
                  chef.targetX = first.x;
                  chef.targetZ = first.z;
                } else {
                  chef.targetX = counterWorldX;
                  chef.targetZ = counterWorldZ;
                }
                chef.task = { type: 'deliver', counterId: counter.id };
              } else {
                chef.task = null;
              }
            } else if (chef.task.type === 'cook') {
              // Arrived at stove to cook - just hang out nearby
              chef.task = null;
            } else if (chef.task.type === 'serve') {
              // Arrived at table to serve customer - set pending serve for game loop to process
              const tableId = chef.task.tableId;
              const counterId = chef.task.counterId;
              
              // Set pending serve - game loop will dispatch the actual action
              chef.pendingServe = { tableId, counterId };
              
              chef.carryingPlate = false;
              chef.task = null;
            } else {
              chef.task = null;
            }
            chef.idleTime = 0;
          } else {
            chef.idleTime += 1;
          }
          
          // Gentle idle bob
          chefRef.current.position.y = Math.sin(time * 0.003) * 0.02;
          
          // Pick new target after idling (only if no task)
          if (!chef.task && chef.idleTime > 120) { // ~2 seconds at 60fps
            chef.idleTime = 0;
            
            // Prioritize going to active stoves or ready food
            const stoves = gameStateRef.current.stoves;
            const cookingStove = stoves.find(s => s.state === 'cooking');
            const readyStove = stoves.find(s => s.state === 'ready');
            
            if (readyStove && !chef.carryingPlate) {
              // Go pick up ready food - use pathfinding
              const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
              const targetZ = stoveWorldZ + 0.5; // Stand in front
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(stoveWorldX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = stoveWorldX;
                chef.targetZ = targetZ;
              }
              chef.task = { type: 'pickup', stoveId: readyStove.id };
            } else if (cookingStove) {
              // Hang out near cooking stove - use pathfinding
              const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
              const targetX = stoveWorldX + (Math.random() - 0.5);
              const targetZ = stoveWorldZ + 0.8; // Stand in front
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = targetX;
                chef.targetZ = targetZ;
              }
            } else {
              // Stay in kitchen area when idle - use pathfinding
              const targetX = (Math.random() - 0.5) * 6; // Kitchen area x (slightly smaller range)
              const targetZ = -5 + Math.random() * 1.5; // Kitchen area z
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = targetX;
                chef.targetZ = targetZ;
              }
            }
          }
        }
        
        // Update position
        chefRef.current.position.x = chef.currentX;
        chefRef.current.position.z = chef.currentZ;
      }
      
      // Animate steam particles
      Object.values(objectsRef.current.steamParticles).forEach(steamGroup => {
        animateSteamParticles(steamGroup);
      });
      
      // Animate sparkle particles
      Object.values(objectsRef.current.sparkleParticles).forEach(sparkleGroup => {
        animateSparkleParticles(sparkleGroup, time);
      });
      
      // Animate purchase bounce-in effect
      const animatePurchase = (obj) => {
        if (obj && obj.userData && obj.userData.animateIn) {
          const { startTime, duration } = obj.userData.animateIn;
          const elapsed = time - startTime;
          const progress = Math.min(1, elapsed / duration);
          
          if (progress < 1) {
            // Elastic ease-out for bouncy effect
            const elasticOut = (t) => {
              const p = 0.4;
              return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
            };
            const scale = elasticOut(progress);
            obj.scale.setScalar(scale);
          } else {
            obj.scale.setScalar(1);
            delete obj.userData.animateIn;
          }
        }
      };
      
      Object.values(objectsRef.current.stoves).forEach(animatePurchase);
      Object.values(objectsRef.current.counters).forEach(animatePurchase);
      Object.values(objectsRef.current.tables).forEach(animatePurchase);
      Object.values(objectsRef.current.chairs || {}).forEach(animatePurchase);
      Object.values(objectsRef.current.decorations).forEach(animatePurchase);
      Object.values(objectsRef.current.dividers || {}).forEach(animatePurchase);
      Object.values(objectsRef.current.doors || {}).forEach(animatePurchase);
      
      // Animate doors opening/closing based on proximity to customers/chef
      Object.values(objectsRef.current.doors || {}).forEach(doorObj => {
        if (!doorObj || !doorObj.userData) return;
        
        const wall = doorObj.userData.wall;
        const wallPosition = doorObj.userData.wallPosition;
        if (!wall || wallPosition === undefined) return;
        
        // Get door grid position for proximity check
        let doorGridX, doorGridZ;
        if (wall === 'back') {
          doorGridX = wallPosition;
          doorGridZ = 0;
        } else if (wall === 'left') {
          doorGridX = 0;
          doorGridZ = wallPosition;
        } else if (wall === 'right') {
          doorGridX = GRID.width - 1;
          doorGridZ = wallPosition;
        }
        
        // Check if anyone is within 1.5 tiles of the door
        let someoneNear = false;
        
        // Check chef position
        const chef = chefStateRef.current;
        if (chef) {
          const chefGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
          const chefGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
          const chefDist = Math.abs(chefGridX - doorGridX) + Math.abs(chefGridZ - doorGridZ);
          if (chefDist <= 1.5) someoneNear = true;
        }
        
        // Check customer positions (customers in entering or leaving states)
        if (!someoneNear && gameStateRef.current) {
          gameStateRef.current.tables.forEach(table => {
            if (table.customer && (table.customer.state === 'entering' || table.customer.state === 'leaving')) {
              const path = table.customer.path;
              const progress = table.customer.walkProgress || 0;
              
              if (path && path.length >= 2) {
                // Calculate current position along path
                const totalSegments = path.length - 1;
                const progressPerSegment = 1 / totalSegments;
                const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
                const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
                
                const fromTile = path[currentSegmentIndex];
                const toTile = path[currentSegmentIndex + 1] || fromTile;
                
                const custGridX = fromTile.gridX + (toTile.gridX - fromTile.gridX) * segmentProgress;
                const custGridZ = fromTile.gridZ + (toTile.gridZ - fromTile.gridZ) * segmentProgress;
                
                const custDist = Math.abs(custGridX - doorGridX) + Math.abs(custGridZ - doorGridZ);
                if (custDist <= 1.5) someoneNear = true;
              }
            }
          });
        }
        
        // Animate door open/close
        const targetOpen = someoneNear ? 1 : 0;
        const currentOpen = doorObj.userData.openAmount || 0;
        const openSpeed = 0.08; // How fast the door opens/closes
        
        let newOpen = currentOpen;
        if (currentOpen < targetOpen) {
          newOpen = Math.min(targetOpen, currentOpen + openSpeed);
        } else if (currentOpen > targetOpen) {
          newOpen = Math.max(targetOpen, currentOpen - openSpeed);
        }
        doorObj.userData.openAmount = newOpen;
        
        // Apply rotation to door pivot(s)
        const maxAngle = Math.PI / 2; // 90 degrees fully open
        
        if (doorObj.userData.isDouble) {
          // Double doors - find both pivots
          const leftPivot = doorObj.getObjectByName('leftDoorPivot');
          const rightPivot = doorObj.getObjectByName('rightDoorPivot');
          if (leftPivot) leftPivot.rotation.y = newOpen * maxAngle; // Opens outward left
          if (rightPivot) rightPivot.rotation.y = -newOpen * maxAngle; // Opens outward right
        } else {
          // Single door - opens outward (away from cafe)
          const pivot = doorObj.getObjectByName('doorPivot');
          if (pivot) pivot.rotation.y = newOpen * maxAngle; // Opens outward
        }
      });
      
      // Update projected positions for UI overlays
      const newPositions = {};
      const tempVec = new THREE.Vector3();
      
      const projectWorldToScreen = (worldX, worldY, worldZ) => {
        tempVec.set(worldX, worldY, worldZ);
        tempVec.project(camera);
        return {
          x: (tempVec.x * 0.5 + 0.5) * 100,
          y: (-tempVec.y * 0.5 + 0.5) * 100
        };
      };
      
      // Project stove positions
      Object.entries(objectsRef.current.stoves).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`stove_${id}`] = pos;
        }
      });
      
      // Project counter positions
      Object.entries(objectsRef.current.counters).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`counter_${id}`] = pos;
        }
      });
      
      // Project table positions
      Object.entries(objectsRef.current.tables).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`table_${id}`] = pos;
        }
      });
      
      setProjectedPositions(newPositions);
      
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle resize
    function handleResize() {
      if (!containerRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      const newAspect = width / height;
      
      camera.left = -frustumSize * newAspect;
      camera.right = frustumSize * newAspect;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    window.addEventListener('resize', handleResize);
    
    // Mark scene as ready (triggers object creation)
    setSceneReady(true);
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
      setSceneReady(false);
    };
  }, []);
  
  // Update 3D objects when game state changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene || !sceneReady) return;
    
    // Cleanup: Remove 3D objects that no longer exist in state
    const stoveIds = new Set(gameState.stoves.map(s => s.id));
    Object.keys(objectsRef.current.stoves).forEach(id => {
      if (!stoveIds.has(id)) {
        scene.remove(objectsRef.current.stoves[id]);
        delete objectsRef.current.stoves[id];
        // Also cleanup associated particles
        if (objectsRef.current.steamParticles[id]) {
          scene.remove(objectsRef.current.steamParticles[id]);
          delete objectsRef.current.steamParticles[id];
        }
        if (objectsRef.current.sparkleParticles[id]) {
          scene.remove(objectsRef.current.sparkleParticles[id]);
          delete objectsRef.current.sparkleParticles[id];
        }
      }
    });
    
    const counterIds = new Set(gameState.counters.map(c => c.id));
    Object.keys(objectsRef.current.counters).forEach(id => {
      if (!counterIds.has(id)) {
        scene.remove(objectsRef.current.counters[id]);
        delete objectsRef.current.counters[id];
        if (objectsRef.current.counterFood[id]) {
          scene.remove(objectsRef.current.counterFood[id]);
          delete objectsRef.current.counterFood[id];
        }
      }
    });
    
    const tableIds = new Set(gameState.tables.map(t => t.id));
    Object.keys(objectsRef.current.tables).forEach(id => {
      if (!tableIds.has(id)) {
        scene.remove(objectsRef.current.tables[id]);
        delete objectsRef.current.tables[id];
        if (objectsRef.current.customers[id]) {
          scene.remove(objectsRef.current.customers[id]);
          delete objectsRef.current.customers[id];
        }
      }
    });
    
    // Update stoves
    gameState.stoves.forEach(stove => {
      let stoveObj = objectsRef.current.stoves[stove.id];
      if (!stoveObj) {
        stoveObj = createStove(stove.gridX, stove.gridZ, stove.rotation || 0);
        stoveObj.userData = { type: 'stove', id: stove.id, rotation: stove.rotation || 0 };
        scene.add(stoveObj);
        objectsRef.current.stoves[stove.id] = stoveObj;
        
        // Check if this is a new purchase (bought within last 500ms)
        const recentPurchase = newPurchases.find(p => p.type === 'stove' && Date.now() - p.time < 500);
        if (recentPurchase) {
          stoveObj.scale.setScalar(0);
          stoveObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Update burner colors based on state
      const burnerColor = stove.state === 'cooking' ? COLORS.stove.burnerOn : 
                          stove.state === 'ready' ? COLORS.readyGlow :
                          stove.state === 'spoiled' ? COLORS.dangerGlow : COLORS.stove.burnerOff;
      stoveObj.children.forEach(child => {
        if (child.name === 'burner') {
          child.material.color.setHex(burnerColor);
          child.material.emissive = new THREE.Color(stove.state === 'cooking' ? 0x441111 : 0x000000);
        }
      });
      
      // Handle steam particles
      const existingSteam = objectsRef.current.steamParticles[stove.id];
      if (stove.state === 'cooking' && !existingSteam) {
        // Add steam particles
        const steam = createSteamParticles();
        steam.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(steam);
        objectsRef.current.steamParticles[stove.id] = steam;
      } else if (stove.state !== 'cooking' && existingSteam) {
        // Remove steam particles
        scene.remove(existingSteam);
        delete objectsRef.current.steamParticles[stove.id];
      }
      
      // Handle sparkle particles for ready food
      const existingSparkle = objectsRef.current.sparkleParticles[stove.id];
      if (stove.state === 'ready' && !existingSparkle) {
        // Add sparkle particles
        const sparkle = createSparkleParticles();
        sparkle.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(sparkle);
        objectsRef.current.sparkleParticles[stove.id] = sparkle;
      } else if (stove.state !== 'ready' && existingSparkle) {
        // Remove sparkle particles
        scene.remove(existingSparkle);
        delete objectsRef.current.sparkleParticles[stove.id];
      }
    });
    
    // Update counters
    gameState.counters.forEach(counter => {
      let counterObj = objectsRef.current.counters[counter.id];
      if (!counterObj) {
        counterObj = createCounter(counter.gridX, counter.gridZ, counter.rotation || 0);
        counterObj.userData = { type: 'counter', id: counter.id, rotation: counter.rotation || 0 };
        scene.add(counterObj);
        objectsRef.current.counters[counter.id] = counterObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'counter' && Date.now() - p.time < 500);
        if (recentPurchase) {
          counterObj.scale.setScalar(0);
          counterObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle food on counter
      const existingFood = objectsRef.current.counterFood[counter.id];
      const hasFood = counter.dishes.length > 0;
      
      // Create a unique key from dish to detect changes (include mastery level for plate color)
      const dish = hasFood ? counter.dishes[0] : null;
      const masteryLevel = dish ? getMasteryLevel(gameState.dishMastery, dish.recipe) : 0;
      const dishesKey = hasFood ? `${dish.recipe}:${dish.servings}:m${masteryLevel}` : '';
      
      if (hasFood && (!existingFood || existingFood.userData?.dishesKey !== dishesKey)) {
        // Remove old food visual if exists
        if (existingFood) {
          scene.remove(existingFood);
          delete objectsRef.current.counterFood[counter.id];
        }
        
        // Add food visual with mastery-colored plate
        const foodGroup = new THREE.Group();
        const plateColor = getMasteryPlateColor(gameState.dishMastery, dish.recipe);
        
        // Create main food plate with mastery color
        const food = createFoodPlate(dish.recipe, plateColor);
        food.position.y = 0.85;
        foodGroup.add(food);
        
        // Add stacked plates underneath for large servings
        if (dish.servings > 20) {
          const plate2 = createFoodPlate(dish.recipe, plateColor);
          plate2.position.set(0.08, 0.8, 0.08);
          plate2.scale.setScalar(0.9);
          foodGroup.add(plate2);
        }
        if (dish.servings > 50) {
          const plate3 = createFoodPlate(dish.recipe, plateColor);
          plate3.position.set(-0.08, 0.75, -0.08);
          plate3.scale.setScalar(0.8);
          foodGroup.add(plate3);
        }
        if (dish.servings > 100) {
          const plate4 = createFoodPlate(dish.recipe, plateColor);
          plate4.position.set(0.15, 0.7, 0);
          plate4.scale.setScalar(0.7);
          foodGroup.add(plate4);
        }
        
        foodGroup.position.set(
          counter.gridX - GRID.width / 2 + 0.5,
          0,
          counter.gridZ - GRID.height / 2 + 0.5
        );
        foodGroup.userData = { dishesKey };
        scene.add(foodGroup);
        objectsRef.current.counterFood[counter.id] = foodGroup;
      } else if (!hasFood && existingFood) {
        // Remove food visual
        scene.remove(existingFood);
        delete objectsRef.current.counterFood[counter.id];
      }
    });
    
    // Update tables
    gameState.tables.forEach(table => {
      let tableObj = objectsRef.current.tables[table.id];
      const style = table.style || 'round';
      const rotation = table.rotation || 0;
      
      // Check if table needs recreation (style or rotation changed)
      if (tableObj && (tableObj.userData.style !== style || tableObj.userData.rotation !== rotation)) {
        scene.remove(tableObj);
        delete objectsRef.current.tables[table.id];
        tableObj = null;
      }
      
      if (!tableObj) {
        tableObj = createTable(table.gridX, table.gridZ, style, rotation);
        tableObj.userData = { type: 'table', id: table.id, style, rotation };
        scene.add(tableObj);
        objectsRef.current.tables[table.id] = tableObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'table' && Date.now() - p.time < 500);
        if (recentPurchase) {
          tableObj.scale.setScalar(0);
          tableObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle customer at table
      const existingCustomer = objectsRef.current.customers[table.id];
      const isWalking = table.customer && (
        table.customer.state === 'walking_to_counter' || 
        table.customer.state === 'walking_to_table' ||
        table.customer.state === 'entering' ||
        table.customer.state === 'leaving'
      );
      const hasPlate = table.customer && (table.customer.state === 'walking_to_table' || table.customer.state === 'eating');
      const needsSeated = table.customer && !isWalking;
      const needsStanding = table.customer && isWalking;
      
      // Track current model type and plate state
      const currentPose = existingCustomer?.userData?.pose || 'seated'; // Default to seated if not set
      const currentHasPlate = existingCustomer?.userData?.hasPlate || false;
      
      // Need to swap model if pose changes OR if plate status changes while standing
      const needsModelSwap = table.customer && (
        !existingCustomer || 
        (needsStanding && currentPose === 'seated') || 
        (needsSeated && currentPose === 'standing') ||
        (needsStanding && hasPlate !== currentHasPlate)
      );
      
      if (needsModelSwap) {
        // Need to create new customer or swap model
        if (existingCustomer) {
          scene.remove(existingCustomer);
        }
        
        const pose = isWalking ? 'standing' : 'seated';
        const customer = createCustomer(table.customer.appearance || {}, pose, hasPlate);
        
        const tableStyle = table.style || 'round';
        const tableRotation = (table.rotation || 0) * (Math.PI / 2);
        
        // Calculate seat position - use stored chair position from customer data
        // New system: chairs are separate objects, customer walks to the chair tile
        const tableWorldX = table.gridX - GRID.width / 2 + 0.5;
        const tableWorldZ = table.gridZ - GRID.height / 2 + 0.5;
        
        // Use the stored chair position if available (new system)
        // Fall back to old calculation for legacy saves
        let seatX, seatZ;
        if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
          // New system: use actual chair tile position
          seatX = table.customer.chairX - GRID.width / 2 + 0.5;
          seatZ = table.customer.chairZ - GRID.height / 2 + 0.5;
        } else {
          // Legacy fallback: calculate from table rotation (for old saves)
          const seatOffset = 0.55;
          seatX = tableWorldX - seatOffset * Math.cos(tableRotation);
          seatZ = tableWorldZ + seatOffset * Math.sin(tableRotation);
        }
        
        customer.position.set(seatX, 0, seatZ);
        // Face toward table center
        const facingAngle = Math.atan2(tableWorldX - seatX, tableWorldZ - seatZ);
        customer.rotation.y = facingAngle;
        
        customer.userData = { 
          type: 'customer', 
          tableId: table.id,
          seatX: seatX,
          seatZ: seatZ,
          tableRotation: tableRotation,
          tableStyle: tableStyle,
          pose: pose,
          hasPlate: hasPlate,
          appearance: table.customer.appearance || {},
        };
        scene.add(customer);
        objectsRef.current.customers[table.id] = customer;
      }
      
      // Re-fetch customer reference after potential swap
      const currentCustomer = objectsRef.current.customers[table.id];
      
      // Update walking customer position with pathfinding through the gap
      if (currentCustomer && table.customer && isWalking) {
        const path = table.customer.path;
        const progress = table.customer.walkProgress || 0;
        
        // Path-based walking: progress 0-1 maps to walking through all path tiles
        if (path && path.length >= 2) {
          // Calculate which segment of the path we're on
          const totalSegments = path.length - 1;
          const progressPerSegment = 1 / totalSegments;
          const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
          const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
          
          // Get current and next tile
          const fromTile = path[currentSegmentIndex];
          const toTile = path[currentSegmentIndex + 1];
          
          // Convert grid to world coordinates
          const fromX = fromTile.gridX - GRID.width / 2 + 0.5;
          const fromZ = fromTile.gridZ - GRID.height / 2 + 0.5;
          const toX = toTile.gridX - GRID.width / 2 + 0.5;
          const toZ = toTile.gridZ - GRID.height / 2 + 0.5;
          
          // Interpolate position
          const currentX = fromX + (toX - fromX) * segmentProgress;
          const currentZ = fromZ + (toZ - fromZ) * segmentProgress;
          
          currentCustomer.position.set(currentX, 0, currentZ);
          
          // Face movement direction
          const dx = toX - fromX;
          const dz = toZ - fromZ;
          if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
            currentCustomer.rotation.y = Math.atan2(dx, dz);
          }
          
          // Walking bob animation
          currentCustomer.position.y = Math.abs(Math.sin(Date.now() * 0.012)) * 0.06;
        } else {
          // Fallback: no path, go directly (shouldn't happen but safety)
          const seatX = currentCustomer.userData.seatX;
          const seatZ = currentCustomer.userData.seatZ;
          const counter = gameState.counters.find(c => c.id === table.customer.targetCounterId);
          
          if (counter) {
            const counterX = counter.gridX - GRID.width / 2 + 0.5;
            const counterZ = counter.gridZ - GRID.height / 2 + 0.5 + 0.6;
            
            if (table.customer.state === 'walking_to_counter') {
              currentCustomer.position.set(
                seatX + (counterX - seatX) * progress,
                0,
                seatZ + (counterZ - seatZ) * progress
              );
            } else {
              currentCustomer.position.set(
                counterX + (seatX - counterX) * progress,
                0,
                counterZ + (seatZ - counterZ) * progress
              );
            }
          }
        }
      } else if (currentCustomer && table.customer && !isWalking) {
        // Sitting at table - ensure proper position and rotation
        const seatX = currentCustomer.userData.seatX;
        const seatZ = currentCustomer.userData.seatZ;
        currentCustomer.position.set(seatX, 0, seatZ);
        // Face toward table center
        const tableWorldX = table.gridX - GRID.width / 2 + 0.5;
        const tableWorldZ = table.gridZ - GRID.height / 2 + 0.5;
        currentCustomer.rotation.y = Math.atan2(tableWorldX - seatX, tableWorldZ - seatZ);
      }
      
      // Remove customer when they leave
      if (!table.customer && currentCustomer) {
        scene.remove(currentCustomer);
        delete objectsRef.current.customers[table.id];
      }
      
      // Handle food plate on table when customer is eating
      const existingTableFood = objectsRef.current.tableFood[table.id];
      const shouldHaveFood = table.customer && table.customer.state === 'eating';
      
      if (shouldHaveFood && !existingTableFood) {
        // Add food plate to table
        const foodPlate = new THREE.Group();
        
        const plate = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.2, 0.03, 12),
          new THREE.MeshLambertMaterial({ color: 0xffffff })
        );
        plate.castShadow = true;
        foodPlate.add(plate);
        
        // Food on plate
        const food = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 6),
          new THREE.MeshLambertMaterial({ color: 0xCD853F })
        );
        food.position.y = 0.07;
        food.scale.y = 0.6;
        foodPlate.add(food);
        
        const worldX = table.gridX - GRID.width / 2 + 0.5;
        const worldZ = table.gridZ - GRID.height / 2 + 0.5;
        foodPlate.position.set(worldX, 0.68, worldZ); // On top of table
        
        scene.add(foodPlate);
        objectsRef.current.tableFood[table.id] = foodPlate;
      } else if (!shouldHaveFood && existingTableFood) {
        // Remove food plate from table
        scene.remove(existingTableFood);
        delete objectsRef.current.tableFood[table.id];
      }
    });
    
    // Update standalone chairs (new mix-and-match system)
    const currentChairIds = new Set((gameState.chairs || []).map(c => c.id));
    
    // Remove chairs that no longer exist
    Object.entries(objectsRef.current.chairs || {}).forEach(([id, obj]) => {
      if (!currentChairIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.chairs[id];
      }
    });
    
    // Add/update chairs
    (gameState.chairs || []).forEach(chair => {
      let chairObj = objectsRef.current.chairs[chair.id];
      const style = chair.style || 'basicWood';
      const rotation = chair.rotation || 0;
      
      // Check if chair needs recreation (style or rotation changed)
      if (chairObj && (chairObj.userData.style !== style || chairObj.userData.rotation !== rotation)) {
        scene.remove(chairObj);
        delete objectsRef.current.chairs[chair.id];
        chairObj = null;
      }
      
      if (!chairObj) {
        chairObj = createStandaloneChair(chair.gridX, chair.gridZ, style, rotation);
        chairObj.userData = { type: 'chair', id: chair.id, style, rotation, gridX: chair.gridX, gridZ: chair.gridZ };
        scene.add(chairObj);
        objectsRef.current.chairs[chair.id] = chairObj;
        
        // Check if this is a new purchase (animate pop-in)
        const recentPurchase = newPurchases.find(p => p.type === 'chair' && Date.now() - p.time < 500);
        if (recentPurchase) {
          chairObj.scale.setScalar(0);
          chairObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
    });
    
    // Update waiter position and appearance
    const waiterObj = objectsRef.current.waiter;
    const waiter = gameState.waiter;
    if (waiterObj && waiter) {
      const isCarrying = waiter.carryingFood !== null;
      
      // Show/hide carrying plate
      const plateGroup = waiterObj.getObjectByName('carryPlate');
      if (plateGroup) {
        plateGroup.visible = isCarrying;
      }
      
      // Update position based on path if walking
      const isWalking = waiter.state === 'walking_to_counter' || waiter.state === 'walking_to_table' || 
                        waiter.state === 'pacing' || waiter.state === 'returning';
      
      if (isWalking && waiter.path && waiter.path.length >= 2) {
        const path = waiter.path;
        const progress = waiter.walkProgress || 0;
        
        // Calculate which segment of the path we're on
        const totalSegments = path.length - 1;
        const progressPerSegment = 1 / totalSegments;
        const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
        const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
        
        // Get current and next tile
        const fromTile = path[currentSegmentIndex];
        const toTile = path[currentSegmentIndex + 1];
        
        if (fromTile && toTile) {
          // Convert grid to world coordinates
          const fromX = (fromTile.gridX ?? fromTile.x) - GRID.width / 2 + 0.5;
          const fromZ = (fromTile.gridZ ?? fromTile.z) - GRID.height / 2 + 0.5;
          const toX = (toTile.gridX ?? toTile.x) - GRID.width / 2 + 0.5;
          const toZ = (toTile.gridZ ?? toTile.z) - GRID.height / 2 + 0.5;
          
          // Interpolate position
          const currentX = fromX + (toX - fromX) * segmentProgress;
          const currentZ = fromZ + (toZ - fromZ) * segmentProgress;
          
          waiterObj.position.set(currentX, 0, currentZ);
          
          // Face movement direction
          const dx = toX - fromX;
          const dz = toZ - fromZ;
          if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
            waiterObj.rotation.y = Math.atan2(dx, dz);
          }
          
          // Walking bob animation
          waiterObj.position.y = Math.abs(Math.sin(Date.now() * 0.012)) * 0.06;
        }
      } else if (isWalking && waiter.path && waiter.path.length === 1) {
        // Single tile path - just go there
        const tile = waiter.path[0];
        const worldX = (tile.gridX ?? tile.x) - GRID.width / 2 + 0.5;
        const worldZ = (tile.gridZ ?? tile.z) - GRID.height / 2 + 0.5;
        waiterObj.position.set(worldX, 0, worldZ);
      } else {
        // Idle at current grid position
        const worldX = waiter.gridX - GRID.width / 2 + 0.5;
        const worldZ = waiter.gridZ - GRID.height / 2 + 0.5;
        waiterObj.position.set(worldX, 0, worldZ);
        waiterObj.position.y = 0; // No bob when idle
      }
    }
    
    // Update decorations
    const currentDecorIds = new Set(gameState.decorations.map(d => d.id));
    
    // Remove decorations that no longer exist
    Object.entries(objectsRef.current.decorations).forEach(([id, obj]) => {
      if (!currentDecorIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.decorations[id];
      }
    });
    
    // Add new decorations
    gameState.decorations.forEach(decor => {
      if (!objectsRef.current.decorations[decor.id]) {
        const decorType = DECORATIONS[decor.type];
        const worldX = decor.gridX - GRID.width / 2 + 0.5;
        const worldZ = decor.gridZ - GRID.height / 2 + 0.5;
        
        const decorObj = createDecoration(decor.type, worldX, worldZ, decor.rotation || 0);
        decorObj.userData = { type: 'decoration', id: decor.id, decorType: decor.type, rotation: decor.rotation || 0 };
        
        // Wall decorations go on the nearest wall (walls are at grid boundary)
        if (decorType.category === 'wall') {
          // Determine which wall is closest based on grid position
          const distToBack = decor.gridZ; // Distance to back wall (z=0)
          const distToLeft = decor.gridX; // Distance to left wall (x=0)
          const distToRight = GRID.width - 1 - decor.gridX; // Distance to right wall
          
          const minDist = Math.min(distToBack, distToLeft, distToRight);
          
          if (minDist === distToBack) {
            // Back wall
            decorObj.position.set(decor.gridX - GRID.width / 2 + 0.5, 0, -GRID.height / 2 + 0.02);
            decorObj.rotation.y = 0;
          } else if (minDist === distToLeft) {
            // Left wall
            decorObj.position.set(-GRID.width / 2 + 0.02, 0, decor.gridZ - GRID.height / 2 + 0.5);
            decorObj.rotation.y = Math.PI / 2;
          } else {
            // Right wall
            decorObj.position.set(GRID.width / 2 - 0.02, 0, decor.gridZ - GRID.height / 2 + 0.5);
            decorObj.rotation.y = -Math.PI / 2;
          }
        }
        
        scene.add(decorObj);
        objectsRef.current.decorations[decor.id] = decorObj;
        
        // If it's a floor lamp, hook up its material and light for night glow
        if (decor.type === 'floorLamp') {
          if (decorObj.userData.lampMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.lampMaterial);
          }
          if (decorObj.userData.bulbMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.bulbMaterial);
          }
          if (decorObj.userData.lampLight) {
            interiorLightsRef.current.push(decorObj.userData.lampLight);
          }
        }
        
        // Bounce-in animation
        decorObj.scale.setScalar(0);
        decorObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
      }
    });
    
    // Update dividers
    const currentDividerIds = new Set((gameState.dividers || []).map(d => d.id));
    
    // Remove dividers that no longer exist
    Object.entries(objectsRef.current.dividers || {}).forEach(([id, obj]) => {
      if (!currentDividerIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.dividers[id];
      }
    });
    
    // Add new dividers
    (gameState.dividers || []).forEach(divider => {
      if (!objectsRef.current.dividers[divider.id]) {
        const worldX = divider.gridX - GRID.width / 2 + 0.5;
        const worldZ = divider.gridZ - GRID.height / 2 + 0.5;
        
        const dividerObj = createDivider(divider.type, worldX, worldZ, divider.rotation || 0);
        dividerObj.userData = { type: 'divider', id: divider.id, dividerType: divider.type };
        
        scene.add(dividerObj);
        objectsRef.current.dividers[divider.id] = dividerObj;
        
        // Bounce-in animation
        dividerObj.scale.setScalar(0);
        dividerObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
      }
    });
    
    // Handle doors
    if (!objectsRef.current.doors) objectsRef.current.doors = {};
    const currentDoorIds = new Set((gameState.doors || []).map(d => d.id));
    const previousDoorIds = new Set(Object.keys(objectsRef.current.doors || {}));
    
    // Check if doors have changed
    const doorsChanged = currentDoorIds.size !== previousDoorIds.size ||
      [...currentDoorIds].some(id => !previousDoorIds.has(id));
    
    // Check if wallpaper has changed
    const currentWallpaper = gameState.wallpaper || 'cream';
    const previousWallpaper = wallSegmentsRef.current?.wallpaper || 'cream';
    const wallpaperChanged = currentWallpaper !== previousWallpaper;
    
    // Check if painted segments have changed (use version counter for reliable detection)
    const currentPaintedSegments = gameState.paintedSegments || [];
    const currentPaintedVersion = gameState.paintedVersion || 0;
    const previousPaintedVersion = wallSegmentsRef.current?.paintedVersion || 0;
    const paintedSegmentsChanged = currentPaintedVersion !== previousPaintedVersion;
    
    // Initialize door header patterns storage if needed
    if (!objectsRef.current.doorHeaderPatterns) objectsRef.current.doorHeaderPatterns = {};
    
    // Remove doors that no longer exist (and their header patterns)
    Object.entries(objectsRef.current.doors || {}).forEach(([id, obj]) => {
      if (!currentDoorIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.doors[id];
        // Also remove header patterns for this door
        const headerPatterns = objectsRef.current.doorHeaderPatterns[id] || [];
        headerPatterns.forEach(p => scene.remove(p));
        delete objectsRef.current.doorHeaderPatterns[id];
      }
    });
    
    // Add new doors (or recreate if wallpaper changed)
    (gameState.doors || []).forEach(door => {
      const needsCreate = !objectsRef.current.doors[door.id];
      const needsRecreate = (wallpaperChanged || paintedSegmentsChanged) && objectsRef.current.doors[door.id];
      
      if (needsRecreate) {
        // Remove old door to recreate with new wallpaper color
        scene.remove(objectsRef.current.doors[door.id]);
        delete objectsRef.current.doors[door.id];
        // Also remove old header patterns
        const oldPatterns = objectsRef.current.doorHeaderPatterns[door.id] || [];
        oldPatterns.forEach(p => scene.remove(p));
        delete objectsRef.current.doorHeaderPatterns[door.id];
      }
      
      if (needsCreate || needsRecreate) {
        // Get wallpaper for this specific segment (check painted segments first, then default)
        const segmentPaint = currentPaintedSegments.find(
          p => p.wall === door.wall && p.position === door.wallPosition
        );
        const segmentWallpaper = segmentPaint ? segmentPaint.wallpaper : currentWallpaper;
        
        const doorObj = createDoor(door.type, door.wall, door.wallPosition, segmentWallpaper);
        doorObj.userData = { type: 'door', id: door.id, doorType: door.type, wall: door.wall, wallPosition: door.wallPosition };
        
        scene.add(doorObj);
        objectsRef.current.doors[door.id] = doorObj;
        
        // Create header patterns for this door (brick mortar, stripes, etc.)
        const headerPatterns = createDoorHeaderPatterns(scene, segmentWallpaper, door.wall, door.wallPosition);
        objectsRef.current.doorHeaderPatterns[door.id] = headerPatterns;
        
        // Bounce-in animation only for new doors, not recreated ones
        if (needsCreate && !needsRecreate) {
          doorObj.scale.setScalar(0);
          doorObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
        }
      }
    });
    
    // Rebuild walls if doors, wallpaper, or painted segments have changed
    if ((doorsChanged || wallpaperChanged || paintedSegmentsChanged) && sceneRef.current && wallSegmentsRef.current) {
      rebuildWalls(sceneRef.current, wallSegmentsRef, gameState.doors || [], currentWallpaper, currentPaintedSegments);
      // Store current state to detect future changes
      if (wallSegmentsRef.current) {
        wallSegmentsRef.current.wallpaper = currentWallpaper;
        wallSegmentsRef.current.paintedVersion = currentPaintedVersion;
      }
    }
  }, [gameState, newPurchases, sceneReady]);
  
  // Clear stuck coins when tab becomes visible again (fixes AFK coin buildup)
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Tab is now visible - clear any stuck coins
        setFlyingCoins(prev => {
          // Only keep coins created in the last 2 seconds
          const now = Date.now();
          const recentCoins = prev.filter(coin => (now - coin.startTime) < 2000);
          // If we cleared some, log it
          if (recentCoins.length < prev.length) {
            console.log(`Cleared ${prev.length - recentCoins.length} stuck coins on tab focus`);
          }
          return recentCoins;
        });
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, []);
  
  // Create/destroy preview decoration when placement mode changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene) return;
    
    // Remove existing preview
    if (previewDecorationRef.current) {
      scene.remove(previewDecorationRef.current);
      previewDecorationRef.current = null;
    }
    
    // Create new preview if placing decoration
    if (placingDecoration) {
      const preview = createDecoration(placingDecoration, 0, 0);
      // Make it semi-transparent and store original colors
      preview.traverse(child => {
        if (child.isMesh && child.material) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
          // Store original color for later restoration
          child.userData.originalColor = child.material.color.getHex();
        }
      });
      preview.visible = false; // Hidden until mouse moves over valid area
      scene.add(preview);
      previewDecorationRef.current = preview;
    }
    
    // Create new preview if placing divider
    if (placingDivider) {
      const preview = createDivider(placingDivider, 0, 0, placementRotation);
      preview.traverse(child => {
        if (child.isMesh && child.material) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
          child.userData.originalColor = child.material.color.getHex();
        }
      });
      preview.visible = false;
      scene.add(preview);
      previewDecorationRef.current = preview;
    }
    
    // Create new preview if placing equipment
    if (placingEquipment) {
      let preview;
      if (placingEquipment === 'stove') {
        preview = createStove(0, 0, placementRotation);
      } else if (placingEquipment === 'counter') {
        preview = createCounter(0, 0, placementRotation);
      } else if (placingEquipment === 'table') {
        preview = createTable(0, 0, placingTableStyle, placementRotation);
      } else if (placingEquipment === 'chair') {
        preview = createStandaloneChair(0, 0, placingChairStyle, placementRotation);
      }
      
      if (preview) {
        // Make it semi-transparent and store original colors
        preview.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.5;
            // Store original color for later restoration
            child.userData.originalColor = child.material.color.getHex();
          }
        });
        preview.visible = false;
        scene.add(preview);
        previewDecorationRef.current = preview;
      }
    }
    
    // Create preview for moving objects (edit mode)
    if (movingObject) {
      let preview;
      if (movingObject.type === 'stove') {
        preview = createStove(0, 0, placementRotation);
      } else if (movingObject.type === 'counter') {
        preview = createCounter(0, 0, placementRotation);
      } else if (movingObject.type === 'table') {
        preview = createTable(0, 0, movingObject.data.style, placementRotation);
      } else if (movingObject.type === 'chair') {
        preview = createStandaloneChair(0, 0, movingObject.data.style, placementRotation);
      } else if (movingObject.type === 'decoration') {
        preview = createDecoration(movingObject.data.decorationType);
      } else if (movingObject.type === 'divider') {
        preview = createDivider(movingObject.data.dividerType, 0, 0, placementRotation);
      }
      
      if (preview) {
        // Make it semi-transparent
        preview.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.6;
            child.userData.originalColor = child.material.color.getHex();
          }
        });
        preview.visible = false;
        scene.add(preview);
        previewDecorationRef.current = preview;
      }
    }
    
    return () => {
      if (previewDecorationRef.current && scene) {
        scene.remove(previewDecorationRef.current);
        previewDecorationRef.current = null;
      }
    };
  }, [placingDecoration, placingDivider, placingEquipment, placingTableStyle, placingChairStyle, movingObject]); // Note: placementRotation removed - handled by separate effect
  
  // Keyboard handler for rotation while placing
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Shift+C = Clear stuck coins (debug helper)
      if (e.shiftKey && (e.key === 'c' || e.key === 'C')) {
        setFlyingCoins([]);
        console.log('Cleared flying coins');
        return;
      }
      
      // Allow rotation for ALL placement modes (equipment, decoration, divider) and moving
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        if (e.key === 'r' || e.key === 'R') {
          setPlacementRotation((prev) => (prev + 1) % 4);
        } else if (e.key === 'Escape') {
          // Cancel placement/move entirely
          setPlacingEquipment(null);
          setPlacingDecoration(null);
          setPlacingDivider(null);
          setMovingObject(null);
          setPlacementLocked(false);
          setLockedPosition(null);
          setPlacementRotation(0);
        }
      }
    };
    
    // Scroll wheel for rotation in placement modes
    const handleWheel = (e) => {
      // Allow rotation for ALL placement modes and moving objects
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        e.preventDefault();
        if (e.deltaY > 0) {
          setPlacementRotation((prev) => (prev + 1) % 4);
        } else {
          setPlacementRotation((prev) => (prev + 3) % 4); // +3 is same as -1 mod 4
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('wheel', handleWheel, { passive: false });
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('wheel', handleWheel);
    };
  }, [placingEquipment, placingDecoration, placingDivider, placementLocked, movingObject]);
  
  // Update preview rotation and re-validate placement when placementRotation changes
  useEffect(() => {
    if (previewDecorationRef.current) {
      // Update rotation
      if (placingDivider) {
        previewDecorationRef.current.rotation.y = (placementRotation % 2) * (Math.PI / 2);
      } else if (placingEquipment || placingDecoration || movingObject) {
        previewDecorationRef.current.rotation.y = placementRotation * (Math.PI / 2);
      }
      
      // Re-validate placement at current position and update colors
      const { gridX, gridZ } = lastPlacementGrid.current;
      let validPlacement = false;
      
      if (placingEquipment === 'table') {
        // New system: tables occupy 1 tile only
        const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
        const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider;
      } else if (placingEquipment === 'chair') {
        // Chairs must be placed facing a table that doesn't already have a chair
        const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        
        // Check if chair would face a table
        const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
        const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
        const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
        
        validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider && tableAvailable;
      } else if (placingEquipment === 'stove') {
        const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        validPlacement = inKitchen && notOnCounter && notOnStove;
      } else if (placingEquipment === 'counter') {
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        validPlacement = inCafe && notOnStove && notOnCounter;
      } else if (placingDecoration || placingDivider || movingObject) {
        // For now, keep it valid - mouse move will handle detailed checks
        validPlacement = true;
      }
      
      // Update preview colors based on validity
      if (placingEquipment) {
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            if (validPlacement) {
              if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              child.material.color.setHex(0xFF0000);
            }
          }
        });
      }
    }
  }, [placementRotation, placingEquipment, placingDecoration, placingDivider, movingObject, gameState.tables, gameState.chairs, gameState.stoves, gameState.counters, gameState.decorations, gameState.dividers]);
  
  // Game tick - update timers, spawn customers, etc.
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
      
      // Progress time of day (1 real second = 2 game minutes, full day = 12 real minutes)
      setTimeOfDay(prev => {
        const newTime = prev + (2 / 60); // Add 2 minutes per second
        return newTime >= 24 ? newTime - 24 : newTime;
      });
      
      // Check cooking timers
      gameState.stoves.forEach(stove => {
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          // Use mastery-adjusted cook time (Level 3 mastery = 5% faster)
          const masteryCookTime = getCookTimeWithMastery(gameState.dishMastery, stove.recipe);
          
          if (elapsed >= masteryCookTime) {
            dispatch({ type: 'FINISH_COOKING', payload: { stoveId: stove.id } });
            SFX.foodReady();
          }
        } else if (stove.state === 'ready' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          // Spoil time is still based on original cook time (no bonus)
          if (elapsed >= recipe.cookTime * 2.2) {
            dispatch({ type: 'SPOIL_FOOD', payload: { stoveId: stove.id } });
            SFX.foodSpoiled();
          }
        }
      });
      
      // Update customer patience & movement
      gameState.tables.forEach(table => {
        if (table.customer) {
          // Customer entering - walking from door to table
          if (table.customer.state === 'entering') {
            const pathLength = table.customer.path?.length || 10;
            const speedPerTile = 0.12; // Slightly faster entry walk
            const progressIncrement = 1 / (pathLength * speedPerTile / 0.02);
            const newProgress = (table.customer.walkProgress || 0) + Math.min(progressIncrement, 0.05);
            if (newProgress >= 1) {
              dispatch({ type: 'CUSTOMER_REACHED_SEAT', payload: { tableId: table.id } });
            } else {
              dispatch({ type: 'UPDATE_WALK_PROGRESS', payload: { tableId: table.id, progress: newProgress } });
            }
          } else if (table.customer.state === 'waiting') {
            const elapsed = (Date.now() - table.customer.spawnTime) / 1000;
            const newPatience = Math.max(0, 100 - elapsed * 2);
            
            if (newPatience <= 0) {
              // Use new START_LEAVING action with happy=false
              dispatch({ type: 'START_LEAVING', payload: { tableId: table.id, happy: false } });
            } else if (Math.abs(newPatience - table.customer.patience) > 1) {
              dispatch({ type: 'UPDATE_CUSTOMER_PATIENCE', payload: { tableId: table.id, patience: newPatience } });
            }
            
            // Customers no longer walk to counter - waiter handles that now
            // (Waiter logic is below in the waiter tick section)
          } else if (table.customer.state === 'eating') {
            const elapsed = (Date.now() - table.customer.eatStartTime) / 1000;
            if (elapsed >= 4) {
              // Use new START_LEAVING action with happy=true
              dispatch({ type: 'START_LEAVING', payload: { tableId: table.id, happy: true } });
              
              // Spawn flying coin from table position (max 5 coins at once to prevent buildup)
              const screenPos = projectedPositions[`table_${table.id}`] || { x: 50, y: 50 };
              setFlyingCoins(prev => {
                const newCoin = {
                  id: Date.now(),
                  startX: screenPos.x,
                  startY: screenPos.y,
                  startTime: Date.now(),
                };
                // Keep only the 4 most recent coins + new one = max 5
                const recentCoins = prev.slice(-4);
                return [...recentCoins, newCoin];
              });
              
              SFX.customerHappy();
              SFX.coinEarn();
              setCoinPop(true);
              setTimeout(() => setCoinPop(false), 300);
            }
          } else if (table.customer.state === 'leaving') {
            // Customer walking from table back to door
            const pathLength = table.customer.path?.length || 10;
            const speedPerTile = 0.12;
            const progressIncrement = 1 / (pathLength * speedPerTile / 0.02);
            const newProgress = (table.customer.walkProgress || 0) + Math.min(progressIncrement, 0.05);
            if (newProgress >= 1) {
              // Customer reached door - remove them
              if (!table.customer.leavingHappy) {
                SFX.customerAngry();
              }
              dispatch({ type: 'CUSTOMER_LEFT', payload: { tableId: table.id } });
            } else {
              dispatch({ type: 'UPDATE_WALK_PROGRESS', payload: { tableId: table.id, progress: newProgress } });
            }
          } else if (table.customer.state === 'leavingHappy') {
            // Legacy state - keep for backwards compatibility
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_HAPPY', payload: { tableId: table.id } });
              SFX.customerHappy();
              SFX.coinEarn();
              // Trigger coin pop effect
              setCoinPop(true);
              setTimeout(() => setCoinPop(false), 300);
            }
          } else if (table.customer.state === 'leavingAngry') {
            // Legacy state - keep for backwards compatibility
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_ANGRY', payload: { tableId: table.id } });
              SFX.customerAngry();
            }
          }
        }
      });
      
      // Spawn customers at empty tables that have adjacent chairs
      // Tables without chairs won't receive customers (must buy a chair for the table!)
      const tablesWithChairs = gameState.tables.filter(t => {
        if (t.customer) return false; // Already has customer
        // Check if this table has an adjacent chair
        const chair = findChairForTable(t, gameState.chairs || []);
        return chair !== null;
      });
      const spawnChance = Math.max(0.01, 0.02 * (gameState.buzz / 50)); // Minimum 1% spawn rate
      if (tablesWithChairs.length > 0 && Math.random() < spawnChance) {
        const randomTable = tablesWithChairs[Math.floor(Math.random() * tablesWithChairs.length)];
        dispatch({ type: 'SPAWN_CUSTOMER', payload: { tableId: randomTable.id } });
        SFX.customerArrive();
      }
      
      // ============ WAITER LOGIC ============
      // Loop: idle ‚Üí walking_to_counter ‚Üí walking_to_table ‚Üí returning ‚Üí idle (pacing)
      const waiter = gameState.waiter;
      
      if (waiter.state === 'idle') {
        // Look for work: food on counter AND waiting customer
        const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
        const targetTable = getMostUrgentCustomer(gameState.tables); // Prioritize by patience!
        
        if (countersWithFood.length > 0 && targetTable) {
          // Work to do! Go get food for the most urgent customer
          const counter = countersWithFood[0];
          
          const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
          const occupancyMap = buildOccupancyMap(gameState);
          occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
          
          const pathToCounter = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
            counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
          
          if (pathToCounter && pathToCounter.length > 0) {
            dispatch({ type: 'WAITER_GO_TO_COUNTER', payload: { 
              counterId: counter.id, 
              tableId: targetTable.id,
              path: pathToCounter 
            }});
          }
        } else {
          // No work - pace near counters if not already there
          // Counters are at gridZ 0, so waiter should be at gridZ 1 (right in front)
          const isNearCounters = waiter.gridZ <= 2;
          
          if (!isNearCounters) {
            // Walk back to counter area (counters are at gridX 9, 11, 13)
            const targetX = 9 + Math.floor(Math.random() * 5); // Random x 9-13 (near counters)
            const targetZ = 1; // Right in front of counters
            
            const occupancyMap = buildOccupancyMap(gameState);
            occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
            
            const path = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
              targetX, targetZ, GRID.width, GRID.height);
            
            if (path && path.length > 1) {
              dispatch({ type: 'WAITER_START_PACING', payload: { path }});
            }
          } else if (Math.random() < 0.01) {
            // Occasionally pace to a nearby spot (1% chance per tick)
            const targetX = waiter.gridX + Math.floor(Math.random() * 5) - 2;
            const clampedX = Math.max(8, Math.min(14, targetX)); // Stay in counter area (8-14)
            
            const occupancyMap = buildOccupancyMap(gameState);
            occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
            
            const path = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
              clampedX, waiter.gridZ, GRID.width, GRID.height);
            
            if (path && path.length > 1) {
              dispatch({ type: 'WAITER_START_PACING', payload: { path }});
            }
          }
        }
      } else if (waiter.state === 'pacing' || waiter.state === 'returning') {
        // Walking (pacing or returning to counter area)
        const pathLength = waiter.path?.length || 1;
        const newProgress = (waiter.walkProgress || 0) + 0.02; // Slower pace
        
        if (newProgress >= 1) {
          // Reached destination
          const finalTile = waiter.path[waiter.path.length - 1];
          const newGridX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
          const newGridZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
          
          // If returning from delivery, immediately check for more work (no hesitation!)
          if (waiter.state === 'returning') {
            const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
            const targetTable = getMostUrgentCustomer(gameState.tables); // Prioritize by patience!
            
            if (countersWithFood.length > 0 && targetTable) {
              // Work to do! Go directly to counter without idle delay
              const counter = countersWithFood[0];
              const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
              
              const occupancyMap = buildOccupancyMap(gameState);
              occupancyMap.delete(getTileKey(newGridX, newGridZ));
              
              const pathToCounter = findPath(occupancyMap, newGridX, newGridZ,
                counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
              
              if (pathToCounter && pathToCounter.length > 0) {
                // Update position and immediately start next job
                dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
                dispatch({ type: 'WAITER_GO_TO_COUNTER', payload: { 
                  counterId: counter.id, 
                  tableId: targetTable.id,
                  path: pathToCounter 
                }});
              } else {
                // No valid path, just go idle
                dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
                dispatch({ type: 'WAITER_GO_IDLE', payload: {} });
              }
            } else {
              // No work available, go idle
              dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
              dispatch({ type: 'WAITER_GO_IDLE', payload: {} });
            }
          } else {
            // Just pacing, go idle
            dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
            dispatch({ type: 'WAITER_GO_IDLE', payload: {} });
          }
        } else {
          // Update position along path (path uses gridX/gridZ, not x/z)
          const pathIndex = Math.floor(newProgress * pathLength);
          const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
          dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
            gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
            gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
            walkProgress: newProgress
          }});
        }
      } else if (waiter.state === 'walking_to_counter') {
        // Walk to counter
        const pathLength = waiter.path?.length || 1;
        const newProgress = (waiter.walkProgress || 0) + 0.03;
        
        if (newProgress >= 1) {
          // Reached counter - pick up food and go to table
          const chair = findChairForTable(
            gameState.tables.find(t => t.id === waiter.targetTableId), 
            gameState.chairs || []
          );
          const table = gameState.tables.find(t => t.id === waiter.targetTableId);
          const deliveryX = chair ? chair.gridX : table?.gridX || waiter.gridX;
          const deliveryZ = chair ? chair.gridZ : table?.gridZ || waiter.gridZ;
          
          const finalTile = waiter.path[waiter.path.length - 1];
          const finalX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
          const finalZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
          
          const occupancyMap = buildOccupancyMap(gameState);
          occupancyMap.delete(getTileKey(finalX, finalZ));
          occupancyMap.delete(getTileKey(deliveryX, deliveryZ));
          
          const pathToTable = findPath(occupancyMap, finalX, finalZ,
            deliveryX, deliveryZ, GRID.width, GRID.height);
          
          dispatch({ type: 'WAITER_PICKUP_AND_GO', payload: { 
            counterId: waiter.targetCounterId, 
            tableId: waiter.targetTableId,
            pathToTable: pathToTable || []
          }});
        } else {
          // Update position along path (path uses gridX/gridZ, not x/z)
          const pathIndex = Math.floor(newProgress * pathLength);
          const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
          dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
            gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
            gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
            walkProgress: newProgress
          }});
        }
      } else if (waiter.state === 'walking_to_table') {
        // Walk to table
        const pathLength = waiter.path?.length || 1;
        const newProgress = (waiter.walkProgress || 0) + 0.03;
        
        if (newProgress >= 1) {
          // Reached table - serve customer
          const finalTile = waiter.path[waiter.path.length - 1];
          const waiterX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
          const waiterZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
          
          // Check for NEXT job BEFORE deciding where to go
          // (This is the key - decide next destination at delivery time, not after returning!)
          const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
          // Note: current customer is still 'waiting' until we dispatch, so filter them out
          // Then get the most urgent remaining customer (lowest patience first!)
          const otherTables = gameState.tables.filter(t => t.id !== waiter.targetTableId);
          const nextTable = getMostUrgentCustomer(otherTables);
          
          const occupancyMap = buildOccupancyMap(gameState);
          occupancyMap.delete(getTileKey(waiterX, waiterZ));
          
          if (countersWithFood.length > 0 && nextTable) {
            // MORE WORK! Go directly to counter with food (skip "return to counter area")
            const counter = countersWithFood[0];
            const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
            
            occupancyMap.delete(getTileKey(counterTile.gridX, counterTile.gridZ));
            
            const pathToCounter = findPath(occupancyMap, waiterX, waiterZ,
              counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
            
            if (pathToCounter && pathToCounter.length > 0) {
              // Serve current customer AND immediately queue up next job
              dispatch({ type: 'WAITER_SERVE_AND_CONTINUE', payload: { 
                tableId: waiter.targetTableId,
                finalX: waiterX,
                finalZ: waiterZ,
                nextCounterId: counter.id,
                nextTableId: nextTable.id,
                pathToCounter: pathToCounter
              }});
              SFX.customerServed();
            } else {
              // Can't path to counter, just return to counter area
              const targetX = 9 + Math.floor(Math.random() * 5);
              const targetZ = 1;
              occupancyMap.delete(getTileKey(targetX, targetZ));
              const returnPath = findPath(occupancyMap, waiterX, waiterZ, targetX, targetZ, GRID.width, GRID.height);
              
              dispatch({ type: 'WAITER_SERVE_AND_RETURN', payload: { 
                tableId: waiter.targetTableId,
                finalX: waiterX,
                finalZ: waiterZ,
                returnPath: returnPath || []
              }});
              SFX.customerServed();
            }
          } else {
            // No more work - return to counter area
            const targetX = 9 + Math.floor(Math.random() * 5);
            const targetZ = 1;
            occupancyMap.delete(getTileKey(targetX, targetZ));
            const returnPath = findPath(occupancyMap, waiterX, waiterZ, targetX, targetZ, GRID.width, GRID.height);
            
            dispatch({ type: 'WAITER_SERVE_AND_RETURN', payload: { 
              tableId: waiter.targetTableId,
              finalX: waiterX,
              finalZ: waiterZ,
              returnPath: returnPath || []
            }});
            SFX.customerServed();
          }
        } else {
          // Update position along path (path uses gridX/gridZ, not x/z)
          const pathIndex = Math.floor(newProgress * pathLength);
          const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
          dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
            gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
            gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
            walkProgress: newProgress
          }});
        }
      }
      
      // Process chef's pending serve action (set by animation loop when chef reaches table)
      if (chefStateRef.current?.pendingServe) {
        const { tableId, counterId } = chefStateRef.current.pendingServe;
        const table = gameState.tables.find(t => t.id === tableId);
        const counter = gameState.counters.find(c => c.id === counterId);
        
        if (table && table.customer?.state === 'waiting' && counter && counter.dishes.length > 0) {
          dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId, counterId } });
          SFX.customerServed();
        }
        
        // Clear the pending serve
        chefStateRef.current.pendingServe = null;
      }
      
      // Auto-serve customers if enabled - chef picks up food and delivers to tables
      if (autoServe && chefStateRef.current) {
        const chef = chefStateRef.current;
        
        // If chef is idle and not carrying food and has no task, look for food to pick up
        if (chef.state === 'idle' && !chef.task && !chef.carryingPlate) {
          const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
          const targetTable = getMostUrgentCustomer(gameState.tables); // Prioritize by patience!
          
          if (countersWithFood.length > 0 && targetTable) {
            // Find counter with food and serve most urgent customer
            const counter = countersWithFood[0];
            
            // Get interaction tile in front of counter
            const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
            const targetX = counterTile.gridX - GRID.width / 2 + 0.5;
            const targetZ = counterTile.gridZ - GRID.height / 2 + 0.5;
            
            // Assign task: pickup food then deliver to table (animation loop handles the rest)
            setChefTargetWithPath(targetX, targetZ, { 
              type: 'pickup', 
              counterId: counter.id, 
              tableId: targetTable.id 
            });
          }
        }
      }
      
      // Clean up finished flying coins (aggressive cleanup to prevent buildup)
      setFlyingCoins(prev => {
        const now = Date.now();
        // Remove coins older than 1 second
        let filtered = prev.filter(coin => (now - coin.startTime) < 1000);
        // Also cap at max 5 coins just in case
        if (filtered.length > 5) {
          filtered = filtered.slice(-5);
        }
        return filtered;
      });
      
      // Clean up old purchase records
      setNewPurchases(prev => prev.filter(p => Date.now() - p.time < 1000));
    }, 100);
    
    return () => clearInterval(interval);
  }, [gameState, autoServe]);
  
  // Handle clicks
  const handleClick = (e) => {
    if (!containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Handle divider placement mode
    if (placingDivider) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Dividers can go anywhere inside cafe
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        
        // Check for collisions
        let hasCollision = false;
        if (inCafe) {
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const dividerType = DIVIDERS[placingDivider];
        const validPlacement = inCafe && !hasCollision;
        
        if (validPlacement && gameState.coins >= dividerType.cost) {
          dispatch({ 
            type: 'PLACE_DIVIDER', 
            payload: { dividerType: placingDivider, gridX, gridZ, rotation: placementRotation % 2 } 
          });
          SFX.purchase();
          // Stay in placement mode - only exit if can't afford another
          if (gameState.coins - dividerType.cost < dividerType.cost) {
            setPlacingDivider(null);
            setPlacementRotation(0);
          }
        } else {
          SFX.error();
        }
      }
      return;
    }
    
    // Handle door placement mode - doors go on walls
    if (placingDoor) {
      // Raycast against all objects in the scene to find wall segments
      const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
      
      // Find the first wall segment we hit
      let hitWallSegment = null;
      for (const hit of intersects) {
        let obj = hit.object;
        // Walk up parent chain to find wall userData
        while (obj && !obj.userData?.wall) {
          obj = obj.parent;
        }
        if (obj && obj.userData?.wall) {
          hitWallSegment = obj;
          break;
        }
      }
      
      if (hitWallSegment) {
        const wall = hitWallSegment.userData.wall;
        const wallPosition = hitWallSegment.userData.position;
        
        // Check if exact position already has a door
        const doorTaken = (gameState.doors || []).some(d => 
          d.wall === wall && d.wallPosition === wallPosition
        );
        
        const doorType = DOORS[placingDoor];
        const validPlacement = !doorTaken;
        
        if (validPlacement && gameState.coins >= doorType.cost) {
          dispatch({ 
            type: 'PLACE_DOOR', 
            payload: { doorType: placingDoor, wall, wallPosition } 
          });
          SFX.purchase();
          // Exit placement mode after placing a door
          setPlacingDoor(null);
        } else {
          SFX.error();
        }
      } else {
        // Didn't click on a wall segment
        SFX.error();
      }
      return;
    }
    
    // Wallpaper painting is now handled via mouseDown/mouseMove for drag support
    // Skip the old click handler for wallpaper
    if (placingWallpaper) {
      return; // Handled by paintWallAtMouse in mouseDown/mouseMove
    }
    
    // Handle decoration placement mode
    if (placingDecoration) {
      const decorType = DECORATIONS[placingDecoration];
      const isWallDecor = decorType.category === 'wall';
      
      if (isWallDecor) {
        // Wall decorations: Raycast against wall segment meshes
        const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
        
        // Find the first wall segment we hit
        let hitWallSegment = null;
        for (const hit of intersects) {
          let obj = hit.object;
          while (obj && !obj.userData?.wall) {
            obj = obj.parent;
          }
          if (obj && obj.userData?.wall) {
            hitWallSegment = obj;
            break;
          }
        }
        
        if (hitWallSegment) {
          const wall = hitWallSegment.userData.wall;
          const wallPosition = hitWallSegment.userData.position;
          
          // Convert wall position to grid coordinates
          let gridX, gridZ;
          if (wall === 'back') {
            gridX = wallPosition;
            gridZ = 0;
          } else if (wall === 'left') {
            gridX = 0;
            gridZ = wallPosition;
          } else { // right
            gridX = GRID.width - 1;
            gridZ = wallPosition;
          }
          
          if (gameState.coins >= decorType.cost) {
            dispatch({ 
              type: 'PLACE_DECORATION', 
              payload: { decorationType: placingDecoration, gridX, gridZ, rotation: placementRotation, wall, wallPosition } 
            });
            SFX.purchase();
            if (gameState.coins - decorType.cost < decorType.cost) {
              setPlacingDecoration(null);
            }
          } else {
            SFX.error();
          }
        } else {
          SFX.error(); // Didn't click on a wall
        }
        return;
      }
      
      // Floor decorations: Raycast against the floor to find placement position
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        // Convert world position to grid position
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Floor decorations go in dining area + divider row (gridZ >= 3)
        const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
        
        // Check for collisions with other floor objects
        let hasCollision = false;
        if (inDiningArea) {
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const validPlacement = inDiningArea && !hasCollision;
        
        if (validPlacement && gameState.coins >= decorType.cost) {
          dispatch({ 
            type: 'PLACE_DECORATION', 
            payload: { decorationType: placingDecoration, gridX, gridZ, rotation: placementRotation } 
          });
          SFX.purchase();
          // Stay in placement mode - only exit if can't afford another
          if (gameState.coins - decorType.cost < decorType.cost) {
            setPlacingDecoration(null);
          }
        } else {
          // Play error sound when placement fails
          SFX.error();
        }
      }
      return;
    }
    
    // Handle equipment placement mode
    if (placingEquipment) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Validate placement based on equipment type
        let validPlacement = false;
        let actionType = '';
        let cost = 0;
        
        // Helper to check for floor decoration collision
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        
        if (placingEquipment === 'stove') {
          // Stoves go in kitchen (gridZ 0-2), and not on counter row
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove && !hasFloorDecor && gameState.stoves.length < 8;
          actionType = 'BUY_STOVE';
          cost = 500;
        } else if (placingEquipment === 'counter') {
          // Counters can be placed anywhere in cafe (buffet style!)
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          validPlacement = inCafe && notOnStove && notOnCounter && notOnTable && !hasFloorDecor && gameState.counters.length < 6;
          actionType = 'BUY_COUNTER';
          cost = 400;
        } else if (placingEquipment === 'table') {
          // New system: Tables occupy just 1 tile (chairs are placed separately)
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          
          // Check tile is not occupied by existing tables
          const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          
          // Check not on chairs
          const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          
          // Check not on stoves/counters
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnDivider = !(gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          
          validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && notOnDivider && !hasFloorDecor && gameState.tables.length < 15;
          actionType = 'BUY_TABLE';
          cost = TABLE_STYLES[placingTableStyle]?.cost || 300;
        } else if (placingEquipment === 'chair') {
          // Chairs must be placed facing a table that doesn't already have a chair
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          
          // Check tile is not occupied
          const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnDivider = !(gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          
          // Check if chair would face a table that's available
          const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
          const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
          const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
          
          const chairCount = (gameState.chairs || []).length;
          validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && notOnDivider && !hasFloorDecor && chairCount < 15 && tableAvailable;
          actionType = 'BUY_CHAIR';
          cost = CHAIR_STYLES[placingChairStyle]?.cost || 100;
        }
        
        if (validPlacement && gameState.coins >= cost) {
          // TWO-CLICK SYSTEM for tables: first click locks position, second click confirms
          if (placingEquipment === 'table' && !placementLocked) {
            // First click - lock position for rotation
            setPlacementLocked(true);
            setLockedPosition({ gridX, gridZ });
            SFX.uiClick?.(); // Optional click sound
            return;
          }
          
          // Second click (or non-table equipment) - confirm placement
          const finalGridX = placementLocked ? lockedPosition.gridX : gridX;
          const finalGridZ = placementLocked ? lockedPosition.gridZ : gridZ;
          
          // Include rotation for all equipment types
          const payload = { gridX: finalGridX, gridZ: finalGridZ, rotation: placementRotation };
          if (placingEquipment === 'table') {
            payload.style = placingTableStyle;
          } else if (placingEquipment === 'chair') {
            payload.style = placingChairStyle;
            // Find and link to the table this chair is facing
            const facingTile = getChairFacingTile(finalGridX, finalGridZ, placementRotation);
            const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
            if (facingTable) {
              payload.linkedTableId = facingTable.id;
            }
          }
          dispatch({ type: actionType, payload });
          SFX.purchase();
          setNewPurchases(prev => [...prev, { type: placingEquipment, time: Date.now() }]);
          setPlacingEquipment(null);
          setPlacementLocked(false);
          setLockedPosition(null);
          setPlacementRotation(0);
        } else {
          // Play error sound when placement fails
          SFX.error();
        }
      }
      return;
    }
    
    // Handle moving objects (edit mode)
    if (movingObject) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Exclude the current object from collision detection
        const excludeId = movingObject.id;
        
        // Helper to check for collisions
        const hasCollision = (gx, gz, excludeType, excludeObjId) => {
          const decorTaken = gameState.decorations.some(d => {
            if (excludeType === 'decoration' && d.id === excludeObjId) return false;
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gx && d.gridZ === gz;
          });
          const tableTaken = gameState.tables.some(t => {
            if (excludeType === 'table' && t.id === excludeObjId) return false;
            return t.gridX === gx && t.gridZ === gz; // Tables now occupy 1 tile
          });
          const chairTaken = (gameState.chairs || []).some(c => {
            if (excludeType === 'chair' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          const stoveTaken = gameState.stoves.some(s => {
            if (excludeType === 'stove' && s.id === excludeObjId) return false;
            return s.gridX === gx && s.gridZ === gz;
          });
          const counterTaken = gameState.counters.some(c => {
            if (excludeType === 'counter' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gx && d.gridZ === gz);
          return decorTaken || tableTaken || chairTaken || stoveTaken || counterTaken || dividerTaken;
        };
        
        let validPlacement = false;
        
        if (movingObject.type === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          validPlacement = inKitchen && !hasCollision(gridX, gridZ, 'stove', excludeId);
        } else if (movingObject.type === 'counter') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'counter', excludeId);
        } else if (movingObject.type === 'table') {
          // New system: tables occupy just 1 tile
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          validPlacement = inDining && !hasCollision(gridX, gridZ, 'table', excludeId);
        } else if (movingObject.type === 'chair') {
          // Chairs occupy 1 tile
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          validPlacement = inDining && !hasCollision(gridX, gridZ, 'chair', excludeId);
        } else if (movingObject.type === 'decoration') {
          const decorType = DECORATIONS[movingObject.data.decorationType];
          const isWallDecor = decorType?.category === 'wall';
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
          const validArea = isWallDecor ? inCafe : inDiningArea;
          validPlacement = validArea && (isWallDecor || !hasCollision(gridX, gridZ, 'decoration', excludeId));
        }
        
        if (validPlacement) {
          // Remove old and add new at new position (no refund for moving)
          if (movingObject.type === 'stove') {
            dispatch({ type: 'REMOVE_STOVE', payload: { stoveId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_STOVE', payload: { gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'counter') {
            dispatch({ type: 'REMOVE_COUNTER', payload: { counterId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_COUNTER', payload: { gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'table') {
            dispatch({ type: 'REMOVE_TABLE', payload: { tableId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_TABLE', payload: { gridX, gridZ, style: movingObject.data.style, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'chair') {
            dispatch({ type: 'REMOVE_CHAIR', payload: { chairId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_CHAIR', payload: { gridX, gridZ, style: movingObject.data.style, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'decoration') {
            dispatch({ type: 'REMOVE_DECORATION', payload: { decorationId: excludeId, noRefund: true } });
            dispatch({ type: 'PLACE_DECORATION', payload: { decorationType: movingObject.data.decorationType, gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'divider') {
            dispatch({ type: 'REMOVE_DIVIDER', payload: { dividerId: excludeId, noRefund: true } });
            dispatch({ type: 'PLACE_DIVIDER', payload: { dividerType: movingObject.data.dividerType, gridX, gridZ, rotation: placementRotation % 2, free: true } });
          }
          SFX.purchase();
          setMovingObject(null);
          setPlacementRotation(0);
        } else {
          SFX.error();
        }
      }
      return;
    }
    
    // Handle edit mode - click to select objects
    if (editMode && !movingObject) {
      const allEditableObjects = [
        ...Object.values(objectsRef.current.stoves),
        ...Object.values(objectsRef.current.counters),
        ...Object.values(objectsRef.current.tables),
        ...Object.values(objectsRef.current.chairs || {}),
        ...Object.values(objectsRef.current.decorations || {}),
        ...Object.values(objectsRef.current.dividers || {}),
        ...Object.values(objectsRef.current.doors || {}),
      ].filter(Boolean);
      
      const intersects = raycasterRef.current.intersectObjects(allEditableObjects, true);
      
      if (intersects.length > 0) {
        let obj = intersects[0].object;
        while (obj && !obj.userData?.type) {
          obj = obj.parent;
        }
        
        if (obj?.userData) {
          const { type, id } = obj.userData;
          // Toggle selection or select new
          if (selectedEditObject?.type === type && selectedEditObject?.id === id) {
            setSelectedEditObject(null); // Deselect if clicking same object
          } else {
            setSelectedEditObject({ type, id });
            SFX.uiClick?.();
          }
          return;
        }
      }
      
      // Clicked empty space - deselect
      setSelectedEditObject(null);
      return;
    }
    
    const allObjects = [
      ...Object.values(objectsRef.current.stoves),
      ...Object.values(objectsRef.current.counters),
      ...Object.values(objectsRef.current.tables),
      ...Object.values(objectsRef.current.customers),
    ].filter(Boolean);
    
    const intersects = raycasterRef.current.intersectObjects(allObjects, true);
    
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && !obj.userData?.type) {
        obj = obj.parent;
      }
      
      if (obj?.userData) {
        const { type, id, tableId } = obj.userData;
        
        if (type === 'stove') {
          const stove = gameState.stoves.find(s => s.id === id);
          if (stove.state === 'empty') {
            setSelectedStove(id);
          } else if (stove.state === 'ready') {
            // First, try to find a counter with the SAME recipe (for stacking)
            let counter = gameState.counters.find(c => c.dishes.length > 0 && c.dishes[0].recipe === stove.recipe);
            // If no matching recipe counter, find an EMPTY counter
            if (!counter) {
              counter = gameState.counters.find(c => c.dishes.length === 0);
            }
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: id, counterId: counter.id } });
              SFX.serveToCounter();
            }
          } else if (stove.state === 'spoiled') {
            dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: id } });
          }
        } else if (type === 'customer') {
          const table = gameState.tables.find(t => t.id === tableId);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        } else if (type === 'table') {
          // Also allow clicking on tables to serve customers!
          const table = gameState.tables.find(t => t.id === id);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId: id, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        }
      }
    }
  };
  
  const handleRecipeSelect = (recipeKey) => {
    if (selectedStove) {
      dispatch({ type: 'START_COOKING', payload: { stoveId: selectedStove, recipeKey } });
      SFX.cookStart();
      setSelectedStove(null);
      setShowCookbook(false);
    }
  };
  
  // Export save - generate JSON for copying
  const handleExportSave = () => {
    const saveData = {
      version: 5, // Updated version for display settings (brightness)
      timestamp: Date.now(),
      gameState: {
        coins: gameState.coins,
        xp: gameState.xp,
        level: gameState.level,
        buzz: gameState.buzz,
        avatar: gameState.avatar, // Save avatar customization
        stats: gameState.stats,
        achievements: gameState.achievements,
        // Save full stove state (cooking items will finish immediately on load since time passed)
        stoves: gameState.stoves.map(s => ({ 
          id: s.id, 
          gridX: s.gridX, 
          gridZ: s.gridZ,
          rotation: s.rotation || 0,
          state: s.state,
          recipe: s.recipe,
          startTime: s.startTime,
          servingsLeft: s.servingsLeft,
        })),
        // Save counter dishes
        counters: gameState.counters.map(c => ({ 
          id: c.id, 
          gridX: c.gridX, 
          gridZ: c.gridZ,
          rotation: c.rotation || 0,
          dishes: c.dishes,
        })),
        // Save tables (customers will be cleared since they're transient)
        tables: gameState.tables.map(t => ({ 
          id: t.id, gridX: t.gridX, gridZ: t.gridZ, style: t.style, rotation: t.rotation || 0, customer: null 
        })),
        // Save decorations
        decorations: gameState.decorations.map(d => ({
          id: d.id, type: d.type, gridX: d.gridX, gridZ: d.gridZ, rotation: d.rotation || 0
        })),
        // Save dividers
        dividers: (gameState.dividers || []).map(d => ({
          id: d.id, type: d.type, gridX: d.gridX, gridZ: d.gridZ, rotation: d.rotation
        })),
        // Save doors
        doors: (gameState.doors || []).map(d => ({
          id: d.id, type: d.type, wall: d.wall, wallPosition: d.wallPosition
        })),
      },
      // Save audio and display settings
      audioSettings: {
        masterEnabled: soundEnabled,
        soundToggles: soundToggles,
      },
      displaySettings: {
        brightness: brightness,
      },
    };
    
    const json = JSON.stringify(saveData);
    setSaveTextArea(json);
    setShowExportText(true);
    setSaveMessage({ type: 'success', text: 'Save generated! Copy the text below.' });
  };
  
  // Import save from textarea
  const handleImportSave = () => {
    try {
      if (!saveTextArea.trim()) {
        throw new Error('Paste save data first');
      }
      
      const saveData = JSON.parse(saveTextArea);
      
      // Validate save data
      if (!saveData.version || !saveData.gameState) {
        throw new Error('Invalid save format');
      }
      
      const gs = saveData.gameState;
      if (typeof gs.coins !== 'number' || typeof gs.level !== 'number') {
        throw new Error('Invalid save data');
      }
      
      // Clear any stuck UI animations before loading
      setFlyingCoins([]);
      setNewPurchases([]);
      
      // Load the save via dispatch
      dispatch({ type: 'LOAD_SAVE', payload: gs });
      
      // Restore audio settings if present
      if (saveData.audioSettings) {
        if (typeof saveData.audioSettings.masterEnabled === 'boolean') {
          setSoundEnabled(saveData.audioSettings.masterEnabled);
          audioEnabled = saveData.audioSettings.masterEnabled;
        }
        if (saveData.audioSettings.soundToggles) {
          const loadedToggles = { ...soundToggles, ...saveData.audioSettings.soundToggles };
          setSoundToggles(loadedToggles);
          Object.assign(soundTogglesGlobal, loadedToggles);
        }
      }
      
      // Restore display settings if present
      if (saveData.displaySettings) {
        if (typeof saveData.displaySettings.brightness === 'number') {
          setBrightness(saveData.displaySettings.brightness);
          brightnessRef.current = saveData.displaySettings.brightness;
        }
      }
      
      setSaveMessage({ type: 'success', text: 'Game loaded successfully!' });
      setSaveTextArea('');
      setShowExportText(false);
      
      // Clear coins again after a short delay (in case any were created during load)
      setTimeout(() => setFlyingCoins([]), 100);
      
      setTimeout(() => {
        setShowSettings(false);
        setSaveMessage(null);
      }, 1500);
    } catch (err) {
      setSaveMessage({ type: 'error', text: 'Failed: ' + err.message });
    }
  };
  
  // Calculate XP progress
  const prevLevelXp = XP_LEVELS[gameState.level - 1] || 0;
  const xpProgress = ((gameState.xp - prevLevelXp) / (currentLevelXp - prevLevelXp)) * 100;
  
  // Get total food available
  const totalFood = gameState.counters.reduce((sum, c) => sum + c.dishes.reduce((s, d) => s + d.servings, 0), 0);
  
  return (
    <div style={{ width: '100%', height: '100vh', position: 'relative', fontFamily: "'Segoe UI', sans-serif", overflow: 'hidden' }}>
      {/* CSS Animations */}
      <style>{`
        @keyframes pulse {
          0%, 100% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.05); }
        }
        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes jumpOut {
          0% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
          30% { transform: translateX(-50%) translateY(-20px) scale(1.2); opacity: 1; }
          100% { transform: translateX(-50%) translateY(-40px) scale(0.5); opacity: 0; }
        }
        @keyframes stomp {
          0%, 100% { transform: translateX(-50%) translateY(0) rotate(0deg); }
          25% { transform: translateX(-50%) translateY(2px) rotate(-5deg); }
          75% { transform: translateX(-50%) translateY(2px) rotate(5deg); }
        }
        @keyframes coinPop {
          0% { transform: scale(1); }
          50% { transform: scale(1.3); }
          100% { transform: scale(1); }
        }
        @keyframes coinFly {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(0.5); opacity: 0.8; }
        }
        @keyframes bounceIn {
          0% { transform: scale(0.5); opacity: 0; }
          60% { transform: scale(1.1); opacity: 1; }
          100% { transform: scale(1); }
        }
        @keyframes slideDown {
          0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
          60% { transform: translateX(-50%) translateY(5px); opacity: 1; }
          100% { transform: translateX(-50%) translateY(0); }
        }
      `}</style>
      
      {/* 3D Canvas */}
      <div 
        ref={containerRef} 
        onClick={handleClick}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onContextMenu={handleContextMenu}
        style={{ 
          width: '100%', 
          height: '100%', 
          cursor: isDragging ? 'grabbing' : 'pointer' 
        }}
      />
      
      {/* Header UI - Stats Only */}
      <div style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        padding: '12px 20px',
        background: 'linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        alignItems: 'center',
        gap: '15px',
        color: 'white',
      }}>
        {/* Cafe Name & Level */}
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '24px' }}>‚òï</span>
          <div>
            <div style={{ fontWeight: 'bold', fontSize: '18px' }}>Elly's Cafe</div>
            <div style={{ fontSize: '12px', opacity: 0.8 }}>Level {gameState.level}</div>
          </div>
        </div>
        
        {/* XP Bar */}
        <div style={{ flex: 1, maxWidth: '180px' }}>
          <div style={{ fontSize: '11px', marginBottom: '4px' }}>XP: {gameState.xp} / {currentLevelXp}</div>
          <div style={{ background: 'rgba(255,255,255,0.2)', borderRadius: '10px', height: '8px', overflow: 'hidden' }}>
            <div style={{ 
              width: `${Math.min(100, xpProgress)}%`, 
              height: '100%', 
              background: `linear-gradient(90deg, ${COLORS.ui.purple}, ${COLORS.ui.blue})`,
              borderRadius: '10px',
              transition: 'width 0.3s ease',
            }} />
          </div>
        </div>
        
        {/* Coins */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(255,215,0,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(255,215,0,0.3)',
          animation: coinPop ? 'coinPop 0.3s ease-out' : 'none',
        }}>
          <span style={{ fontSize: '18px' }}>ü™ô</span>
          <span style={{ fontWeight: 'bold', color: COLORS.ui.gold }}>{gameState.coins.toLocaleString()}</span>
        </div>
        
        {/* Buzz Rating */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(34,197,94,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(34,197,94,0.3)',
        }}>
          <span style={{ fontSize: '16px' }}>‚≠ê</span>
          <span style={{ fontWeight: 'bold', color: '#22c55e' }}>{gameState.buzz}</span>
        </div>
        
        {/* Food Ready */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(139,69,19,0.3)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(139,69,19,0.4)',
        }}>
          <span style={{ fontSize: '16px' }}>üçΩÔ∏è</span>
          <span style={{ fontWeight: 'bold' }}>{totalFood}</span>
        </div>
        
        {/* Spacer */}
        <div style={{ flex: 1 }} />
        
        {/* Time Display */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(0,0,0,0.3)',
          padding: '6px 12px',
          borderRadius: '20px',
        }}>
          <span style={{ fontSize: '16px' }}>
            {timeOfDay >= 5 && timeOfDay < 7 ? 'üåÖ' : 
             timeOfDay >= 7 && timeOfDay < 17 ? '‚òÄÔ∏è' : 
             timeOfDay >= 17 && timeOfDay < 19 ? 'üåá' : 'üåô'}
          </span>
          <span style={{ fontWeight: 'bold', fontSize: '13px' }}>
            {Math.floor(timeOfDay % 12 || 12)}:{String(Math.floor((timeOfDay % 1) * 60)).padStart(2, '0')} 
            {timeOfDay >= 12 ? ' PM' : ' AM'}
          </span>
        </div>
        
        {/* Auto-Serve Toggle */}
        <button
          onClick={() => setAutoServe(!autoServe)}
          style={{
            background: autoServe ? 'rgba(34, 197, 94, 0.4)' : 'rgba(0,0,0,0.3)',
            border: autoServe ? '1px solid rgba(34, 197, 94, 0.6)' : '1px solid rgba(255,255,255,0.2)',
            padding: '6px 10px',
            borderRadius: '20px',
            color: 'white',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '5px',
            fontSize: '12px',
          }}
          title={autoServe ? 'Chef is auto-serving customers' : 'Click to enable auto-serve'}
        >
          <span>üßë‚Äçüç≥</span>
          <span style={{ 
            width: '8px', 
            height: '8px', 
            borderRadius: '50%', 
            background: autoServe ? '#4ade80' : 'rgba(255,255,255,0.3)',
            boxShadow: autoServe ? '0 0 6px #4ade80' : 'none',
          }}></span>
        </button>
      </div>
      
      {/* Edit Mode Banner */}
      {editMode && (
        <div style={{
          position: 'absolute',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'linear-gradient(135deg, #ef4444, #dc2626)',
          color: 'white',
          padding: '12px 24px',
          borderRadius: '12px',
          fontWeight: 'bold',
          fontSize: '14px',
          boxShadow: '0 4px 20px rgba(239, 68, 68, 0.5)',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          zIndex: 100,
          animation: 'pulse 2s infinite',
        }}>
          <span style={{ fontSize: '20px' }}>‚úèÔ∏è</span>
          <div>
            <div>EDIT MODE</div>
            <div style={{ fontSize: '11px', opacity: 0.9 }}>Click object to select ‚Ä¢ Move or Delete</div>
          </div>
          <button
            onClick={() => {
              setEditMode(false);
              setSelectedEditObject(null);
            }}
            style={{
              background: 'rgba(0,0,0,0.3)',
              border: 'none',
              color: 'white',
              padding: '6px 12px',
              borderRadius: '6px',
              cursor: 'pointer',
              marginLeft: '8px',
            }}
          >
            ‚ùå Exit
          </button>
        </div>
      )}
      
      {/* Moving Object Banner */}
      {movingObject && (
        <div style={{
          position: 'absolute',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
          color: 'white',
          padding: '12px 24px',
          borderRadius: '12px',
          fontWeight: 'bold',
          fontSize: '14px',
          boxShadow: '0 4px 20px rgba(59, 130, 246, 0.5)',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          zIndex: 100,
          animation: 'pulse 2s infinite',
        }}>
          <span style={{ fontSize: '20px' }}>‚úã</span>
          <div>
            <div>MOVING {movingObject.type.toUpperCase()}</div>
            <div style={{ fontSize: '11px', opacity: 0.9 }}>Click to place ‚Ä¢ R to rotate ‚Ä¢ ESC/Right-click to cancel</div>
          </div>
          <button
            onClick={() => {
              setMovingObject(null);
              setPlacementRotation(0);
            }}
            style={{
              background: 'rgba(0,0,0,0.3)',
              border: 'none',
              color: 'white',
              padding: '6px 12px',
              borderRadius: '6px',
              cursor: 'pointer',
              marginLeft: '8px',
            }}
          >
            ‚ùå Cancel
          </button>
        </div>
      )}
      
      {/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          MAIN BOTTOM BAR - Clean organized icons like original Cafe World
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */}
      <div style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        height: showShop ? 'auto' : '70px',
        background: 'linear-gradient(to bottom, #f5e6d3, #e8d4be)',
        borderTop: '3px solid #8B4513',
        zIndex: 90,
        boxShadow: '0 -4px 15px rgba(0,0,0,0.2)',
      }}>
        {/* Main Icon Bar - Always visible */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '8px',
          padding: '8px 15px',
          height: '54px',
        }}>
          {/* Left side - Main action buttons */}
          <div style={{ display: 'flex', gap: '6px' }}>
            {/* Decor/Shop Button */}
            <button
              onClick={() => {
                setShowShop(!showShop);
                if (showShop) {
                  setPlacingEquipment(null);
                  setPlacingDecoration(null);
                }
              }}
              style={{
                background: showShop ? '#4CAF50' : 'linear-gradient(135deg, #8B5A2B, #A0522D)',
                color: 'white',
                border: 'none',
                padding: '10px 18px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                boxShadow: showShop ? '0 0 0 3px rgba(76,175,80,0.4)' : '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="Shop - Buy furniture & decorations"
            >
              ü™ë {showShop ? 'Close' : 'Shop'}
            </button>
            
            {/* Edit Mode Button */}
            <button
              onClick={() => {
                if (editMode) {
                  setSelectedEditObject(null);
                }
                setEditMode(!editMode);
                // Clear ALL placement modes when toggling edit
                setPlacingDecoration(null);
                setPlacingEquipment(null);
                setPlacingWallpaper(null);
                setPlacingDivider(null);
                setPlacingDoor(null);
                setShowShop(false);
              }}
              style={{
                background: editMode ? '#ef4444' : 'linear-gradient(135deg, #f97316, #ea580c)',
                color: 'white',
                border: 'none',
                padding: '10px 16px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: editMode ? '0 0 0 3px rgba(239,68,68,0.4)' : '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="Edit/Move/Delete items"
            >
              ‚úèÔ∏è {editMode ? 'Done' : 'Edit'}
            </button>
            
            {/* Cookbook Button */}
            <button
              onClick={() => setShowCookbook(true)}
              style={{
                background: 'linear-gradient(135deg, #7c3aed, #6d28d9)',
                color: 'white',
                border: 'none',
                padding: '10px 16px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="View all recipes"
            >
              üìñ Recipes
            </button>
          </div>
          
          {/* Center - Cafe Info */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '15px',
            padding: '0 20px',
            borderLeft: '1px solid rgba(139,69,19,0.3)',
            borderRight: '1px solid rgba(139,69,19,0.3)',
            marginLeft: '10px',
            marginRight: '10px',
          }}>
            <div style={{ textAlign: 'center', fontSize: '13px' }}>
              <div style={{ fontWeight: 'bold', color: '#5D3A1A' }}>Tables</div>
              <div style={{ color: '#8B4513' }}>{gameState.tables.length}/15</div>
            </div>
            <div style={{ textAlign: 'center', fontSize: '13px' }}>
              <div style={{ fontWeight: 'bold', color: '#5D3A1A' }}>Stoves</div>
              <div style={{ color: '#8B4513' }}>{gameState.stoves.length}/8</div>
            </div>
          </div>
          
          {/* Right side - Utility buttons */}
          <div style={{ display: 'flex', gap: '6px' }}>
            {/* Camera Controls */}
            <div style={{
              display: 'flex',
              gap: '3px',
              background: 'rgba(139,69,19,0.15)',
              padding: '5px',
              borderRadius: '8px',
            }}>
              <button onClick={() => setCameraAngle(prev => prev + Math.PI/6)} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }} title="Rotate Left">‚Ü∫</button>
              <button onClick={() => { setCameraAngle(Math.PI / 4); setCameraPitch(0.6); }} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontSize: '12px' }} title="Reset View">‚åÇ</button>
              <button onClick={() => setCameraAngle(prev => prev - Math.PI/6)} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }} title="Rotate Right">‚Üª</button>
              <div style={{ width: '1px', background: 'rgba(139,69,19,0.3)', margin: '2px' }} />
              <button onClick={() => setZoomLevel(Math.max(0.5, zoomLevel - 0.25))} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: zoomLevel > 0.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel > 0.5 ? 1 : 0.5, fontWeight: 'bold' }} title="Zoom In">+</button>
              <button onClick={() => setZoomLevel(Math.min(1.5, zoomLevel + 0.25))} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: zoomLevel < 1.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel < 1.5 ? 1 : 0.5, fontWeight: 'bold' }} title="Zoom Out">‚àí</button>
            </div>
            
            {/* Volume Toggle */}
            <button
              onClick={() => {
                setSoundEnabled(!soundEnabled);
                audioEnabled = !soundEnabled;
              }}
              style={{
                background: soundEnabled ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'linear-gradient(135deg, #6b7280, #4b5563)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                fontSize: '16px',
              }}
              title={soundEnabled ? 'Sound ON - Click to mute' : 'Sound OFF - Click to unmute'}
            >
              {soundEnabled ? 'üîä' : 'üîá'}
            </button>
            
            {/* Trophy/Achievements */}
            <button
              onClick={() => setShowTrophies(true)}
              style={{
                background: 'linear-gradient(135deg, #fbbf24, #f59e0b)',
                color: '#5D3A1A',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '4px',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                fontWeight: 'bold',
                fontSize: '13px',
              }}
              title="Achievements"
            >
              üèÜ {gameState.achievements.length}/{Object.keys(ACHIEVEMENTS).length}
            </button>
            
            {/* Avatar Customize */}
            <button
              onClick={() => setShowAvatarCustomize(true)}
              style={{
                background: 'linear-gradient(135deg, #F472B6, #EC4899)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Customize Chef"
            >
              üë©‚Äçüç≥
            </button>
            
            {/* Save/Load */}
            <button
              onClick={() => setShowSettings(true)}
              style={{
                background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Save/Load Game"
            >
              üíæ
            </button>
            
            {/* Audio/Settings */}
            <button
              onClick={() => setShowAudioSettings(true)}
              style={{
                background: 'linear-gradient(135deg, #6b7280, #4b5563)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Settings"
            >
              ‚öôÔ∏è
            </button>
          </div>
        </div>
        
        {/* Shop Panel Content - Shows below the bar when shop is open */}
        {showShop && (
          <>
            {/* Category Tabs */}
            <div style={{
              display: 'flex',
              gap: '5px',
              padding: '0 10px',
              borderTop: '1px solid rgba(139,69,19,0.2)',
              borderBottom: '2px solid #d4c4a8',
              background: 'rgba(255,255,255,0.3)',
            }}>
              {[
                { id: 'equipment', icon: 'üî•', label: 'Kitchen' },
                { id: 'tables', icon: 'üçΩÔ∏è', label: 'Tables' },
                { id: 'chairs', icon: 'ü™ë', label: 'Chairs' },
                { id: 'decor', icon: 'üå∏', label: 'Decor' },
                { id: 'dividers', icon: 'üöß', label: 'Dividers' },
                { id: 'doors', icon: 'üö™', label: 'Doors' },
                { id: 'walls', icon: 'üé®', label: 'Walls' },
              ].map(cat => (
                <button
                  key={cat.id}
                  onClick={() => setShopCategory(cat.id)}
                  style={{
                    padding: '10px 20px',
                    border: 'none',
                    borderRadius: '8px 8px 0 0',
                    background: shopCategory === cat.id ? '#fff' : 'transparent',
                    cursor: 'pointer',
                    fontWeight: shopCategory === cat.id ? 'bold' : 'normal',
                    color: shopCategory === cat.id ? '#8B4513' : '#666',
                    borderBottom: shopCategory === cat.id ? '3px solid #4CAF50' : '3px solid transparent',
                    marginBottom: '-2px',
                    fontSize: '14px',
                    transition: 'all 0.15s',
                  }}
                >
                  {cat.icon} {cat.label}
                </button>
              ))}
            </div>
            
            {/* Placement Hint */}
            {(placingEquipment || placingDecoration || placingDivider) && (
              <div style={{
                background: '#e8f5e9',
                padding: '8px 15px',
                textAlign: 'center',
                borderTop: '1px solid #c8e6c9',
                color: '#2e7d32',
                fontSize: '13px',
                fontWeight: 'bold',
              }}>
                üëÜ Click to place ‚Ä¢ Press R to rotate ‚Ä¢ Click item again to deselect
              </div>
            )}
            
            {/* Wallpaper Placement Hint */}
            {placingWallpaper && (
              <div style={{
                background: '#f3e5f5',
                padding: '8px 15px',
                textAlign: 'center',
                borderTop: '1px solid #e1bee7',
                color: '#7b1fa2',
                fontSize: '13px',
                fontWeight: 'bold',
              }}>
                üé® Click or drag across wall segments to paint! (ü™ô{WALLPAPERS[placingWallpaper]?.cost} each) ‚Ä¢ Click wallpaper in shop to deselect
              </div>
            )}
            
            {/* Items Row */}
            <div style={{ 
              display: 'flex',
              alignItems: 'stretch',
              background: '#fff',
            }}>
              {/* Left Arrow */}
              <div 
                onClick={() => {
                  if (shopScrollRef.current && shopScrollPos.left > 0) {
                    shopScrollRef.current.scrollBy({ left: -200, behavior: 'smooth' });
                  }
                }}
                style={{
                  width: '45px',
                  background: shopScrollPos.left > 0 
                    ? 'linear-gradient(135deg, #e8a849 0%, #d4892a 100%)'
                    : '#ccc',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  cursor: shopScrollPos.left > 0 ? 'pointer' : 'default',
                  fontSize: '24px',
                  color: 'white',
                  fontWeight: 'bold',
                }}
              >‚óÄ</div>
              
              {/* Scrollable Items Container */}
              <div 
                ref={shopScrollRef}
                onScroll={(e) => {
                  const el = e.target;
                  setShopScrollPos({
                    left: el.scrollLeft,
                    max: el.scrollWidth - el.clientWidth
                  });
                }}
                onWheel={(e) => {
                  // Allow horizontal scrolling with mouse wheel
                  if (shopScrollRef.current) {
                    e.preventDefault();
                    shopScrollRef.current.scrollLeft += e.deltaY;
                  }
                }}
                style={{
                  flex: 1,
                  display: 'flex',
                  gap: '12px',
                  padding: '15px 20px',
                  overflowX: 'auto',
                  background: 'linear-gradient(180deg, #fffcf5 0%, #fff8ed 100%)',
                  scrollbarWidth: 'none',
                }}
              >
              {/* Equipment Category */}
              {shopCategory === 'equipment' && (
                <>
                  <div
                    onClick={() => {
                      if (gameState.coins >= 500 && gameState.stoves.length < 8) {
                        setPlacingEquipment(placingEquipment === 'stove' ? null : 'stove');
                        setPlacingDecoration(null);
                        setPlacingDivider(null);
                        setPlacingDoor(null);
                        setPlacingWallpaper(null);
                      }
                    }}
                    style={{
                      minWidth: '100px',
                      padding: '10px',
                      border: placingEquipment === 'stove' ? '3px solid #4CAF50' : '2px solid #ddd',
                      borderRadius: '10px',
                      background: placingEquipment === 'stove' ? '#e8f5e9' : (gameState.coins >= 500 && gameState.stoves.length < 8 ? '#fffaf5' : '#f0f0f0'),
                      cursor: gameState.coins >= 500 && gameState.stoves.length < 8 ? 'pointer' : 'not-allowed',
                      opacity: gameState.coins >= 500 && gameState.stoves.length < 8 ? 1 : 0.5,
                      textAlign: 'center',
                      transition: 'all 0.15s',
                      transform: placingEquipment === 'stove' ? 'scale(1.05)' : 'scale(1)',
                    }}
                  >
                    <div style={{ fontSize: '32px', marginBottom: '5px' }}>üî•</div>
                    <div style={{ fontSize: '12px', fontWeight: 'bold' }}>Stove</div>
                    <div style={{ fontSize: '10px', color: '#666' }}>{gameState.stoves.length}/8</div>
                    <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô 500</div>
                  </div>
                  
                  <div
                    onClick={() => {
                      if (gameState.coins >= 400 && gameState.counters.length < 6) {
                        setPlacingEquipment(placingEquipment === 'counter' ? null : 'counter');
                        setPlacingDecoration(null);
                        setPlacingDivider(null);
                        setPlacingDoor(null);
                        setPlacingWallpaper(null);
                      }
                    }}
                    style={{
                      minWidth: '100px',
                      padding: '10px',
                      border: placingEquipment === 'counter' ? '3px solid #4CAF50' : '2px solid #ddd',
                      borderRadius: '10px',
                      background: placingEquipment === 'counter' ? '#e8f5e9' : (gameState.coins >= 400 && gameState.counters.length < 6 ? '#fffaf5' : '#f0f0f0'),
                      cursor: gameState.coins >= 400 && gameState.counters.length < 6 ? 'pointer' : 'not-allowed',
                      opacity: gameState.coins >= 400 && gameState.counters.length < 6 ? 1 : 0.5,
                      textAlign: 'center',
                      transition: 'all 0.15s',
                      transform: placingEquipment === 'counter' ? 'scale(1.05)' : 'scale(1)',
                    }}
                  >
                    <div style={{ fontSize: '32px', marginBottom: '5px' }}>üçΩÔ∏è</div>
                    <div style={{ fontSize: '12px', fontWeight: 'bold' }}>Counter</div>
                    <div style={{ fontSize: '10px', color: '#666' }}>{gameState.counters.length}/6</div>
                    <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô 400</div>
                  </div>
                </>
              )}
              
              {/* Tables Category */}
              {shopCategory === 'tables' && (
                <>
                  {Object.entries(TABLE_STYLES).map(([key, tableStyle]) => {
                    const canAfford = gameState.coins >= tableStyle.cost && gameState.tables.length < 15;
                    const isSelected = placingEquipment === 'table' && placingTableStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingTableStyle('square');
                            } else {
                              setPlacingEquipment('table');
                              setPlacingTableStyle(key);
                              setPlacingDecoration(null);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{tableStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{tableStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{gameState.tables.length}/15</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {tableStyle.cost}</div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Chairs Category (Mix & Match with Tables) */}
              {shopCategory === 'chairs' && (
                <>
                  {Object.entries(CHAIR_STYLES).map(([key, chairStyle]) => {
                    const chairCount = (gameState.chairs || []).length;
                    const canAfford = gameState.coins >= chairStyle.cost && chairCount < 15;
                    const isSelected = placingEquipment === 'chair' && placingChairStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingChairStyle('basicWood');
                            } else {
                              setPlacingEquipment('chair');
                              setPlacingChairStyle(key);
                              setPlacingDecoration(null);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{chairStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{chairStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{chairCount}/15</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {chairStyle.cost}</div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Decor Category */}
              {shopCategory === 'decor' && (
                <>
                  {Object.entries(DECORATIONS).map(([key, decor]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= decor.cost) {
                          setPlacingDecoration(placingDecoration === key ? null : key);
                          setPlacingEquipment(null);
                          setPlacingDivider(null);
                          setPlacingDoor(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDecoration === key ? '3px solid #4CAF50' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDecoration === key ? '#e8f5e9' : (gameState.coins >= decor.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= decor.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= decor.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDecoration === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{decor.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{decor.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{decor.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {decor.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {/* Dividers Category */}
              {shopCategory === 'dividers' && (
                <>
                  <div style={{ 
                    minWidth: '200px', 
                    padding: '8px', 
                    background: '#fff8e1', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: '#8B4513',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    üöß Dividers block customers but are short enough to see over!
                  </div>
                  {Object.entries(DIVIDERS).map(([key, divider]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= divider.cost) {
                          setPlacingDivider(placingDivider === key ? null : key);
                          setPlacingDoor(null);
                          setPlacingDecoration(null);
                          setPlacingEquipment(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDivider === key ? '3px solid #4CAF50' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDivider === key ? '#e8f5e9' : (gameState.coins >= divider.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= divider.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= divider.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDivider === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{divider.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{divider.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{divider.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {divider.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {/* Doors Category */}
              {shopCategory === 'doors' && (
                <>
                  <div style={{ 
                    minWidth: '250px', 
                    padding: '8px', 
                    background: '#e3f2fd', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: '#1565c0',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    üö™ Place doors on walls for customers to enter! Click a wall after selecting.
                  </div>
                  {Object.entries(DOORS).map(([key, door]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= door.cost) {
                          setPlacingDoor(placingDoor === key ? null : key);
                          setPlacingDivider(null);
                          setPlacingDecoration(null);
                          setPlacingEquipment(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDoor === key ? '3px solid #2196F3' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDoor === key ? '#e3f2fd' : (gameState.coins >= door.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= door.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= door.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDoor === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{door.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{door.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{door.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ü™ô {door.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {shopCategory === 'walls' && (
                <>
                  <div style={{ 
                    minWidth: '280px', 
                    padding: '8px', 
                    background: placingWallpaper ? '#e8f5e9' : '#f3e5f5', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: placingWallpaper ? '#2e7d32' : '#7b1fa2',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    {placingWallpaper 
                      ? `üé® Click or DRAG across walls to paint! ü™ô${WALLPAPERS[placingWallpaper]?.cost} per segment`
                      : `üé® Select a wallpaper, then click or drag to paint wall segments!`
                    }
                  </div>
                  {Object.entries(WALLPAPERS).map(([key, wallpaper]) => {
                    const isCurrentWallpaper = (gameState.wallpaper || 'cream') === key;
                    const isSelected = placingWallpaper === key;
                    const canAfford = gameState.coins >= wallpaper.cost;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (isSelected) {
                            // Deselect
                            setPlacingWallpaper(null);
                          } else if (canAfford || wallpaper.cost === 0) {
                            // Select this wallpaper for placement
                            setPlacingWallpaper(key);
                            setPlacingDoor(null);
                            setPlacingDivider(null);
                            setPlacingDecoration(null);
                            setPlacingEquipment(null);
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : (isCurrentWallpaper ? '3px solid #9c27b0' : '2px solid #ddd'),
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (isCurrentWallpaper ? '#f3e5f5' : (canAfford || wallpaper.cost === 0 ? '#fffaf5' : '#f0f0f0')),
                          cursor: (canAfford || wallpaper.cost === 0) ? 'pointer' : 'not-allowed',
                          opacity: (canAfford || wallpaper.cost === 0) ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.08)' : (isCurrentWallpaper ? 'scale(1.02)' : 'scale(1)'),
                        }}
                      >
                        {/* Color swatch preview */}
                        <div style={{ 
                          width: '50px', 
                          height: '50px', 
                          margin: '0 auto 5px',
                          borderRadius: '8px',
                          border: '2px solid #ccc',
                          background: wallpaper.pattern === 'stripes' 
                            ? `repeating-linear-gradient(90deg, #${wallpaper.color.toString(16).padStart(6, '0')}, #${wallpaper.color.toString(16).padStart(6, '0')} 8px, #${wallpaper.stripeColor.toString(16).padStart(6, '0')} 8px, #${wallpaper.stripeColor.toString(16).padStart(6, '0')} 12px)`
                            : wallpaper.pattern === 'brick'
                            ? `repeating-linear-gradient(0deg, #${wallpaper.color.toString(16).padStart(6, '0')}, #${wallpaper.color.toString(16).padStart(6, '0')} 10px, #d3d3d3 10px, #d3d3d3 12px)`
                            : `#${wallpaper.color.toString(16).padStart(6, '0')}`,
                          position: 'relative',
                        }}>
                          {isCurrentWallpaper && (
                            <div style={{
                              position: 'absolute',
                              top: '50%',
                              left: '50%',
                              transform: 'translate(-50%, -50%)',
                              fontSize: '20px',
                            }}>‚úì</div>
                          )}
                          {isSelected && (
                            <div style={{
                              position: 'absolute',
                              top: '-5px',
                              right: '-5px',
                              background: '#4CAF50',
                              borderRadius: '50%',
                              width: '20px',
                              height: '20px',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              color: 'white',
                              fontSize: '12px',
                            }}>üé®</div>
                          )}
                        </div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{wallpaper.name}</div>
                        {wallpaper.buzz > 0 && <div style={{ fontSize: '10px', color: '#22c55e' }}>+{wallpaper.buzz} Buzz</div>}
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>
                          {isCurrentWallpaper ? '‚úì Current' : (wallpaper.cost === 0 ? 'Free' : `ü™ô ${wallpaper.cost}`)}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              </div>
              
              {/* Right Arrow */}
              <div 
                onClick={() => {
                  if (shopScrollRef.current && shopScrollPos.left < shopScrollPos.max - 5) {
                    shopScrollRef.current.scrollBy({ left: 200, behavior: 'smooth' });
                  }
                }}
                style={{
                  width: '45px',
                  background: shopScrollPos.left < shopScrollPos.max - 5
                    ? 'linear-gradient(135deg, #e8a849 0%, #d4892a 100%)'
                    : '#ccc',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  cursor: shopScrollPos.left < shopScrollPos.max - 5 ? 'pointer' : 'default',
                  fontSize: '24px',
                  color: 'white',
                  fontWeight: 'bold',
                }}
              >‚ñ∂</div>
            </div>
          </>
        )}
      </div>
      
      {/* Stove Status Indicators - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.stoves.map(stove => {
        const screenPos = projectedPositions[`stove_${stove.id}`];
        if (!screenPos) return null;
        
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (currentTime - stove.startTime) / 1000;
          // Use mastery-adjusted cook time for progress calculation
          const masteryCookTime = getCookTimeWithMastery(gameState.dishMastery, stove.recipe);
          const progress = Math.min(100, (elapsed / masteryCookTime) * 100);
          const remaining = Math.max(0, masteryCookTime - elapsed);
          
          return (
            <div key={stove.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              background: 'rgba(0,0,0,0.8)',
              padding: '6px 10px',
              borderRadius: '8px',
              color: 'white',
              fontSize: '11px',
              textAlign: 'center',
            }}>
              <div>{recipe.icon} {recipe.name}</div>
              <div style={{ 
                background: 'rgba(255,255,255,0.2)', 
                borderRadius: '4px', 
                height: '4px', 
                marginTop: '4px',
                overflow: 'hidden',
              }}>
                <div style={{ 
                  width: `${progress}%`, 
                  height: '100%', 
                  background: COLORS.ui.green,
                  transition: 'width 0.1s linear',
                }} />
              </div>
              <div style={{ marginTop: '2px', opacity: 0.8 }}>{formatTimeDisplay(remaining)}</div>
            </div>
          );
        }
        
        if (stove.state === 'ready') {
          const recipe = RECIPES[stove.recipe];
          const handleServeToCounter = () => {
            // First, try to find a counter with the SAME recipe (for stacking)
            let counter = gameState.counters.find(c => c.dishes.length > 0 && c.dishes[0].recipe === stove.recipe);
            // If no matching recipe counter, find an EMPTY counter
            if (!counter) {
              counter = gameState.counters.find(c => c.dishes.length === 0);
            }
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: stove.id, counterId: counter.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleServeToCounter}
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: COLORS.ui.green,
                padding: '8px 14px',
                borderRadius: '10px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                boxShadow: '0 2px 10px rgba(34, 197, 94, 0.5)',
                animation: 'pulse 1s infinite',
                border: 'none',
                cursor: 'pointer',
              }}>
              <div>{recipe.icon} READY!</div>
              <div style={{ fontSize: '10px', opacity: 0.9 }}>Click to serve ({stove.servingsLeft})</div>
            </button>
          );
        }
        
        if (stove.state === 'spoiled') {
          const handleClean = () => {
            if (gameState.coins >= 15) {
              dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: stove.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleClean}
              disabled={gameState.coins < 15}
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: COLORS.ui.red,
                padding: '8px 14px',
                borderRadius: '10px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                boxShadow: '0 2px 10px rgba(239, 68, 68, 0.5)',
                border: 'none',
                cursor: gameState.coins >= 15 ? 'pointer' : 'not-allowed',
                opacity: gameState.coins >= 15 ? 1 : 0.7,
              }}>
              <div>üóëÔ∏è SPOILED!</div>
              <div style={{ fontSize: '10px', opacity: 0.9 }}>Click to clean (15ü™ô)</div>
            </button>
          );
        }
        
        return null;
      })}
      
      {/* EDIT MODE - Single selected object popup */}
      {editMode && !isDragging && !movingObject && selectedEditObject && (() => {
        const { type, id } = selectedEditObject;
        let screenPos, canDelete, canMove, name, deleteAction, refund;
        
        if (type === 'stove') {
          const stove = gameState.stoves.find(s => s.id === id);
          if (!stove) return null;
          screenPos = projectedPositions[`stove_${id}`];
          canDelete = gameState.stoves.length > 1 && stove.state === 'empty';
          canMove = stove.state === 'empty';
          name = 'üî• Stove';
          refund = 250;
          deleteAction = () => dispatch({ type: 'REMOVE_STOVE', payload: { stoveId: id } });
        } else if (type === 'counter') {
          const counter = gameState.counters.find(c => c.id === id);
          if (!counter) return null;
          screenPos = projectedPositions[`counter_${id}`];
          canDelete = gameState.counters.length > 1 && counter.dishes.length === 0;
          canMove = counter.dishes.length === 0;
          name = 'üçΩÔ∏è Counter';
          refund = 200;
          deleteAction = () => dispatch({ type: 'REMOVE_COUNTER', payload: { counterId: id } });
        } else if (type === 'table') {
          const table = gameState.tables.find(t => t.id === id);
          if (!table) return null;
          screenPos = projectedPositions[`table_${id}`];
          canDelete = gameState.tables.length > 1 && !table.customer;
          canMove = !table.customer;
          const tableStyleData = TABLE_STYLES[table.style] || TABLE_STYLES.round;
          name = `üçΩÔ∏è ${tableStyleData.name}`;
          refund = Math.floor(tableStyleData.cost * 0.5); // 50% refund based on table cost
          deleteAction = () => dispatch({ type: 'REMOVE_TABLE', payload: { tableId: id } });
        } else if (type === 'chair') {
          const chair = (gameState.chairs || []).find(c => c.id === id);
          if (!chair) return null;
          const chairStyleData = CHAIR_STYLES[chair.style] || CHAIR_STYLES.basicWood;
          const worldX = chair.gridX - GRID.width / 2 + 0.5;
          const worldZ = chair.gridZ - GRID.height / 2 + 0.5;
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.4, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `ü™ë ${chairStyleData.name}`;
          refund = Math.floor(chairStyleData.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_CHAIR', payload: { chairId: id } });
        } else if (type === 'decoration') {
          const decor = gameState.decorations.find(d => d.id === id);
          if (!decor) return null;
          const decorType = DECORATIONS[decor.type];
          const worldX = decor.gridX - GRID.width / 2 + 0.5;
          const worldZ = decor.gridZ - GRID.height / 2 + 0.5;
          // Calculate screen position
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.5, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `${decorType.icon} ${decorType.name}`;
          refund = Math.floor(decorType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DECORATION', payload: { decorationId: id } });
        } else if (type === 'divider') {
          const divider = (gameState.dividers || []).find(d => d.id === id);
          if (!divider) return null;
          const dividerType = DIVIDERS[divider.type];
          const worldX = divider.gridX - GRID.width / 2 + 0.5;
          const worldZ = divider.gridZ - GRID.height / 2 + 0.5;
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.3, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `${dividerType.icon} ${dividerType.name}`;
          refund = Math.floor(dividerType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DIVIDER', payload: { dividerId: id } });
        } else if (type === 'door') {
          const door = (gameState.doors || []).find(d => d.id === id);
          if (!door) return null;
          const doorType = DOORS[door.type];
          // Calculate world position based on wall
          let worldX, worldZ;
          if (door.wall === 'back') {
            worldX = door.wallPosition - GRID.width / 2 + 0.5;
            worldZ = -GRID.height / 2 - 0.15;
          } else if (door.wall === 'left') {
            worldX = -GRID.width / 2 - 0.15;
            worldZ = door.wallPosition - GRID.height / 2 + 0.5;
          } else if (door.wall === 'right') {
            worldX = GRID.width / 2 + 0.15;
            worldZ = door.wallPosition - GRID.height / 2 + 0.5;
          }
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 1.5, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = false; // Doors can't be moved, only deleted and re-placed
          name = `üö™ ${doorType.name}`;
          refund = Math.floor(doorType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DOOR', payload: { doorId: id } });
        }
        
        if (!screenPos) return null;
        
        return (
          <div style={{
            position: 'absolute',
            left: `${screenPos.x}%`,
            top: `${screenPos.y - 8}%`,
            transform: 'translate(-50%, -100%)',
            background: 'rgba(0, 0, 0, 0.9)',
            padding: '8px 12px',
            borderRadius: '8px',
            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
            zIndex: 200,
          }}>
            <div style={{ color: 'white', fontSize: '12px', fontWeight: 'bold', marginBottom: '8px', textAlign: 'center' }}>
              {name}
            </div>
            <div style={{ display: 'flex', gap: '6px' }}>
              <button
                onClick={() => {
                  if (canMove) {
                    const obj = type === 'stove' ? gameState.stoves.find(s => s.id === id) :
                                type === 'counter' ? gameState.counters.find(c => c.id === id) :
                                type === 'table' ? gameState.tables.find(t => t.id === id) :
                                type === 'chair' ? (gameState.chairs || []).find(c => c.id === id) :
                                type === 'divider' ? (gameState.dividers || []).find(d => d.id === id) :
                                gameState.decorations.find(d => d.id === id);
                    if (obj) {
                      const moveData = type === 'decoration' 
                        ? { ...obj, decorationType: obj.type }
                        : type === 'divider'
                        ? { ...obj, dividerType: obj.type }
                        : { ...obj };
                      setMovingObject({ type, id, data: moveData });
                      setPlacementRotation(obj.rotation || 0);
                      setSelectedEditObject(null);
                      SFX.uiClick?.();
                    }
                  }
                }}
                disabled={!canMove}
                style={{
                  background: canMove ? '#3b82f6' : '#6b7280',
                  color: 'white',
                  border: 'none',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  fontSize: '11px',
                  fontWeight: 'bold',
                  cursor: canMove ? 'pointer' : 'not-allowed',
                }}
              >
                ‚úã Move
              </button>
              {(type === 'table' || type === 'chair') && (
                <button
                  onClick={() => {
                    if (canMove) {
                      if (type === 'table') {
                        dispatch({ type: 'ROTATE_TABLE', payload: { tableId: id } });
                      } else if (type === 'chair') {
                        dispatch({ type: 'ROTATE_CHAIR', payload: { chairId: id } });
                      }
                      SFX.uiClick?.();
                    }
                  }}
                  disabled={!canMove}
                  style={{
                    background: canMove ? '#2563eb' : '#6b7280',
                    color: 'white',
                    border: 'none',
                    padding: '6px 10px',
                    borderRadius: '6px',
                    fontSize: '11px',
                    fontWeight: 'bold',
                    cursor: canMove ? 'pointer' : 'not-allowed',
                  }}
                >
                  üîÑ
                </button>
              )}
              <button
                onClick={() => {
                  if (canDelete) {
                    deleteAction();
                    setSelectedEditObject(null);
                    SFX.error();
                  }
                }}
                disabled={!canDelete}
                style={{
                  background: canDelete ? '#dc2626' : '#6b7280',
                  color: 'white',
                  border: 'none',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  fontSize: '11px',
                  fontWeight: 'bold',
                  cursor: canDelete ? 'pointer' : 'not-allowed',
                }}
              >
                üóëÔ∏è +{refund}ü™ô
              </button>
            </div>
          </div>
        );
      })()}
      
      {/* Counter Food Labels - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.counters.map(counter => {
        if (counter.dishes.length === 0) return null;
        const screenPos = projectedPositions[`counter_${counter.id}`];
        if (!screenPos) return null;
        
        const dish = counter.dishes[0];
        const recipe = RECIPES[dish.recipe];
        
        return (
          <div key={counter.id} style={{
            position: 'absolute',
            left: `${screenPos.x}%`,
            top: `${screenPos.y}%`,
            transform: 'translate(-50%, -100%)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
          }}>
            <div style={{
              background: 'rgba(46, 139, 87, 0.9)',
              padding: '4px 8px',
              borderRadius: '6px',
              color: 'white',
              fontSize: '12px',
              textAlign: 'center',
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
            }}>
              <span style={{ fontSize: '16px' }}>{recipe.icon}</span>
              <span>{dish.servings}</span>
            </div>
            <button
              onClick={() => setTrashConfirm({ counterId: counter.id, recipeName: recipe.name, servings: dish.servings, icon: recipe.icon })}
              style={{
                background: 'rgba(239, 68, 68, 0.9)',
                border: 'none',
                borderRadius: '4px',
                padding: '3px 5px',
                cursor: 'pointer',
                fontSize: '10px',
                color: 'white',
              }}
              title={`Trash ${dish.servings} ${recipe.name}`}
            >
              üóëÔ∏è
            </button>
          </div>
        );
      })}
      
      {/* Customer Status Indicators - CLICKABLE - hidden while dragging */}
      {!isDragging && gameState.tables.map(table => {
        if (!table.customer) return null;
        const screenPos = projectedPositions[`table_${table.id}`];
        if (!screenPos) return null;
        
        if (table.customer.state === 'waiting') {
          const patience = table.customer.patience;
          const barColor = patience > 60 ? COLORS.ui.green : patience > 30 ? '#eab308' : COLORS.ui.red;
          const hasFood = totalFood > 0;
          
          // Dynamic emoji based on patience
          const emoji = patience > 60 ? 'üòä' : patience > 30 ? 'üòê' : 'üò†';
          
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: '2px',
              pointerEvents: 'none',
            }}>
              {/* Emoji + optional "ready to order" icon */}
              <div style={{ 
                fontSize: '18px', 
                transition: 'transform 0.2s ease',
                transform: patience < 30 ? 'scale(1.1)' : 'scale(1)',
                filter: patience < 30 ? 'drop-shadow(0 0 3px red)' : 'none',
                display: 'flex',
                alignItems: 'center',
                gap: '2px',
              }}>
                {emoji}
                {hasFood && <span style={{ fontSize: '12px' }}>üö∂</span>}
              </div>
              
              {/* Compact patience bar */}
              <div style={{ 
                width: '32px',
                background: 'rgba(0,0,0,0.4)', 
                borderRadius: '3px', 
                height: '4px',
                overflow: 'hidden',
              }}>
                <div style={{ 
                  width: `${patience}%`, 
                  height: '100%', 
                  background: barColor,
                  transition: 'width 0.1s linear, background 0.3s ease',
                }} />
              </div>
            </div>
          );
        }
        
        if (table.customer.state === 'walking_to_counter') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ 
                fontSize: '14px',
                background: 'rgba(59, 130, 246, 0.85)',
                borderRadius: '50%',
                width: '22px',
                height: '22px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}>üö∂</div>
            </div>
          );
        }
        
        if (table.customer.state === 'walking_to_table') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ 
                fontSize: '14px',
                background: 'rgba(34, 197, 94, 0.85)',
                borderRadius: '50%',
                width: '22px',
                height: '22px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}>üçΩÔ∏è</div>
            </div>
          );
        }
        
        if (table.customer.state === 'eating') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '16px' }}>üòã</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingHappy') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              animation: 'jumpOut 0.8s ease-out forwards',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '18px' }}>üòÑüíö</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingAngry') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              animation: 'stomp 0.2s ease-in-out 4',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '18px' }}>üò°üíî</div>
            </div>
          );
        }
        
        return null;
      })}
      
      {/* Flying Coins Animation */}
      {flyingCoins.filter(coin => {
        const now = Date.now();
        const elapsed = (now - coin.startTime) / 1000;
        // Remove if: animation done (>0.85s), OR invalid/future startTime, OR very old (>5s safety)
        if (elapsed < 0 || elapsed > 5 || !coin.startTime) return false;
        return elapsed < 0.85;
      }).map(coin => {
        const elapsed = (Date.now() - coin.startTime) / 1000;
        const duration = 0.8;
        const progress = Math.min(1, Math.max(0, elapsed / duration)); // Clamp to 0-1
        
        // Ease out curve for smooth deceleration
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        // Calculate position (fly from table to header COIN area)
        // Based on header layout: Cafe name/level (left) | XP bar | Coins | Buzz | Food | Time (right)
        const targetX = 36; // Coins display position (fine-tuned)
        const targetY = 2.5;  // Top of screen %
        const currentX = coin.startX + (targetX - coin.startX) * easeOut;
        const currentY = coin.startY + (targetY - coin.startY) * easeOut;
        
        // Arc effect - rise up in an arc
        const arcHeight = -12 * Math.sin(progress * Math.PI);
        
        return (
          <div
            key={coin.id}
            style={{
              position: 'absolute',
              left: `${currentX}%`,
              top: `${currentY + arcHeight}%`,
              transform: 'translate(-50%, -50%)',
              fontSize: '24px',
              pointerEvents: 'none',
              zIndex: 200,
              opacity: 1 - progress * 0.3,
              filter: `drop-shadow(0 2px 4px rgba(0,0,0,0.3))`,
            }}
          >
            ü™ô
          </div>
        );
      })}
      
      {/* Stats Footer */}
      <div style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: '10px 20px',
        background: 'linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        justifyContent: 'center',
        gap: '30px',
        color: 'white',
        fontSize: '13px',
      }}>
        <div>üç≥ Dishes: {gameState.stats.dishesCooked}</div>
        <div>üòä Served: {gameState.stats.customersServed}</div>
        <div>üí∞ Earned: ${gameState.stats.totalEarned}</div>
      </div>
      
      {/* Cookbook Modal */}
      {(selectedStove || showCookbook) && (() => {
        const recipeEntries = Object.entries(RECIPES);
        const recipesPerPage = 4;
        const totalPages = Math.ceil(recipeEntries.length / recipesPerPage);
        const startIdx = cookbookPage * recipesPerPage;
        const pageRecipes = recipeEntries.slice(startIdx, startIdx + recipesPerPage);
        const isBrowseMode = showCookbook && !selectedStove; // Browse mode = no stove selected
        
        // Use slightly different format for cookbook (more readable)
        const formatCookTime = (seconds) => {
          if (seconds < 60) return `${seconds} secs`;
          if (seconds < 3600) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return secs > 0 ? `${mins}m ${secs}s` : `${mins} mins`;
          }
          const hours = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          if (mins > 0) return `${hours}h ${mins}m`;
          return `${hours} hour${hours > 1 ? 's' : ''}`;
        };
        
        const closeCookbook = () => {
          setSelectedStove(null);
          setShowCookbook(false);
          setCookbookPage(0);
        };
        
        return (
          <div style={{
            position: 'absolute',
            inset: 0,
            background: 'rgba(0,0,0,0.7)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 100,
          }} onClick={closeCookbook}>
            <div 
              style={{
                background: 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)',
                borderRadius: '20px',
                padding: '0',
                maxWidth: '620px',
                width: '95%',
                overflow: 'hidden',
                boxShadow: '0 10px 40px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.5)',
                border: '5px solid #b45309',
              }} 
              onClick={e => e.stopPropagation()}
              onWheel={(e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.deltaY > 0) {
                  // Scroll down = next page
                  setCookbookPage(p => Math.min(totalPages - 1, p + 1));
                } else if (e.deltaY < 0) {
                  // Scroll up = previous page
                  setCookbookPage(p => Math.max(0, p - 1));
                }
              }}
            >
              
              {/* Cookbook Header */}
              <div style={{
                background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                padding: '12px 20px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                borderBottom: '3px solid #92400e',
              }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '28px' }}>üìñ</span>
                  <h2 style={{ 
                    margin: 0, 
                    color: '#451a03',
                    fontWeight: 'bold',
                    fontSize: '22px',
                    textShadow: '1px 1px 0 rgba(255,255,255,0.3)',
                    letterSpacing: '2px',
                  }}>{isBrowseMode ? 'RECIPE BOOK' : 'COOKBOOK'}</h2>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                  <div style={{ 
                    background: 'rgba(255,255,255,0.4)', 
                    padding: '6px 14px', 
                    borderRadius: '14px',
                    fontWeight: 'bold',
                    color: '#451a03',
                    fontSize: '15px',
                    boxShadow: 'inset 0 1px 2px rgba(0,0,0,0.1)',
                  }}>
                    ü™ô {gameState.coins.toLocaleString()}
                  </div>
                  <button
                    onClick={closeCookbook}
                    style={{
                      background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                      border: '2px solid #991b1b',
                      borderRadius: '50%',
                      width: '34px',
                      height: '34px',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '20px',
                      fontWeight: 'bold',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >√ó</button>
                </div>
              </div>
              
              {/* Content Area with Navigation */}
              <div style={{ 
                display: 'flex', 
                alignItems: 'stretch',
                padding: '15px 10px',
                gap: '10px',
                minHeight: '380px',
              }}>
                
                {/* Left Arrow */}
                <button
                  onClick={() => setCookbookPage(p => Math.max(0, p - 1))}
                  disabled={cookbookPage === 0}
                  style={{
                    background: cookbookPage === 0 ? '#d1d5db' : 'linear-gradient(135deg, #f59e0b, #d97706)',
                    border: cookbookPage === 0 ? '2px solid #9ca3af' : '2px solid #92400e',
                    borderRadius: '10px',
                    width: '44px',
                    color: cookbookPage === 0 ? '#9ca3af' : 'white',
                    cursor: cookbookPage === 0 ? 'not-allowed' : 'pointer',
                    fontSize: '24px',
                    fontWeight: 'bold',
                    boxShadow: cookbookPage === 0 ? 'none' : '0 2px 6px rgba(0,0,0,0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >‚óÄ</button>
                
                {/* Recipe Grid - 2x2 */}
                <div style={{
                  flex: 1,
                  display: 'grid',
                  gridTemplateColumns: 'repeat(2, 1fr)',
                  gridTemplateRows: 'repeat(2, 1fr)',
                  gap: '12px',
                }}>
                  {pageRecipes.map(([key, recipe]) => {
                    const totalRevenue = recipe.servings * recipe.revenue;
                    const profit = totalRevenue - recipe.cost;
                    const isUnlocked = recipe.level <= gameState.level;
                    const canAfford = gameState.coins >= recipe.cost;
                    const isNew = recipe.level === gameState.level && recipe.level > 1;
                    
                    if (!isUnlocked) {
                      return (
                        <div
                          key={key}
                          style={{
                            background: 'linear-gradient(135deg, #e5e7eb, #d1d5db)',
                            borderRadius: '14px',
                            padding: '12px',
                            border: '3px dashed #9ca3af',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            opacity: 0.7,
                          }}
                        >
                          <span style={{ fontSize: '48px', filter: 'grayscale(1) brightness(1.3)', marginBottom: '8px' }}>
                            {recipe.icon}
                          </span>
                          <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#6b7280', marginBottom: '4px' }}>
                            {recipe.name}
                          </div>
                          <div style={{
                            background: '#6b7280',
                            color: 'white',
                            padding: '4px 12px',
                            borderRadius: '10px',
                            fontSize: '12px',
                            fontWeight: 'bold',
                          }}>
                            üîí Level {recipe.level}
                          </div>
                        </div>
                      );
                    }
                    
                    return (
                      <div
                        key={key}
                        style={{
                          background: 'linear-gradient(135deg, #fff 0%, #fef9c3 100%)',
                          borderRadius: '14px',
                          padding: '12px',
                          border: isNew ? '3px solid #f59e0b' : '3px solid #a3a3a3',
                          display: 'flex',
                          flexDirection: 'column',
                          boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                          position: 'relative',
                        }}
                      >
                        {/* NEW Badge */}
                        {isNew && (
                          <div style={{
                            position: 'absolute',
                            top: -8,
                            right: -8,
                            background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                            color: 'white',
                            fontSize: '10px',
                            fontWeight: 'bold',
                            padding: '3px 8px',
                            borderRadius: '8px',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                            animation: 'pulse 1s infinite',
                          }}>
                            NEW!
                          </div>
                        )}
                        
                        {/* Recipe Name */}
                        <div style={{
                          fontWeight: 'bold',
                          fontSize: '14px',
                          color: '#1f2937',
                          marginBottom: '6px',
                          textAlign: 'center',
                        }}>
                          {recipe.name}
                        </div>
                        
                        {/* Icon and Cost */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '8px' }}>
                          <div style={{
                            background: 'linear-gradient(135deg, #dbeafe, #bfdbfe)',
                            borderRadius: '10px',
                            padding: '8px',
                            border: '2px solid #93c5fd',
                          }}>
                            <span style={{ fontSize: '36px' }}>{recipe.icon}</span>
                          </div>
                          
                          <div style={{ flex: 1, fontSize: '12px', color: '#4b5563' }}>
                            <div style={{ marginBottom: '2px' }}>
                              <strong>Cost:</strong>{' '}
                              <span style={{
                                background: '#fef3c7',
                                padding: '2px 6px',
                                borderRadius: '6px',
                                color: '#92400e',
                                fontWeight: 'bold',
                              }}>ü™ô {recipe.cost}</span>
                            </div>
                            <div><strong>Servings:</strong> {recipe.servings}</div>
                          </div>
                        </div>
                        
                        {/* Earnings Info */}
                        <div style={{
                          background: '#f0fdf4',
                          borderRadius: '8px',
                          padding: '6px 8px',
                          marginBottom: '8px',
                          fontSize: '11px',
                          border: '1px solid #bbf7d0',
                        }}>
                          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '2px' }}>
                            <span>Earns:</span>
                            <span style={{ color: '#15803d', fontWeight: 'bold' }}>
                              ü™ô {recipe.revenue} per serving
                            </span>
                          </div>
                          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                            <span></span>
                            <span style={{ color: '#166534', fontWeight: 'bold' }}>
                              ü™ô {totalRevenue} total
                            </span>
                          </div>
                        </div>
                        
                        {/* Ready Time & XP */}
                        <div style={{
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          fontSize: '11px',
                          marginBottom: '8px',
                          padding: '4px 8px',
                          background: 'linear-gradient(135deg, #fef3c7, #fde68a)',
                          borderRadius: '6px',
                          border: '1px solid #fbbf24',
                        }}>
                          <div>
                            <span style={{ color: '#78350f' }}>‚è±Ô∏è </span>
                            <span style={{ color: '#dc2626', fontWeight: 'bold' }}>
                              {formatCookTime(recipe.cookTime)}
                            </span>
                          </div>
                          <div>
                            <span style={{ color: '#78350f' }}>‚≠ê </span>
                            <span style={{ color: '#7c3aed', fontWeight: 'bold' }}>
                              +{recipe.xp} XP
                            </span>
                          </div>
                        </div>
                        
                        {/* Mastery Progress */}
                        {(() => {
                          const mastery = gameState.dishMastery?.[key] || { cooked: 0 };
                          const level = getMasteryLevel(gameState.dishMastery, key);
                          const nextLevel = level < 3 ? level + 1 : 3;
                          const nextThreshold = level < 3 ? MASTERY_LEVELS[nextLevel].cooksRequired : MASTERY_LEVELS[3].cooksRequired;
                          const prevThreshold = level > 0 ? MASTERY_LEVELS[level].cooksRequired : 0;
                          const progressInLevel = level < 3 
                            ? ((mastery.cooked - prevThreshold) / (nextThreshold - prevThreshold)) * 100
                            : 100;
                          
                          const plateColors = {
                            0: '#FFFAF0', // Ivory (default)
                            1: '#87CEEB', // Light blue
                            2: '#4169E1', // Royal blue  
                            3: '#FFD700', // Gold
                          };
                          
                          return (
                            <div style={{
                              background: level > 0 
                                ? `linear-gradient(135deg, ${level === 3 ? '#fef3c7' : level === 2 ? '#dbeafe' : '#e0f2fe'}, white)`
                                : '#f9fafb',
                              borderRadius: '8px',
                              padding: '6px 8px',
                              marginBottom: '8px',
                              fontSize: '10px',
                              border: `1px solid ${level === 3 ? '#fbbf24' : level === 2 ? '#60a5fa' : level === 1 ? '#7dd3fc' : '#e5e7eb'}`,
                            }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '3px' }}>
                                {/* Plate indicator */}
                                <div style={{
                                  width: '14px',
                                  height: '14px',
                                  borderRadius: '50%',
                                  background: plateColors[level],
                                  border: `2px solid ${level === 3 ? '#b8860b' : level === 2 ? '#1e40af' : level === 1 ? '#0284c7' : '#d1d5db'}`,
                                  boxShadow: level === 3 ? '0 0 4px #fbbf24' : 'none',
                                }} />
                                <span style={{ fontWeight: 'bold', color: '#374151' }}>
                                  {level === 0 ? 'No Mastery' : MASTERY_LEVELS[level].name}
                                </span>
                                <span style={{ marginLeft: 'auto', color: '#6b7280' }}>
                                  {mastery.cooked}/{level < 3 ? nextThreshold : '‚úì'}
                                </span>
                              </div>
                              
                              {/* Progress bar */}
                              <div style={{
                                background: '#e5e7eb',
                                borderRadius: '4px',
                                height: '4px',
                                overflow: 'hidden',
                              }}>
                                <div style={{
                                  width: `${Math.min(100, progressInLevel)}%`,
                                  height: '100%',
                                  background: level === 3 ? '#fbbf24' : level === 2 ? '#3b82f6' : level === 1 ? '#38bdf8' : '#9ca3af',
                                  transition: 'width 0.3s ease',
                                }} />
                              </div>
                              
                              {/* Bonus indicators */}
                              {level > 0 && (
                                <div style={{ display: 'flex', gap: '6px', marginTop: '4px', flexWrap: 'wrap' }}>
                                  {level >= 1 && (
                                    <span style={{ 
                                      background: '#dcfce7', 
                                      color: '#15803d', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% Servings</span>
                                  )}
                                  {level >= 2 && (
                                    <span style={{ 
                                      background: '#ede9fe', 
                                      color: '#6d28d9', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% XP</span>
                                  )}
                                  {level >= 3 && (
                                    <span style={{ 
                                      background: '#fef3c7', 
                                      color: '#b45309', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% Speed</span>
                                  )}
                                </div>
                              )}
                            </div>
                          );
                        })()}
                        
                        {/* Buy Button - Only in cooking mode */}
                        {!isBrowseMode ? (
                          <button
                            onClick={() => handleRecipeSelect(key)}
                            disabled={!canAfford}
                            style={{
                              background: canAfford 
                                ? 'linear-gradient(135deg, #22c55e, #16a34a)' 
                                : 'linear-gradient(135deg, #9ca3af, #6b7280)',
                              border: canAfford ? '2px solid #15803d' : '2px solid #4b5563',
                              borderRadius: '10px',
                              padding: '8px 0',
                              color: 'white',
                              fontWeight: 'bold',
                              fontSize: '14px',
                              cursor: canAfford ? 'pointer' : 'not-allowed',
                              boxShadow: canAfford ? '0 2px 6px rgba(0,0,0,0.2)' : 'none',
                              letterSpacing: '1px',
                            }}
                          >
                            {canAfford ? 'COOK!' : 'Need ü™ô' + recipe.cost}
                          </button>
                        ) : (
                          <div style={{
                            background: 'linear-gradient(135deg, #e5e7eb, #d1d5db)',
                            border: '2px solid #9ca3af',
                            borderRadius: '10px',
                            padding: '8px 0',
                            color: '#6b7280',
                            fontWeight: 'bold',
                            fontSize: '12px',
                            textAlign: 'center',
                            letterSpacing: '0.5px',
                          }}>
                            Click stove to cook
                          </div>
                        )}
                      </div>
                    );
                  })}
                  
                  {/* Fill empty slots */}
                  {[...Array(recipesPerPage - pageRecipes.length)].map((_, i) => (
                    <div key={`empty-${i}`} style={{
                      background: 'rgba(0,0,0,0.05)',
                      borderRadius: '14px',
                      border: '3px dashed #d1d5db',
                    }} />
                  ))}
                </div>
                
                {/* Right Arrow */}
                <button
                  onClick={() => setCookbookPage(p => Math.min(totalPages - 1, p + 1))}
                  disabled={cookbookPage >= totalPages - 1}
                  style={{
                    background: cookbookPage >= totalPages - 1 ? '#d1d5db' : 'linear-gradient(135deg, #f59e0b, #d97706)',
                    border: cookbookPage >= totalPages - 1 ? '2px solid #9ca3af' : '2px solid #92400e',
                    borderRadius: '10px',
                    width: '44px',
                    color: cookbookPage >= totalPages - 1 ? '#9ca3af' : 'white',
                    cursor: cookbookPage >= totalPages - 1 ? 'not-allowed' : 'pointer',
                    fontSize: '24px',
                    fontWeight: 'bold',
                    boxShadow: cookbookPage >= totalPages - 1 ? 'none' : '0 2px 6px rgba(0,0,0,0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >‚ñ∂</button>
              </div>
              
              {/* Page Indicator */}
              <div style={{
                background: 'rgba(0,0,0,0.1)',
                padding: '10px',
                textAlign: 'center',
                borderTop: '2px solid rgba(0,0,0,0.1)',
              }}>
                <span style={{ color: '#78350f', fontSize: '14px' }}>
                  Page {cookbookPage + 1} of {totalPages}
                </span>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '6px', marginTop: '6px' }}>
                  {[...Array(totalPages)].map((_, i) => (
                    <button
                      key={i}
                      onClick={() => setCookbookPage(i)}
                      style={{
                        width: '10px',
                        height: '10px',
                        borderRadius: '50%',
                        border: 'none',
                        background: i === cookbookPage ? '#d97706' : '#d1d5db',
                        cursor: 'pointer',
                        padding: 0,
                      }}
                    />
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      })()}
      
      {/* Decoration Placement Mode UI - Only when shop is closed */}
      {placingDecoration && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #e8f5e9, #c8e6c9)',
          borderTop: '3px solid #4CAF50',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {DECORATIONS[placingDecoration].icon}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#2e7d32' }}>
              Placing: {DECORATIONS[placingDecoration].name} (ü™ô{DECORATIONS[placingDecoration].cost})
            </div>
            <div style={{ fontSize: '13px', color: '#558b2f' }}>
              {DECORATIONS[placingDecoration].category === 'wall' 
                ? 'Click near any wall to hang ‚Ä¢ Keep clicking to place more!'
                : 'Click on the floor to place ‚Ä¢ Keep clicking to place more!'}
            </div>
          </div>
          <button
            onClick={() => setPlacingDecoration(null)}
            style={{
              background: '#4CAF50',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            ‚úì Done
          </button>
        </div>
      )}
      
      {/* Divider Placement Mode UI */}
      {placingDivider && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #fff3e0, #ffe0b2)',
          borderTop: '3px solid #ff9800',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {DIVIDERS[placingDivider].icon}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#e65100' }}>
              Placing: {DIVIDERS[placingDivider].name} (ü™ô{DIVIDERS[placingDivider].cost})
            </div>
            <div style={{ fontSize: '13px', color: '#f57c00' }}>
              Click to place ‚Ä¢ R to rotate ‚Ä¢ Keep clicking to place more!
            </div>
          </div>
          <button
            onClick={() => {
              setPlacingDivider(null);
              setPlacementRotation(0);
            }}
            style={{
              background: '#ff9800',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            ‚úì Done
          </button>
        </div>
      )}
      
      {/* Equipment Placement Mode UI - Only when shop is closed */}
      {placingEquipment && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #fff3e0, #ffe0b2)',
          borderTop: '3px solid #FF9800',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {placingEquipment === 'stove' ? 'üî•' : placingEquipment === 'counter' ? 'üçΩÔ∏è' : placingEquipment === 'chair' ? 'ü™ë' : 'üçΩÔ∏è'}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#e65100' }}>
              Placing: {placingEquipment === 'stove' ? 'Stove (ü™ô500)' 
                : placingEquipment === 'counter' ? 'Counter (ü™ô400)' 
                : placingEquipment === 'chair' ? `Chair (ü™ô${CHAIR_STYLES[placingChairStyle]?.cost || 100})`
                : `Table (ü™ô${TABLE_STYLES[placingTableStyle]?.cost || 300})`}
            </div>
            <div style={{ fontSize: '13px', color: '#f57c00' }}>
              {placingEquipment === 'table' 
                ? 'Click in DINING area ‚Ä¢ R to rotate'
                : placingEquipment === 'chair'
                ? 'Click in DINING area ‚Ä¢ Place next to table ‚Ä¢ R to rotate'
                : placingEquipment === 'counter'
                ? 'Click anywhere ‚Ä¢ R to rotate ‚Ä¢ Customers pick up from front'
                : 'Click in KITCHEN area ‚Ä¢ R to rotate ‚Ä¢ Chef interacts from front'}
            </div>
          </div>
          <button
            onClick={() => {
              setPlacingEquipment(null);
              setPlacementRotation(0);
            }}
            style={{
              background: '#ff9800',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            ‚úì Done
          </button>
        </div>
      )}
      
      {/* Settings/Save Modal */}
      {showSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 100,
        }} onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}>
          <div style={{
            background: 'white',
            borderRadius: '16px',
            padding: '20px',
            maxWidth: '400px',
            width: '90%',
          }} onClick={e => e.stopPropagation()}>
            <h2 style={{ margin: '0 0 15px', textAlign: 'center' }}>üíæ Save / Load</h2>
            
            {saveMessage && (
              <div style={{
                marginBottom: '15px',
                padding: '10px',
                borderRadius: '8px',
                background: saveMessage.type === 'success' ? '#dcfce7' : '#fef2f2',
                color: saveMessage.type === 'success' ? '#166534' : '#991b1b',
                textAlign: 'center',
                fontSize: '14px',
              }}>
                {saveMessage.type === 'success' ? '‚úÖ' : '‚ùå'} {saveMessage.text}
              </div>
            )}
            
            <div style={{ display: 'grid', gap: '10px' }}>
              <button
                onClick={handleExportSave}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '12px',
                  border: '2px solid #22c55e',
                  borderRadius: '10px',
                  background: '#f0fdf4',
                  cursor: 'pointer',
                }}
              >
                <span style={{ fontSize: '24px' }}>üì§</span>
                <div style={{ flex: 1, textAlign: 'left' }}>
                  <div style={{ fontWeight: 'bold' }}>Export Save</div>
                  <div style={{ fontSize: '11px', color: '#666' }}>Generate save data to copy</div>
                </div>
              </button>
              
              {showExportText && (
                <div style={{ position: 'relative' }}>
                  <textarea
                    value={saveTextArea}
                    readOnly
                    onClick={(e) => e.target.select()}
                    style={{
                      width: '100%',
                      height: '60px',
                      padding: '8px',
                      border: '2px solid #22c55e',
                      borderRadius: '8px',
                      fontFamily: 'monospace',
                      fontSize: '10px',
                      resize: 'none',
                      background: '#f0fdf4',
                    }}
                  />
                  <div style={{ fontSize: '11px', color: '#666', marginTop: '4px' }}>
                    üëÜ Click to select, then Ctrl+C / Cmd+C to copy
                  </div>
                </div>
              )}
              
              <div style={{ borderTop: '1px solid #e0e0e0', margin: '5px 0' }} />
              
              <div style={{ fontSize: '12px', color: '#666', textAlign: 'center' }}>
                To load: paste save data below, then click Import
              </div>
              
              <textarea
                value={showExportText ? '' : saveTextArea}
                onChange={(e) => { setSaveTextArea(e.target.value); setShowExportText(false); }}
                placeholder="Paste your save data here..."
                style={{
                  width: '100%',
                  height: '60px',
                  padding: '8px',
                  border: '2px solid #3b82f6',
                  borderRadius: '8px',
                  fontFamily: 'monospace',
                  fontSize: '10px',
                  resize: 'none',
                }}
              />
              
              <button
                onClick={handleImportSave}
                disabled={!saveTextArea.trim() || showExportText}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  padding: '12px',
                  border: 'none',
                  borderRadius: '10px',
                  background: (!saveTextArea.trim() || showExportText) ? '#e0e0e0' : '#3b82f6',
                  color: 'white',
                  cursor: (!saveTextArea.trim() || showExportText) ? 'not-allowed' : 'pointer',
                  fontWeight: 'bold',
                }}
              >
                <span>üì•</span> Import Save
              </button>
            </div>
            
            <div style={{
              marginTop: '15px',
              padding: '10px',
              background: '#f8fafc',
              borderRadius: '8px',
              fontSize: '11px',
              color: '#64748b',
            }}>
              <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>üìä Current Progress:</div>
              <div>Level {gameState.level} ‚Ä¢ {gameState.coins.toLocaleString()} coins ‚Ä¢ {gameState.stats.customersServed} served</div>
              <div>{gameState.stoves.length} stoves ‚Ä¢ {gameState.counters.length} counters ‚Ä¢ {gameState.tables.length} tables</div>
            </div>
            
            {/* Clear stuck coins button */}
            {flyingCoins.length > 0 && (
              <button
                onClick={() => {
                  setFlyingCoins([]);
                  setSaveMessage({ type: 'success', text: 'Cleared ' + flyingCoins.length + ' stuck coin(s)!' });
                  setTimeout(() => setSaveMessage(null), 2000);
                }}
                style={{
                  width: '100%',
                  marginTop: '10px',
                  padding: '10px',
                  border: '2px solid #f59e0b',
                  borderRadius: '8px',
                  background: '#fffbeb',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  fontSize: '13px',
                }}
              >
                <span>ü™ô</span> Clear Stuck Coins ({flyingCoins.length})
              </button>
            )}
            
            <button
              onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}
              style={{
                width: '100%',
                marginTop: '15px',
                padding: '10px',
                border: 'none',
                borderRadius: '8px',
                background: '#f0f0f0',
                cursor: 'pointer',
              }}
            >
              Close
            </button>
          </div>
        </div>
      )}
      
      {/* Level Up Celebration */}
      {showLevelUp && (() => {
        const unlockedRecipe = Object.values(RECIPES).find(r => r.level === gameState.level);
        return (
          <div style={{
            position: 'absolute',
            inset: 0,
            background: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 100,
            animation: 'fadeIn 0.3s ease',
          }}>
            <div style={{
              background: 'linear-gradient(135deg, #ffd700, #ffec8b)',
              borderRadius: '20px',
              padding: '30px 50px',
              textAlign: 'center',
              boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
              animation: 'bounceIn 0.5s ease',
            }}>
              <div style={{ fontSize: '48px', marginBottom: '10px' }}>üéâ</div>
              <h2 style={{ margin: '0 0 10px', color: '#8b4513' }}>Level Up!</h2>
              <div style={{ fontSize: '36px', fontWeight: 'bold', color: '#8b4513' }}>Level {gameState.level}</div>
              <div style={{ marginTop: '10px', color: '#a0522d' }}>+1000 coins bonus!</div>
              {unlockedRecipe && (
                <div style={{ 
                  marginTop: '15px', 
                  padding: '10px 15px',
                  background: 'rgba(255,255,255,0.5)',
                  borderRadius: '10px',
                }}>
                  <div style={{ fontSize: '12px', color: '#666' }}>üîì New Recipe Unlocked!</div>
                  <div style={{ fontSize: '24px', marginTop: '5px' }}>
                    {unlockedRecipe.icon} {unlockedRecipe.name}
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      })()}
      
      {/* Achievement Unlocked Popup */}
      {showAchievement && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.4)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 110,
          animation: 'fadeIn 0.3s ease',
        }}>
          <div style={{
            background: 'linear-gradient(180deg, #fef7ed 0%, #fdf2e3 50%, #f5e6d3 100%)',
            borderRadius: '20px',
            padding: '0',
            textAlign: 'center',
            boxShadow: '0 12px 40px rgba(139, 90, 43, 0.35), 0 4px 12px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8)',
            border: '3px solid #c9a66b',
            position: 'relative',
            minWidth: '280px',
            maxWidth: '320px',
            animation: 'bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55)',
            overflow: 'hidden',
          }}>
            {/* Close button */}
            <button
              onClick={() => setShowAchievement(null)}
              style={{
                position: 'absolute',
                top: '8px',
                right: '8px',
                background: 'rgba(139, 90, 43, 0.15)',
                border: 'none',
                borderRadius: '50%',
                width: '28px',
                height: '28px',
                cursor: 'pointer',
                fontSize: '16px',
                color: '#8b5a2b',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                transition: 'all 0.2s',
              }}
              onMouseOver={(e) => e.target.style.background = 'rgba(139, 90, 43, 0.3)'}
              onMouseOut={(e) => e.target.style.background = 'rgba(139, 90, 43, 0.15)'}
            >
              ‚úï
            </button>
            
            {/* Ribbon banner at top */}
            <div style={{
              background: 'linear-gradient(135deg, #d4a574 0%, #c9956c 50%, #b8845c 100%)',
              padding: '10px 20px',
              marginBottom: '15px',
              boxShadow: '0 2px 8px rgba(139, 90, 43, 0.3)',
              position: 'relative',
            }}>
              <div style={{
                fontSize: '13px',
                fontWeight: 'bold',
                color: '#fff',
                textShadow: '0 1px 2px rgba(0,0,0,0.2)',
                letterSpacing: '1px',
                textTransform: 'uppercase',
              }}>
                üèÜ Achievement Unlocked!
              </div>
              {/* Ribbon tails */}
              <div style={{
                position: 'absolute',
                bottom: '-6px',
                left: '20px',
                width: '0',
                height: '0',
                borderLeft: '8px solid transparent',
                borderRight: '8px solid transparent',
                borderTop: '6px solid #a07050',
              }} />
              <div style={{
                position: 'absolute',
                bottom: '-6px',
                right: '20px',
                width: '0',
                height: '0',
                borderLeft: '8px solid transparent',
                borderRight: '8px solid transparent',
                borderTop: '6px solid #a07050',
              }} />
            </div>
            
            {/* Content */}
            <div style={{ padding: '5px 25px 20px' }}>
              {/* Icon with decorative circle */}
              <div style={{
                width: '70px',
                height: '70px',
                margin: '0 auto 12px',
                background: 'linear-gradient(135deg, #fff9f0, #f5ebe0)',
                borderRadius: '50%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: '36px',
                boxShadow: '0 4px 12px rgba(139, 90, 43, 0.2), inset 0 -2px 4px rgba(139, 90, 43, 0.1)',
                border: '2px solid #d4a574',
              }}>
                {showAchievement.icon}
              </div>
              
              {/* Title */}
              <div style={{
                fontSize: '22px',
                fontWeight: 'bold',
                color: '#5c3d2e',
                marginBottom: '6px',
                textShadow: '0 1px 0 rgba(255,255,255,0.5)',
              }}>
                {showAchievement.name}
              </div>
              
              {/* Description */}
              <div style={{
                fontSize: '13px',
                color: '#8b6d5c',
                marginBottom: '15px',
                lineHeight: 1.4,
              }}>
                {showAchievement.description}
              </div>
              
              {/* Reward badge */}
              <div style={{
                display: 'inline-flex',
                alignItems: 'center',
                gap: '6px',
                background: 'linear-gradient(135deg, #ffd700, #ffb700)',
                padding: '8px 16px',
                borderRadius: '20px',
                boxShadow: '0 3px 8px rgba(255, 183, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.5)',
                marginBottom: '15px',
              }}>
                <span style={{ fontSize: '16px', fontWeight: 'bold', color: '#5c3d2e' }}>
                  +{showAchievement.reward}
                </span>
                <span style={{ fontSize: '18px' }}>ü™ô</span>
              </div>
              
              {/* OK Button */}
              <div>
                <button
                  onClick={() => setShowAchievement(null)}
                  style={{
                    background: 'linear-gradient(135deg, #6b8e23, #556b2f)',
                    border: 'none',
                    borderRadius: '12px',
                    padding: '10px 40px',
                    fontSize: '15px',
                    fontWeight: 'bold',
                    color: 'white',
                    cursor: 'pointer',
                    boxShadow: '0 4px 12px rgba(85, 107, 47, 0.4), inset 0 1px 0 rgba(255,255,255,0.2)',
                    textShadow: '0 1px 2px rgba(0,0,0,0.2)',
                    transition: 'all 0.2s',
                  }}
                  onMouseOver={(e) => {
                    e.target.style.transform = 'scale(1.05)';
                    e.target.style.boxShadow = '0 6px 16px rgba(85, 107, 47, 0.5), inset 0 1px 0 rgba(255,255,255,0.2)';
                  }}
                  onMouseOut={(e) => {
                    e.target.style.transform = 'scale(1)';
                    e.target.style.boxShadow = '0 4px 12px rgba(85, 107, 47, 0.4), inset 0 1px 0 rgba(255,255,255,0.2)';
                  }}
                >
                  Awesome! ‚úì
                </button>
              </div>
            </div>
            
            {/* Decorative corner flourishes */}
            <div style={{
              position: 'absolute',
              bottom: '10px',
              left: '10px',
              fontSize: '14px',
              opacity: 0.3,
            }}>‚òï</div>
            <div style={{
              position: 'absolute',
              bottom: '10px',
              right: '10px',
              fontSize: '14px',
              opacity: 0.3,
            }}>‚òï</div>
          </div>
        </div>
      )}
      
      {/* Trophies Panel */}
      {showTrophies && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1a1a2e, #16213e)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '500px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: '#ffd700', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>üèÜ</span> Achievements
              </h2>
              <button
                onClick={() => setShowTrophies(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            <div style={{ 
              color: 'rgba(255,255,255,0.6)', 
              marginBottom: '15px',
              fontSize: '14px',
            }}>
              {gameState.achievements.length} of {Object.keys(ACHIEVEMENTS).length} unlocked
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
              {Object.values(ACHIEVEMENTS).map(ach => {
                const unlocked = gameState.achievements.includes(ach.id);
                return (
                  <div key={ach.id} style={{
                    background: unlocked 
                      ? 'linear-gradient(135deg, rgba(147, 51, 234, 0.3), rgba(124, 58, 237, 0.2))'
                      : 'rgba(255,255,255,0.05)',
                    borderRadius: '12px',
                    padding: '12px 15px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '12px',
                    border: unlocked ? '1px solid rgba(147, 51, 234, 0.5)' : '1px solid rgba(255,255,255,0.1)',
                    opacity: unlocked ? 1 : 0.5,
                  }}>
                    <div style={{ 
                      fontSize: '28px',
                      filter: unlocked ? 'none' : 'grayscale(1)',
                    }}>
                      {ach.icon}
                    </div>
                    <div style={{ flex: 1 }}>
                      <div style={{ 
                        color: unlocked ? 'white' : 'rgba(255,255,255,0.5)', 
                        fontWeight: 'bold',
                        fontSize: '14px',
                      }}>
                        {ach.name}
                      </div>
                      <div style={{ 
                        color: 'rgba(255,255,255,0.5)', 
                        fontSize: '12px',
                      }}>
                        {ach.description}
                      </div>
                    </div>
                    <div style={{ 
                      color: unlocked ? '#ffd700' : 'rgba(255,255,255,0.3)',
                      fontSize: '12px',
                      fontWeight: 'bold',
                    }}>
                      {unlocked ? '‚úì' : `+${ach.reward} ü™ô`}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}
      
      {/* Settings Panel */}
      {showAudioSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '450px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>‚öôÔ∏è</span> Settings
              </h2>
              <button
                onClick={() => setShowAudioSettings(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            {/* Display Settings Section */}
            <div style={{ marginBottom: '20px' }}>
              <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '1px' }}>
                Display
              </div>
              
              {/* Brightness Slider */}
              <div style={{
                background: 'rgba(255,255,255,0.05)',
                borderRadius: '12px',
                padding: '12px 15px',
                marginBottom: '10px',
                border: '1px solid rgba(255,255,255,0.1)',
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ color: 'white', fontWeight: 'bold' }}>‚òÄÔ∏è Brightness</div>
                  <div style={{ color: 'rgba(255,255,255,0.7)', fontSize: '14px' }}>{Math.round(brightness * 100)}%</div>
                </div>
                <input
                  type="range"
                  min="50"
                  max="150"
                  value={brightness * 100}
                  onChange={(e) => setBrightness(Number(e.target.value) / 100)}
                  style={{
                    width: '100%',
                    height: '8px',
                    borderRadius: '4px',
                    background: `linear-gradient(to right, #4a5568 0%, #fbbf24 50%, #fef3c7 100%)`,
                    appearance: 'none',
                    cursor: 'pointer',
                  }}
                />
                <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '4px' }}>
                  <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: '10px' }}>Darker</span>
                  <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: '10px' }}>Brighter</span>
                </div>
              </div>
            </div>
            
            {/* Audio Settings Section */}
            <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '1px' }}>
              Audio
            </div>
            
            {/* Master Toggle */}
            <div style={{
              background: soundEnabled ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255,255,255,0.05)',
              borderRadius: '12px',
              padding: '12px 15px',
              marginBottom: '15px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              border: soundEnabled ? '1px solid rgba(34, 197, 94, 0.4)' : '1px solid rgba(255,255,255,0.1)',
            }}>
              <div style={{ color: 'white', fontWeight: 'bold' }}>üîä Master Volume</div>
              <button
                onClick={() => setSoundEnabled(!soundEnabled)}
                style={{
                  background: soundEnabled ? '#22c55e' : '#666',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '6px 16px',
                  color: 'white',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                }}
              >
                {soundEnabled ? 'ON' : 'OFF'}
              </button>
            </div>
            
            <div style={{ color: 'rgba(255,255,255,0.5)', fontSize: '12px', marginBottom: '10px' }}>
              Individual Sounds (click üîà to preview)
            </div>
            
            {/* Individual Sound Toggles */}
            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
              {[
                { key: 'cooking', name: 'Cooking Sizzle', icon: 'üî•', sfx: () => SFX.cookStart() },
                { key: 'foodReady', name: 'Food Ready', icon: '‚ú®', sfx: () => SFX.foodReady() },
                { key: 'foodSpoiled', name: 'Food Spoiled', icon: 'üí®', sfx: () => SFX.foodSpoiled() },
                { key: 'customerArrive', name: 'Customer Arrives', icon: 'üö™', sfx: () => SFX.customerArrive() },
                { key: 'customerServed', name: 'Customer Served', icon: 'üçΩÔ∏è', sfx: () => SFX.customerServed() },
                { key: 'customerHappy', name: 'Customer Happy', icon: 'üòä', sfx: () => SFX.customerHappy() },
                { key: 'customerAngry', name: 'Customer Angry', icon: 'üò†', sfx: () => SFX.customerAngry() },
                { key: 'coins', name: 'Coins', icon: 'üí∞', sfx: () => SFX.coinEarn() },
                { key: 'purchase', name: 'Purchase', icon: 'üõí', sfx: () => SFX.purchase() },
                { key: 'levelUp', name: 'Level Up', icon: 'üéâ', sfx: () => SFX.levelUp() },
                { key: 'achievement', name: 'Achievement', icon: 'üèÜ', sfx: () => SFX.achievement() },
              ].map(sound => (
                <div key={sound.key} style={{
                  background: 'rgba(255,255,255,0.05)',
                  borderRadius: '10px',
                  padding: '10px 12px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '10px',
                  border: '1px solid rgba(255,255,255,0.1)',
                }}>
                  <span style={{ fontSize: '18px', width: '24px' }}>{sound.icon}</span>
                  <span style={{ flex: 1, color: 'white', fontSize: '13px' }}>{sound.name}</span>
                  
                  {/* Sample Button - works even if sound is toggled off, for testing */}
                  <button
                    onClick={() => {
                      if (soundEnabled) {
                        // Temporarily enable this sound for preview
                        const oldValue = soundTogglesGlobal[sound.key];
                        soundTogglesGlobal[sound.key] = true;
                        sound.sfx();
                        // Restore after sounds complete
                        setTimeout(() => { soundTogglesGlobal[sound.key] = oldValue; }, 1500);
                      }
                    }}
                    style={{
                      background: 'rgba(59, 130, 246, 0.3)',
                      border: 'none',
                      borderRadius: '6px',
                      padding: '4px 8px',
                      color: 'white',
                      cursor: soundEnabled ? 'pointer' : 'not-allowed',
                      fontSize: '12px',
                      opacity: soundEnabled ? 1 : 0.4,
                    }}
                    title="Preview sound"
                  >
                    üîà
                  </button>
                  
                  {/* Toggle Button */}
                  <button
                    onClick={() => {
                      const newValue = !soundToggles[sound.key];
                      soundTogglesGlobal[sound.key] = newValue; // Sync immediately
                      setSoundToggles(prev => ({ ...prev, [sound.key]: newValue }));
                    }}
                    style={{
                      background: soundToggles[sound.key] ? '#22c55e' : '#666',
                      border: 'none',
                      borderRadius: '12px',
                      padding: '4px 10px',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '10px',
                      fontWeight: 'bold',
                      minWidth: '40px',
                    }}
                  >
                    {soundToggles[sound.key] ? 'ON' : 'OFF'}
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
      
      {/* Avatar Customization Panel */}
      {showAvatarCustomize && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.8)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 130,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '650px',
            maxHeight: '85vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>{gameState.avatar.gender === 'female' ? 'üë©‚Äçüç≥' : 'üë®‚Äçüç≥'}</span> Customize Your Chef
              </h2>
              <button
                onClick={() => setShowAvatarCustomize(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >√ó</button>
            </div>
            
            {/* Main content: Preview + Options side by side */}
            <div style={{ display: 'flex', gap: '25px', flexWrap: 'wrap' }}>
              
              {/* Left: Preview */}
              <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 100%)',
                borderRadius: '16px',
                padding: '15px',
                minWidth: '180px',
              }}>
                <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '8px' }}>Preview</div>
                <canvas 
                  ref={avatarPreviewRef}
                  width={180}
                  height={220}
                  style={{
                    borderRadius: '12px',
                    background: 'radial-gradient(circle at 50% 80%, #4a6741 0%, #2d3a29 100%)',
                  }}
                />
                
                {/* Gender Toggle */}
                <div style={{ marginTop: '15px', width: '100%' }}>
                  <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '11px', marginBottom: '6px', textAlign: 'center' }}>
                    Gender
                  </div>
                  <div style={{ display: 'flex', gap: '6px' }}>
                    {AVATAR_OPTIONS.genders.map(g => (
                      <button
                        key={g.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'gender', value: g.id } })}
                        style={{
                          flex: 1,
                          padding: '8px',
                          borderRadius: '10px',
                          border: 'none',
                          background: gameState.avatar.gender === g.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.gender === g.id ? 'bold' : 'normal',
                          fontSize: '14px',
                        }}
                      >
                        {g.icon} {g.name}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              
              {/* Right: Options */}
              <div style={{ flex: 1, minWidth: '280px' }}>
                {/* Skin Tone */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üé® Skin Tone
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.skinTones.map(skin => (
                      <button
                        key={skin.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'skinTone', value: skin.id } })}
                        style={{
                          width: '38px',
                          height: '38px',
                          borderRadius: '8px',
                          border: gameState.avatar.skinTone === skin.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${skin.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.skinTone === skin.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={skin.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üíá Hair Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairColors.map(hair => (
                      <button
                        key={hair.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairColor', value: hair.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '50%',
                          border: gameState.avatar.hairColor === hair.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${hair.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.hairColor === hair.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={hair.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Style */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ‚úÇÔ∏è Hair Style
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairStyles.map(style => (
                      <button
                        key={style.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairStyle', value: style.id } })}
                        style={{
                          padding: '6px 12px',
                          borderRadius: '16px',
                          border: 'none',
                          background: gameState.avatar.hairStyle === style.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.hairStyle === style.id ? 'bold' : 'normal',
                          fontSize: '12px',
                        }}
                      >
                        {style.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {/* Apron Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    üëï Apron Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.apronColors.map(apron => (
                      <button
                        key={apron.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'apronColor', value: apron.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.apronColor === apron.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${apron.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.apronColor === apron.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={apron.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Outfit Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ü•º Chef Coat Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.outfitColors.map(outfit => (
                      <button
                        key={outfit.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'outfitColor', value: outfit.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.outfitColor === outfit.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${outfit.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.outfitColor === outfit.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={outfit.name}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Done Button */}
            <button
              onClick={() => setShowAvatarCustomize(false)}
              style={{
                width: '100%',
                padding: '14px',
                borderRadius: '12px',
                border: 'none',
                background: 'linear-gradient(135deg, #F472B6, #EC4899)',
                color: 'white',
                fontSize: '16px',
                fontWeight: 'bold',
                cursor: 'pointer',
                marginTop: '15px',
              }}
            >
              ‚ú® Done!
            </button>
          </div>
        </div>
      )}
      
      {/* Trash Confirmation Modal */}
      {trashConfirm && (
        <div style={{
          position: 'absolute',
          top: 0, left: 0, right: 0, bottom: 0,
          background: 'rgba(0,0,0,0.6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 150,
        }} onClick={() => setTrashConfirm(null)}>
          <div style={{
            background: 'white',
            padding: '24px',
            borderRadius: '16px',
            textAlign: 'center',
            maxWidth: '300px',
            boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
          }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: '48px', marginBottom: '12px' }}>üóëÔ∏è</div>
            <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>
              Trash Food?
            </div>
            <div style={{ fontSize: '14px', color: '#666', marginBottom: '20px' }}>
              Throw away {trashConfirm.servings} {trashConfirm.icon} {trashConfirm.recipeName}?
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={() => setTrashConfirm(null)}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: '2px solid #ccc',
                  background: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  dispatch({ type: 'TRASH_COUNTER', payload: { counterId: trashConfirm.counterId } });
                  setTrashConfirm(null);
                }}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: 'none',
                  background: '#ef4444',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                üóëÔ∏è Trash
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Toast Notification */}
      {saveMessage && !showSettings && (
        <div style={{
          position: 'absolute',
          top: '80px',
          left: '50%',
          transform: 'translateX(-50%)',
          padding: '12px 24px',
          borderRadius: '8px',
          background: saveMessage.type === 'success' ? '#22c55e' : '#ef4444',
          color: 'white',
          fontWeight: 'bold',
          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
          zIndex: 200,
          animation: 'fadeIn 0.3s ease-out',
        }}>
          {saveMessage.type === 'success' ? '‚úÖ' : '‚ùå'} {saveMessage.text}
        </div>
      )}
    </div>
  );
}

    // Render the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CafeWorld3D />);
  </script>
</body>
</html>
