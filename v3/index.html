<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elly's Cafe - A Cafe World Tribute</title>
  <meta name="description" content="A loving recreation of the classic Cafe World game, made with love for Elly">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>â˜•</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel">
const { useEffect, useRef, useReducer, useState } = React;


// ============================================
// CONSTANTS & CONFIG
// ============================================
const COLORS = {
  floor: { wood: 0xd4a574, kitchen: 0xe8e8e8, tile1: 0xf5e6d3, tile2: 0xe8d4b8 },
  walls: { cream: 0xfff5e6, trim: 0x8b4513, window: 0x87ceeb },
  roof: { tiles: 0xb45309 },
  stove: { body: 0x505050, burnerOff: 0x2a2a2a, burnerOn: 0xff4444, door: 0x1a1a1a },
  counter: { top: 0xfafafa, cabinet: 0x2e8b57 },
  table: { wood: 0x8b4513, cloth: 0xdc3545 },
  chair: { wood: 0xa0522d },
  customer: [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da],
  ui: {
    gold: '#ffd700',
    green: '#22c55e',
    red: '#ef4444',
    blue: '#3b82f6',
    purple: '#8b5cf6',
  },
  readyGlow: 0x22c55e,
  warningGlow: 0xeab308,
  dangerGlow: 0xef4444,
  grass: 0x7cad7c,
};

// ============================================
// AUDIO SYSTEM
// ============================================
let audioContext = null;
let audioEnabled = true;
let soundTogglesGlobal = {
  cooking: true,
  foodReady: true,
  foodSpoiled: true,
  customerArrive: true,
  customerServed: true,
  customerHappy: true,
  customerAngry: true,
  coins: true,
  levelUp: true,
  purchase: true,
  achievement: true,
};

function getAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Resume if suspended (browsers require user interaction)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  return audioContext;
}

// Simple synth sound generator
function playTone(frequency, duration, type = 'sine', volume = 0.3, decay = true) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
    
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    if (decay) {
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    }
    
    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + duration);
  } catch (e) {
    // Audio not supported or blocked
  }
}

// Create noise for sizzle effects
function playNoise(duration, volume = 0.1, filterFreq = 3000) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const bufferSize = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Fill with white noise
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    
    // Filter to make it sound more like sizzling
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = filterFreq;
    filter.Q.value = 1;
    
    const gainNode = ctx.createGain();
    gainNode.gain.setValueAtTime(volume, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    
    noise.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(ctx.destination);
    
    noise.start();
    noise.stop(ctx.currentTime + duration);
  } catch (e) {}
}

// Metallic coin clink sound
function playCoinClink(delay = 0) {
  if (!audioEnabled) return;
  try {
    const ctx = getAudioContext();
    const time = ctx.currentTime + delay;
    
    // High metallic frequencies for coin sound
    const frequencies = [2500, 3500, 4200];
    
    frequencies.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      // Quick pitch bend down for metallic quality
      osc.frequency.exponentialRampToValueAtTime(freq * 0.7, time + 0.08);
      
      // Quick attack, fast decay for "clink"
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.12 - i * 0.03, time + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
      
      osc.start(time);
      osc.stop(time + 0.12);
    });
  } catch (e) {}
}

// Sound effects
const SFX = {
  // Cooking start - sizzle/grill sound
  cookStart: () => {
    if (!audioEnabled || !soundTogglesGlobal.cooking) return;
    // Initial "fwoosh" of putting food on grill
    playNoise(0.15, 0.2, 2000);
    // Followed by sizzling
    setTimeout(() => {
      playNoise(0.3, 0.12, 4000);
      playNoise(0.25, 0.08, 5000);
    }, 100);
    setTimeout(() => {
      playNoise(0.2, 0.06, 3500);
    }, 250);
  },
  
  // Food ready - pleasant ding (like a kitchen timer)
  foodReady: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodReady) return;
    // Bell-like ding
    playTone(1200, 0.3, 'sine', 0.25);
    playTone(2400, 0.2, 'sine', 0.1); // Harmonic
    setTimeout(() => {
      playTone(1200, 0.25, 'sine', 0.15);
      playTone(2400, 0.15, 'sine', 0.05);
    }, 180);
  },
  
  // Food spoiled - buzzer/sad sound
  foodSpoiled: () => {
    if (!audioEnabled || !soundTogglesGlobal.foodSpoiled) return;
    playTone(180, 0.3, 'sawtooth', 0.15);
    playTone(175, 0.3, 'sawtooth', 0.1); // Slight detune for dissonance
    setTimeout(() => {
      playTone(140, 0.35, 'sawtooth', 0.12);
      playTone(138, 0.35, 'sawtooth', 0.08);
    }, 200);
  },
  
  // Customer arrives - door chime / bell
  customerArrive: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerArrive) return;
    playTone(880, 0.2, 'sine', 0.15);
    playTone(1760, 0.15, 'sine', 0.08); // Harmonic
    setTimeout(() => playTone(1100, 0.25, 'sine', 0.12), 120);
  },
  
  // Customer served - plate down sound
  customerServed: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    // Soft thud + clink
    playTone(200, 0.08, 'sine', 0.2);
    setTimeout(() => {
      playTone(800, 0.06, 'triangle', 0.1);
      playTone(1200, 0.05, 'triangle', 0.05);
    }, 30);
  },
  
  // Customer leaves happy - cheerful
  customerHappy: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerHappy) return;
    playTone(523, 0.12, 'sine', 0.15);
    setTimeout(() => playTone(659, 0.12, 'sine', 0.15), 80);
    setTimeout(() => playTone(784, 0.18, 'sine', 0.12), 160);
  },
  
  // Customer leaves angry - negative sound
  customerAngry: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerAngry) return;
    playTone(200, 0.2, 'sawtooth', 0.12);
    setTimeout(() => playTone(150, 0.25, 'sawtooth', 0.08), 150);
  },
  
  // Coin earned - actual coin clink sounds!
  coinEarn: () => {
    if (!audioEnabled || !soundTogglesGlobal.coins) return;
    playCoinClink(0);
    playCoinClink(0.08); // Second coin for "ka-ching"
  },
  
  // Level up fanfare!
  levelUp: () => {
    if (!audioEnabled || !soundTogglesGlobal.levelUp) return;
    const notes = [523, 659, 784, 1047]; // C E G C
    notes.forEach((freq, i) => {
      setTimeout(() => playTone(freq, 0.22, 'sine', 0.2), i * 100);
    });
    // Triumphant chord + coin shower
    setTimeout(() => {
      playTone(523, 0.5, 'sine', 0.15);
      playTone(659, 0.5, 'sine', 0.12);
      playTone(784, 0.5, 'sine', 0.12);
      playTone(1047, 0.5, 'sine', 0.15);
      // Coin sounds
      playCoinClink(0.1);
      playCoinClink(0.2);
      playCoinClink(0.35);
    }, 420);
  },
  
  // UI click
  click: () => {
    playTone(800, 0.04, 'sine', 0.08);
  },
  
  // Purchase - cash register style
  purchase: () => {
    if (!audioEnabled || !soundTogglesGlobal.purchase) return;
    // Register "ka-ching"
    playCoinClink(0);
    setTimeout(() => {
      playTone(600, 0.08, 'sine', 0.12);
      playTone(750, 0.1, 'sine', 0.1);
    }, 80);
    playCoinClink(0.15);
  },
  
  // Serve food to counter - plate sound
  serveToCounter: () => {
    if (!audioEnabled || !soundTogglesGlobal.customerServed) return;
    playTone(300, 0.06, 'sine', 0.15);
    setTimeout(() => {
      playTone(600, 0.05, 'triangle', 0.08);
    }, 40);
  },
  
  // Achievement unlocked - triumphant!
  achievement: () => {
    if (!audioEnabled || !soundTogglesGlobal.achievement) return;
    // Magical sparkle + fanfare
    playTone(880, 0.15, 'sine', 0.2);
    playTone(1760, 0.1, 'sine', 0.1);
    setTimeout(() => {
      playTone(1100, 0.15, 'sine', 0.2);
      playTone(2200, 0.1, 'sine', 0.08);
    }, 100);
    setTimeout(() => {
      playTone(1320, 0.2, 'sine', 0.18);
      playTone(2640, 0.12, 'sine', 0.06);
      playCoinClink(0.05);
    }, 200);
    setTimeout(() => {
      playCoinClink(0);
      playCoinClink(0.08);
    }, 350);
  },
  
  // Error/invalid placement - short buzz
  error: () => {
    if (!audioEnabled) return;
    playTone(220, 0.12, 'sawtooth', 0.15);
    playTone(200, 0.12, 'sawtooth', 0.1);
  },
};

const GRID = { width: 16, height: 14 };
const TILE_SIZE = 1;

// Door position - where customers enter/exit (front center of cafe)
const DOOR_POSITION = { 
  gridX: 8,  // Center of cafe
  gridZ: GRID.height - 1,  // Front edge of cafe floor (grid coord 13)
  worldX: 0,  // Center in world coords
  worldZ: GRID.height / 2 - 0.5  // Front of cafe in world coords
};

const RECIPES = {
  // Level 1 - Quick starters (15-30 sec)
  burger: { name: 'Burger', icon: 'ðŸ”', cost: 25, servings: 13, revenue: 4, cookTime: 15, xp: 7, level: 1 },
  salad: { name: 'Salad', icon: 'ðŸ¥—', cost: 50, servings: 25, revenue: 4, cookTime: 30, xp: 14, level: 1 },
  
  // Level 2-3 - Basic dishes (45-90 sec)
  soup: { name: 'Soup', icon: 'ðŸ²', cost: 100, servings: 40, revenue: 5, cookTime: 60, xp: 35, level: 2 },
  pancakes: { name: 'Pancakes', icon: 'ðŸ¥ž', cost: 150, servings: 50, revenue: 5, cookTime: 90, xp: 50, level: 2 },
  cake: { name: 'Cake', icon: 'ðŸŽ‚', cost: 200, servings: 60, revenue: 6, cookTime: 120, xp: 70, level: 3 },
  tacos: { name: 'Tacos', icon: 'ðŸŒ®', cost: 175, servings: 55, revenue: 5, cookTime: 90, xp: 55, level: 3 },
  
  // Level 4-5 - Intermediate (3-6 min)
  pizza: { name: 'Pizza', icon: 'ðŸ•', cost: 300, servings: 80, revenue: 6, cookTime: 180, xp: 90, level: 4 },
  pasta: { name: 'Pasta', icon: 'ðŸ', cost: 350, servings: 90, revenue: 6, cookTime: 240, xp: 110, level: 4 },
  chicken: { name: 'Roast Chicken', icon: 'ðŸ—', cost: 500, servings: 120, revenue: 7, cookTime: 300, xp: 150, level: 5 },
  ramen: { name: 'Ramen', icon: 'ðŸœ', cost: 450, servings: 100, revenue: 7, cookTime: 360, xp: 165, level: 5 },
  
  // Level 6-7 - Advanced (8-15 min)
  sushi: { name: 'Sushi Platter', icon: 'ðŸ£', cost: 700, servings: 150, revenue: 8, cookTime: 480, xp: 220, level: 6 },
  curry: { name: 'Curry', icon: 'ðŸ›', cost: 600, servings: 130, revenue: 7, cookTime: 540, xp: 200, level: 6 },
  steak: { name: 'Steak Dinner', icon: 'ðŸ¥©', cost: 900, servings: 180, revenue: 9, cookTime: 600, xp: 280, level: 7 },
  lobster: { name: 'Lobster', icon: 'ðŸ¦ž', cost: 1100, servings: 200, revenue: 10, cookTime: 720, xp: 340, level: 7 },
  
  // Level 8-9 - Expert (15-30 min)
  paella: { name: 'Paella', icon: 'ðŸ¥˜', cost: 1300, servings: 250, revenue: 10, cookTime: 900, xp: 420, level: 8 },
  dimsum: { name: 'Dim Sum', icon: 'ðŸ¥Ÿ', cost: 1000, servings: 220, revenue: 9, cookTime: 1080, xp: 380, level: 8 },
  bbqRibs: { name: 'BBQ Ribs', icon: 'ðŸ–', cost: 1500, servings: 280, revenue: 11, cookTime: 1200, xp: 500, level: 9 },
  crabBisque: { name: 'Crab Bisque', icon: 'ðŸ¦€', cost: 1800, servings: 300, revenue: 12, cookTime: 1500, xp: 580, level: 9 },
  
  // Level 10-12 - Master Chef (30-60 min)
  weddingCake: { name: 'Wedding Cake', icon: 'ðŸŽ‚', cost: 2500, servings: 400, revenue: 14, cookTime: 1800, xp: 750, level: 10 },
  beef: { name: 'Beef Wellington', icon: 'ðŸ¥©', cost: 3000, servings: 450, revenue: 15, cookTime: 2400, xp: 900, level: 10 },
  feastPlatter: { name: 'Grand Feast', icon: 'ðŸ±', cost: 4000, servings: 600, revenue: 16, cookTime: 3000, xp: 1100, level: 11 },
  turkeyDinner: { name: 'Turkey Dinner', icon: 'ðŸ¦ƒ', cost: 5000, servings: 800, revenue: 18, cookTime: 3600, xp: 1400, level: 12 },
};

// Dish Mastery System - Cook dishes multiple times to earn bonuses
// Each dish tracks how many times it's been successfully cooked
const MASTERY_LEVELS = {
  1: { 
    name: 'Apprentice', 
    cooksRequired: 10, 
    plateColor: 0x87CEEB, // Light blue plate
    bonus: 'servings', // +5% more servings
    bonusAmount: 0.05,
    description: '+5% Servings'
  },
  2: { 
    name: 'Journeyman', 
    cooksRequired: 25, 
    plateColor: 0x4169E1, // Dark blue plate
    bonus: 'xp', // +5% more XP
    bonusAmount: 0.05,
    description: '+5% XP'
  },
  3: { 
    name: 'Master', 
    cooksRequired: 50, 
    plateColor: 0xFFD700, // Gold plate
    bonus: 'speed', // +5% faster cooking
    bonusAmount: 0.05,
    description: '+5% Faster'
  },
};

// Helper function to get mastery level for a dish
const getMasteryLevel = (dishMastery, recipeKey) => {
  const mastery = dishMastery?.[recipeKey] || { cooked: 0 };
  if (mastery.cooked >= MASTERY_LEVELS[3].cooksRequired) return 3;
  if (mastery.cooked >= MASTERY_LEVELS[2].cooksRequired) return 2;
  if (mastery.cooked >= MASTERY_LEVELS[1].cooksRequired) return 1;
  return 0;
};

// Helper function to get the plate color for a dish based on mastery
const getMasteryPlateColor = (dishMastery, recipeKey) => {
  const level = getMasteryLevel(dishMastery, recipeKey);
  if (level === 0) return 0xFFFFF0; // Default ivory plate
  return MASTERY_LEVELS[level].plateColor;
};

// Helper function to calculate cook time with mastery bonus
const getCookTimeWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let cookTime = recipe.cookTime;
  // Level 3 mastery gives 5% faster cooking (stacks with previous levels)
  if (level >= 3) {
    cookTime = Math.floor(cookTime * (1 - MASTERY_LEVELS[3].bonusAmount));
  }
  return cookTime;
};

// Helper function to calculate servings with mastery bonus
const getServingsWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let servings = recipe.servings;
  // Level 1+ mastery gives 5% more servings
  if (level >= 1) {
    servings = Math.floor(servings * (1 + MASTERY_LEVELS[1].bonusAmount));
  }
  return servings;
};

// Helper function to calculate XP with mastery bonus
const getXPWithMastery = (dishMastery, recipeKey) => {
  const recipe = RECIPES[recipeKey];
  if (!recipe) return 0;
  const level = getMasteryLevel(dishMastery, recipeKey);
  let xp = recipe.xp;
  // Level 2+ mastery gives 5% more XP
  if (level >= 2) {
    xp = Math.floor(xp * (1 + MASTERY_LEVELS[2].bonusAmount));
  }
  return xp;
};

const XP_LEVELS = [0, 120, 280, 520, 840, 1240, 1720, 2280, 2920, 3640, 4440, 5400, 6500];

// Helper function to format time display (e.g., "5m 30s", "1h 15m")
const formatTimeDisplay = (seconds) => {
  seconds = Math.ceil(seconds);
  if (seconds < 60) {
    return `${seconds}s`;
  } else if (seconds < 3600) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
  } else {
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
  }
};

// Table styles for variety
const TABLE_STYLES = {
  // === BASIC TABLES (300-1000ðŸª™) ===
  square: { 
    name: 'Classic Red', icon: 'ðŸŸ¥', cost: 2000, shape: 'square',
    woodColor: 0x8B4513, clothColor: 0xDC143C, chairColor: 0x8B4513,
  },
  basicWood: { 
    name: 'Basic Wood', icon: 'ðŸªµ', cost: 750, shape: 'square',
    woodColor: 0xA0522D, clothColor: null, chairColor: 0xA0522D,
  },
  oak: { 
    name: 'Oak', icon: 'ðŸŸ¤', cost: 750, shape: 'square',
    woodColor: 0xDEB887, clothColor: null, chairColor: 0xDEB887,
  },
  modernBlack: { 
    name: 'Modern Black', icon: 'â¬›', cost: 750, shape: 'square',
    woodColor: 0x1a1a1a, clothColor: null, chairColor: 0x2d2d2d,
  },
  whiteElegant: { 
    name: 'White Elegant', icon: 'â¬œ', cost: 2000, shape: 'square',
    woodColor: 0xFAFAFA, clothColor: 0xFFFFFF, chairColor: 0xF5F5F5,
  },
  mahogany: { 
    name: 'Mahogany', icon: 'ðŸŸ«', cost: 750, shape: 'square',
    woodColor: 0x420D09, clothColor: null, chairColor: 0x420D09,
  },
  
  // === MID-RANGE TABLES (1500-3500ðŸª™) ===
  rusticFarm: { 
    name: 'Rustic Farm', icon: 'ðŸŒ¾', cost: 2000, shape: 'square',
    woodColor: 0x8B7355, clothColor: 0xF5DEB3, chairColor: 0x8B7355,
  },
  redDiner: { 
    name: 'Red Diner', icon: 'ðŸ”´', cost: 2000, shape: 'square',
    woodColor: 0xC0C0C0, clothColor: 0xCC0000, chairColor: 0xCC0000,
  },
  darkCherry: { 
    name: 'Dark Cherry', icon: 'ðŸ’', cost: 2000, shape: 'square',
    woodColor: 0x3D0C02, clothColor: 0x800020, chairColor: 0x3D0C02,
  },
  blueOcean: { 
    name: 'Blue Ocean', icon: 'ðŸ”µ', cost: 2000, shape: 'square',
    woodColor: 0xF5F5F5, clothColor: 0x1E90FF, chairColor: 0xF5F5F5,
  },
  pinkRomantic: { 
    name: 'Pink Romantic', icon: 'ðŸ’—', cost: 2000, shape: 'square',
    woodColor: 0xFFFFFF, clothColor: 0xFFB6C1, chairColor: 0xFFB6C1,
  },
  greenGarden: { 
    name: 'Garden Green', icon: 'ðŸŒ¿', cost: 2000, shape: 'square',
    woodColor: 0xF5F5DC, clothColor: 0x228B22, chairColor: 0x2E8B57,
  },
  premiumWhite: { 
    name: 'Premium White', icon: 'âœ¨', cost: 2000, shape: 'square',
    woodColor: 0xFFFFF0, clothColor: 0xFFFACD, chairColor: 0xFFFFF0,
  },
  goldLuxury: { 
    name: 'Gold Luxury', icon: 'ðŸ‘‘', cost: 2000, shape: 'square',
    woodColor: 0xFFD700, clothColor: 0x800020, chairColor: 0xFFD700,
  },
  luxuryPink: { 
    name: 'Luxury Pink', icon: 'ðŸ’–', cost: 2000, shape: 'square',
    woodColor: 0xFFF0F5, clothColor: 0xFF69B4, chairColor: 0xFFB6C1,
  },
  // (checkeredPicnic, marble, executive removed - old/boring, not grouped)
  
  // === 50s DINER TABLES (2000-4000 coins) ===
  dinerClassic: {
    name: 'Diner Classic', icon: 'ðŸ”', cost: 2500, shape: 'diner',
    topColor: 0xf5f5f5, variant: 'classic',
  },
  dinerPink: {
    name: 'Diner Pink', icon: 'ðŸŽ€', cost: 2500, shape: 'diner',
    topColor: 0xffb6c1, variant: 'pink',
  },
  dinerMint: {
    name: 'Diner Mint', icon: 'ðŸŒ¿', cost: 2500, shape: 'diner',
    topColor: 0x98ff98, variant: 'mint',
  },
  dinerTurquoise: {
    name: 'Diner Turquoise', icon: 'ðŸ’Ž', cost: 2500, shape: 'diner',
    topColor: 0x40e0d0, variant: 'turquoise',
  },
  dinerRed: {
    name: 'Diner Red', icon: 'â¤ï¸', cost: 2500, shape: 'diner',
    topColor: 0xdc143c, variant: 'red',
  },
  dinerCheckered: {
    name: 'Diner Checkered', icon: 'ðŸ', cost: 2500, shape: 'diner',
    topColor: 0xffffff, variant: 'checkered',
  },
  
  // === ROMANTIC TABLES (5000-10000 coins) ===
  romanticPink: {
    name: 'Romantic Pink', icon: 'ðŸŒ¸', cost: 6000, shape: 'romantic',
    clothColor: 0xf8a0b0, trimColor: 0xfaf5f0, variant: 'pink',
  },
  romanticRed: {
    name: 'Romantic Red', icon: 'ðŸŒ¹', cost: 6000, shape: 'romantic',
    clothColor: 0xdc143c, trimColor: 0xfaf5f0, variant: 'red',
  },
  romanticWhite: {
    name: 'Romantic White', icon: 'ðŸ•Šï¸', cost: 6000, shape: 'romantic',
    clothColor: 0xfffafa, trimColor: 0xf5f5f5, variant: 'white',
  },
  romanticLavender: {
    name: 'Romantic Lavender', icon: 'ðŸ’œ', cost: 6000, shape: 'romantic',
    clothColor: 0xc8a2c8, trimColor: 0xfaf5f0, variant: 'lavender',
  },
  romanticChampagne: {
    name: 'Romantic Champagne', icon: 'ðŸ¥‚', cost: 6000, shape: 'romantic',
    clothColor: 0xf4d98c, trimColor: 0xfaf5f0, variant: 'champagne',
  },
  romanticBlue: {
    name: 'Romantic Blue', icon: 'ðŸ’™', cost: 6000, shape: 'romantic',
    clothColor: 0xadd8e6, trimColor: 0xfaf5f0, variant: 'softblue',
  },
  
  // === MEDITERRANEAN TABLES (3000-6000 coins) ===
  medTuscan: {
    name: 'Tuscan', icon: 'ðŸ›ï¸', cost: 4000, shape: 'mediterranean',
    topColor: 0xdeb887, accentColor: 0xcd853f, legColor: 0x8b4513, variant: 'tuscan',
  },
  medGreek: {
    name: 'Greek', icon: 'ðŸ‡¬ðŸ‡·', cost: 4000, shape: 'mediterranean',
    topColor: 0xffffff, accentColor: 0x4169e1, legColor: 0xffffff, variant: 'greek',
  },
  medSpanish: {
    name: 'Spanish', icon: 'ðŸ‡ªðŸ‡¸', cost: 4000, shape: 'mediterranean',
    topColor: 0xf4a460, accentColor: 0xdc143c, legColor: 0x8b4513, variant: 'spanish',
  },
  medMosaic: {
    name: 'Mosaic', icon: 'ðŸŽ¨', cost: 4000, shape: 'mediterranean',
    topColor: 0xf5f5dc, accentColor: 0x20b2aa, legColor: 0x696969, variant: 'mosaic',
  },
  medTerracotta: {
    name: 'Terracotta', icon: 'ðŸ§±', cost: 4000, shape: 'mediterranean',
    topColor: 0xe2725b, accentColor: 0xcd5c5c, legColor: 0x8b4513, variant: 'terracotta',
  },
  medOlive: {
    name: 'Olive', icon: 'ðŸ«’', cost: 4000, shape: 'mediterranean',
    topColor: 0x808000, accentColor: 0x6b8e23, legColor: 0x556b2f, variant: 'olive',
  },
};

// Chair styles for mix-and-match seating
const CHAIR_STYLES = {
  // === BASIC CHAIRS (100-400ðŸª™) ===
  basicWood: {
    name: 'Basic Wood', icon: 'ðŸª‘', cost: 200,
    color: 0xA0522D, seatColor: null, // null = same as frame
  },
  oak: {
    name: 'Oak Chair', icon: 'ðŸªµ', cost: 200,
    color: 0xDEB887, seatColor: null,
  },
  darkWood: {
    name: 'Dark Wood', icon: 'ðŸŸ¤', cost: 200,
    color: 0x8B4513, seatColor: null,
  },
  white: {
    name: 'White Chair', icon: 'â¬œ', cost: 200,
    color: 0xF5F5F5, seatColor: null,
  },
  black: {
    name: 'Black Chair', icon: 'â¬›', cost: 200,
    color: 0x2D2D2D, seatColor: null,
  },
  
  // === CUSHIONED CHAIRS (400-1000ðŸª™) ===
  redCushion: {
    name: 'Red Cushion', icon: 'ðŸ”´', cost: 450,
    color: 0x8B4513, seatColor: 0xDC143C,
  },
  blueCushion: {
    name: 'Blue Cushion', icon: 'ðŸ”µ', cost: 450,
    color: 0x8B4513, seatColor: 0x1E90FF,
  },
  greenCushion: {
    name: 'Green Cushion', icon: 'ðŸŸ¢', cost: 450,
    color: 0x8B4513, seatColor: 0x228B22,
  },
  pinkCushion: {
    name: 'Pink Cushion', icon: 'ðŸ’—', cost: 450,
    color: 0xF5F5F5, seatColor: 0xFFB6C1,
  },
  
  // === PREMIUM CHAIRS (1000-3000ðŸª™) ===
  velvetRed: {
    name: 'Velvet Red', icon: 'ðŸ·', cost: 1000,
    color: 0x420D09, seatColor: 0x800020,
  },
  velvetBlue: {
    name: 'Velvet Blue', icon: 'ðŸ’Ž', cost: 1000,
    color: 0x1a1a1a, seatColor: 0x191970,
  },
  // (goldFrame, executive, luxuryWhite removed - not special enough)
  
  // === 50s DINER CHAIRS (500-1500 coins) ===
  dinerClassic: {
    name: 'Diner Classic', icon: 'ðŸ”', cost: 750,
    color: 0xc0c0c0, seatColor: 0xdc143c, renderType: 'diner',
  },
  dinerPink: {
    name: 'Diner Pink', icon: 'ðŸŽ€', cost: 750,
    color: 0xc0c0c0, seatColor: 0xffb6c1, renderType: 'diner',
  },
  dinerMint: {
    name: 'Diner Mint', icon: 'ðŸŒ¿', cost: 750,
    color: 0xc0c0c0, seatColor: 0x98ff98, renderType: 'diner',
  },
  dinerTurquoise: {
    name: 'Diner Turquoise', icon: 'ðŸ’Ž', cost: 750,
    color: 0xc0c0c0, seatColor: 0x40e0d0, renderType: 'diner',
  },
  dinerRed: {
    name: 'Diner Red', icon: 'â¤ï¸', cost: 750,
    color: 0xc0c0c0, seatColor: 0xdc143c, renderType: 'diner',
  },
  dinerYellow: {
    name: 'Diner Yellow', icon: 'ðŸŒŸ', cost: 750,
    color: 0xc0c0c0, seatColor: 0xf5e6c8, renderType: 'diner',
  },
  
  // === ROMANTIC CHAIRS (1500-3500 coins) ===
  romanticPink: {
    name: 'Romantic Pink', icon: 'ðŸŒ¸', cost: 2000,
    color: 0xfaf5f0, seatColor: 0xf8a0b0, renderType: 'romantic',
  },
  romanticRed: {
    name: 'Romantic Red', icon: 'ðŸŒ¹', cost: 2000,
    color: 0xfaf5f0, seatColor: 0xdc143c, renderType: 'romantic',
  },
  romanticWhite: {
    name: 'Romantic White', icon: 'ðŸ•Šï¸', cost: 2000,
    color: 0xf5f5f5, seatColor: 0xfffafa, renderType: 'romantic',
  },
  romanticLavender: {
    name: 'Romantic Lavender', icon: 'ðŸ’œ', cost: 2000,
    color: 0xfaf5f0, seatColor: 0xc8a2c8, renderType: 'romantic',
  },
  romanticChampagne: {
    name: 'Romantic Champagne', icon: 'ðŸ¥‚', cost: 2000,
    color: 0xfaf5f0, seatColor: 0xf4d98c, renderType: 'romantic',
  },
  romanticBlue: {
    name: 'Romantic Blue', icon: 'ðŸ’™', cost: 2000,
    color: 0xfaf5f0, seatColor: 0xadd8e6, renderType: 'romantic',
  },
  
  // === MEDITERRANEAN CHAIRS (800-2000 coins) ===
  medTuscan: {
    name: 'Tuscan Chair', icon: 'ðŸ›ï¸', cost: 1200,
    color: 0x8b4513, seatColor: 0xdeb887, renderType: 'mediterranean',
  },
  medGreek: {
    name: 'Greek Chair', icon: 'ðŸ‡¬ðŸ‡·', cost: 1200,
    color: 0x4169e1, seatColor: 0xffffff, renderType: 'mediterranean',
  },
  medSpanish: {
    name: 'Spanish Chair', icon: 'ðŸ‡ªðŸ‡¸', cost: 1200,
    color: 0x8b4513, seatColor: 0xf4a460, renderType: 'mediterranean',
  },
  medMosaic: {
    name: 'Mosaic Chair', icon: 'ðŸŽ¨', cost: 1200,
    color: 0x696969, seatColor: 0xf5f5dc, renderType: 'mediterranean',
  },
  medTerracotta: {
    name: 'Terracotta Chair', icon: 'ðŸ§±', cost: 1200,
    color: 0x8b4513, seatColor: 0xe2725b, renderType: 'mediterranean',
  },
  medOlive: {
    name: 'Olive Chair', icon: 'ðŸ«’', cost: 1200,
    color: 0x556b2f, seatColor: 0x808000, renderType: 'mediterranean',
  },
};

// Stove styles for kitchen equipment variety
const STOVE_STYLES = {
  // === BASIC STOVES (500-1500ðŸª™) ===
  basic: {
    name: 'Basic Stove', icon: 'ðŸ³', cost: 500, type: 'basic',
    bodyColor: 0x505050, topColor: 0x333333, doorColor: 0x1a1a1a,
  },
  basicWhite: {
    name: 'White Basic', icon: 'â¬œ', cost: 500, type: 'basic',
    bodyColor: 0xf0f0f0, topColor: 0x888899, doorColor: 0xfafafa,
  },
  basicBlack: {
    name: 'Black Basic', icon: 'â¬›', cost: 500, type: 'basic',
    bodyColor: 0x303030, topColor: 0x333333, doorColor: 0x252525,
  },
  
  // === MODERN WITH GRATES (1500-3000ðŸª™) ===
  modernBlack: {
    name: 'Modern Black', icon: 'ðŸ–¤', cost: 1500, type: 'modern',
    bodyColor: 0x303030, topColor: 0x888899, trimColor: 0x404040, doorColor: 0x252525,
  },
  modernWhite: {
    name: 'Modern White', icon: 'ðŸ¤', cost: 1500, type: 'modern',
    bodyColor: 0xf0f0f0, topColor: 0x888899, trimColor: 0xe0e0e0, doorColor: 0xfafafa,
  },
  modernStainless: {
    name: 'Modern Stainless', icon: 'ðŸªž', cost: 1500, type: 'modern',
    bodyColor: 0x8899aa, topColor: 0x99aabb, trimColor: 0x778899, doorColor: 0x8090a0, isShiny: true,
  },
  modernRed: {
    name: 'Modern Red', icon: 'â¤ï¸', cost: 1500, type: 'modern',
    bodyColor: 0x8b2020, topColor: 0x888899, trimColor: 0x6a1818, doorColor: 0x701818,
  },
  modernNavy: {
    name: 'Modern Navy', icon: 'ðŸ’™', cost: 1500, type: 'modern',
    bodyColor: 0x1a2a4a, topColor: 0x888899, trimColor: 0x152035, doorColor: 0x101828,
  },
  
  // === PROFESSIONAL RANGE (3000-6000ðŸª™) ===
  proStainless: {
    name: 'Pro Stainless', icon: 'ðŸ‘¨â€ðŸ³', cost: 3500, type: 'professional',
    bodyColor: 0x2d2d2d, panelColor: 0xaabbcc, topColor: 0x99aabb, isShiny: true,
  },
  proBlack: {
    name: 'Pro Black', icon: 'ðŸ–¤', cost: 3500, type: 'professional',
    bodyColor: 0x1a1a1a, panelColor: 0x333333, topColor: 0x444444,
  },
  proRed: {
    name: 'Pro Red', icon: 'ðŸ”´', cost: 3500, type: 'professional',
    bodyColor: 0x8b1a1a, panelColor: 0xaa3333, topColor: 0x666666,
  },
  proBlue: {
    name: 'Pro Blue', icon: 'ðŸ”µ', cost: 3500, type: 'professional',
    bodyColor: 0x1a2a5a, panelColor: 0x3344aa, topColor: 0x666688,
  },
  proWhite: {
    name: 'Pro White', icon: 'âšª', cost: 3500, type: 'professional',
    bodyColor: 0xe8e8e8, panelColor: 0xfafafa, topColor: 0xcccccc,
  },
  
  // === RETRO/VINTAGE (4000-8000ðŸª™) - Pastels! ===
  retroMint: {
    name: 'Retro Mint', icon: 'ðŸŒ¿', cost: 4000, type: 'retro',
    bodyColor: 0x88c4cc, chromeColor: 0xdddddd,
  },
  retroPink: {
    name: 'Retro Pink', icon: 'ðŸŒ¸', cost: 4000, type: 'retro',
    bodyColor: 0xdda0a0, chromeColor: 0xdddddd,
  },
  retroYellow: {
    name: 'Retro Yellow', icon: 'ðŸŒ»', cost: 4000, type: 'retro',
    bodyColor: 0xe8d888, chromeColor: 0xdddddd,
  },
  retroCream: {
    name: 'Retro Cream', icon: 'ðŸ¦', cost: 4000, type: 'retro',
    bodyColor: 0xf5f0e0, chromeColor: 0xcccccc,
  },
  retroLavender: {
    name: 'Retro Lavender', icon: 'ðŸ’œ', cost: 4000, type: 'retro',
    bodyColor: 0xb8a8c8, chromeColor: 0xdddddd,
  },
  retroCoral: {
    name: 'Retro Coral', icon: 'ðŸª¸', cost: 4000, type: 'retro',
    bodyColor: 0xe89080, chromeColor: 0xdddddd,
  },
  retroRobinEgg: {
    name: 'Robin Egg', icon: 'ðŸ¥š', cost: 4000, type: 'retro',
    bodyColor: 0x70c8d8, chromeColor: 0xeeeeee,
  },
  retroPeach: {
    name: 'Retro Peach', icon: 'ðŸ‘', cost: 4000, type: 'retro',
    bodyColor: 0xf8c8a8, chromeColor: 0xdddddd,
  },
  
  // === GLASS TOP MODERN (5000-8000ðŸª™) ===
  glassBlack: {
    name: 'Glass Black', icon: 'ðŸ”³', cost: 5500, type: 'glasstop',
    bodyColor: 0x1a1a1a, frameColor: 0x444444,
  },
  glassWhite: {
    name: 'Glass White', icon: 'â¬œ', cost: 5500, type: 'glasstop',
    bodyColor: 0xf0f0f0, frameColor: 0xcccccc, isShiny: true,
  },
  glassStainless: {
    name: 'Glass Stainless', icon: 'ðŸªž', cost: 5500, type: 'glasstop',
    bodyColor: 0x8899aa, frameColor: 0x666677, isShiny: true,
  },
  glassGraphite: {
    name: 'Glass Graphite', icon: 'ðŸ©¶', cost: 5500, type: 'glasstop',
    bodyColor: 0x3a3a3a, frameColor: 0x555555,
  },
  
  // === COMMERCIAL (8000-15000ðŸª™) ===
  commercialStainless: {
    name: 'Commercial SS', icon: 'ðŸª', cost: 8000, type: 'commercial',
    bodyColor: 0x99aabb, grillColor: 0x555555, isShiny: true,
  },
  commercialBlack: {
    name: 'Commercial Black', icon: 'ðŸ­', cost: 8000, type: 'commercial',
    bodyColor: 0x2a2a2a, grillColor: 0x444444,
  },
  commercialCharcoal: {
    name: 'Commercial Char', icon: 'âš«', cost: 8000, type: 'commercial',
    bodyColor: 0x4a4a4a, grillColor: 0x333333,
  },
};

// Counter styles for serving counter variety
// ============================================
// STARTER FURNITURE OPTIONS (for randomized initial setup)
// Only includes affordable items a new cafe would have
// ============================================
const STARTER_TABLE_STYLES = ['basicWood', 'oak', 'modernBlack', 'mahogany'];
const STARTER_CHAIR_STYLES = ['basicWood', 'oak', 'darkWood', 'white', 'black', 'redCushion', 'blueCushion', 'greenCushion'];
const STARTER_STOVE_STYLES = ['basic', 'basicWhite', 'basicBlack'];
const STARTER_COUNTER_STYLES = ['basic', 'basicWhite', 'basicBlack', 'basicRed', 'basicBlue'];

// Generate randomized initial furniture
function generateRandomInitialFurniture() {
  // Pick random styles for this cafe
  const randomTableStyle = () => STARTER_TABLE_STYLES[Math.floor(Math.random() * STARTER_TABLE_STYLES.length)];
  const randomChairStyle = () => STARTER_CHAIR_STYLES[Math.floor(Math.random() * STARTER_CHAIR_STYLES.length)];
  const randomStoveStyle = () => STARTER_STOVE_STYLES[Math.floor(Math.random() * STARTER_STOVE_STYLES.length)];
  const randomCounterStyle = () => STARTER_COUNTER_STYLES[Math.floor(Math.random() * STARTER_COUNTER_STYLES.length)];
  
  // Stoves - back left, pick 2 random styles
  const stoves = [
    { id: 'stove-1', gridX: 1, gridZ: 0, rotation: 0, style: randomStoveStyle(), state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
    { id: 'stove-2', gridX: 3, gridZ: 0, rotation: 0, style: randomStoveStyle(), state: 'empty', recipe: null, startTime: null, servingsLeft: 0 },
  ];
  
  // Counters - back right, pick 3 random styles
  const counters = [
    { id: 'counter-1', gridX: 9, gridZ: 0, rotation: 0, style: randomCounterStyle(), dishes: [] },
    { id: 'counter-2', gridX: 11, gridZ: 0, rotation: 0, style: randomCounterStyle(), dishes: [] },
    { id: 'counter-3', gridX: 13, gridZ: 0, rotation: 0, style: randomCounterStyle(), dishes: [] },
  ];
  
  // Tables and chairs - randomize styles for each pair
  const tables = [];
  const chairs = [];
  
  // Define table/chair positions (same layout, random styles)
  const tablePositions = [
    { gridX: 3, gridZ: 5, chairX: 2, chairZ: 5, chairRotation: 1 },   // Row 1
    { gridX: 7, gridZ: 5, chairX: 6, chairZ: 5, chairRotation: 1 },
    { gridX: 11, gridZ: 5, chairX: 10, chairZ: 5, chairRotation: 1 },
    { gridX: 4, gridZ: 8, chairX: 5, chairZ: 8, chairRotation: 3 },   // Row 2
    { gridX: 8, gridZ: 8, chairX: 9, chairZ: 8, chairRotation: 3 },
    { gridX: 12, gridZ: 8, chairX: 13, chairZ: 8, chairRotation: 3 },
    { gridX: 3, gridZ: 11, chairX: 2, chairZ: 11, chairRotation: 1 }, // Row 3
    { gridX: 7, gridZ: 11, chairX: 6, chairZ: 11, chairRotation: 1 },
  ];
  
  tablePositions.forEach((pos, i) => {
    const tableId = `table-${i + 1}`;
    const tableStyle = randomTableStyle();
    const chairStyle = randomChairStyle();
    
    tables.push({
      id: tableId,
      gridX: pos.gridX,
      gridZ: pos.gridZ,
      style: tableStyle,
      rotation: 0,
      customer: null,
    });
    
    chairs.push({
      id: `chair-${i + 1}`,
      gridX: pos.chairX,
      gridZ: pos.chairZ,
      style: chairStyle,
      rotation: pos.chairRotation,
      linkedTableId: tableId,
    });
  });
  
  return { stoves, counters, tables, chairs };
}

// Generate initial furniture on load
const INITIAL_FURNITURE = generateRandomInitialFurniture();

const COUNTER_STYLES = {
  // === BASIC COUNTERS (400-800ðŸª™) ===
  basic: {
    name: 'Basic Green', icon: 'ðŸ’š', cost: 500, type: 'basic',
    cabinetColor: 0x2e8b57, topColor: 0xfafafa, handleColor: 0x888888,
  },
  basicWhite: {
    name: 'Basic White', icon: 'â¬œ', cost: 500, type: 'basic',
    cabinetColor: 0xf5f5f5, topColor: 0xfafafa, handleColor: 0x666666,
  },
  basicBlack: {
    name: 'Basic Black', icon: 'â¬›', cost: 500, type: 'basic',
    cabinetColor: 0x2d2d2d, topColor: 0xe0e0e0, handleColor: 0x888888,
  },
  basicRed: {
    name: 'Basic Red', icon: 'â¤ï¸', cost: 500, type: 'basic',
    cabinetColor: 0x8b2020, topColor: 0xfafafa, handleColor: 0x888888,
  },
  basicBlue: {
    name: 'Basic Blue', icon: 'ðŸ’™', cost: 500, type: 'basic',
    cabinetColor: 0x1e4d7b, topColor: 0xfafafa, handleColor: 0x888888,
  },
  
  // === MODERN COUNTERS (1000-2000ðŸª™) ===
  modernWhite: {
    name: 'Modern White', icon: 'ðŸ¤', cost: 1200, type: 'modern',
    cabinetColor: 0xfafafa, topColor: 0xe8e8e8, accentColor: 0x333333,
  },
  modernBlack: {
    name: 'Modern Black', icon: 'ðŸ–¤', cost: 1200, type: 'modern',
    cabinetColor: 0x1a1a1a, topColor: 0x333333, accentColor: 0x888888,
  },
  modernGray: {
    name: 'Modern Gray', icon: 'ðŸ©¶', cost: 1200, type: 'modern',
    cabinetColor: 0x555555, topColor: 0x444444, accentColor: 0x888888,
  },
  modernNavy: {
    name: 'Modern Navy', icon: 'ðŸ”µ', cost: 1200, type: 'modern',
    cabinetColor: 0x1a2a4a, topColor: 0x3a4a6a, accentColor: 0xaabbcc,
  },
  
  // === RETRO/VINTAGE COUNTERS (2000-3500ðŸª™) - Pastels + Chrome ===
  retroMint: {
    name: 'Retro Mint', icon: 'ðŸŒ¿', cost: 2000, type: 'retro',
    bodyColor: 0x88c4cc, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  retroPink: {
    name: 'Retro Pink', icon: 'ðŸŒ¸', cost: 2000, type: 'retro',
    bodyColor: 0xdda0a0, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  retroYellow: {
    name: 'Retro Yellow', icon: 'ðŸŒ»', cost: 2000, type: 'retro',
    bodyColor: 0xe8d888, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  retroCream: {
    name: 'Retro Cream', icon: 'ðŸ¦', cost: 2000, type: 'retro',
    bodyColor: 0xf5f0e0, chromeColor: 0xcccccc, topColor: 0xffffff,
  },
  retroLavender: {
    name: 'Retro Lavender', icon: 'ðŸ’œ', cost: 2000, type: 'retro',
    bodyColor: 0xb8a8c8, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  retroCoral: {
    name: 'Retro Coral', icon: 'ðŸª¸', cost: 2000, type: 'retro',
    bodyColor: 0xe89080, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  retroRobinEgg: {
    name: 'Robin Egg', icon: 'ðŸ¥š', cost: 2000, type: 'retro',
    bodyColor: 0x70c8d8, chromeColor: 0xeeeeee, topColor: 0xffffff,
  },
  retroPeach: {
    name: 'Retro Peach', icon: 'ðŸ‘', cost: 2000, type: 'retro',
    bodyColor: 0xf8c8a8, chromeColor: 0xdddddd, topColor: 0xf8f8f8,
  },
  
  // === WOOD & NATURAL COUNTERS (2500-4000ðŸª™) ===
  woodOak: {
    name: 'Oak Counter', icon: 'ðŸªµ', cost: 3000, type: 'wood',
    cabinetColor: 0xDEB887, topColor: 0xD2B48C, trimColor: 0x8B7355,
  },
  woodWalnut: {
    name: 'Walnut Counter', icon: 'ðŸŸ¤', cost: 3000, type: 'wood',
    cabinetColor: 0x5D4037, topColor: 0x4E342E, trimColor: 0x3E2723,
  },
  woodCherry: {
    name: 'Cherry Counter', icon: 'ðŸ’', cost: 3000, type: 'wood',
    cabinetColor: 0x8B4513, topColor: 0x7B3F00, trimColor: 0x5D2906,
  },
  woodMaple: {
    name: 'Maple Counter', icon: 'ðŸ', cost: 3000, type: 'wood',
    cabinetColor: 0xE8D4A8, topColor: 0xDCC69C, trimColor: 0xC4A77D,
  },
  woodBamboo: {
    name: 'Bamboo Counter', icon: 'ðŸŽ‹', cost: 3000, type: 'wood',
    cabinetColor: 0xC4A35A, topColor: 0xB8956E, trimColor: 0x8B7355,
  },
  
  // === MARBLE & LUXURY COUNTERS (5000-10000ðŸª™) ===
  marbleCarrara: {
    name: 'Carrara Marble', icon: 'ðŸª¨', cost: 7000, type: 'marble',
    cabinetColor: 0x2F2F2F, topColor: 0xE8E8E8, accentColor: 0xCCCCCC,
  },
  marbleNero: {
    name: 'Nero Marble', icon: 'ðŸ–¤', cost: 7000, type: 'marble',
    cabinetColor: 0x1a1a1a, topColor: 0x2a2a2a, accentColor: 0xFFD700,
  },
  marbleCalacatta: {
    name: 'Calacatta', icon: 'âœ¨', cost: 7000, type: 'marble',
    cabinetColor: 0xF5F5F5, topColor: 0xFAFAFA, accentColor: 0xDDDDDD,
  },
  marbleEmperador: {
    name: 'Emperador', icon: 'ðŸ‘‘', cost: 7000, type: 'marble',
    cabinetColor: 0x3D2914, topColor: 0x5D4037, accentColor: 0x8D6E63,
  },
  
  // === COMMERCIAL COUNTERS (6000-12000ðŸª™) ===
  commercialStainless: {
    name: 'Commercial SS', icon: 'ðŸª', cost: 6500, type: 'commercial',
    bodyColor: 0x99aabb, topColor: 0xaabbcc, trimColor: 0x888899,
  },
  commercialBlack: {
    name: 'Commercial Black', icon: 'ðŸ­', cost: 6500, type: 'commercial',
    bodyColor: 0x2a2a2a, topColor: 0x3a3a3a, trimColor: 0x444444,
  },
  commercialGalvanized: {
    name: 'Galvanized', icon: 'âš™ï¸', cost: 6500, type: 'commercial',
    bodyColor: 0x8899aa, topColor: 0x99aabb, trimColor: 0x778899,
  },
};

// === FURNITURE COLLECTIONS ===
// Group variants by collection for cleaner shop UI (1 slot with color swatches instead of N slots)
// Swatches use the most visually distinctive color for each type

const TABLE_COLLECTIONS = {
  wood: {
    name: 'Wood', icon: 'ðŸªµ', cost: 750,
    variants: ['basicWood', 'oak', 'modernBlack', 'mahogany'],
    colors: [0xA0522D, 0xDEB887, 0x1a1a1a, 0x420D09], // woodColor
    colorNames: ['Basic', 'Oak', 'Black', 'Mahogany'],
  },
  cloth: {
    name: 'Cloth', icon: 'ðŸ§µ', cost: 2000,
    variants: ['square', 'whiteElegant', 'rusticFarm', 'redDiner', 'darkCherry', 'blueOcean', 'pinkRomantic', 'greenGarden', 'premiumWhite', 'goldLuxury', 'luxuryPink'],
    colors: [0xDC143C, 0xFFFFFF, 0xF5DEB3, 0xCC0000, 0x800020, 0x1E90FF, 0xFFB6C1, 0x228B22, 0xFFFACD, 0x800020, 0xFF69B4], // clothColor
    colorNames: ['Classic Red', 'White', 'Rustic', 'Red Diner', 'Cherry', 'Ocean', 'Pink', 'Garden', 'Premium', 'Gold', 'Luxury Pink'],
  },
  diner: {
    name: 'Diner', icon: 'ðŸ”', cost: 2500,
    variants: ['dinerClassic', 'dinerPink', 'dinerMint', 'dinerTurquoise', 'dinerRed', 'dinerCheckered'],
    colors: [0xf5f5f5, 0xffb6c1, 0x98ff98, 0x40e0d0, 0xdc143c, 0x888888], // topColor (checkered = gray for pattern)
    colorNames: ['Classic', 'Pink', 'Mint', 'Turquoise', 'Red', 'Checkered'],
  },
  romantic: {
    name: 'Romantic', icon: 'ðŸŒ¹', cost: 6000,
    variants: ['romanticPink', 'romanticRed', 'romanticWhite', 'romanticLavender', 'romanticChampagne', 'romanticBlue'],
    colors: [0xf8a0b0, 0xdc143c, 0xfffafa, 0xc8a2c8, 0xf4d98c, 0xadd8e6], // clothColor
    colorNames: ['Pink', 'Red', 'White', 'Lavender', 'Champagne', 'Blue'],
  },
  mediterranean: {
    name: 'Mediterranean', icon: 'ðŸ›ï¸', cost: 4000,
    variants: ['medTuscan', 'medGreek', 'medSpanish', 'medMosaic', 'medTerracotta', 'medOlive'],
    colors: [0xcd853f, 0x4169e1, 0xdc143c, 0x20b2aa, 0xcd5c5c, 0x6b8e23], // accentColor (mosaic pattern)
    colorNames: ['Tuscan', 'Greek', 'Spanish', 'Mosaic', 'Terracotta', 'Olive'],
  },
};

const CHAIR_COLLECTIONS = {
  wood: {
    name: 'Wood', icon: 'ðŸªµ', cost: 200,
    variants: ['basicWood', 'oak', 'darkWood', 'white', 'black'],
    colors: [0xA0522D, 0xDEB887, 0x8B4513, 0xF5F5F5, 0x2D2D2D], // frame color
    colorNames: ['Basic', 'Oak', 'Dark', 'White', 'Black'],
  },
  cushion: {
    name: 'Cushion', icon: 'ðŸ”´', cost: 450,
    variants: ['redCushion', 'blueCushion', 'greenCushion', 'pinkCushion'],
    colors: [0xDC143C, 0x1E90FF, 0x228B22, 0xFFB6C1], // seatColor (cushion)
    colorNames: ['Red', 'Blue', 'Green', 'Pink'],
  },
  velvet: {
    name: 'Velvet', icon: 'ðŸ·', cost: 1000,
    variants: ['velvetRed', 'velvetBlue'],
    colors: [0x800020, 0x191970], // seatColor (velvet)
    colorNames: ['Red', 'Blue'],
  },
  diner: {
    name: 'Diner', icon: 'ðŸ”', cost: 750,
    variants: ['dinerClassic', 'dinerPink', 'dinerMint', 'dinerTurquoise', 'dinerRed', 'dinerYellow'],
    colors: [0xdc143c, 0xffb6c1, 0x98ff98, 0x40e0d0, 0xdc143c, 0xf5e6c8], // seatColor
    colorNames: ['Classic', 'Pink', 'Mint', 'Turquoise', 'Red', 'Yellow'],
  },
  romantic: {
    name: 'Romantic', icon: 'ðŸŒ¹', cost: 2000,
    variants: ['romanticPink', 'romanticRed', 'romanticWhite', 'romanticLavender', 'romanticChampagne', 'romanticBlue'],
    colors: [0xf8a0b0, 0xdc143c, 0xfffafa, 0xc8a2c8, 0xf4d98c, 0xadd8e6], // seatColor
    colorNames: ['Pink', 'Red', 'White', 'Lavender', 'Champagne', 'Blue'],
  },
  mediterranean: {
    name: 'Mediterranean', icon: 'ðŸ›ï¸', cost: 1200,
    variants: ['medTuscan', 'medGreek', 'medSpanish', 'medMosaic', 'medTerracotta', 'medOlive'],
    colors: [0xdeb887, 0xffffff, 0xf4a460, 0xf5f5dc, 0xe2725b, 0x808000], // seatColor
    colorNames: ['Tuscan', 'Greek', 'Spanish', 'Mosaic', 'Terracotta', 'Olive'],
  },
};

const STOVE_COLLECTIONS = {
  basic: {
    name: 'Basic', icon: 'ðŸ³', cost: 500,
    variants: ['basic', 'basicWhite', 'basicBlack'],
    colors: [0x505050, 0xf0f0f0, 0x303030], // bodyColor
    colorNames: ['Gray', 'White', 'Black'],
  },
  modern: {
    name: 'Modern', icon: 'ðŸ–¤', cost: 1500,
    variants: ['modernBlack', 'modernWhite', 'modernStainless', 'modernRed', 'modernNavy'],
    colors: [0x303030, 0xf0f0f0, 0x8899aa, 0x8b2020, 0x1a2a4a], // bodyColor
    colorNames: ['Black', 'White', 'Stainless', 'Red', 'Navy'],
  },
  professional: {
    name: 'Pro', icon: 'ðŸ‘¨â€ðŸ³', cost: 3500,
    variants: ['proStainless', 'proBlack', 'proRed', 'proBlue', 'proWhite'],
    colors: [0xaabbcc, 0x1a1a1a, 0x8b1a1a, 0x1a2a5a, 0xe8e8e8], // panelColor/bodyColor
    colorNames: ['Stainless', 'Black', 'Red', 'Blue', 'White'],
  },
  retro: {
    name: 'Retro', icon: 'ðŸŽ€', cost: 4000,
    variants: ['retroMint', 'retroPink', 'retroYellow', 'retroCream', 'retroLavender', 'retroCoral', 'retroRobinEgg', 'retroPeach'],
    colors: [0x88c4cc, 0xdda0a0, 0xe8d888, 0xf5f0e0, 0xb8a8c8, 0xe89080, 0x70c8d8, 0xf8c8a8], // bodyColor
    colorNames: ['Mint', 'Pink', 'Yellow', 'Cream', 'Lavender', 'Coral', 'Robin Egg', 'Peach'],
  },
  glasstop: {
    name: 'Glass Top', icon: 'ðŸ”³', cost: 5500,
    variants: ['glassBlack', 'glassWhite', 'glassStainless', 'glassGraphite'],
    colors: [0x1a1a1a, 0xf0f0f0, 0x8899aa, 0x3a3a3a], // bodyColor
    colorNames: ['Black', 'White', 'Stainless', 'Graphite'],
  },
  commercial: {
    name: 'Commercial', icon: 'ðŸª', cost: 8000,
    variants: ['commercialStainless', 'commercialBlack', 'commercialCharcoal'],
    colors: [0x99aabb, 0x2a2a2a, 0x4a4a4a], // bodyColor
    colorNames: ['Stainless', 'Black', 'Charcoal'],
  },
};

const COUNTER_COLLECTIONS = {
  basic: {
    name: 'Basic', icon: 'ðŸ’š', cost: 500,
    variants: ['basic', 'basicWhite', 'basicBlack', 'basicRed', 'basicBlue'],
    colors: [0x2e8b57, 0xf5f5f5, 0x2d2d2d, 0x8b2020, 0x1e4d7b], // cabinetColor
    colorNames: ['Green', 'White', 'Black', 'Red', 'Blue'],
  },
  modern: {
    name: 'Modern', icon: 'ðŸ–¤', cost: 1200,
    variants: ['modernWhite', 'modernBlack', 'modernGray', 'modernNavy'],
    colors: [0xfafafa, 0x1a1a1a, 0x555555, 0x1a2a4a], // cabinetColor
    colorNames: ['White', 'Black', 'Gray', 'Navy'],
  },
  retro: {
    name: 'Retro', icon: 'ðŸŽ€', cost: 2000,
    variants: ['retroMint', 'retroPink', 'retroYellow', 'retroCream', 'retroLavender', 'retroCoral', 'retroRobinEgg', 'retroPeach'],
    colors: [0x88c4cc, 0xdda0a0, 0xe8d888, 0xf5f0e0, 0xb8a8c8, 0xe89080, 0x70c8d8, 0xf8c8a8], // bodyColor
    colorNames: ['Mint', 'Pink', 'Yellow', 'Cream', 'Lavender', 'Coral', 'Robin Egg', 'Peach'],
  },
  wood: {
    name: 'Wood', icon: 'ðŸªµ', cost: 3000,
    variants: ['woodOak', 'woodWalnut', 'woodCherry', 'woodMaple', 'woodBamboo'],
    colors: [0xDEB887, 0x5D4037, 0x8B4513, 0xE8D4A8, 0xC4A35A], // cabinetColor
    colorNames: ['Oak', 'Walnut', 'Cherry', 'Maple', 'Bamboo'],
  },
  marble: {
    name: 'Marble', icon: 'ðŸª¨', cost: 7000,
    variants: ['marbleCarrara', 'marbleNero', 'marbleCalacatta', 'marbleEmperador'],
    colors: [0xE8E8E8, 0x2a2a2a, 0xFAFAFA, 0x5D4037], // topColor (marble surface)
    colorNames: ['Carrara', 'Nero', 'Calacatta', 'Emperador'],
  },
  commercial: {
    name: 'Commercial', icon: 'ðŸª', cost: 6500,
    variants: ['commercialStainless', 'commercialBlack', 'commercialGalvanized'],
    colors: [0x99aabb, 0x2a2a2a, 0x8899aa], // bodyColor
    colorNames: ['Stainless', 'Black', 'Galvanized'],
  },
};

// Get all variant keys that belong to collections (to exclude from individual listing)
const TABLE_COLLECTION_VARIANTS = Object.values(TABLE_COLLECTIONS).flatMap(c => c.variants);
const CHAIR_COLLECTION_VARIANTS = Object.values(CHAIR_COLLECTIONS).flatMap(c => c.variants);
const STOVE_COLLECTION_VARIANTS = Object.values(STOVE_COLLECTIONS).flatMap(c => c.variants);
const COUNTER_COLLECTION_VARIANTS = Object.values(COUNTER_COLLECTIONS).flatMap(c => c.variants);

// Helper: Get chair tile position based on table position and rotation
// Used for LEGACY tables that have built-in chairs
// Rotation: 0=chair left, 1=chair up, 2=chair right, 3=chair down
const getChairTile = (tableGridX, tableGridZ, rotation) => {
  // Must match visual positioning: x' = -offset*cos(Î¸), z' = +offset*sin(Î¸)
  const offsets = [
    [-1, 0],  // Rotation 0: chair to the left (X-1)
    [0, 1],   // Rotation 1: chair in front/down (Z+1) - toward camera
    [1, 0],   // Rotation 2: chair to the right (X+1)
    [0, -1],  // Rotation 3: chair behind/up (Z-1) - toward back
  ];
  const [dx, dz] = offsets[rotation % 4];
  return { gridX: tableGridX + dx, gridZ: tableGridZ + dz };
};

// Helper: Get all tiles occupied by a table
// New tables occupy only 1 tile (the table itself)
// Legacy tables with hasBuiltInChair=true occupy 2 tiles
const getTableTiles = (table) => {
  // New tables (no built-in chair) occupy only 1 tile
  if (!table.hasBuiltInChair) {
    return [{ gridX: table.gridX, gridZ: table.gridZ, type: 'table' }];
  }
  // Legacy tables occupy 2 tiles (table + chair)
  const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
  return [
    { gridX: table.gridX, gridZ: table.gridZ, type: 'table' },
    { gridX: chairTile.gridX, gridZ: chairTile.gridZ, type: 'chair' },
  ];
};

// Helper: Find a chair adjacent to a table position
// Returns the chair object if found, null otherwise
const findChairForTable = (table, chairs) => {
  // First, check for explicitly linked chairs (new system)
  const linkedChair = chairs.find(c => c.linkedTableId === table.id);
  if (linkedChair) return linkedChair;
  
  // Fallback for old saves: check all 4 adjacent tiles for a chair facing this table
  const adjacentOffsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  for (const [dx, dz] of adjacentOffsets) {
    const chair = chairs.find(c => 
      c.gridX === table.gridX + dx && 
      c.gridZ === table.gridZ + dz &&
      !c.linkedTableId // Only unlinked chairs for fallback
    );
    if (chair) {
      // Check if chair is facing the table
      const facingTile = getChairFacingTile(chair.gridX, chair.gridZ, chair.rotation || 0);
      if (facingTile.gridX === table.gridX && facingTile.gridZ === table.gridZ) {
        return chair;
      }
    }
  }
  return null;
};

// Helper: Get the tile position a chair is facing based on its rotation
const getChairFacingTile = (gridX, gridZ, rotation) => {
  // Chair rotation: 0=faces +Z, 1=faces +X, 2=faces -Z, 3=faces -X
  // In THREE.js, positive rotation.y is counter-clockwise from above
  switch (rotation % 4) {
    case 0: return { gridX, gridZ: gridZ + 1 };      // Faces +Z (south)
    case 1: return { gridX: gridX + 1, gridZ };      // Faces +X (east)
    case 2: return { gridX, gridZ: gridZ - 1 };      // Faces -Z (north)
    case 3: return { gridX: gridX - 1, gridZ };      // Faces -X (west)
    default: return { gridX, gridZ: gridZ + 1 };
  }
};

// Helper: Find a table at a specific grid position
const findTableAtPosition = (tables, gridX, gridZ) => {
  return tables.find(t => t.gridX === gridX && t.gridZ === gridZ);
};

// Helper: Check if a table already has a chair linked to it
const isTableLinkedToChair = (chairs, tableId) => {
  return chairs.some(c => c.linkedTableId === tableId);
};

// Helper: Get the table a chair is adjacent to
const findTableForChair = (chair, tables) => {
  const adjacentOffsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  for (const [dx, dz] of adjacentOffsets) {
    const table = tables.find(t => 
      t.gridX === chair.gridX + dx && 
      t.gridZ === chair.gridZ + dz
    );
    if (table) return table;
  }
  return null;
};

// Helper: Calculate chair rotation to face the table
const getChairRotationForTable = (chairGridX, chairGridZ, tableGridX, tableGridZ) => {
  const dx = tableGridX - chairGridX;
  const dz = tableGridZ - chairGridZ;
  // Return rotation so chair faces the table
  if (dx > 0) return 1;  // Table is to the right, face right (-X direction)
  if (dx < 0) return 3;  // Table is to the left, face left (+X direction)
  if (dz > 0) return 0;  // Table is forward, face forward (+Z direction)
  if (dz < 0) return 2;  // Table is behind, face back (-Z direction)
  return 0; // Default
};

// ============================================
// TILE OCCUPANCY SYSTEM (Story 8.4)
// ============================================
// All rotatable objects use: 0=front faces +Z, 1=front faces -X, 2=front faces -Z, 3=front faces +X
// "Front" is where NPCs stand to interact with the object

// Direction offsets for each rotation
const DIRECTION_OFFSETS = [
  [0, 1],   // Rotation 0: front faces +Z (toward camera/dining area)
  [-1, 0],  // Rotation 1: front faces -X (toward left)
  [0, -1],  // Rotation 2: front faces -Z (toward back/kitchen)
  [1, 0],   // Rotation 3: front faces +X (toward right)
];

// Get the tile where an NPC should stand to interact with an object
const getInteractionTile = (objectType, gridX, gridZ, rotation = 0) => {
  const [dx, dz] = DIRECTION_OFFSETS[rotation % 4];
  
  switch (objectType) {
    case 'stove':
      // Chef stands in front of stove to cook
      return { gridX: gridX + dx, gridZ: gridZ + dz };
    case 'counter':
      // Customer stands in front of counter to get food
      return { gridX: gridX + dx, gridZ: gridZ + dz };
    case 'table':
      // Customer sits in chair (handled by getChairTile)
      return getChairTile(gridX, gridZ, rotation);
    default:
      return { gridX, gridZ };
  }
};

// Get all tiles an object occupies (blocks movement)
const getObjectTiles = (objectType, gridX, gridZ, rotation = 0, hasBuiltInChair = false) => {
  switch (objectType) {
    case 'stove':
      return [{ gridX, gridZ, type: 'stove' }];
    case 'counter':
      return [{ gridX, gridZ, type: 'counter' }];
    case 'table':
      // New tables (no built-in chair) occupy 1 tile
      if (!hasBuiltInChair) {
        return [{ gridX, gridZ, type: 'table' }];
      }
      // Legacy tables with built-in chair occupy 2 tiles
      const chairTile = getChairTile(gridX, gridZ, rotation);
      return [
        { gridX, gridZ, type: 'table' },
        { gridX: chairTile.gridX, gridZ: chairTile.gridZ, type: 'chair' },
      ];
    case 'chair':
      // Standalone chairs occupy 1 tile
      return [{ gridX, gridZ, type: 'chair' }];
    case 'decoration':
      return [{ gridX, gridZ, type: 'decoration' }];
    default:
      return [{ gridX, gridZ, type: objectType }];
  }
};

// Create tile key for map lookups
const getTileKey = (gridX, gridZ) => `${gridX},${gridZ}`;

// Build complete occupancy map from game state
const buildOccupancyMap = (state) => {
  const map = new Map(); // key: "x,z", value: { type, id, rotation }
  
  // Add stoves
  state.stoves.forEach(stove => {
    const key = getTileKey(stove.gridX, stove.gridZ);
    map.set(key, { type: 'stove', id: stove.id, rotation: stove.rotation || 0 });
  });
  
  // Add counters
  state.counters.forEach(counter => {
    const key = getTileKey(counter.gridX, counter.gridZ);
    map.set(key, { type: 'counter', id: counter.id, rotation: counter.rotation || 0 });
  });
  
  // Add tables (new tables = 1 tile, legacy tables with built-in chairs = 2 tiles)
  state.tables.forEach(table => {
    const tiles = getTableTiles(table);
    tiles.forEach(tile => {
      const key = getTileKey(tile.gridX, tile.gridZ);
      map.set(key, { type: tile.type, id: table.id, rotation: table.rotation || 0 });
    });
  });
  
  // Add standalone chairs (separate from tables)
  if (state.chairs) {
    state.chairs.forEach(chair => {
      const key = getTileKey(chair.gridX, chair.gridZ);
      map.set(key, { type: 'chair', id: chair.id, chairStyle: chair.style, rotation: chair.rotation || 0 });
    });
  }
  
  // Add floor decorations that block movement (not rugs - you can walk on those!)
  state.decorations.forEach(decor => {
    const decorType = DECORATIONS[decor.type];
    // Only add to occupancy if it's a floor decoration AND it blocks movement
    // blocksMovement defaults to true for backward compatibility (old decorations without the property)
    if (decorType && decorType.category === 'floor' && decorType.blocksMovement !== false) {
      const key = getTileKey(decor.gridX, decor.gridZ);
      map.set(key, { type: 'decoration', id: decor.id, decorType: decor.type });
    }
  });
  
  // Add dividers (always block pathfinding)
  if (state.dividers) {
    state.dividers.forEach(divider => {
      const key = getTileKey(divider.gridX, divider.gridZ);
      map.set(key, { type: 'divider', id: divider.id, dividerType: divider.type, rotation: divider.rotation || 0 });
    });
  }
  
  return map;
};

// Check if a tile is occupied
const isTileOccupied = (occupancyMap, gridX, gridZ) => {
  return occupancyMap.has(getTileKey(gridX, gridZ));
};

// Check if a tile is walkable (not occupied by blocking object)
const isTileWalkable = (occupancyMap, gridX, gridZ, gridWidth, gridHeight) => {
  // Out of bounds
  if (gridX < 0 || gridX >= gridWidth || gridZ < 0 || gridZ >= gridHeight) {
    return false;
  }
  // Check occupancy
  return !isTileOccupied(occupancyMap, gridX, gridZ);
};

// Find an adjacent walkable tile for delivering to a customer (next to chair, not on it)
const getDeliveryTile = (occupancyMap, chairX, chairZ, gridWidth, gridHeight) => {
  // Try adjacent tiles in order of preference (front, sides, back)
  const adjacentOffsets = [
    { dx: 0, dz: 1 },   // Front (toward cafe)
    { dx: 1, dz: 0 },   // Right
    { dx: -1, dz: 0 },  // Left
    { dx: 0, dz: -1 },  // Back (toward kitchen)
    { dx: 1, dz: 1 },   // Front-right diagonal
    { dx: -1, dz: 1 },  // Front-left diagonal
    { dx: 1, dz: -1 },  // Back-right diagonal
    { dx: -1, dz: -1 }, // Back-left diagonal
  ];
  
  for (const offset of adjacentOffsets) {
    const testX = chairX + offset.dx;
    const testZ = chairZ + offset.dz;
    
    // Check bounds and walkability
    if (testX >= 0 && testX < gridWidth && testZ >= 0 && testZ < gridHeight) {
      if (!isTileOccupied(occupancyMap, testX, testZ)) {
        return { gridX: testX, gridZ: testZ };
      }
    }
  }
  
  // Fallback: return the chair position itself (waiter will walk onto customer)
  return { gridX: chairX, gridZ: chairZ };
};

// Get the most urgent waiting customer (lowest patience = most urgent, or longest wait time)
// Filters out customers already being served by a waiter (locked)
// excludeTableId: optional table to exclude (e.g., current delivery target)
// lockedTableIds: array of tableIds already targeted by other waiters
const getMostUrgentCustomer = (tables, excludeTableId = null, lockedTableIds = []) => {
  const waitingTables = tables.filter(t => {
    if (!t.customer || t.customer.state !== 'waiting') return false;
    if (excludeTableId && t.id === excludeTableId) return false;
    if (lockedTableIds.includes(t.id)) return false; // Skip customers already targeted by another waiter
    return true;
  });
  
  if (waitingTables.length === 0) return null;
  
  // Sort by patience (lowest first = most urgent)
  // If patience is equal, sort by spawnTime (earliest first = waited longest)
  waitingTables.sort((a, b) => {
    const patienceA = a.customer.patience ?? 100;
    const patienceB = b.customer.patience ?? 100;
    
    // Lower patience = higher priority
    if (patienceA !== patienceB) {
      return patienceA - patienceB;
    }
    
    // If patience is equal, earlier spawn time = higher priority
    const spawnA = a.customer.spawnTime ?? Date.now();
    const spawnB = b.customer.spawnTime ?? Date.now();
    return spawnA - spawnB;
  });
  
  return waitingTables[0];
};

// Get all table IDs currently being targeted by waiters (to prevent double-serving)
const getLockedTableIds = (waiters, excludeWaiterId = null) => {
  return waiters
    .filter(w => w.id !== excludeWaiterId && w.targetTableId)
    .map(w => w.targetTableId);
};

// A* Pathfinding Algorithm
// Returns array of {gridX, gridZ} tiles from start to end, or null if no path
const findPath = (occupancyMap, startX, startZ, endX, endZ, gridWidth, gridHeight) => {
  // If start or end is out of bounds, return null
  if (startX < 0 || startX >= gridWidth || startZ < 0 || startZ >= gridHeight ||
      endX < 0 || endX >= gridWidth || endZ < 0 || endZ >= gridHeight) {
    return null;
  }
  
  // If end tile is occupied, find nearest walkable tile
  let targetX = endX;
  let targetZ = endZ;
  if (isTileOccupied(occupancyMap, endX, endZ)) {
    // Search adjacent tiles for walkable one
    const adjacent = [
      { x: endX, z: endZ + 1 }, // Front
      { x: endX, z: endZ - 1 }, // Back
      { x: endX - 1, z: endZ }, // Left
      { x: endX + 1, z: endZ }, // Right
    ];
    let found = false;
    for (const adj of adjacent) {
      if (isTileWalkable(occupancyMap, adj.x, adj.z, gridWidth, gridHeight)) {
        targetX = adj.x;
        targetZ = adj.z;
        found = true;
        break;
      }
    }
    if (!found) return null; // No walkable tiles near destination
  }
  
  // A* implementation
  const openSet = [];
  const closedSet = new Set();
  const cameFrom = new Map();
  const gScore = new Map();
  const fScore = new Map();
  
  const getKey = (x, z) => `${x},${z}`;
  const heuristic = (x1, z1, x2, z2) => Math.abs(x1 - x2) + Math.abs(z1 - z2); // Manhattan distance
  
  const startKey = getKey(startX, startZ);
  gScore.set(startKey, 0);
  fScore.set(startKey, heuristic(startX, startZ, targetX, targetZ));
  openSet.push({ x: startX, z: startZ, f: fScore.get(startKey) });
  
  // Directions: 4-way movement (no diagonals for cleaner paths)
  const directions = [
    { dx: 0, dz: 1 },  // Down (+Z)
    { dx: 0, dz: -1 }, // Up (-Z)
    { dx: 1, dz: 0 },  // Right (+X)
    { dx: -1, dz: 0 }, // Left (-X)
  ];
  
  let iterations = 0;
  const maxIterations = gridWidth * gridHeight * 2; // Prevent infinite loops
  
  while (openSet.length > 0 && iterations < maxIterations) {
    iterations++;
    
    // Find node with lowest fScore
    openSet.sort((a, b) => a.f - b.f);
    const current = openSet.shift();
    const currentKey = getKey(current.x, current.z);
    
    // Reached destination?
    if (current.x === targetX && current.z === targetZ) {
      // Reconstruct path
      const path = [];
      let key = currentKey;
      while (key) {
        const [x, z] = key.split(',').map(Number);
        path.unshift({ gridX: x, gridZ: z });
        key = cameFrom.get(key);
      }
      return path;
    }
    
    closedSet.add(currentKey);
    
    // Check neighbors
    for (const dir of directions) {
      const nx = current.x + dir.dx;
      const nz = current.z + dir.dz;
      const neighborKey = getKey(nx, nz);
      
      // Skip if already evaluated
      if (closedSet.has(neighborKey)) continue;
      
      // Skip if not walkable (unless it's the target tile - we already validated it)
      if (nx !== targetX || nz !== targetZ) {
        if (!isTileWalkable(occupancyMap, nx, nz, gridWidth, gridHeight)) continue;
      }
      
      const tentativeG = gScore.get(currentKey) + 1;
      
      // Is this a better path?
      if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
        cameFrom.set(neighborKey, currentKey);
        gScore.set(neighborKey, tentativeG);
        const f = tentativeG + heuristic(nx, nz, targetX, targetZ);
        fScore.set(neighborKey, f);
        
        // Add to open set if not already there
        if (!openSet.some(n => n.x === nx && n.z === nz)) {
          openSet.push({ x: nx, z: nz, f });
        }
      }
    }
  }
  
  // No path found
  return null;
};

// Get rotation angle in radians for 3D rendering
const getRotationAngle = (rotation) => {
  return (rotation % 4) * (Math.PI / 2); // 0, 90, 180, 270 degrees
};

// Decoration types for cafe customization
const DECORATIONS = {
  // Plants - all block movement (you can't walk through a potted plant!)
  plant: { name: 'Potted Plant', icon: 'ðŸª´', cost: 100, buzz: 2, category: 'floor', blocksMovement: true },
  plant2: { name: 'Tall Plant', icon: 'ðŸŒ¿', cost: 175, buzz: 2, category: 'floor', blocksMovement: true },
  cactus: { name: 'Cactus', icon: 'ðŸŒµ', cost: 125, buzz: 2, category: 'floor', blocksMovement: true },
  flowers: { name: 'Flower Bouquet', icon: 'ðŸ’', cost: 150, buzz: 3, category: 'floor', blocksMovement: true },
  tulips: { name: 'Pink Tulips', icon: 'ðŸŒ·', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  sunflower: { name: 'Sunflower Pot', icon: 'ðŸŒ»', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  
  // Lighting - floor lamps and candle tables block movement
  floorLamp: { name: 'Floor Lamp', icon: 'ðŸª”', cost: 150, buzz: 2, category: 'floor', blocksMovement: true },
  candleTable: { name: 'Candle Table', icon: 'ðŸ•¯ï¸', cost: 125, buzz: 3, category: 'floor', blocksMovement: true },
  fairyLights: { name: 'Fairy Lights', icon: 'âœ¨', cost: 300, buzz: 5, category: 'wall' },
  
  // Floor items - RUGS are walkable! You walk ON them, not around them
  rug: { name: 'Cozy Rug', icon: 'ðŸŸ«', cost: 200, buzz: 3, category: 'floor', blocksMovement: false },
  pinkRug: { name: 'Pink Rug', icon: 'ðŸ©·', cost: 250, buzz: 4, category: 'floor', blocksMovement: false },
  
  // Wall decor - walls don't block floor movement
  window: { name: 'Window', icon: 'ðŸªŸ', cost: 200, buzz: 3, category: 'wall' },
  picture: { name: 'Wall Art', icon: 'ðŸ–¼ï¸', cost: 250, buzz: 3, category: 'wall' },
  clock: { name: 'Wall Clock', icon: 'ðŸ•', cost: 175, buzz: 2, category: 'wall' },
  heart: { name: 'Heart Sign', icon: 'â¤ï¸', cost: 200, buzz: 4, category: 'wall' },
  star: { name: 'Star Decor', icon: 'â­', cost: 225, buzz: 4, category: 'wall' },
  menu: { name: 'Menu Board', icon: 'ðŸ“‹', cost: 300, buzz: 5, category: 'wall' },
  
  // Special items - all large items that block movement
  jukebox: { name: 'Jukebox', icon: 'ðŸŽµ', cost: 500, buzz: 8, category: 'floor', blocksMovement: true },
  aquarium: { name: 'Aquarium', icon: 'ðŸ ', cost: 600, buzz: 10, category: 'floor', blocksMovement: true },
  fountain: { name: 'Mini Fountain', icon: 'â›²', cost: 450, buzz: 7, category: 'floor', blocksMovement: true },
  cakeDisplay: { name: 'Cake Display', icon: 'ðŸŽ‚', cost: 350, buzz: 6, category: 'floor', blocksMovement: true },
  gumball: { name: 'Gumball Machine', icon: 'ðŸ”´', cost: 275, buzz: 5, category: 'floor', blocksMovement: true },
  
  // Cute stuff - small items on display stands that block movement
  teddyBear: { name: 'Teddy Bear', icon: 'ðŸ§¸', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  balloons: { name: 'Balloons', icon: 'ðŸŽˆ', cost: 150, buzz: 3, category: 'floor', blocksMovement: true },
  giftBox: { name: 'Gift Box', icon: 'ðŸŽ', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  
  // Plushie Collection! ðŸ§¸ - all plushies are on display stands and block movement
  catPlush: { name: 'Cat Plushie', icon: 'ðŸ±', cost: 225, buzz: 4, category: 'floor', blocksMovement: true },
  dogPlush: { name: 'Dog Plushie', icon: 'ðŸ¶', cost: 225, buzz: 4, category: 'floor', blocksMovement: true },
  bunnyPlush: { name: 'Bunny Plushie', icon: 'ðŸ°', cost: 250, buzz: 5, category: 'floor', blocksMovement: true },
  pandaPlush: { name: 'Panda Plushie', icon: 'ðŸ¼', cost: 300, buzz: 5, category: 'floor', blocksMovement: true },
  penguinPlush: { name: 'Penguin Plushie', icon: 'ðŸ§', cost: 250, buzz: 5, category: 'floor', blocksMovement: true },
  unicornPlush: { name: 'Unicorn Plushie', icon: 'ðŸ¦„', cost: 400, buzz: 7, category: 'floor', blocksMovement: true },
  pigPlush: { name: 'Pig Plushie', icon: 'ðŸ·', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  frogPlush: { name: 'Frog Plushie', icon: 'ðŸ¸', cost: 200, buzz: 4, category: 'floor', blocksMovement: true },
  duckPlush: { name: 'Duck Plushie', icon: 'ðŸ¦†', cost: 175, buzz: 3, category: 'floor', blocksMovement: true },
  owlPlush: { name: 'Owl Plushie', icon: 'ðŸ¦‰', cost: 275, buzz: 5, category: 'floor', blocksMovement: true },
};

// Dividers - short barriers that block pathfinding but are low enough to see over
const DIVIDERS = {
  ropeStanchion: { name: 'Rope Stanchion', icon: 'ðŸŽª', cost: 75, buzz: 1 },
  lowRailing: { name: 'Low Railing', icon: 'ðŸš§', cost: 100, buzz: 1 },
  planterDivider: { name: 'Planter Divider', icon: 'ðŸŒ¿', cost: 150, buzz: 3 },
};

// Doors - customer entry/exit points, placed on walls
const DOORS = {
  basicDoor: { 
    name: 'Basic Door', 
    icon: 'ðŸšª', 
    cost: 300, 
    buzz: 2,
    frameColor: 0x8B4513,  // Brown wood frame
    doorColor: 0xA0522D,   // Sienna door
  },
  glassDoor: { 
    name: 'Glass Door', 
    icon: 'ðŸšª', 
    cost: 500, 
    buzz: 4,
    frameColor: 0x404040,  // Dark metal frame
    doorColor: 0x87CEEB,   // Light blue glass
    isGlass: true,
  },
};

// Wallpapers - interior wall styles
const WALLPAPERS = {
  // Solid colors
  cream: {
    name: 'Cream',
    icon: 'ðŸ ',
    cost: 0,
    buzz: 0,
    color: 0xF5F5DC,
    pattern: 'solid',
  },
  cerulean: {
    name: 'Cerulean Blue',
    icon: 'ðŸ’™',
    cost: 500,
    buzz: 2,
    color: 0x007BA7,
    pattern: 'solid',
  },
  burgundy: {
    name: 'Burgundy',
    icon: 'â¤ï¸',
    cost: 500,
    buzz: 2,
    color: 0x800020,
    pattern: 'solid',
  },
  lushGreen: {
    name: 'Lush Green',
    icon: 'ðŸ’š',
    cost: 500,
    buzz: 2,
    color: 0x228B22,
    pattern: 'solid',
  },
  pink: {
    name: 'Pink',
    icon: 'ðŸ©·',
    cost: 500,
    buzz: 2,
    color: 0xFFB6C1,
    pattern: 'solid',
  },
  orange: {
    name: 'Orange',
    icon: 'ðŸ§¡',
    cost: 500,
    buzz: 2,
    color: 0xFF8C00,
    pattern: 'solid',
  },
  stormy: {
    name: 'Stormy Gray',
    icon: 'ðŸŒ§ï¸',
    cost: 500,
    buzz: 2,
    color: 0x708090,
    pattern: 'solid',
  },
  // Stripe patterns
  blueStripes: {
    name: 'Blue Stripes',
    icon: 'ðŸ”µ',
    cost: 1000,
    buzz: 4,
    color: 0xADD8E6,
    stripeColor: 0x4169E1,
    pattern: 'stripes',
  },
  greenStripes: {
    name: 'Green Stripes',
    icon: 'ðŸŸ¢',
    cost: 1000,
    buzz: 4,
    color: 0x98FB98,
    stripeColor: 0x228B22,
    pattern: 'stripes',
  },
  pinkStripes: {
    name: 'Pink Stripes',
    icon: 'ðŸ©·',
    cost: 1000,
    buzz: 4,
    color: 0xFFE4E1,
    stripeColor: 0xFF69B4,
    pattern: 'stripes',
  },
  // Textured patterns
  smoothBrick: {
    name: 'Smooth Brick',
    icon: 'ðŸ§±',
    cost: 2000,
    buzz: 6,
    color: 0xB22222,
    pattern: 'brick',
  },
  stoneWall: {
    name: 'Stone Wall',
    icon: 'ðŸª¨',
    cost: 2000,
    buzz: 6,
    color: 0x808080,
    pattern: 'stone',
  },
  woodPaneling: {
    name: 'Wood Paneling',
    icon: 'ðŸªµ',
    cost: 2500,
    buzz: 8,
    color: 0x8B4513,
    pattern: 'wood',
  },
  // Subway tile patterns
  subwayWhite: {
    name: 'Subway White',
    icon: 'ðŸ”²',
    cost: 1500,
    buzz: 5,
    color: 0xFFFFFF,
    groutColor: 0xCCCCCC,
    pattern: 'subway',
  },
  subwayBlack: {
    name: 'Subway Black',
    icon: 'â¬›',
    cost: 1500,
    buzz: 5,
    color: 0x2F2F2F,
    groutColor: 0x1A1A1A,
    pattern: 'subway',
  },
  subwayBlue: {
    name: 'Subway Blue',
    icon: 'ðŸ”µ',
    cost: 1500,
    buzz: 5,
    color: 0x4A90D9,
    groutColor: 0x3366AA,
    pattern: 'subway',
  },
  subwayGreen: {
    name: 'Subway Green',
    icon: 'ðŸŸ¢',
    cost: 1500,
    buzz: 5,
    color: 0x5D8A5D,
    groutColor: 0x446644,
    pattern: 'subway',
  },
  // Wainscoting patterns (wood bottom, solid top with chair rail)
  wainscotCream: {
    name: 'Wainscot Cream',
    icon: 'ðŸ›ï¸',
    cost: 3000,
    buzz: 10,
    color: 0xF5F5DC,         // Top color (cream)
    bottomColor: 0x8B4513,   // Bottom wood color
    railColor: 0x5D3A1A,     // Dark wood molding
    pattern: 'wainscot',
  },
  wainscotBlue: {
    name: 'Wainscot Blue',
    icon: 'ðŸ›ï¸',
    cost: 3000,
    buzz: 10,
    color: 0xB0C4DE,         // Top color (light steel blue)
    bottomColor: 0x8B4513,   // Bottom wood color
    railColor: 0x5D3A1A,     // Dark wood molding
    pattern: 'wainscot',
  },
  wainscotGreen: {
    name: 'Wainscot Green',
    icon: 'ðŸ›ï¸',
    cost: 3000,
    buzz: 10,
    color: 0x98FB98,         // Top color (pale green)
    bottomColor: 0x8B4513,   // Bottom wood color
    railColor: 0x5D3A1A,     // Dark wood molding
    pattern: 'wainscot',
  },
  // Wainscot + Subway tile (wood bottom, subway tiles top)
  wainscotTileWhite: {
    name: 'Wainscot Tile',
    icon: 'ðŸ ',
    cost: 3500,
    buzz: 12,
    color: 0xFFFFFF,         // Top tile color
    groutColor: 0xCCCCCC,    // Tile grout
    bottomColor: 0x8B4513,   // Bottom wood color
    railColor: 0x5D3A1A,     // Dark wood molding
    pattern: 'wainscotTile',
  },
  wainscotTileBlue: {
    name: 'Wainscot Blue Tile',
    icon: 'ðŸŒŠ',
    cost: 3500,
    buzz: 12,
    color: 0x4A90D9,         // Top tile color (blue)
    groutColor: 0x3366AA,    // Tile grout
    bottomColor: 0x8B4513,   // Bottom wood color
    railColor: 0x5D3A1A,     // Dark wood molding
    pattern: 'wainscotTile',
  },
  wainscotTileGray: {
    name: 'Wainscot Gray Tile',
    icon: 'ðŸª¨',
    cost: 3500,
    buzz: 12,
    color: 0xA0A0A0,         // Top tile color (gray)
    groutColor: 0x707070,    // Tile grout
    bottomColor: 0x654321,   // Dark oak bottom
    railColor: 0x3D2817,     // Darker oak molding
    pattern: 'wainscotTile',
  },
};

// === WALLPAPER COLLECTIONS ===
// Group wall variants by pattern type for cleaner shop UI
// Note: 'cream' is kept individual as free default wall
const WALLPAPER_COLLECTIONS = {
  solid: {
    name: 'Solid', icon: 'ðŸŽ¨', cost: 500,
    variants: ['cerulean', 'burgundy', 'lushGreen', 'pink', 'orange', 'stormy'],
    colors: [0x007BA7, 0x800020, 0x228B22, 0xFFB6C1, 0xFF8C00, 0x708090],
    colorNames: ['Cerulean', 'Burgundy', 'Green', 'Pink', 'Orange', 'Gray'],
  },
  stripes: {
    name: 'Stripes', icon: 'ðŸ“Š', cost: 1000,
    variants: ['blueStripes', 'greenStripes', 'pinkStripes'],
    colors: [0x4169E1, 0x228B22, 0xFF69B4], // stripeColor (the darker accent)
    colorNames: ['Blue', 'Green', 'Pink'],
  },
  subway: {
    name: 'Subway Tile', icon: 'ðŸ”²', cost: 1500,
    variants: ['subwayWhite', 'subwayBlack', 'subwayBlue', 'subwayGreen'],
    colors: [0xFFFFFF, 0x2F2F2F, 0x4A90D9, 0x5D8A5D], // tile color
    colorNames: ['White', 'Black', 'Blue', 'Green'],
  },
  wainscot: {
    name: 'Wainscot', icon: 'ðŸ›ï¸', cost: 3000,
    variants: ['wainscotCream', 'wainscotBlue', 'wainscotGreen'],
    colors: [0xF5F5DC, 0xB0C4DE, 0x98FB98], // top paint color
    colorNames: ['Cream', 'Blue', 'Green'],
  },
  wainscotTile: {
    name: 'Wainscot + Tile', icon: 'ðŸ ', cost: 3500,
    variants: ['wainscotTileWhite', 'wainscotTileBlue', 'wainscotTileGray'],
    colors: [0xFFFFFF, 0x4A90D9, 0xA0A0A0], // top tile color
    colorNames: ['White', 'Blue', 'Gray'],
  },
};

// Get all wallpaper variant keys that belong to collections
const WALLPAPER_COLLECTION_VARIANTS = Object.values(WALLPAPER_COLLECTIONS).flatMap(c => c.variants);

// Floor styles - sorted by cost (cheapest to most expensive)
// Small/Large variants have same cost and are adjacent
const FLOOR_STYLES = {
  // === 0 COINS - FREE ===
  whiteTile: {
    name: 'White Tile',
    icon: 'â¬œ',
    cost: 0,
    color1: 0xffffff,
    color2: 0xe8e8e8,
    pattern: 'checker',
  },
  
  // === 10 COINS ===
  // === 10 COINS - LIGHT WOOD (all variants together) ===
  woodLight: {
    name: 'Light Wood',
    icon: 'ðŸŸ«',
    cost: 10,
    color1: 0xDEB887,
    color2: 0xD2A679,
    pattern: 'checker',
  },
  woodPlanksLight: {
    name: 'Light Planks',
    icon: 'ðŸªµ',
    cost: 10,
    color1: 0xDEB887,
    color2: 0x8B7355,
    pattern: 'canvasWoodPlanks',
  },
  woodPlanksLightV: {
    name: 'Light Planks V',
    icon: 'ðŸª“',
    cost: 10,
    color1: 0xDEB887,
    color2: 0x8B7355,
    pattern: 'canvasWoodPlanksVertical',
  },
  parquetLight: {
    name: 'Light Parquet',
    icon: 'ðŸ”²',
    cost: 10,
    color1: 0xDEB887,
    color2: 0x8B7355,
    pattern: 'canvasWoodParquet',
  },
  
  // === 15 COINS - DARK WOOD (all variants together) ===
  woodDark: {
    name: 'Dark Wood',
    icon: 'ðŸŸ¤',
    cost: 15,
    color1: 0x8B4513,
    color2: 0x7A3C10,
    pattern: 'checker',
  },
  woodPlanksDark: {
    name: 'Dark Planks',
    icon: 'ðŸªµ',
    cost: 15,
    color1: 0x8B4513,
    color2: 0x5D3A1A,
    pattern: 'canvasWoodPlanks',
  },
  woodPlanksDarkV: {
    name: 'Dark Planks V',
    icon: 'ðŸª“',
    cost: 15,
    color1: 0x8B4513,
    color2: 0x5D3A1A,
    pattern: 'canvasWoodPlanksVertical',
  },
  parquetDark: {
    name: 'Dark Parquet',
    icon: 'ðŸ”²',
    cost: 15,
    color1: 0x8B4513,
    color2: 0x5D3A1A,
    pattern: 'canvasWoodParquet',
  },
  
  // === 25 COINS - CHERRY WOOD (all variants together) ===
  woodCherry: {
    name: 'Cherry Wood',
    icon: 'ðŸ’',
    cost: 25,
    color1: 0xB5651D,
    color2: 0xA0522D,
    pattern: 'checker',
  },
  woodPlanksCherry: {
    name: 'Cherry Planks',
    icon: 'ðŸªµ',
    cost: 25,
    color1: 0xB5651D,
    color2: 0x6B3A0F,
    pattern: 'canvasWoodPlanks',
  },
  woodPlanksCherryV: {
    name: 'Cherry Planks V',
    icon: 'ðŸª“',
    cost: 25,
    color1: 0xB5651D,
    color2: 0x6B3A0F,
    pattern: 'canvasWoodPlanksVertical',
  },
  parquetCherry: {
    name: 'Cherry Parquet',
    icon: 'ðŸ”²',
    cost: 25,
    color1: 0xB5651D,
    color2: 0x6B3A0F,
    pattern: 'canvasWoodParquet',
  },
  
  // === 35 COINS - CLASSIC & GRAY WOOD ===
  parquet: {
    name: 'Classic Parquet',
    icon: 'ðŸ”¶',
    cost: 35,
    color1: 0xC4A35A,
    color2: 0xAA8844,
    pattern: 'checker',
  },
  woodPlanksGray: {
    name: 'Gray Planks',
    icon: 'ðŸªµ',
    cost: 35,
    color1: 0x808080,
    color2: 0x4a4a4a,
    pattern: 'canvasWoodPlanks',
  },
  woodPlanksGrayV: {
    name: 'Gray Planks V',
    icon: 'ðŸª“',
    cost: 35,
    color1: 0x808080,
    color2: 0x4a4a4a,
    pattern: 'canvasWoodPlanksVertical',
  },
  parquetGray: {
    name: 'Gray Parquet',
    icon: 'ðŸ”²',
    cost: 35,
    color1: 0x808080,
    color2: 0x4a4a4a,
    pattern: 'canvasWoodParquet',
  },
  
  // === 50 COINS ===
  blackWhite: {
    name: 'Checkered',
    icon: 'ðŸ',
    cost: 50,
    color1: 0xffffff,
    color2: 0x222222,
    pattern: 'canvasShinyChecker',
  },
  blackWhiteLg: {
    name: 'Checkered Lg',
    icon: 'ðŸ”²',
    cost: 50,
    color1: 0xffffff,
    color2: 0x222222,
    pattern: 'canvasSolidShiny',
  },
  harlequin: {
    name: 'Harlequin',
    icon: 'â—ª',
    cost: 50,
    color1: 0xffffff,
    color2: 0x222222,
    pattern: 'canvasHarlequin',
  },
  
  // === 100 COINS ===
  concrete: {
    name: 'Concrete',
    icon: 'ðŸ—ï¸',
    cost: 100,
    color1: 0x999999,
    color2: 0x888888,
    pattern: 'canvasShiny',
  },
  
  // === 150 COINS ===
  spanishTile: {
    name: 'Spanish Tile',
    icon: 'ðŸ”´',
    cost: 200,
    color1: 0xF5E6D3,
    color2: 0xCC4444,
    pattern: 'canvasDiagonal',
  },
  spanishTileLg: {
    name: 'Spanish Tile Lg',
    icon: 'ðŸŸ¥',
    cost: 200,
    color1: 0xF5E6D3,
    color2: 0xCC4444,
    pattern: 'canvasDiagonalLarge',
  },
  lemonTile: {
    name: 'Lemon Tiles',
    icon: 'ðŸ‹',
    cost: 200,
    color1: 0xFFF8DC,
    color2: 0xE8D44A,
    pattern: 'canvasDiagonal',
  },
  lemonTileLg: {
    name: 'Lemon Tiles Lg',
    icon: 'ðŸŒŸ',
    cost: 200,
    color1: 0xFFF8DC,
    color2: 0xE8D44A,
    pattern: 'canvasDiagonalLarge',
  },
  
  // === 200 COINS ===
  terracotta: {
    name: 'Terracotta',
    icon: 'ðŸ§±',
    cost: 200,
    color1: 0xE07040,
    color2: 0xC85030,
    pattern: 'canvasShiny',
  },
  apricotTile: {
    name: 'Apricot Tile',
    icon: 'ðŸ‘',
    cost: 200,
    color1: 0xFFF5E6,
    color2: 0xFFCC99,
    pattern: 'canvasDiagonal',
  },
  apricotTileLg: {
    name: 'Apricot Tile Lg',
    icon: 'ðŸ§¡',
    cost: 200,
    color1: 0xFFF5E6,
    color2: 0xFFCC99,
    pattern: 'canvasDiagonalLarge',
  },
  carpet: {
    name: 'Red Carpet',
    icon: 'â¤ï¸',
    cost: 200,
    color1: 0xAA2222,
    color2: 0x991111,
    pattern: 'checker',
  },
  blueCarpet: {
    name: 'Blue Carpet',
    icon: 'ðŸ’™',
    cost: 200,
    color1: 0x224488,
    color2: 0x1A3366,
    pattern: 'checker',
  },
  greenCarpet: {
    name: 'Green Carpet',
    icon: 'ðŸ’š',
    cost: 200,
    color1: 0x228844,
    color2: 0x1A6633,
    pattern: 'checker',
  },
  
  // === 250 COINS ===
  pinkCeramic: {
    name: 'Pink Ceramic',
    icon: 'ðŸ©·',
    cost: 300,
    color1: 0xFFF0F5,
    color2: 0xFFB6C1,
    pattern: 'canvasDiagonal',
  },
  pinkCeramicLg: {
    name: 'Pink Ceramic Lg',
    icon: 'ðŸ’—',
    cost: 300,
    color1: 0xFFF0F5,
    color2: 0xFFB6C1,
    pattern: 'canvasDiagonalLarge',
  },
  
  // === 300 COINS ===
  orangeTile: {
    name: 'Orange Tile',
    icon: 'ðŸ§¡',
    cost: 300,
    color1: 0xFFE4B5,
    color2: 0xFF8C00,
    pattern: 'canvasDiagonal',
  },
  orangeTileLg: {
    name: 'Orange Tile Lg',
    icon: 'ðŸ”¶',
    cost: 300,
    color1: 0xFFE4B5,
    color2: 0xFF8C00,
    pattern: 'canvasDiagonalLarge',
  },
  canvasDiagonalRed: {
    name: 'Red Stripe',
    icon: 'ðŸ“',
    cost: 300,
    color1: 0xFFE4E1,
    color2: 0xDC143C,
    pattern: 'canvasDiagonal',
  },
  canvasDiagonalRedLg: {
    name: 'Red Stripe Lg',
    icon: 'ðŸ”º',
    cost: 300,
    color1: 0xFFE4E1,
    color2: 0xDC143C,
    pattern: 'canvasDiagonalLarge',
  },
  canvasDiagonalBlue: {
    name: 'Blue Stripe', 
    icon: 'ðŸ“',
    cost: 300,
    color1: 0xE6F3FF,
    color2: 0x4169E1,
    pattern: 'canvasDiagonal',
  },
  canvasDiagonalBlueLg: {
    name: 'Blue Stripe Lg', 
    icon: 'ðŸ”¹',
    cost: 300,
    color1: 0xE6F3FF,
    color2: 0x4169E1,
    pattern: 'canvasDiagonalLarge',
  },
  stone: {
    name: 'Stone Tiles',
    icon: 'â¬›',
    cost: 300,
    color1: 0x888888,
    color2: 0x666666,
    pattern: 'canvasShiny',
  },
  steel: {
    name: 'Steel Plate',
    icon: 'ðŸ”©',
    cost: 300,
    color1: 0x888888,
    color2: 0x555555,
    pattern: 'canvasShiny',
  },
  
  // === 350 COINS ===
  winterfresh: {
    name: 'Winterfresh',
    icon: 'â„ï¸',
    cost: 400,
    color1: 0xF0FFFF,
    color2: 0xADD8E6,
    pattern: 'canvasDiamond',
  },
  winterfreshLg: {
    name: 'Winterfresh Lg',
    icon: 'ðŸ’Ž',
    cost: 400,
    color1: 0xF0FFFF,
    color2: 0xADD8E6,
    pattern: 'canvasDiamondLarge',
  },
  marble: {
    name: 'White Marble',
    icon: 'ðŸª¨',
    cost: 400,
    color1: 0xf5f5f5,
    color2: 0xaaaaaa,
    pattern: 'canvasMarble',
  },
  
  // === 400 COINS ===
  bavarianTile: {
    name: 'Bavarian Tile',
    icon: 'ðŸ”ï¸',
    cost: 400,
    color1: 0xF5F5F5,
    color2: 0x4682B4,
    pattern: 'canvasDiamond',
  },
  bavarianTileLg: {
    name: 'Bavarian Tile Lg',
    icon: 'ðŸ”·',
    cost: 400,
    color1: 0xF5F5F5,
    color2: 0x4682B4,
    pattern: 'canvasDiamondLarge',
  },
  dungeonTile: {
    name: 'Dungeon Tile',
    icon: 'ðŸ°',
    cost: 400,
    color1: 0x2F1F23,
    color2: 0x722F37,
    pattern: 'canvasDiamond',
  },
  dungeonTileLg: {
    name: 'Dungeon Tile Lg',
    icon: 'âš”ï¸',
    cost: 400,
    color1: 0x2F1F23,
    color2: 0x722F37,
    pattern: 'canvasDiamondLarge',
  },
  hexagonWhite: {
    name: 'Hexagon White',
    icon: 'â¬¡',
    cost: 400,
    color1: 0xFFFFFF,
    color2: 0x333333,
    pattern: 'canvasHexagon',
  },
  hexagonWhiteLg: {
    name: 'Hexagon White Lg',
    icon: 'â¬¢',
    cost: 400,
    color1: 0xFFFFFF,
    color2: 0x333333,
    pattern: 'canvasHexagonLarge',
  },
  hexagonBlue: {
    name: 'Hexagon Blue',
    icon: 'â¬¢',
    cost: 400,
    color1: 0xADD8E6,
    color2: 0x000080,
    pattern: 'canvasHexagon',
  },
  hexagonBlueLg: {
    name: 'Hexagon Blue Lg',
    icon: 'ðŸ”·',
    cost: 400,
    color1: 0xADD8E6,
    color2: 0x000080,
    pattern: 'canvasHexagonLarge',
  },
  polkaDot: {
    name: 'Polka Dot',
    icon: 'âšª',
    cost: 400,
    color1: 0xFFB6C1,
    color2: 0xFF1493,
    pattern: 'canvasDots',
  },
  polkaDotLg: {
    name: 'Polka Dot Lg',
    icon: 'ðŸ”´',
    cost: 400,
    color1: 0xFFB6C1,
    color2: 0xFF1493,
    pattern: 'canvasDotsLarge',
  },
  marbleBlack: {
    name: 'Black Marble',
    icon: 'ðŸ–¤',
    cost: 400,
    color1: 0x2a2a2a,
    color2: 0x555555,
    pattern: 'canvasMarble',
  },
  granite: {
    name: 'Granite',
    icon: 'ðŸ”˜',
    cost: 400,
    color1: 0x808080,
    color2: 0x404040,
    pattern: 'canvasGranite',
  },
  
  // === 450 COINS ===
  greenTiles: {
    name: 'Green Tiles',
    icon: 'ðŸŒ¿',
    cost: 400,
    color1: 0x90EE90,
    color2: 0x228B22,
    pattern: 'canvasDiamond',
  },
  greenTilesLg: {
    name: 'Green Tiles Lg',
    icon: 'ðŸ€',
    cost: 400,
    color1: 0x90EE90,
    color2: 0x228B22,
    pattern: 'canvasDiamondLarge',
  },
  plaidRed: {
    name: 'Plaid Red',
    icon: 'ðŸ”´',
    cost: 450,
    color1: 0xFFF8DC,
    color2: 0xB22222,
    pattern: 'canvasPlaid',
  },
  plaidRedLg: {
    name: 'Plaid Red Lg',
    icon: 'ðŸŸ¥',
    cost: 450,
    color1: 0xFFF8DC,
    color2: 0xB22222,
    pattern: 'canvasPlaidLarge',
  },
  plaidGreen: {
    name: 'Plaid Green',
    icon: 'ðŸŸ¢',
    cost: 450,
    color1: 0xF5FFFA,
    color2: 0x228B22,
    pattern: 'canvasPlaid',
  },
  plaidGreenLg: {
    name: 'Plaid Green Lg',
    icon: 'ðŸŸ©',
    cost: 450,
    color1: 0xF5FFFA,
    color2: 0x228B22,
    pattern: 'canvasPlaidLarge',
  },
  marbleRose: {
    name: 'Rose Marble',
    icon: 'ðŸ©·',
    cost: 450,
    color1: 0xf5e0e0,
    color2: 0xcc9999,
    pattern: 'canvasMarble',
  },
  graniteBlue: {
    name: 'Blue Granite',
    icon: 'ðŸ”µ',
    cost: 450,
    color1: 0x4a6080,
    color2: 0x2a4060,
    pattern: 'canvasGranite',
  },
  
  // === 500 COINS ===
  roseTiles: {
    name: 'Rose Tiles',
    icon: 'ðŸŒ¹',
    cost: 400,
    color1: 0xFFF0F5,
    color2: 0xDB7093,
    pattern: 'canvasDiamond',
  },
  roseTilesLg: {
    name: 'Rose Tiles Lg',
    icon: 'ðŸŒº',
    cost: 400,
    color1: 0xFFF0F5,
    color2: 0xDB7093,
    pattern: 'canvasDiamondLarge',
  },
  tanTiki: {
    name: 'Tan Tiki',
    icon: 'ðŸŽ‹',
    cost: 500,
    color1: 0xD2B48C,
    color2: 0x8B7355,
    pattern: 'canvasTiki',
  },
  tanTikiLg: {
    name: 'Tan Tiki Lg',
    icon: 'ðŸŽ',
    cost: 500,
    color1: 0xD2B48C,
    color2: 0x8B7355,
    pattern: 'canvasTikiLarge',
  },
  blueTiki: {
    name: 'Blue Tiki',
    icon: 'ðŸŒŠ',
    cost: 500,
    color1: 0x5F9EA0,
    color2: 0x2F4F4F,
    pattern: 'canvasTiki',
  },
  blueTikiLg: {
    name: 'Blue Tiki Lg',
    icon: 'ðŸŒ€',
    cost: 500,
    color1: 0x5F9EA0,
    color2: 0x2F4F4F,
    pattern: 'canvasTikiLarge',
  },
  aegeanTile: {
    name: 'Aegean Tile',
    icon: 'ðŸ›ï¸',
    cost: 500,
    color1: 0xE0FFFF,
    color2: 0x008B8B,
    pattern: 'canvasBorder',
  },
  aegeanTileLg: {
    name: 'Aegean Tile Lg',
    icon: 'ðŸº',
    cost: 500,
    color1: 0xE0FFFF,
    color2: 0x008B8B,
    pattern: 'canvasBorderLarge',
  },
  floralPink: {
    name: 'Floral Pink',
    icon: 'ðŸŒ¸',
    cost: 500,
    color1: 0xFFF0F5,
    color2: 0xFF69B4,
    pattern: 'canvasFloral',
  },
  floralPinkLg: {
    name: 'Floral Pink Lg',
    icon: 'ðŸŒº',
    cost: 500,
    color1: 0xFFF0F5,
    color2: 0xFF69B4,
    pattern: 'canvasFloralLarge',
  },
  floralBlue: {
    name: 'Floral Blue',
    icon: 'ðŸ’',
    cost: 500,
    color1: 0xF0F8FF,
    color2: 0x6495ED,
    pattern: 'canvasFloral',
  },
  floralBlueLg: {
    name: 'Floral Blue Lg',
    icon: 'ðŸª»',
    cost: 500,
    color1: 0xF0F8FF,
    color2: 0x6495ED,
    pattern: 'canvasFloralLarge',
  },
  
  // === 600 COINS ===
  ciaoTile: {
    name: 'Ciao Tile',
    icon: 'ðŸ‡®ðŸ‡¹',
    cost: 600,
    color1: 0xF5DEB3,
    color2: 0x8B4513,
    pattern: 'canvasBorder',
  },
  ciaoTileLg: {
    name: 'Ciao Tile Lg',
    icon: 'ðŸ',
    cost: 600,
    color1: 0xF5DEB3,
    color2: 0x8B4513,
    pattern: 'canvasBorderLarge',
  },
  swirlPurple: {
    name: 'Swirl Purple',
    icon: 'ðŸŒ€',
    cost: 600,
    color1: 0xE6E6FA,
    color2: 0x8B008B,
    pattern: 'canvasSwirl',
  },
  swirlPurpleLg: {
    name: 'Swirl Purple Lg',
    icon: 'ðŸ’œ',
    cost: 600,
    color1: 0xE6E6FA,
    color2: 0x8B008B,
    pattern: 'canvasSwirlLarge',
  },
  swirlGold: {
    name: 'Swirl Gold',
    icon: 'âœ¨',
    cost: 600,
    color1: 0xFFFACD,
    color2: 0xDAA520,
    pattern: 'canvasSwirl',
  },
  swirlGoldLg: {
    name: 'Swirl Gold Lg',
    icon: 'ðŸŒŸ',
    cost: 600,
    color1: 0xFFFACD,
    color2: 0xDAA520,
    pattern: 'canvasSwirlLarge',
  },
  
  // === 700 COINS ===
  starlight: {
    name: 'Starlight',
    icon: 'â­',
    cost: 700,
    color1: 0x191970,
    color2: 0xFFD700,
    pattern: 'canvasStar',
  },
  starlightLg: {
    name: 'Starlight Lg',
    icon: 'ðŸŒ ',
    cost: 700,
    color1: 0x191970,
    color2: 0xFFD700,
    pattern: 'canvasStarLarge',
  },
  
  // === 800 COINS ===
  discoFloor: {
    name: 'Disco Floor',
    icon: 'ðŸª©',
    cost: 800,
    color1: 0x111111,
    color2: 0xFF00FF,
    pattern: 'canvasShinyChecker',
  },
  discoFloorLg: {
    name: 'Disco Floor Lg',
    icon: 'ðŸ’œ',
    cost: 800,
    color1: 0x111111,
    color2: 0xFF00FF,
    pattern: 'canvasSolidShiny',
  },
  discoHarlequin: {
    name: 'Disco Harlequin',
    icon: 'ðŸ”®',
    cost: 800,
    color1: 0x111111,
    color2: 0xFF00FF,
    pattern: 'canvasHarlequin',
  },
};

// Floor collections for organized shop display
const FLOOR_COLLECTIONS = {
  woodLight: {
    name: 'Light Wood', icon: 'ðŸªµ', cost: 10,
    variants: ['woodLight', 'woodPlanksLight', 'woodPlanksLightV', 'parquetLight'],
    swatchType: 'pattern', // Show pattern icons instead of colors
    patterns: ['checker', 'planks', 'planksV', 'parquet'],
    patternNames: ['Checker', 'Planks', 'Planks V', 'Parquet'],
    patternIcons: ['â¬œ', 'â•', 'â•‘', 'â–¦'],
    baseColor: 0xDEB887,
  },
  woodDark: {
    name: 'Dark Wood', icon: 'ðŸªµ', cost: 15,
    variants: ['woodDark', 'woodPlanksDark', 'woodPlanksDarkV', 'parquetDark'],
    swatchType: 'pattern',
    patterns: ['checker', 'planks', 'planksV', 'parquet'],
    patternNames: ['Checker', 'Planks', 'Planks V', 'Parquet'],
    patternIcons: ['â¬œ', 'â•', 'â•‘', 'â–¦'],
    baseColor: 0x8B4513,
  },
  woodCherry: {
    name: 'Cherry Wood', icon: 'ðŸ’', cost: 25,
    variants: ['woodCherry', 'woodPlanksCherry', 'woodPlanksCherryV', 'parquetCherry'],
    swatchType: 'pattern',
    patterns: ['checker', 'planks', 'planksV', 'parquet'],
    patternNames: ['Checker', 'Planks', 'Planks V', 'Parquet'],
    patternIcons: ['â¬œ', 'â•', 'â•‘', 'â–¦'],
    baseColor: 0xB5651D,
  },
  woodGray: {
    name: 'Gray Wood', icon: 'ðŸªµ', cost: 35,
    variants: ['woodPlanksGray', 'woodPlanksGrayV', 'parquetGray'],
    swatchType: 'pattern',
    patterns: ['planks', 'planksV', 'parquet'],
    patternNames: ['Planks', 'Planks V', 'Parquet'],
    patternIcons: ['â•', 'â•‘', 'â–¦'],
    baseColor: 0x808080,
  },
  checkered: {
    name: 'Checkered', icon: 'ðŸ', cost: 50,
    variants: ['blackWhite', 'blackWhiteLg', 'harlequin'],
    swatchType: 'pattern',
    patterns: ['small', 'large', 'harlequin'],
    patternNames: ['Small', 'Large', 'Harlequin'],
    patternIcons: ['â–ª', 'â–«', 'â—ª'],
    baseColor: 0x888888,
  },
  carpet: {
    name: 'Carpet', icon: 'ðŸ§¶', cost: 200,
    variants: ['carpet', 'blueCarpet', 'greenCarpet'],
    colors: [0xAA2222, 0x224488, 0x228844],
    colorNames: ['Red', 'Blue', 'Green'],
  },
  diagonalTile: {
    name: 'Diagonal Tile', icon: 'ðŸ“', cost: 200,
    variants: ['spanishTile', 'spanishTileLg', 'lemonTile', 'lemonTileLg', 'apricotTile', 'apricotTileLg'],
    swatchType: 'colorPair', // Show pairs (sm/lg same color)
    colors: [0xCC4444, 0xE8D44A, 0xFFCC99], // Accent colors
    colorNames: ['Spanish', 'Lemon', 'Apricot'],
    hasSizes: true,
  },
  ceramicTile: {
    name: 'Ceramic Tile', icon: 'ðŸ”²', cost: 300,
    variants: ['pinkCeramic', 'pinkCeramicLg', 'orangeTile', 'orangeTileLg', 'canvasDiagonalRed', 'canvasDiagonalRedLg', 'canvasDiagonalBlue', 'canvasDiagonalBlueLg'],
    swatchType: 'colorPair',
    colors: [0xFFB6C1, 0xFF8C00, 0xDC143C, 0x4169E1], // Accent colors
    colorNames: ['Pink', 'Orange', 'Red', 'Blue'],
    hasSizes: true,
  },
  diamondTile: {
    name: 'Diamond Tile', icon: 'ðŸ’Ž', cost: 400,
    variants: ['winterfresh', 'winterfreshLg', 'bavarianTile', 'bavarianTileLg', 'dungeonTile', 'dungeonTileLg', 'greenTiles', 'greenTilesLg', 'roseTiles', 'roseTilesLg'],
    swatchType: 'colorPair',
    colors: [0xADD8E6, 0x4682B4, 0x722F37, 0x228B22, 0xDB7093], // Accent colors
    colorNames: ['Winter', 'Bavarian', 'Dungeon', 'Green', 'Rose'],
    hasSizes: true,
  },
  hexagon: {
    name: 'Hexagon', icon: 'â¬¡', cost: 400,
    variants: ['hexagonWhite', 'hexagonWhiteLg', 'hexagonBlue', 'hexagonBlueLg'],
    swatchType: 'colorPair',
    colors: [0xFFFFFF, 0xADD8E6],
    colorNames: ['White', 'Blue'],
    hasSizes: true,
  },
  marble: {
    name: 'Marble', icon: 'ðŸª¨', cost: 400,
    variants: ['marble', 'marbleBlack', 'marbleRose'],
    colors: [0xf5f5f5, 0x2a2a2a, 0xf5e0e0],
    colorNames: ['White', 'Black', 'Rose'],
  },
  granite: {
    name: 'Granite', icon: 'ðŸ”˜', cost: 400,
    variants: ['granite', 'graniteBlue'],
    colors: [0x808080, 0x4a6080],
    colorNames: ['Gray', 'Blue'],
  },
  plaid: {
    name: 'Plaid', icon: 'ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿', cost: 450,
    variants: ['plaidRed', 'plaidRedLg', 'plaidGreen', 'plaidGreenLg'],
    swatchType: 'colorPair',
    colors: [0xB22222, 0x228B22],
    colorNames: ['Red', 'Green'],
    hasSizes: true,
  },
  tiki: {
    name: 'Tiki', icon: 'ðŸŽ‹', cost: 500,
    variants: ['tanTiki', 'tanTikiLg', 'blueTiki', 'blueTikiLg'],
    swatchType: 'colorPair',
    colors: [0xD2B48C, 0x5F9EA0],
    colorNames: ['Tan', 'Blue'],
    hasSizes: true,
  },
  borderTile: {
    name: 'Border Tile', icon: 'ðŸ›ï¸', cost: 550,
    variants: ['aegeanTile', 'aegeanTileLg', 'ciaoTile', 'ciaoTileLg'],
    swatchType: 'colorPair',
    colors: [0x008B8B, 0x8B4513],
    colorNames: ['Aegean', 'Ciao'],
    hasSizes: true,
  },
  floral: {
    name: 'Floral', icon: 'ðŸŒ¸', cost: 500,
    variants: ['floralPink', 'floralPinkLg', 'floralBlue', 'floralBlueLg'],
    swatchType: 'colorPair',
    colors: [0xFF69B4, 0x6495ED],
    colorNames: ['Pink', 'Blue'],
    hasSizes: true,
  },
  swirl: {
    name: 'Swirl', icon: 'ðŸŒ€', cost: 600,
    variants: ['swirlPurple', 'swirlPurpleLg', 'swirlGold', 'swirlGoldLg'],
    swatchType: 'colorPair',
    colors: [0x8B008B, 0xDAA520],
    colorNames: ['Purple', 'Gold'],
    hasSizes: true,
  },
  starlight: {
    name: 'Starlight', icon: 'â­', cost: 700,
    variants: ['starlight', 'starlightLg'],
    swatchType: 'pattern',
    patterns: ['small', 'large'],
    patternNames: ['Small', 'Large'],
    patternIcons: ['âœ¦', 'â˜…'],
    baseColor: 0xFFD700,
  },
  disco: {
    name: 'Disco', icon: 'ðŸª©', cost: 800,
    variants: ['discoFloor', 'discoFloorLg', 'discoHarlequin'],
    swatchType: 'pattern',
    patterns: ['small', 'large', 'harlequin'],
    patternNames: ['Small', 'Large', 'Harlequin'],
    patternIcons: ['â–ª', 'â–«', 'â—ª'],
    baseColor: 0xFF00FF,
  },
};

// Get all floor variants that are part of collections (to filter from individual list)
const FLOOR_COLLECTION_VARIANTS = Object.values(FLOOR_COLLECTIONS).flatMap(c => c.variants);

// Achievements system
const ACHIEVEMENTS = {
  firstDish: {
    id: 'firstDish',
    name: 'First Dish',
    description: 'Cook your first meal',
    icon: 'ðŸ³',
    reward: 100,
  },
  firstCustomer: {
    id: 'firstCustomer',
    name: 'First Customer',
    description: 'Serve your first customer',
    icon: 'ðŸ˜Š',
    reward: 100,
  },
  busyKitchen: {
    id: 'busyKitchen',
    name: 'Busy Kitchen',
    description: 'Have all 3 stoves cooking at once',
    icon: 'ðŸ”¥',
    reward: 250,
  },
  fullHouse: {
    id: 'fullHouse',
    name: 'Full House',
    description: 'Fill all tables with customers',
    icon: 'ðŸª‘',
    reward: 500,
  },
  bigSpender: {
    id: 'bigSpender',
    name: 'Big Spender',
    description: 'Spend 5,000 coins total',
    icon: 'ðŸ’¸',
    reward: 300,
  },
  decorator: {
    id: 'decorator',
    name: 'Interior Designer',
    description: 'Place 5 decorations',
    icon: 'ðŸŽ¨',
    reward: 200,
  },
  speedyChef: {
    id: 'speedyChef',
    name: 'Speedy Chef',
    description: 'Serve 10 customers in one session',
    icon: 'âš¡',
    reward: 300,
  },
  chef: {
    id: 'chef',
    name: 'Rising Chef',
    description: 'Reach level 5',
    icon: 'ðŸ‘¨â€ðŸ³',
    reward: 500,
  },
  masterChef: {
    id: 'masterChef',
    name: 'Master Chef',
    description: 'Reach level 10',
    icon: 'ðŸ‘‘',
    reward: 1000,
  },
  mogul: {
    id: 'mogul',
    name: 'Cafe Mogul',
    description: 'Earn 10,000 coins total',
    icon: 'ðŸ’°',
    reward: 1000,
  },
  expansion: {
    id: 'expansion',
    name: 'Growing Business',
    description: 'Own 3 stoves and 10 tables',
    icon: 'ðŸ“ˆ',
    reward: 500,
  },
  nightOwl: {
    id: 'nightOwl',
    name: 'Night Owl',
    description: 'Serve a customer after 10 PM',
    icon: 'ðŸŒ™',
    reward: 150,
  },
};

// ============================================
// INITIAL GAME STATE
// ============================================
// ============================================
// AVATAR CUSTOMIZATION OPTIONS
// ============================================
const AVATAR_OPTIONS = {
  genders: [
    { id: 'female', name: 'Female', icon: 'ðŸ‘©â€ðŸ³' },
    { id: 'male', name: 'Male', icon: 'ðŸ‘¨â€ðŸ³' },
  ],
  skinTones: [
    { id: 'light', name: 'Light', color: 0xFFDBAC },
    { id: 'fair', name: 'Fair', color: 0xF5D0B5 },
    { id: 'medium', name: 'Medium', color: 0xD4A574 },
    { id: 'tan', name: 'Tan', color: 0xC68642 },
    { id: 'brown', name: 'Brown', color: 0x8D5524 },
    { id: 'dark', name: 'Dark', color: 0x5C3A21 },
  ],
  hairColors: [
    { id: 'black', name: 'Black', color: 0x1a1a1a },
    { id: 'brown', name: 'Brown', color: 0x4a3728 },
    { id: 'auburn', name: 'Auburn', color: 0x8B4513 },
    { id: 'blonde', name: 'Blonde', color: 0xD4A76A },
    { id: 'ginger', name: 'Ginger', color: 0xB85C38 },
    { id: 'gray', name: 'Gray', color: 0x888888 },
    { id: 'white', name: 'White', color: 0xE8E8E8 },
    { id: 'pink', name: 'Pink', color: 0xFF69B4 },
    { id: 'blue', name: 'Blue', color: 0x4169E1 },
    { id: 'purple', name: 'Purple', color: 0x9370DB },
  ],
  hairStyles: [
    { id: 'short', name: 'Short' },
    { id: 'bun', name: 'Bun' },
    { id: 'ponytail', name: 'Ponytail' },
    { id: 'long', name: 'Long' },
    { id: 'none', name: 'Bald' },
  ],
  apronColors: [
    { id: 'lightBlue', name: 'Light Blue', color: 0x87CEEB },
    { id: 'pink', name: 'Pink', color: 0xFFB6C1 },
    { id: 'mint', name: 'Mint', color: 0x98FF98 },
    { id: 'yellow', name: 'Yellow', color: 0xFFE66D },
    { id: 'lavender', name: 'Lavender', color: 0xE6E6FA },
    { id: 'coral', name: 'Coral', color: 0xFF7F7F },
    { id: 'white', name: 'White', color: 0xFFFFFF },
    { id: 'red', name: 'Red', color: 0xE74C3C },
  ],
  outfitColors: [
    { id: 'white', name: 'Classic White', color: 0xFFFFFF },
    { id: 'cream', name: 'Cream', color: 0xFFFDD0 },
    { id: 'black', name: 'Black', color: 0x2D2D2D },
    { id: 'navy', name: 'Navy', color: 0x1E3A5F },
    { id: 'burgundy', name: 'Burgundy', color: 0x800020 },
    { id: 'forest', name: 'Forest Green', color: 0x228B22 },
  ],
};

const initialState = {
  coins: 100000,
  xp: 0,
  level: 1,
  buzz: 50, // Starts at 50, not 0!
  
  // Waiters - deliver food from counters to customers (can hire more!)
  waiters: [
    {
      id: 'waiter-1',
      name: 'Alex',
      showName: false,
      state: 'idle', // idle, walking_to_counter, walking_to_table, pacing, returning
      gridX: 10, gridZ: 1, // Start in front of counters
      targetCounterId: null,
      targetTableId: null, // Customer is "locked" when waiter targets them
      carryingFood: null, // { recipe } when carrying food
      path: [],
      walkProgress: 0,
      // Customization
      skin: 2,       // 0-5 skin tones
      hair: 3,       // 0-7 hair colors
      hairStyle: 0,  // 0-3 hair styles
      outfit: 0,     // 0-7 outfit colors
    }
  ],
  maxWaiters: 5, // Maximum hireable waiters
  
  // Avatar customization
  avatar: {
    name: 'Chef',
    showName: false,
    gender: 'female',
    skinTone: 'light',
    hairColor: 'brown',
    hairStyle: 'short',
    apronColor: 'lightBlue',
    outfitColor: 'white',
  },
  
  stoves: INITIAL_FURNITURE.stoves,
  
  counters: INITIAL_FURNITURE.counters,
  
  tables: INITIAL_FURNITURE.tables,
  
  // Separate chairs - must be placed adjacent to tables and facing them
  // Rotation: 0=faces +Z, 1=faces +X, 2=faces -Z, 3=faces -X
  // Each chair has linkedTableId to connect it to its table
  chairs: INITIAL_FURNITURE.chairs,
  
  stats: {
    dishesCooked: 0,
    customersServed: 0,
    totalEarned: 0,
    totalSpent: 0,
    customersServedSession: 0, // Resets each session
  },
  
  // Dish Mastery - tracks how many times each dish has been cooked
  // Structure: { burger: { cooked: 15 }, salad: { cooked: 8 }, ... }
  dishMastery: {},
  
  achievements: [], // Array of unlocked achievement IDs
  
  decorations: [], // Player-placed decorations
  dividers: [], // Player-placed dividers (block pathfinding)
  doors: [
    // Default starting door on left wall (visible, customers enter/exit here)
    { id: 'door-initial', type: 'basicDoor', wall: 'left', wallPosition: 11 }
  ],
  wallpaper: 'cream', // Default interior wallpaper style (for unpainted segments)
  paintedSegments: [], // Individual painted segments: [{ wall: 'back', position: 0, wallpaper: 'cerulean' }, ...]
  paintedVersion: 0, // Increments on every paint change to trigger updates
  
  // Floor tiles - key is "gridX,gridZ", value is floor style name
  // Empty = uses default (whiteTile for rows 0-2, woodLight for rows 3+)
  floorTiles: {},
  floorVersion: 0, // Increments on floor changes to trigger re-render
  
  nextCustomerId: 1,
};

// ============================================
// GAME REDUCER
// ============================================
function gameReducer(state, action) {
  switch (action.type) {
    case 'START_COOKING': {
      const { stoveId, recipeKey } = action.payload;
      const recipe = RECIPES[recipeKey];
      if (state.coins < recipe.cost) return state;
      
      // Apply mastery bonus to servings (Level 1+ gives +5% servings)
      const masteryServings = getServingsWithMastery(state.dishMastery, recipeKey);
      
      return {
        ...state,
        coins: state.coins - recipe.cost,
        stats: {
          ...state.stats,
          totalSpent: state.stats.totalSpent + recipe.cost,
        },
        stoves: state.stoves.map(s => 
          s.id === stoveId 
            ? { ...s, state: 'cooking', recipe: recipeKey, startTime: Date.now(), servingsLeft: masteryServings }
            : s
        ),
      };
    }
    
    case 'FINISH_COOKING': {
      const { stoveId } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      const recipeKey = stove?.recipe;
      
      // Update mastery tracking for this dish
      const currentMastery = state.dishMastery[recipeKey] || { cooked: 0 };
      const newMastery = { ...currentMastery, cooked: currentMastery.cooked + 1 };
      
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'ready' } : s
        ),
        stats: { ...state.stats, dishesCooked: state.stats.dishesCooked + 1 },
        dishMastery: {
          ...state.dishMastery,
          [recipeKey]: newMastery,
        },
      };
    }
    
    case 'SPOIL_FOOD': {
      const { stoveId } = action.payload;
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'spoiled' } : s
        ),
      };
    }
    
    case 'SERVE_TO_COUNTER': {
      const { stoveId, counterId } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      if (!stove || stove.state !== 'ready') return state;
      
      const counter = state.counters.find(c => c.id === counterId);
      
      // Counter can only have one dish type - check if empty or same recipe
      if (counter.dishes.length > 0 && counter.dishes[0].recipe !== stove.recipe) {
        return state; // Can't mix recipes on same counter
      }
      
      // Apply mastery bonus to XP (Level 2+ gives +5% XP)
      const masteryXP = getXPWithMastery(state.dishMastery, stove.recipe);
      
      return {
        ...state,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
        counters: state.counters.map(c => {
          if (c.id !== counterId) return c;
          
          if (c.dishes.length > 0) {
            // Stack onto existing dish of same recipe
            return { 
              ...c, 
              dishes: [{ ...c.dishes[0], servings: c.dishes[0].servings + stove.servingsLeft }] 
            };
          } else {
            // Add new dish
            return { ...c, dishes: [{ recipe: stove.recipe, servings: stove.servingsLeft }] };
          }
        }),
        xp: state.xp + masteryXP,
      };
    }
    
    case 'CLEAN_STOVE': {
      const { stoveId } = action.payload;
      if (state.coins < 15) return state;
      return {
        ...state,
        coins: state.coins - 15,
        stoves: state.stoves.map(s =>
          s.id === stoveId ? { ...s, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 } : s
        ),
      };
    }
    
    case 'SPAWN_CUSTOMER': {
      const { tableId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table) return state;
      
      // Find the chair adjacent to this table (required for seating)
      const chair = findChairForTable(table, state.chairs || []);
      if (!chair) return state; // No chair = no customer can sit here
      
      // 5% chance to spawn a VIP customer
      const isVIP = Math.random() < 0.05;
      const vipType = isVIP ? VIP_TYPES[Math.floor(Math.random() * VIP_TYPES.length)] : null;
      
      // Generate fully random appearance for variety (no more clones!)
      const appearance = {
        skinTone: Math.floor(Math.random() * 8),      // 8 skin tones
        shirtColor: Math.floor(Math.random() * 14),   // 14 shirt colors
        pantsColor: Math.floor(Math.random() * 10),   // 10 pants colors
        hairColor: Math.floor(Math.random() * 10),    // 10 hair colors
        hairStyle: Math.floor(Math.random() * 6),     // 6 hair styles
        shoeColor: Math.floor(Math.random() * 6),     // 6 shoe colors
        isMale: Math.random() > 0.5,                  // 50/50 gender presentation
        // Accessories (30% chance each)
        hat: Math.random() < 0.3 ? Math.floor(Math.random() * 5) : null,      // 5 hat types
        glasses: Math.random() < 0.25 ? Math.floor(Math.random() * 3) : null, // 3 glasses types
        accessory: Math.random() < 0.15 ? Math.floor(Math.random() * 4) : null, // 4 extra accessories
        // VIP info
        isVIP: isVIP,
        vipType: vipType,
      };
      
      // Find entry point - use placed door if available, otherwise use default
      let entryGridX, entryGridZ;
      if (state.doors && state.doors.length > 0) {
        // Use a random door if multiple exist
        const door = state.doors[Math.floor(Math.random() * state.doors.length)];
        const entryPoint = getDoorEntryPoint(door);
        entryGridX = entryPoint.gridX;
        entryGridZ = entryPoint.gridZ;
      } else {
        // Fall back to default door position
        entryGridX = DOOR_POSITION.gridX;
        entryGridZ = DOOR_POSITION.gridZ;
      }
      
      // Calculate path from door to the chair position (not the old built-in chair tile)
      const occupancyMap = buildOccupancyMap(state);
      // Remove the chair tile from occupancy so pathfinding can reach it
      occupancyMap.delete(getTileKey(chair.gridX, chair.gridZ));
      const path = findPath(occupancyMap, entryGridX, entryGridZ, 
        chair.gridX, chair.gridZ, GRID.width, GRID.height);
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { 
                id: state.nextCustomerId, 
                patience: 100, 
                state: 'entering',  // Start at door, walking to table
                appearance,
                colorIndex: 0,
                spawnTime: Date.now(),
                targetCounterId: null,
                walkProgress: 0,
                hasFood: false,
                // Path from door to chair
                path: path || [],
                pathIndex: 0,
                // Store positions for rendering
                currentGridX: entryGridX,
                currentGridZ: entryGridZ,
                // Store door entry for exit path
                doorGridX: entryGridX,
                doorGridZ: entryGridZ,
                tableX: table.gridX,
                tableZ: table.gridZ,
                // Store chair info for rendering and pathfinding
                chairId: chair.id,
                chairX: chair.gridX,
                chairZ: chair.gridZ,
              } }
            : t
        ),
        nextCustomerId: state.nextCustomerId + 1,
      };
    }
    
    case 'CUSTOMER_REACHED_SEAT': {
      // Customer walked from door to their table, now they sit and wait
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer?.state === 'entering'
            ? { ...t, customer: { ...t.customer, state: 'waiting', walkProgress: 0, path: [], pathIndex: 0 } }
            : t
        ),
      };
    }
    
    case 'START_LEAVING': {
      // Customer finished eating (happy) or gave up (angry), now walks to door
      const { tableId, happy } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) return state;
      
      // ALWAYS use a current door position (doors may have been moved/deleted since spawn)
      let exitGridX, exitGridZ;
      if (state.doors && state.doors.length > 0) {
        // Pick a random door (or closest could be implemented later)
        const door = state.doors[Math.floor(Math.random() * state.doors.length)];
        const exitPoint = getDoorEntryPoint(door);
        exitGridX = exitPoint.gridX;
        exitGridZ = exitPoint.gridZ;
      } else {
        // Fallback to default door position if no doors exist
        exitGridX = DOOR_POSITION.gridX;
        exitGridZ = DOOR_POSITION.gridZ;
      }
      
      // Calculate path from chair back to door
      // Use stored chair position if available, otherwise fall back to getChairTile for legacy saves
      let chairGridX, chairGridZ;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX = table.customer.chairX;
        chairGridZ = table.customer.chairZ;
      } else {
        const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX = chairTile.gridX;
        chairGridZ = chairTile.gridZ;
      }
      const occupancyMap = buildOccupancyMap(state);
      // Remove the chair tile from occupancy so pathfinding can start from there
      occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
      const path = findPath(occupancyMap, chairGridX, chairGridZ,
        exitGridX, exitGridZ, GRID.width, GRID.height);
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { 
                ...t.customer, 
                state: 'leaving',
                leavingHappy: happy,
                walkProgress: 0, 
                path: path || [], 
                pathIndex: 0,
                leaveStartTime: Date.now(),
              } }
            : t
        ),
        // Give coins/buzz immediately for happy customers
        coins: happy ? state.coins : state.coins,
        buzz: happy ? Math.min(105, state.buzz + 2) : Math.max(0, state.buzz - 3),
      };
    }
    
    case 'CUSTOMER_LEFT': {
      // Customer reached the door and exits
      const { tableId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const wasHappy = table?.customer?.leavingHappy;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        stats: wasHappy 
          ? { ...state.stats, customersServed: state.stats.customersServed + 1 }
          : { ...state.stats, customersLost: (state.stats.customersLost || 0) + 1 },
      };
    }
    
    case 'CUSTOMER_WALK_TO_COUNTER': {
      const { tableId, counterId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const counter = state.counters.find(c => c.id === counterId);
      
      if (!table || !table.customer || table.customer.state !== 'waiting' || !counter) {
        return state;
      }
      
      // Calculate path from customer's seat (chair tile) to counter's interaction tile
      // Use stored chair position if available, otherwise fall back for legacy saves
      let chairGridX, chairGridZ;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX = table.customer.chairX;
        chairGridZ = table.customer.chairZ;
      } else {
        const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX = chairTile.gridX;
        chairGridZ = chairTile.gridZ;
      }
      const counterInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
      
      // Build occupancy map (exclude the table's own tiles since customer is leaving)
      const occupancyMap = buildOccupancyMap(state);
      // Remove the customer's chair tile from occupancy (they can walk from their seat)
      occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
      // Also remove table tile
      occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
      
      // Find path
      const path = findPath(occupancyMap, chairGridX, chairGridZ, 
        counterInteraction.gridX, counterInteraction.gridZ, GRID.width, GRID.height);
      
      // If no path found, customer stays waiting (don't block forever)
      if (!path || path.length === 0) {
        console.log('No path found to counter, customer waits');
        return state;
      }
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId
            ? { ...t, customer: { ...t.customer, state: 'walking_to_counter', targetCounterId: counterId, walkProgress: 0, path, pathIndex: 0 } }
            : t
        ),
      };
    }
    
    case 'CUSTOMER_REACHED_COUNTER': {
      const { tableId, counterId } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      const counter = state.counters.find(c => c.id === counterId);
      
      if (!table || !table.customer) return state;
      
      // If no food at this counter, check other counters or send customer back to waiting
      if (!counter || counter.dishes.length === 0) {
        // Try to find another counter with food
        const otherCounter = state.counters.find(c => c.dishes.length > 0);
        if (otherCounter) {
          // Calculate path to other counter
          const currentInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
          const otherInteraction = getInteractionTile('counter', otherCounter.gridX, otherCounter.gridZ, otherCounter.rotation || 0);
          
          const occupancyMap = buildOccupancyMap(state);
          const tableTiles = getTableTiles(table);
          tableTiles.forEach(tile => occupancyMap.delete(getTileKey(tile.gridX, tile.gridZ)));
          
          const path = findPath(occupancyMap, currentInteraction.gridX, currentInteraction.gridZ,
            otherInteraction.gridX, otherInteraction.gridZ, GRID.width, GRID.height);
          
          return {
            ...state,
            tables: state.tables.map(t =>
              t.id === tableId && t.customer
                ? { ...t, customer: { ...t.customer, targetCounterId: otherCounter.id, walkProgress: 0, path: path || [], pathIndex: 0 } }
                : t
            ),
          };
        }
        // No food anywhere - go back to seat and wait
        const currentInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
        
        // Use stored chair position if available
        let chairGridX, chairGridZ;
        if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
          chairGridX = table.customer.chairX;
          chairGridZ = table.customer.chairZ;
        } else {
          const chairTile = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
          chairGridX = chairTile.gridX;
          chairGridZ = chairTile.gridZ;
        }
        
        const occupancyMap = buildOccupancyMap(state);
        occupancyMap.delete(getTileKey(chairGridX, chairGridZ));
        occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
        
        const path = findPath(occupancyMap, currentInteraction.gridX, currentInteraction.gridZ,
          chairGridX, chairGridZ, GRID.width, GRID.height);
        
        return {
          ...state,
          tables: state.tables.map(t =>
            t.id === tableId && t.customer
              ? { ...t, customer: { ...t.customer, state: 'walking_to_table', walkProgress: 0, targetCounterId: null, path: path || [], pathIndex: 0, hasFood: false } }
              : t
          ),
        };
      }
      
      const dish = counter.dishes[0];
      const recipe = RECIPES[dish.recipe];
      const newServings = dish.servings - 1;
      
      // Calculate path back to seat
      const counterInteraction = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
      
      // Use stored chair position if available
      let chairGridX2, chairGridZ2;
      if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
        chairGridX2 = table.customer.chairX;
        chairGridZ2 = table.customer.chairZ;
      } else {
        const chairTile2 = getChairTile(table.gridX, table.gridZ, table.rotation || 0);
        chairGridX2 = chairTile2.gridX;
        chairGridZ2 = chairTile2.gridZ;
      }
      
      const occupancyMap = buildOccupancyMap(state);
      occupancyMap.delete(getTileKey(chairGridX2, chairGridZ2));
      occupancyMap.delete(getTileKey(table.gridX, table.gridZ));
      
      const path = findPath(occupancyMap, counterInteraction.gridX, counterInteraction.gridZ,
        chairGridX2, chairGridZ2, GRID.width, GRID.height);
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 ? [{ ...dish, servings: newServings }] : [] }
            : c
        ),
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'walking_to_table', walkProgress: 0, hasFood: true, path: path || [], pathIndex: 0 } }
            : t
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          customersServed: state.stats.customersServed + 1,
          totalEarned: state.stats.totalEarned + recipe.revenue,
        },
      };
    }
    
    case 'CUSTOMER_REACHED_TABLE': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', walkProgress: 0, eatStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'UPDATE_WALK_PROGRESS': {
      const { tableId, progress } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, walkProgress: progress } }
            : t
        ),
      };
    }
    
    case 'UPDATE_CUSTOMER_PATIENCE': {
      const { tableId, patience } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, patience } }
            : t
        ),
      };
    }
    
    case 'SERVE_CUSTOMER': {
      const { tableId, counterId } = action.payload;
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter || counter.dishes.length === 0) return state;
      
      const dish = counter.dishes[0];
      const recipe = RECIPES[dish.recipe];
      const newServings = dish.servings - 1;
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 ? [{ ...dish, servings: newServings }, ...c.dishes.slice(1)] : c.dishes.slice(1) }
            : c
        ),
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'TRASH_COUNTER': {
      const { counterId } = action.payload;
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId ? { ...c, dishes: [] } : c
        ),
      };
    }
    
    case 'CUSTOMER_LEAVE_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.min(105, state.buzz + 2),
        stats: { ...state.stats, customersServed: state.stats.customersServed + 1 },
      };
    }
    
    case 'CUSTOMER_LEAVE_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, customer: null } : t
        ),
        buzz: Math.max(0, state.buzz - 5),
      };
    }
    
    // ============ WAITER ACTIONS ============
    // Each action now includes waiterId to update specific waiter in array
    // Locking: targetTableId "locks" a customer so other waiters won't serve them
    
    case 'HIRE_WAITER': {
      // Cost increases: 1000, 2000, 3000, etc.
      const waiterCount = state.waiters.length;
      const cost = (waiterCount) * 1000;
      
      if (state.coins < cost || waiterCount >= state.maxWaiters) return state;
      
      // Default names for new waiters
      const defaultNames = ['Sam', 'Jordan', 'Riley', 'Casey', 'Morgan', 'Taylor', 'Quinn', 'Avery'];
      
      // Position new waiter near counters with slight offset
      const newWaiter = {
        id: `waiter-${waiterCount + 1}`,
        name: defaultNames[waiterCount % defaultNames.length],
        showName: false,
        state: 'idle',
        gridX: 9 + (waiterCount % 5), // Spread them out
        gridZ: 1,
        targetCounterId: null,
        targetTableId: null,
        carryingFood: null,
        path: [],
        walkProgress: 0,
        // Random customization
        skin: Math.floor(Math.random() * 6),
        hair: Math.floor(Math.random() * 8),
        hairStyle: Math.floor(Math.random() * 4),
        outfit: Math.floor(Math.random() * 8),
      };
      
      return {
        ...state,
        coins: state.coins - cost,
        waiters: [...state.waiters, newWaiter],
      };
    }
    
    case 'UPDATE_WAITER': {
      const { waiterId, updates } = action.payload;
      return {
        ...state,
        waiters: state.waiters.map(w => 
          w.id === waiterId ? { ...w, ...updates } : w
        ),
      };
    }
    
    case 'WAITER_GO_TO_COUNTER': {
      const { waiterId, counterId, tableId, path } = action.payload;
      if (!path || path.length === 0) return state;
      
      return {
        ...state,
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: 'walking_to_counter',
            targetCounterId: counterId,
            targetTableId: tableId, // This "locks" the customer
            path,
            pathIndex: 0,
            walkProgress: 0,
          } : w
        ),
      };
    }
    
    case 'WAITER_PICKUP_AND_GO': {
      const { waiterId, counterId, tableId, pathToTable } = action.payload;
      
      const waiter = state.waiters.find(w => w.id === waiterId);
      if (!waiter || waiter.state !== 'walking_to_counter') return state;
      
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter || counter.dishes.length === 0 || !pathToTable || pathToTable.length === 0) {
        return {
          ...state,
          waiters: state.waiters.map(w => 
            w.id === waiterId ? { ...w, state: 'idle', path: [], carryingFood: null, targetTableId: null } : w
          ),
        };
      }
      
      const dish = counter.dishes[0];
      const newServings = dish.servings - 1;
      const finalCounterTile = waiter.path[waiter.path.length - 1];
      
      return {
        ...state,
        counters: state.counters.map(c =>
          c.id === counterId
            ? { ...c, dishes: newServings > 0 
                ? [{ ...dish, servings: newServings }, ...c.dishes.slice(1)] 
                : c.dishes.slice(1) }
            : c
        ),
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: 'walking_to_table',
            gridX: finalCounterTile?.gridX ?? finalCounterTile?.x ?? w.gridX,
            gridZ: finalCounterTile?.gridZ ?? finalCounterTile?.z ?? w.gridZ,
            carryingFood: { recipe: dish.recipe },
            path: pathToTable,
            pathIndex: 0,
            walkProgress: 0,
          } : w
        ),
      };
    }
    
    case 'WAITER_SERVE_CUSTOMER': {
      const { waiterId, tableId } = action.payload;
      
      const waiter = state.waiters.find(w => w.id === waiterId);
      if (!waiter || waiter.state !== 'walking_to_table' || !waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiters: state.waiters.map(w => 
            w.id === waiterId ? { ...w, state: 'idle', path: [], carryingFood: null, targetTableId: null } : w
          ),
        };
      }
      
      const recipe = RECIPES[waiter.carryingFood.recipe];
      const finalTile = waiter.path[waiter.path.length - 1];
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: 'idle',
            gridX: finalTile?.gridX ?? finalTile?.x ?? w.gridX,
            gridZ: finalTile?.gridZ ?? finalTile?.z ?? w.gridZ,
            carryingFood: null,
            targetCounterId: null,
            targetTableId: null, // Release lock
            path: [],
            pathIndex: 0,
            walkProgress: 0,
          } : w
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'WAITER_UPDATE_POSITION': {
      const { waiterId, gridX, gridZ, walkProgress } = action.payload;
      return {
        ...state,
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            gridX: gridX ?? w.gridX,
            gridZ: gridZ ?? w.gridZ,
            walkProgress: walkProgress ?? w.walkProgress,
          } : w
        ),
      };
    }
    
    case 'WAITER_START_PACING': {
      const { waiterId, path } = action.payload;
      return {
        ...state,
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: 'pacing',
            path: path || [],
            walkProgress: 0,
          } : w
        ),
      };
    }
    
    case 'WAITER_GO_IDLE': {
      const { waiterId } = action.payload;
      return {
        ...state,
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: 'idle',
            path: [],
            walkProgress: 0,
            targetTableId: null, // Release lock when going idle
          } : w
        ),
      };
    }
    
    case 'WAITER_SERVE_AND_RETURN': {
      const { waiterId, tableId, finalX, finalZ, returnPath } = action.payload;
      
      const waiter = state.waiters.find(w => w.id === waiterId);
      if (!waiter || waiter.state !== 'walking_to_table' || !waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiters: state.waiters.map(w => 
            w.id === waiterId ? { ...w, state: 'idle', path: [], carryingFood: null, gridX: finalX, gridZ: finalZ, targetTableId: null } : w
          ),
        };
      }
      
      const recipe = RECIPES[waiter.carryingFood.recipe];
      const hasValidPath = returnPath && returnPath.length >= 2;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: hasValidPath ? 'returning' : 'idle',
            gridX: finalX,
            gridZ: finalZ,
            carryingFood: null,
            targetCounterId: null,
            targetTableId: null, // Release lock after serving
            path: hasValidPath ? returnPath : [],
            walkProgress: 0,
          } : w
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'WAITER_SERVE_AND_CONTINUE': {
      const { waiterId, tableId, finalX, finalZ, nextCounterId, nextTableId, pathToCounter } = action.payload;
      
      const waiter = state.waiters.find(w => w.id === waiterId);
      if (!waiter || waiter.state !== 'walking_to_table' || !waiter.carryingFood) return state;
      
      const table = state.tables.find(t => t.id === tableId);
      if (!table || !table.customer) {
        return {
          ...state,
          waiters: state.waiters.map(w => 
            w.id === waiterId ? { ...w, state: 'idle', path: [], carryingFood: null, gridX: finalX, gridZ: finalZ, targetTableId: null } : w
          ),
        };
      }
      
      const recipe = RECIPES[waiter.carryingFood.recipe];
      const hasValidPath = pathToCounter && pathToCounter.length >= 1;
      
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'eating', eatStartTime: Date.now() } }
            : t
        ),
        waiters: state.waiters.map(w => 
          w.id === waiterId ? {
            ...w,
            state: hasValidPath ? 'walking_to_counter' : 'idle',
            gridX: finalX,
            gridZ: finalZ,
            carryingFood: null,
            targetCounterId: nextCounterId,
            targetTableId: nextTableId, // Lock new customer
            path: hasValidPath ? pathToCounter : [],
            walkProgress: 0,
          } : w
        ),
        coins: state.coins + recipe.revenue,
        stats: { 
          ...state.stats, 
          totalEarned: state.stats.totalEarned + recipe.revenue,
          customersServed: state.stats.customersServed + 1,
          customersServedSession: state.stats.customersServedSession + 1,
        },
      };
    }
    
    case 'START_LEAVING_HAPPY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingHappy', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'START_LEAVING_ANGRY': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId && t.customer
            ? { ...t, customer: { ...t.customer, state: 'leavingAngry', leaveStartTime: Date.now() } }
            : t
        ),
      };
    }
    
    case 'LEVEL_UP': {
      return {
        ...state,
        level: state.level + 1,
        coins: state.coins + 1000,
      };
    }
    
    case 'BUY_STOVE': {
      const { gridX, gridZ, rotation = 0, style = 'basic', free = false } = action.payload || {};
      const stoveStyle = STOVE_STYLES[style] || STOVE_STYLES.basic;
      const cost = stoveStyle.cost;
      
      if (!free && state.coins < cost) return state;
      if (state.stoves.length >= 8) return state; // Max 8 stoves
      
      // Check position not already taken by anything
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      if (stoveTaken || counterTaken || tableTaken || decorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        stoves: [...state.stoves, { id: `stove-${Date.now()}`, gridX, gridZ, rotation, style, state: 'empty', recipe: null, startTime: null, servingsLeft: 0 }],
      };
    }
    
    case 'BUY_TABLE': {
      const { gridX, gridZ, style = 'round', rotation = 0, free = false } = action.payload || {};
      const tableStyle = TABLE_STYLES[style] || TABLE_STYLES.round;
      const cost = tableStyle.cost;
      
      if (!free && state.coins < cost) return state;
      if (state.tables.length >= 15) return state;
      
      // New tables only occupy 1 tile (the table itself)
      // Chairs are placed separately
      const newTableTile = { gridX, gridZ };
      
      // Check tile isn't occupied by existing tables
      const tableTaken = state.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
      
      // Check tile isn't occupied by chairs
      const chairTaken = (state.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
      
      // Check tile isn't occupied by decorations
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      
      // Check tile isn't occupied by stoves/counters
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      
      // Check dividers
      const dividerTaken = (state.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
      
      if (tableTaken || chairTaken || decorTaken || stoveTaken || counterTaken || dividerTaken) return state;
      
      const newTableId = `table-${Date.now()}`;
      
      // Auto-link any adjacent unlinked chairs that are FACING this new table
      const updatedChairs = (state.chairs || []).map(chair => {
        // Skip chairs that are already linked
        if (chair.linkedTableId) return chair;
        
        // Check if this chair is facing the new table position
        const facingTile = getChairFacingTile(chair.gridX, chair.gridZ, chair.rotation || 0);
        if (facingTile.gridX === gridX && facingTile.gridZ === gridZ) {
          // Chair is facing the new table - link it!
          return { ...chair, linkedTableId: newTableId };
        }
        
        return chair;
      });
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        tables: [...state.tables, { id: newTableId, gridX, gridZ, style, rotation, customer: null }],
        chairs: updatedChairs,
      };
    }
    
    case 'BUY_CHAIR': {
      const { gridX, gridZ, style = 'basicWood', rotation = 0, linkedTableId = null, free = false } = action.payload || {};
      const chairStyle = CHAIR_STYLES[style] || CHAIR_STYLES.basicWood;
      const cost = chairStyle.cost;
      
      if (!free && state.coins < cost) return state;
      
      // Max chairs = same as max tables (15)
      if ((state.chairs || []).length >= 15) return state;
      
      // Check tile isn't already occupied
      const chairTaken = (state.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
      const tableTaken = state.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const dividerTaken = (state.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
      
      if (chairTaken || tableTaken || decorTaken || stoveTaken || counterTaken || dividerTaken) return state;
      
      // Auto-link to adjacent table if no linkedTableId provided
      // Only link if the chair is FACING that table based on its rotation
      let finalLinkedTableId = linkedTableId;
      if (!finalLinkedTableId) {
        // Find what tile this chair is facing based on its rotation
        const facingTile = getChairFacingTile(gridX, gridZ, rotation);
        
        // Check if there's an unlinked table at the facing position
        const facingTable = state.tables.find(t => 
          t.gridX === facingTile.gridX && t.gridZ === facingTile.gridZ
        );
        
        if (facingTable) {
          // Check if this table already has a linked chair
          const tableAlreadyLinked = (state.chairs || []).some(c => c.linkedTableId === facingTable.id);
          if (!tableAlreadyLinked) {
            finalLinkedTableId = facingTable.id;
          }
        }
      }
      
      // Validate linked table exists and isn't already linked to another chair
      if (finalLinkedTableId) {
        const linkedTable = state.tables.find(t => t.id === finalLinkedTableId);
        if (!linkedTable) finalLinkedTableId = null; // Table doesn't exist
        const tableAlreadyLinked = (state.chairs || []).some(c => c.linkedTableId === finalLinkedTableId);
        if (tableAlreadyLinked) finalLinkedTableId = null; // Table already has a chair
      }
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        chairs: [...(state.chairs || []), { id: `chair-${Date.now()}`, gridX, gridZ, style, rotation, linkedTableId: finalLinkedTableId }],
      };
    }
    
    case 'REMOVE_CHAIR': {
      const { chairId, noRefund = false } = action.payload;
      const chair = (state.chairs || []).find(c => c.id === chairId);
      if (!chair) return state;
      
      const chairStyleData = CHAIR_STYLES[chair.style] || CHAIR_STYLES.basicWood;
      const refund = noRefund ? 0 : Math.floor(chairStyleData.cost * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        chairs: (state.chairs || []).filter(c => c.id !== chairId),
      };
    }
    
    case 'ROTATE_CHAIR': {
      const { chairId } = action.payload;
      return {
        ...state,
        chairs: (state.chairs || []).map(c =>
          c.id === chairId ? { ...c, rotation: ((c.rotation || 0) + 1) % 4 } : c
        ),
      };
    }
    
    case 'BUY_COUNTER': {
      const { gridX, gridZ, rotation = 0, style = 'basic', free = false } = action.payload || {};
      const counterStyle = COUNTER_STYLES[style] || COUNTER_STYLES.basic;
      const cost = counterStyle.cost;
      
      if (!free && state.coins < cost) return state;
      if (state.counters.length >= 6) return state; // Max 6 counters
      
      // Check position not already taken by anything
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      if (counterTaken || stoveTaken || tableTaken || decorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + cost },
        counters: [...state.counters, { id: `counter-${Date.now()}`, gridX, gridZ, rotation, style, dishes: [] }],
      };
    }
    
    case 'PLACE_DECORATION': {
      const { decorationType, gridX, gridZ, rotation = 0, wall, wallPosition, free = false } = action.payload;
      const decor = DECORATIONS[decorationType];
      if (!decor || (!free && state.coins < decor.cost)) return state;
      
      // Check if position is already taken by anything (floor decorations only)
      if (decor.category !== 'wall') {
        const decorTaken = state.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const tableTaken = state.tables.some(t => {
          const tiles = getTableTiles(t);
          return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
        });
        const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        if (decorTaken || tableTaken || stoveTaken || counterTaken) return state;
      } else {
        // Wall decorations: check if this wall segment already has a decoration
        const wallDecorTaken = state.decorations.some(d => 
          d.wall === wall && d.wallPosition === wallPosition
        );
        if (wallDecorTaken) return state;
      }
      
      // Build decoration object - include wall info for wall decorations
      const newDecor = {
        id: `decor-${Date.now()}`,
        type: decorationType,
        gridX,
        gridZ,
        rotation,
      };
      
      // Add wall data for wall decorations
      if (decor.category === 'wall' && wall && wallPosition !== undefined) {
        newDecor.wall = wall;
        newDecor.wallPosition = wallPosition;
      }
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - decor.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + decor.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + decor.buzz),
        decorations: [...state.decorations, newDecor],
      };
    }
    
    case 'REMOVE_DECORATION': {
      const { decorationId, noRefund = false } = action.payload;
      const decor = state.decorations.find(d => d.id === decorationId);
      if (!decor) return state;
      const decorType = DECORATIONS[decor.type];
      const refund = noRefund ? 0 : Math.floor(decorType.cost * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - decorType.buzz),
        decorations: state.decorations.filter(d => d.id !== decorationId),
      };
    }
    
    case 'PLACE_DIVIDER': {
      const { dividerType, gridX, gridZ, rotation = 0, free = false } = action.payload;
      const divider = DIVIDERS[dividerType];
      if (!divider || (!free && state.coins < divider.cost)) return state;
      
      // Check if position is already taken
      const dividerTaken = state.dividers.some(d => d.gridX === gridX && d.gridZ === gridZ);
      const decorTaken = state.decorations.some(d => {
        const dt = DECORATIONS[d.type];
        return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
      });
      const tableTaken = state.tables.some(t => {
        const tiles = getTableTiles(t);
        return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
      });
      const stoveTaken = state.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
      const counterTaken = state.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
      if (dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - divider.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + divider.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + divider.buzz),
        dividers: [...state.dividers, {
          id: `divider-${Date.now()}`,
          type: dividerType,
          gridX,
          gridZ,
          rotation: rotation % 2, // Only 0 or 1 (0Â° or 90Â°)
        }],
      };
    }
    
    case 'REMOVE_DIVIDER': {
      const { dividerId, noRefund = false } = action.payload;
      const divider = state.dividers.find(d => d.id === dividerId);
      if (!divider) return state;
      const dividerType = DIVIDERS[divider.type];
      const refund = noRefund ? 0 : Math.floor(dividerType.cost * 0.5);
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - dividerType.buzz),
        dividers: state.dividers.filter(d => d.id !== dividerId),
      };
    }
    
    case 'PLACE_DOOR': {
      const { doorType, wall, wallPosition, free = false } = action.payload;
      const door = DOORS[doorType];
      if (!door || (!free && state.coins < door.cost)) return state;
      
      // Check if position is already taken by another door
      const doorTaken = state.doors.some(d => d.wall === wall && d.wallPosition === wallPosition);
      if (doorTaken) return state;
      
      return {
        ...state,
        coins: free ? state.coins : state.coins - door.cost,
        stats: free ? state.stats : { ...state.stats, totalSpent: state.stats.totalSpent + door.cost },
        buzz: free ? state.buzz : Math.min(100, state.buzz + door.buzz),
        doors: [...state.doors, {
          id: `door-${Date.now()}`,
          type: doorType,
          wall,           // 'back', 'left', or 'right'
          wallPosition,   // Position along the wall (0 to wall length)
        }],
      };
    }
    
    case 'REMOVE_DOOR': {
      const { doorId, noRefund = false } = action.payload;
      const door = state.doors.find(d => d.id === doorId);
      if (!door) return state;
      const doorType = DOORS[door.type];
      const refund = noRefund ? 0 : Math.floor(doorType.cost * 0.5);
      
      return {
        ...state,
        coins: state.coins + refund,
        buzz: noRefund ? state.buzz : Math.max(0, state.buzz - doorType.buzz),
        doors: state.doors.filter(d => d.id !== doorId),
      };
    }
    
    case 'CHANGE_WALLPAPER': {
      const { wallpaperType } = action.payload;
      const wallpaper = WALLPAPERS[wallpaperType];
      if (!wallpaper) return state;
      
      // If same wallpaper, no change needed
      if (state.wallpaper === wallpaperType) return state;
      
      // Check if player can afford it
      if (state.coins < wallpaper.cost) return state;
      
      // Get old wallpaper buzz to remove
      const oldWallpaper = WALLPAPERS[state.wallpaper] || WALLPAPERS.cream;
      
      return {
        ...state,
        coins: state.coins - wallpaper.cost,
        buzz: Math.min(100, Math.max(0, state.buzz - oldWallpaper.buzz + wallpaper.buzz)),
        wallpaper: wallpaperType,
        paintedSegments: [], // Clear individual paints when setting base wallpaper
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + wallpaper.cost },
      };
    }
    
    case 'PAINT_SEGMENT': {
      const { wall, position, wallpaperType } = action.payload;
      const wallpaper = WALLPAPERS[wallpaperType];
      if (!wallpaper) return state;
      
      // Check if this segment already has this wallpaper
      const existingPaint = (state.paintedSegments || []).find(
        p => p.wall === wall && p.position === position
      );
      if (existingPaint && existingPaint.wallpaper === wallpaperType) return state;
      
      // Check if player can afford it
      if (state.coins < wallpaper.cost) return state;
      
      // Remove any existing paint for this segment
      const otherPaints = (state.paintedSegments || []).filter(
        p => !(p.wall === wall && p.position === position)
      );
      
      // Add new paint
      const newPaints = [...otherPaints, { wall, position, wallpaper: wallpaperType }];
      
      return {
        ...state,
        coins: state.coins - wallpaper.cost,
        paintedSegments: newPaints,
        paintedVersion: (state.paintedVersion || 0) + 1, // Increment version to trigger updates
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + wallpaper.cost },
      };
    }
    
    case 'PAINT_WALL_SEGMENTS': {
      // Batch paint multiple wall segments at once (used for preview/confirm system)
      const { segments, wallpaperType } = action.payload;
      const wallpaper = WALLPAPERS[wallpaperType];
      if (!wallpaper || !segments || segments.length === 0) return state;
      
      // Calculate cost - only charge for segments that are changing
      let segmentsToChange = 0;
      segments.forEach(({ wall, position }) => {
        const existingPaint = (state.paintedSegments || []).find(
          p => p.wall === wall && p.position === position
        );
        if (!existingPaint || existingPaint.wallpaper !== wallpaperType) {
          segmentsToChange++;
        }
      });
      
      const totalCost = segmentsToChange * wallpaper.cost;
      if (state.coins < totalCost) return state;
      
      // Apply new wallpapers
      let newPaints = [...(state.paintedSegments || [])];
      segments.forEach(({ wall, position }) => {
        // Remove any existing paint for this segment
        newPaints = newPaints.filter(p => !(p.wall === wall && p.position === position));
        // Add new paint
        newPaints.push({ wall, position, wallpaper: wallpaperType });
      });
      
      return {
        ...state,
        coins: state.coins - totalCost,
        paintedSegments: newPaints,
        paintedVersion: (state.paintedVersion || 0) + 1,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + totalCost },
      };
    }
    
    case 'PAINT_FLOOR_TILES': {
      const { tiles, floorStyle } = action.payload;
      const style = FLOOR_STYLES[floorStyle];
      if (!style || !tiles || tiles.length === 0) return state;
      
      // Calculate cost - only charge for tiles that are changing
      let tilesToChange = 0;
      tiles.forEach(({ gridX, gridZ }) => {
        const key = `${gridX},${gridZ}`;
        const currentStyle = state.floorTiles[key];
        // Default floor depends on row: whiteTile for rows 0-2, woodLight for rest
        const defaultStyle = gridZ < 3 ? 'whiteTile' : 'woodLight';
        const effectiveCurrentStyle = currentStyle || defaultStyle;
        if (effectiveCurrentStyle !== floorStyle) {
          tilesToChange++;
        }
      });
      
      const totalCost = tilesToChange * style.cost;
      if (state.coins < totalCost) return state;
      
      // Apply new floor tiles
      const newFloorTiles = { ...state.floorTiles };
      tiles.forEach(({ gridX, gridZ }) => {
        const key = `${gridX},${gridZ}`;
        newFloorTiles[key] = floorStyle;
      });
      
      return {
        ...state,
        coins: state.coins - totalCost,
        floorTiles: newFloorTiles,
        floorVersion: (state.floorVersion || 0) + 1,
        stats: { ...state.stats, totalSpent: state.stats.totalSpent + totalCost },
      };
    }
    
    case 'REMOVE_STOVE': {
      const { stoveId, noRefund = false } = action.payload;
      const stove = state.stoves.find(s => s.id === stoveId);
      if (!stove) return state;
      if (!noRefund && state.stoves.length <= 1) return state; // Must keep at least 1 stove (not when moving)
      const refund = noRefund ? 0 : Math.floor(500 * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        stoves: state.stoves.filter(s => s.id !== stoveId),
      };
    }
    
    case 'REMOVE_COUNTER': {
      const { counterId, noRefund = false } = action.payload;
      const counter = state.counters.find(c => c.id === counterId);
      if (!counter) return state;
      if (!noRefund && state.counters.length <= 1) return state; // Must keep at least 1 counter (not when moving)
      const refund = noRefund ? 0 : Math.floor(400 * 0.5); // 50% refund
      
      return {
        ...state,
        coins: state.coins + refund,
        counters: state.counters.filter(c => c.id !== counterId),
      };
    }
    
    case 'REMOVE_TABLE': {
      const { tableId, noRefund = false } = action.payload;
      const table = state.tables.find(t => t.id === tableId);
      if (!table) return state;
      if (!noRefund && state.tables.length <= 1) return state; // Must keep at least 1 table (not when moving)
      if (table.customer) return state; // Can't remove table with customer
      const tableStyleData = TABLE_STYLES[table.style] || TABLE_STYLES.round;
      const refund = noRefund ? 0 : Math.floor(tableStyleData.cost * 0.5); // 50% refund based on table cost
      
      // Unlink any chair that was linked to this table (don't delete it!)
      // Chair stays in place and can be re-linked to a new table
      return {
        ...state,
        coins: state.coins + refund,
        tables: state.tables.filter(t => t.id !== tableId),
        chairs: (state.chairs || []).map(c => 
          c.linkedTableId === tableId ? { ...c, linkedTableId: null } : c
        ),
      };
    }
    
    case 'ROTATE_TABLE': {
      const { tableId } = action.payload;
      return {
        ...state,
        tables: state.tables.map(t =>
          t.id === tableId ? { ...t, rotation: ((t.rotation || 0) + 1) % 4 } : t
        ),
      };
    }
    
    case 'LOAD_SAVE': {
      const gs = action.payload;
      const now = Date.now();
      
      // Process stoves - cooking becomes ready, ready gets fresh spoil timer
      const loadedStoves = (gs.stoves || state.stoves).map(s => {
        if (s.state === 'cooking') {
          // Food finished cooking while you were away!
          return { ...s, state: 'ready', startTime: now };
        }
        if (s.state === 'ready') {
          // Reset spoil timer so it doesn't immediately spoil
          return { ...s, startTime: now };
        }
        return s;
      });
      
      // Load tables first (needed for chair migration)
      const loadedTables = (gs.tables || state.tables).map(t => ({ 
        ...t, 
        style: t.style || 'round', 
        rotation: t.rotation || 0 
      }));
      
      // Migrate old chairs: add linkedTableId if missing
      // For each chair without a link, check if it faces a table and link them
      const loadedChairs = (gs.chairs || state.chairs || []).map(c => ({ 
        ...c, 
        style: c.style || 'basicWood', 
        rotation: c.rotation || 0 
      }));
      
      // Track which tables are already linked
      const linkedTableIds = new Set(loadedChairs.filter(c => c.linkedTableId).map(c => c.linkedTableId));
      
      // For chairs without linkedTableId, try to auto-link based on facing direction
      const migratedChairs = loadedChairs.map(chair => {
        if (chair.linkedTableId) return chair; // Already linked
        
        // Calculate which tile this chair faces
        const rotation = chair.rotation || 0;
        let facingX = chair.gridX;
        let facingZ = chair.gridZ;
        switch (rotation % 4) {
          case 0: facingZ = chair.gridZ + 1; break; // Faces +Z
          case 1: facingX = chair.gridX + 1; break; // Faces +X
          case 2: facingZ = chair.gridZ - 1; break; // Faces -Z
          case 3: facingX = chair.gridX - 1; break; // Faces -X
        }
        
        // Find table at facing position
        const facingTable = loadedTables.find(t => t.gridX === facingX && t.gridZ === facingZ);
        if (facingTable && !linkedTableIds.has(facingTable.id)) {
          linkedTableIds.add(facingTable.id);
          return { ...chair, linkedTableId: facingTable.id };
        }
        
        return chair;
      });
      
      return {
        ...state,
        coins: gs.coins || 5000,
        xp: gs.xp || 0,
        level: gs.level || 1,
        buzz: gs.buzz || 50,
        avatar: {
          ...state.avatar,
          ...(gs.avatar || {}),
          name: gs.avatar?.name || state.avatar.name || 'Chef',
          showName: gs.avatar?.showName || false,
        }, // Load avatar customization with defaults
        stats: {
          dishesCooked: gs.stats?.dishesCooked || 0,
          customersServed: gs.stats?.customersServed || 0,
          totalEarned: gs.stats?.totalEarned || 0,
          totalSpent: gs.stats?.totalSpent || 0,
          customersServedSession: 0, // Reset session stats on load
        },
        dishMastery: gs.dishMastery || {}, // Load dish mastery progress
        achievements: gs.achievements || [],
        stoves: loadedStoves.map(s => ({ ...s, rotation: s.rotation || 0, style: s.style || 'basic' })),
        counters: (gs.counters || state.counters).map(c => ({ ...c, rotation: c.rotation || 0, style: c.style || 'basic' })),
        tables: loadedTables,
        chairs: migratedChairs,
        waiters: (gs.waiters || [{ id: 'waiter-1' }]).map((w, idx) => ({ 
          // Reset each waiter to idle on load, preserve customization
          id: w.id || `waiter-${idx + 1}`,
          name: w.name || ['Alex', 'Sam', 'Jordan', 'Riley', 'Casey'][idx % 5],
          showName: w.showName || false,
          state: 'idle',
          gridX: w.gridX || 10, 
          gridZ: w.gridZ || 1,
          targetCounterId: null,
          targetTableId: null,
          carryingFood: null,
          path: [],
          walkProgress: 0,
          // Customization (with defaults for old saves)
          skin: w.skin ?? 2,
          hair: w.hair ?? 3,
          hairStyle: w.hairStyle ?? 0,
          outfit: w.outfit ?? 0,
        })),
        maxWaiters: gs.maxWaiters || 5,
        decorations: gs.decorations || [],
        dividers: gs.dividers || [],
        // Ensure at least one door exists (migration for old saves)
        doors: (gs.doors && gs.doors.length > 0) 
          ? gs.doors 
          : [{ id: 'door-initial', type: 'basicDoor', wall: 'left', wallPosition: 11 }],
        wallpaper: gs.wallpaper || 'cream',
        paintedSegments: gs.paintedSegments || [],
        paintedVersion: gs.paintedVersion || 0,
        floorTiles: gs.floorTiles || {},
        floorVersion: gs.floorVersion || 0,
      };
    }
    
    case 'UPDATE_AVATAR': {
      const { field, value } = action.payload;
      return {
        ...state,
        avatar: {
          ...state.avatar,
          [field]: value,
        },
      };
    }
    
    case 'UNLOCK_ACHIEVEMENT': {
      const { achievementId } = action.payload;
      // Don't unlock if already unlocked
      if (state.achievements.includes(achievementId)) return state;
      
      const achievement = ACHIEVEMENTS[achievementId];
      if (!achievement) return state;
      
      return {
        ...state,
        achievements: [...state.achievements, achievementId],
        coins: state.coins + achievement.reward,
        stats: { ...state.stats, totalEarned: state.stats.totalEarned + achievement.reward },
      };
    }
    
    default:
      return state;
  }
}

// ============================================
// 3D OBJECT CREATION HELPERS
// ============================================
function createVoxelBox(width, height, depth, color, x = 0, y = 0, z = 0) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function createVoxelSphere(radius, color, x = 0, y = 0, z = 0, segments = 10) {
  const geometry = new THREE.SphereGeometry(radius, segments, segments);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  return mesh;
}

function createVoxelCylinder(radiusTop, radiusBottom, height, color, x = 0, y = 0, z = 0, segments = 10) {
  const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, segments);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  return mesh;
}

function createVoxelCone(radius, height, color, x = 0, y = 0, z = 0, segments = 8) {
  const geometry = new THREE.ConeGeometry(radius, height, segments);
  const material = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  return mesh;
}

// Create canvas-based floor texture with mini-tiles (Cafe World style)
function createCanvasFloorTexture(style, isLight) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  // Convert hex to CSS color
  const toCSS = (hex) => '#' + hex.toString(16).padStart(6, '0');
  const color1 = toCSS(style.color1);
  const color2 = toCSS(style.color2);
  // Derive additional colors for variety
  const color1Light = toCSS(Math.min(0xFFFFFF, (style.color1 & 0xFEFEFE) + 0x181818));
  const color2Light = toCSS(Math.min(0xFFFFFF, (style.color2 & 0xFEFEFE) + 0x181818));
  
  const pattern = style.pattern;
  const halfSize = 64; // Each mini-tile is 64x64
  
  // Helper to add shine/reflection effect to a mini-tile (top-left corner highlight)
  const addShine = (x, y, size) => {
    // Create a radial gradient for the shine effect
    // Cap shine size so large tiles don't have oversized shine
    const shineSize = Math.min(size * 0.4, 30);
    const gradient = ctx.createRadialGradient(
      x + shineSize * 0.5, y + shineSize * 0.5, 0,
      x + shineSize * 0.5, y + shineSize * 0.5, shineSize
    );
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.35)');
    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.12)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, shineSize, shineSize);
    
    // Add a subtle white line on top-left edges
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 3, y + size - 3);
    ctx.lineTo(x + 3, y + 3);
    ctx.lineTo(x + size - 3, y + 3);
    ctx.stroke();
  };
  
  // Helper to add shadow on bottom-right (opposite of shine)
  const addShadow = (x, y, size) => {
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + size - 3, y + 3);
    ctx.lineTo(x + size - 3, y + size - 3);
    ctx.lineTo(x + 3, y + size - 3);
    ctx.stroke();
  };
  
  // Helper to draw a mini-tile with diagonal stripes
  const drawDiagonalMiniTile = (x, y, size, bgColor, stripeColor) => {
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, size, size);
    ctx.strokeStyle = stripeColor;
    ctx.lineWidth = 4;
    for (let i = -size; i < size * 2; i += 12) {
      ctx.beginPath();
      ctx.moveTo(x + i, y);
      ctx.lineTo(x + i + size, y + size);
      ctx.stroke();
    }
    // Border
    ctx.strokeStyle = stripeColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
    // Add shine and shadow
    addShine(x, y, size);
    addShadow(x, y, size);
  };
  
  // Helper to draw a mini-tile with diamond
  const drawDiamondMiniTile = (x, y, size, bgColor, diamondColor) => {
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, size, size);
    // Diamond in center
    const cx = x + size / 2;
    const cy = y + size / 2;
    const r = size * 0.35;
    ctx.fillStyle = diamondColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy - r);
    ctx.lineTo(cx + r, cy);
    ctx.lineTo(cx, cy + r);
    ctx.lineTo(cx - r, cy);
    ctx.closePath();
    ctx.fill();
    // Small corner squares
    const cornerSize = 8;
    ctx.fillRect(x + 4, y + 4, cornerSize, cornerSize);
    ctx.fillRect(x + size - cornerSize - 4, y + 4, cornerSize, cornerSize);
    ctx.fillRect(x + 4, y + size - cornerSize - 4, cornerSize, cornerSize);
    ctx.fillRect(x + size - cornerSize - 4, y + size - cornerSize - 4, cornerSize, cornerSize);
    // Add shine and shadow
    addShine(x, y, size);
    addShadow(x, y, size);
  };
  
  // Helper for border/frame pattern mini-tile
  const drawBorderMiniTile = (x, y, size, bgColor, borderColor) => {
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, size, size);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 6;
    ctx.strokeRect(x + 8, y + 8, size - 16, size - 16);
    // Center dot
    ctx.fillStyle = borderColor;
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, 6, 0, Math.PI * 2);
    ctx.fill();
    // Add shine and shadow
    addShine(x, y, size);
    addShadow(x, y, size);
  };
  
  // Helper for tiki/bamboo pattern
  const drawTikiMiniTile = (x, y, size, bgColor, lineColor) => {
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, size, size);
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 3;
    // Horizontal lines
    for (let i = 12; i < size; i += 16) {
      ctx.beginPath();
      ctx.moveTo(x + 4, y + i);
      ctx.lineTo(x + size - 4, y + i);
      ctx.stroke();
    }
    // Vertical accent
    ctx.beginPath();
    ctx.moveTo(x + size/2, y + 4);
    ctx.lineTo(x + size/2, y + size - 4);
    ctx.stroke();
    // Add shine and shadow
    addShine(x, y, size);
    addShadow(x, y, size);
  };
  
  if (pattern === 'canvasDiagonal') {
    // 2x2 grid of mini-tiles with diagonal stripes, alternating colors
    drawDiagonalMiniTile(0, 0, halfSize, color1, color2);
    drawDiagonalMiniTile(halfSize, 0, halfSize, color2, color1);
    drawDiagonalMiniTile(0, halfSize, halfSize, color2, color1);
    drawDiagonalMiniTile(halfSize, halfSize, halfSize, color1, color2);
  } else if (pattern === 'canvasDiamond' || pattern === 'diamond') {
    // 2x2 grid with diamonds
    drawDiamondMiniTile(0, 0, halfSize, color1, color2);
    drawDiamondMiniTile(halfSize, 0, halfSize, color2Light, color1);
    drawDiamondMiniTile(0, halfSize, halfSize, color2Light, color1);
    drawDiamondMiniTile(halfSize, halfSize, halfSize, color1, color2);
  } else if (pattern === 'canvasBorder' || pattern === 'border') {
    // 2x2 grid with border frames
    drawBorderMiniTile(0, 0, halfSize, color1, color2);
    drawBorderMiniTile(halfSize, 0, halfSize, color2, color1);
    drawBorderMiniTile(0, halfSize, halfSize, color2, color1);
    drawBorderMiniTile(halfSize, halfSize, halfSize, color1, color2);
  } else if (pattern === 'canvasTiki' || pattern === 'tiki') {
    // 2x2 grid with tiki/bamboo lines
    drawTikiMiniTile(0, 0, halfSize, color1, color2);
    drawTikiMiniTile(halfSize, 0, halfSize, color1Light, color2);
    drawTikiMiniTile(0, halfSize, halfSize, color1Light, color2);
    drawTikiMiniTile(halfSize, halfSize, halfSize, color1, color2);
  } else if (pattern === 'canvasFloral') {
    // Floral pattern with center flower in 2x2
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Draw flower in each quadrant
    [[32, 32], [96, 32], [32, 96], [96, 96]].forEach(([cx, cy], idx) => {
      const flowerColor = idx % 2 === 0 ? color2 : color1Light;
      ctx.fillStyle = flowerColor;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.ellipse(cx + Math.cos(angle) * 12, cy + Math.sin(angle) * 12, 8, 5, angle, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = color2;
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, Math.PI * 2);
      ctx.fill();
    });
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasPlaid') {
    // Plaid with mini-tile awareness
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = color2;
    for (let x = 0; x < 128; x += 32) {
      ctx.fillRect(x, 0, 10, 128);
    }
    for (let y = 0; y < 128; y += 32) {
      ctx.fillRect(0, y, 128, 10);
    }
    ctx.globalAlpha = 1;
    // Grid lines
    ctx.strokeStyle = color2;
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, 64, 64);
    ctx.strokeRect(64, 0, 64, 64);
    ctx.strokeRect(0, 64, 64, 64);
    ctx.strokeRect(64, 64, 64, 64);
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasHexagon') {
    // Hexagon in each mini-tile
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    [[32, 32], [96, 32], [32, 96], [96, 96]].forEach(([cx, cy]) => {
      ctx.strokeStyle = color2;
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
        const px = cx + Math.cos(angle) * 22;
        const py = cy + Math.sin(angle) * 22;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
    });
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasSwirl') {
    // Swirl in center of 2x2
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Mini borders
    ctx.strokeStyle = color2;
    ctx.lineWidth = 2;
    ctx.strokeRect(2, 2, 60, 60);
    ctx.strokeRect(66, 2, 60, 60);
    ctx.strokeRect(2, 66, 60, 60);
    ctx.strokeRect(66, 66, 60, 60);
    // Swirl in each
    [[32, 32], [96, 32], [32, 96], [96, 96]].forEach(([cx, cy]) => {
      ctx.strokeStyle = color2;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 360; i++) {
        const angle = (i / 90) * Math.PI;
        const r = 3 + i / 25;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    });
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasStar' || pattern === 'star') {
    // Star pattern in 2x2 mini-tiles
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    [[32, 32], [96, 32], [32, 96], [96, 96]].forEach(([cx, cy], idx) => {
      // Alternate star color
      ctx.fillStyle = idx % 2 === 0 ? color2 : color1Light;
      // 8-point star
      ctx.beginPath();
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 - Math.PI / 2;
        const r = i % 2 === 0 ? 18 : 8;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    });
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasDots' || pattern === 'dots') {
    // Polka dots in 2x2
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Dots in each quadrant
    const dotPositions = [
      [16, 16], [48, 16], [16, 48], [48, 48],
      [80, 16], [112, 16], [80, 48], [112, 48],
      [16, 80], [48, 80], [16, 112], [48, 112],
      [80, 80], [112, 80], [80, 112], [112, 112],
      [32, 32], [96, 32], [32, 96], [96, 96] // Center dots
    ];
    dotPositions.forEach(([x, y], idx) => {
      ctx.fillStyle = idx >= 16 ? color2 : color2Light;
      ctx.beginPath();
      ctx.arc(x, y, idx >= 16 ? 10 : 6, 0, Math.PI * 2);
      ctx.fill();
    });
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  }
  
  // === SHINY HARD SURFACE PATTERNS (marble, checkered, stone, etc.) ===
  
  if (pattern === 'canvasShiny') {
    // Simple shiny tile - solid color with shine effect (marble, stone, etc.)
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Subtle color variation for texture
    ctx.fillStyle = color2;
    ctx.globalAlpha = 0.3;
    ctx.fillRect(0, 0, 64, 64);
    ctx.fillRect(64, 64, 64, 64);
    ctx.globalAlpha = 1;
    // Add shine and shadow to full tile
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasShinyChecker') {
    // Checkered pattern with shine on each tile (2x2 mini-tiles)
    // Top-left and bottom-right: color1
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 64, 64);
    ctx.fillRect(64, 64, 64, 64);
    // Top-right and bottom-left: color2
    ctx.fillStyle = color2;
    ctx.fillRect(64, 0, 64, 64);
    ctx.fillRect(0, 64, 64, 64);
    // Add shine to each quadrant
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
    addShadow(0, 0, halfSize);
    addShadow(halfSize, 0, halfSize);
    addShadow(0, halfSize, halfSize);
    addShadow(halfSize, halfSize, halfSize);
  } else if (pattern === 'canvasHarlequin') {
    // Harlequin - diagonal split (two triangles) pattern
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Diagonal half in color2
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(128, 0);
    ctx.lineTo(128, 128);
    ctx.closePath();
    ctx.fill();
    // Single shine and shadow for whole tile
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasSolidShiny') {
    // Solid shiny tile - uses isLight to alternate colors for true checkerboard
    ctx.fillStyle = isLight ? color1 : color2;
    ctx.fillRect(0, 0, 128, 128);
    // Add shine and shadow
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasMarble') {
    // Marble with veining effect
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Add marble veins
    ctx.strokeStyle = color2;
    ctx.globalAlpha = 0.4;
    ctx.lineWidth = 2;
    // Random-ish veins
    ctx.beginPath();
    ctx.moveTo(10, 30);
    ctx.quadraticCurveTo(40, 50, 80, 25);
    ctx.quadraticCurveTo(100, 15, 120, 40);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(5, 80);
    ctx.quadraticCurveTo(30, 70, 60, 90);
    ctx.quadraticCurveTo(90, 110, 125, 85);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(20, 110);
    ctx.quadraticCurveTo(50, 95, 70, 115);
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Strong shine for polished marble
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasGranite') {
    // Granite with speckled effect
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Add speckles
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * 128;
      const y = Math.random() * 128;
      const size = Math.random() * 3 + 1;
      ctx.fillStyle = i % 3 === 0 ? color2 : (i % 3 === 1 ? color1Light : color2Light);
      ctx.globalAlpha = 0.5 + Math.random() * 0.5;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasWoodPlanks') {
    // Horizontal wood planks with grain
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    
    // Draw 4 horizontal planks
    const plankHeight = 32;
    for (let p = 0; p < 4; p++) {
      const y = p * plankHeight;
      // Alternate plank shade slightly
      ctx.fillStyle = p % 2 === 0 ? color1 : color1Light;
      ctx.fillRect(0, y, 128, plankHeight);
      
      // Wood grain lines
      ctx.strokeStyle = color2;
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      for (let g = 0; g < 5; g++) {
        const gy = y + 5 + g * 6;
        ctx.beginPath();
        ctx.moveTo(0, gy);
        // Wavy grain line
        ctx.quadraticCurveTo(32, gy + (g % 2 === 0 ? 2 : -2), 64, gy);
        ctx.quadraticCurveTo(96, gy + (g % 2 === 0 ? -2 : 2), 128, gy);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Plank separation line (darker groove)
      ctx.strokeStyle = color2;
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, y + plankHeight - 1);
      ctx.lineTo(128, y + plankHeight - 1);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    // Subtle shine on wood
    addShine(0, 0, 128);
  } else if (pattern === 'canvasWoodPlanksVertical') {
    // Vertical wood planks with grain
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    
    // Draw 4 vertical planks
    const plankWidth = 32;
    for (let p = 0; p < 4; p++) {
      const x = p * plankWidth;
      // Alternate plank shade slightly
      ctx.fillStyle = p % 2 === 0 ? color1 : color1Light;
      ctx.fillRect(x, 0, plankWidth, 128);
      
      // Wood grain lines (vertical)
      ctx.strokeStyle = color2;
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      for (let g = 0; g < 5; g++) {
        const gx = x + 5 + g * 6;
        ctx.beginPath();
        ctx.moveTo(gx, 0);
        ctx.quadraticCurveTo(gx + (g % 2 === 0 ? 2 : -2), 32, gx, 64);
        ctx.quadraticCurveTo(gx + (g % 2 === 0 ? -2 : 2), 96, gx, 128);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Plank separation line
      ctx.strokeStyle = color2;
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + plankWidth - 1, 0);
      ctx.lineTo(x + plankWidth - 1, 128);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    addShine(0, 0, 128);
  } else if (pattern === 'canvasWoodParquet') {
    // Parquet pattern - alternating horizontal/vertical squares
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    
    // 2x2 grid of parquet squares
    for (let qy = 0; qy < 2; qy++) {
      for (let qx = 0; qx < 2; qx++) {
        const x = qx * 64;
        const y = qy * 64;
        const isHorizontal = (qx + qy) % 2 === 0;
        
        ctx.fillStyle = isHorizontal ? color1 : color1Light;
        ctx.fillRect(x, y, 64, 64);
        
        // Draw mini planks
        ctx.strokeStyle = color2;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 1;
        
        if (isHorizontal) {
          // Horizontal lines
          for (let i = 8; i < 64; i += 12) {
            ctx.beginPath();
            ctx.moveTo(x + 2, y + i);
            ctx.lineTo(x + 62, y + i);
            ctx.stroke();
          }
        } else {
          // Vertical lines
          for (let i = 8; i < 64; i += 12) {
            ctx.beginPath();
            ctx.moveTo(x + i, y + 2);
            ctx.lineTo(x + i, y + 62);
            ctx.stroke();
          }
        }
        ctx.globalAlpha = 1;
      }
    }
    // Border between squares
    ctx.strokeStyle = color2;
    ctx.globalAlpha = 0.5;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(64, 0);
    ctx.lineTo(64, 128);
    ctx.moveTo(0, 64);
    ctx.lineTo(128, 64);
    ctx.stroke();
    ctx.globalAlpha = 1;
    addShine(0, 0, halfSize);
    addShine(halfSize, 0, halfSize);
    addShine(0, halfSize, halfSize);
    addShine(halfSize, halfSize, halfSize);
  }
  
  // === LARGE VARIANTS (single full-size pattern, not 2x2) ===
  
  if (pattern === 'canvasDiagonalLarge') {
    // Full-size diagonal stripes
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    ctx.strokeStyle = color2;
    ctx.lineWidth = 8;
    for (let i = -128; i < 256; i += 20) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i + 128, 128);
      ctx.stroke();
    }
    // Border
    ctx.strokeStyle = color2;
    ctx.lineWidth = 4;
    ctx.strokeRect(4, 4, 120, 120);
    // Full tile shine
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasDiamondLarge') {
    // Full-size diamond
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Large center diamond
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.moveTo(64, 10);
    ctx.lineTo(118, 64);
    ctx.lineTo(64, 118);
    ctx.lineTo(10, 64);
    ctx.closePath();
    ctx.fill();
    // Corner accents
    const cornerSize = 16;
    ctx.fillRect(6, 6, cornerSize, cornerSize);
    ctx.fillRect(128 - cornerSize - 6, 6, cornerSize, cornerSize);
    ctx.fillRect(6, 128 - cornerSize - 6, cornerSize, cornerSize);
    ctx.fillRect(128 - cornerSize - 6, 128 - cornerSize - 6, cornerSize, cornerSize);
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasBorderLarge') {
    // Full-size border frame
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    ctx.strokeStyle = color2;
    ctx.lineWidth = 10;
    ctx.strokeRect(12, 12, 104, 104);
    // Center decorative element
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.arc(64, 64, 15, 0, Math.PI * 2);
    ctx.fill();
    // Inner accent square
    ctx.strokeStyle = color2;
    ctx.lineWidth = 3;
    ctx.strokeRect(35, 35, 58, 58);
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasTikiLarge') {
    // Full-size tiki/bamboo
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    ctx.strokeStyle = color2;
    ctx.lineWidth = 5;
    // Horizontal bamboo lines
    for (let y = 20; y < 128; y += 25) {
      ctx.beginPath();
      ctx.moveTo(8, y);
      ctx.lineTo(120, y);
      ctx.stroke();
    }
    // Vertical accents
    ctx.beginPath();
    ctx.moveTo(40, 8);
    ctx.lineTo(40, 120);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(88, 8);
    ctx.lineTo(88, 120);
    ctx.stroke();
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasFloralLarge') {
    // Full-size single flower
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Large center flower
    ctx.fillStyle = color2;
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      ctx.beginPath();
      ctx.ellipse(64 + Math.cos(angle) * 30, 64 + Math.sin(angle) * 30, 20, 12, angle, 0, Math.PI * 2);
      ctx.fill();
    }
    // Center
    ctx.fillStyle = color1Light;
    ctx.beginPath();
    ctx.arc(64, 64, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.arc(64, 64, 10, 0, Math.PI * 2);
    ctx.fill();
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasStarLarge') {
    // Full-size star
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Large 8-point star
    ctx.fillStyle = color2;
    ctx.beginPath();
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2 - Math.PI / 2;
      const r = i % 2 === 0 ? 50 : 22;
      const x = 64 + Math.cos(angle) * r;
      const y = 64 + Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    // Small corner stars
    [[20, 20], [108, 20], [20, 108], [108, 108]].forEach(([cx, cy]) => {
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
        const r = i % 2 === 0 ? 12 : 5;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    });
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasDotsLarge') {
    // Full-size polka dots
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Large center dot
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.arc(64, 64, 25, 0, Math.PI * 2);
    ctx.fill();
    // Medium corner dots
    [[28, 28], [100, 28], [28, 100], [100, 100]].forEach(([x, y]) => {
      ctx.beginPath();
      ctx.arc(x, y, 16, 0, Math.PI * 2);
      ctx.fill();
    });
    // Small accent dots
    [[64, 20], [64, 108], [20, 64], [108, 64]].forEach(([x, y]) => {
      ctx.fillStyle = color2Light;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
    });
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasHexagonLarge') {
    // Full-size hexagon
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Large hexagon
    ctx.strokeStyle = color2;
    ctx.lineWidth = 6;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
      const x = 64 + Math.cos(angle) * 50;
      const y = 64 + Math.sin(angle) * 50;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
    // Inner hexagon
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
      const x = 64 + Math.cos(angle) * 28;
      const y = 64 + Math.sin(angle) * 28;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
    // Center dot
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.arc(64, 64, 8, 0, Math.PI * 2);
    ctx.fill();
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasSwirlLarge') {
    // Full-size swirl
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    // Border
    ctx.strokeStyle = color2;
    ctx.lineWidth = 4;
    ctx.strokeRect(6, 6, 116, 116);
    // Large spiral
    ctx.lineWidth = 4;
    ctx.beginPath();
    for (let i = 0; i < 720; i++) {
      const angle = (i / 90) * Math.PI;
      const r = 5 + i / 15;
      const x = 64 + Math.cos(angle) * r;
      const y = 64 + Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  } else if (pattern === 'canvasPlaidLarge') {
    // Full-size plaid
    ctx.fillStyle = color1;
    ctx.fillRect(0, 0, 128, 128);
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = color2;
    // Wider stripes for large version
    for (let x = 0; x < 128; x += 40) {
      ctx.fillRect(x, 0, 16, 128);
    }
    for (let y = 0; y < 128; y += 40) {
      ctx.fillRect(0, y, 128, 16);
    }
    ctx.globalAlpha = 1;
    addShine(0, 0, 128);
    addShadow(0, 0, 128);
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  return texture;
}

// Helper to create a patterned floor tile
function createPatternedFloorTile(style, worldX, worldZ, isLight) {
  const group = new THREE.Group();
  group.position.set(worldX, 0, worldZ);
  
  const tileSize = TILE_SIZE * 0.98;
  const pattern = style.pattern || 'checker';
  
  // Check if this is a canvas-based pattern
  if (pattern.startsWith('canvas')) {
    // Use canvas texture for complex patterns
    const texture = createCanvasFloorTexture(style, isLight);
    const geo = new THREE.BoxGeometry(tileSize, 0.1, tileSize);
    const mat = new THREE.MeshLambertMaterial({ map: texture });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.receiveShadow = true;
    group.add(mesh);
    return group;
  }
  
  // Base tile (always present for multi-mesh patterns)
  const baseColor = isLight ? style.color1 : style.color2;
  const baseGeo = new THREE.BoxGeometry(tileSize, 0.1, tileSize);
  const baseMat = new THREE.MeshLambertMaterial({ color: baseColor });
  const baseMesh = new THREE.Mesh(baseGeo, baseMat);
  baseMesh.receiveShadow = true;
  group.add(baseMesh);
  
  // Add pattern details based on type
  if (pattern === 'diamond') {
    // Diamond shape in center
    const diamondColor = isLight ? style.color2 : style.color1;
    const diamondMat = new THREE.MeshLambertMaterial({ color: diamondColor });
    const diamond = new THREE.Mesh(
      new THREE.BoxGeometry(tileSize * 0.5, 0.12, tileSize * 0.5),
      diamondMat
    );
    diamond.position.set(0, 0.01, 0);
    diamond.rotation.y = Math.PI / 4; // Rotate 45 degrees to make diamond
    group.add(diamond);
    
    // Small corner accents
    const cornerMat = new THREE.MeshLambertMaterial({ color: style.color1 });
    [[-0.35, -0.35], [-0.35, 0.35], [0.35, -0.35], [0.35, 0.35]].forEach(([cx, cz]) => {
      const corner = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.12, 0.15),
        cornerMat
      );
      corner.position.set(cx, 0.01, cz);
      group.add(corner);
    });
  } else if (pattern === 'tiki') {
    // Bamboo/tiki lines
    const lineColor = style.color2;
    const lineMat = new THREE.MeshLambertMaterial({ color: lineColor });
    // Horizontal lines
    for (let i = -1; i <= 1; i++) {
      const line = new THREE.Mesh(
        new THREE.BoxGeometry(tileSize, 0.12, 0.06),
        lineMat
      );
      line.position.set(0, 0.01, i * 0.3);
      group.add(line);
    }
    // Vertical accent lines
    for (let i = -1; i <= 1; i += 2) {
      const vline = new THREE.Mesh(
        new THREE.BoxGeometry(0.06, 0.12, tileSize * 0.4),
        lineMat
      );
      vline.position.set(i * 0.35, 0.01, 0);
      group.add(vline);
    }
  } else if (pattern === 'border') {
    // Frame/border pattern
    const borderColor = isLight ? style.color2 : style.color1;
    const borderMat = new THREE.MeshLambertMaterial({ color: borderColor });
    const thickness = 0.08;
    const offset = tileSize / 2 - thickness / 2 - 0.02;
    // Four border edges
    [
      [0, offset, tileSize - 0.04, thickness],    // Top
      [0, -offset, tileSize - 0.04, thickness],   // Bottom
      [-offset, 0, thickness, tileSize - 0.04],   // Left
      [offset, 0, thickness, tileSize - 0.04],    // Right
    ].forEach(([bx, bz, bw, bd]) => {
      const border = new THREE.Mesh(
        new THREE.BoxGeometry(bw, 0.12, bd),
        borderMat
      );
      border.position.set(bx, 0.01, bz);
      group.add(border);
    });
    // Center accent
    const center = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.12, 0.2),
      borderMat
    );
    center.position.set(0, 0.01, 0);
    group.add(center);
  } else if (pattern === 'star') {
    // Star pattern
    const starColor = style.color2;
    const starMat = new THREE.MeshLambertMaterial({ color: starColor });
    // Center of star
    const starCenter = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.12, 0.15),
      starMat
    );
    starCenter.position.set(0, 0.01, 0);
    group.add(starCenter);
    // Star points (4 directions + 4 diagonals)
    const points = [
      [0.25, 0], [-0.25, 0], [0, 0.25], [0, -0.25],
      [0.18, 0.18], [-0.18, 0.18], [0.18, -0.18], [-0.18, -0.18]
    ];
    points.forEach(([px, pz]) => {
      const point = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.12, 0.1),
        starMat
      );
      point.position.set(px, 0.01, pz);
      group.add(point);
    });
  } else if (pattern === 'dots') {
    // Polka dots
    const dotColor = style.color2;
    const dotMat = new THREE.MeshLambertMaterial({ color: dotColor });
    const dotPositions = [
      [0, 0], [-0.25, -0.25], [0.25, -0.25], [-0.25, 0.25], [0.25, 0.25]
    ];
    dotPositions.forEach(([dx, dz]) => {
      const dot = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 0.12, 8),
        dotMat
      );
      dot.position.set(dx, 0.01, dz);
      group.add(dot);
    });
  }
  // 'checker' pattern is just the base tile, no extra details
  
  return group;
}

function createFloor(scene, floorTiles = {}, objectsRef = null) {
  // Create floor tiles based on floorTiles state
  // Each tile can have its own style, with defaults based on position
  
  // Clear existing floor tiles from scene if re-creating
  if (objectsRef?.current?.floorTiles) {
    Object.values(objectsRef.current.floorTiles).forEach(tile => {
      if (tile && tile.parent) {
        tile.parent.remove(tile);
      }
    });
  }
  
  if (objectsRef) {
    objectsRef.current.floorTiles = {};
  }
  
  for (let x = 0; x < GRID.width; x++) {
    for (let z = 0; z < GRID.height; z++) {
      const key = `${x},${z}`;
      const isLight = (x + z) % 2 === 0;
      
      // Determine floor style - use saved style or default
      const defaultStyle = z < 3 ? 'whiteTile' : 'woodLight';
      const styleKey = floorTiles[key] || defaultStyle;
      const style = FLOOR_STYLES[styleKey] || FLOOR_STYLES[defaultStyle];
      
      const worldX = x - GRID.width / 2 + 0.5;
      const worldZ = z - GRID.height / 2 + 0.5;
      
      // Create patterned tile
      const tile = createPatternedFloorTile(style, worldX, worldZ, isLight);
      tile.userData = { gridX: x, gridZ: z, styleKey, style };
      scene.add(tile);
      
      // Store reference for dynamic updates
      if (objectsRef) {
        objectsRef.current.floorTiles[key] = tile;
      }
    }
  }
}

// Standalone function to create wallpaper pattern previews for selected segments
// Returns array of meshes that should be added to scene and cleaned up later
function createWallpaperPreviewPatterns(scene, wallType, position, wallpaper) {
  if (!wallpaper || !wallpaper.pattern) return [];
  
  const patterns = [];
  const pattern = wallpaper.pattern;
  const wallHeight = 3;
  const segmentWidth = 1.1;
  
  // Calculate segment center position based on wall type
  let segmentX, segmentZ;
  if (wallType === 'back') {
    segmentX = position - GRID.width / 2 + 0.5;
    segmentZ = -GRID.height / 2;
  } else if (wallType === 'left') {
    segmentX = -GRID.width / 2;
    segmentZ = position - GRID.height / 2 + 0.5;
  } else if (wallType === 'right') {
    segmentX = GRID.width / 2;
    segmentZ = position - GRID.height / 2 + 0.5;
  }
  
  if (pattern === 'stripes' && wallpaper.stripeColor) {
    const stripeMat = new THREE.MeshLambertMaterial({ color: wallpaper.stripeColor });
    const stripeWidth = 0.06;
    const stripeDepth = 0.02;
    const stripeSpacing = 0.25;
    
    for (let offset = -0.3; offset <= 0.3; offset += stripeSpacing) {
      let stripe;
      
      if (wallType === 'back') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeWidth, wallHeight - 0.1, stripeDepth),
          stripeMat
        );
        stripe.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + stripeDepth / 2);
      } else if (wallType === 'left') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
          stripeMat
        );
        stripe.position.set(-GRID.width / 2 + stripeDepth / 2, wallHeight / 2, segmentZ + offset);
      } else if (wallType === 'right') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
          stripeMat
        );
        stripe.position.set(GRID.width / 2 - stripeDepth / 2, wallHeight / 2, segmentZ + offset);
      }
      
      if (stripe) {
        scene.add(stripe);
        patterns.push(stripe);
      }
    }
  }
  
  if (pattern === 'brick') {
    const mortarMat = new THREE.MeshLambertMaterial({ color: 0xD3D3D3 });
    const mortarHeight = 0.025;
    const mortarDepth = 0.02;
    const brickRowHeight = 0.25;
    
    // Horizontal mortar lines
    for (let y = brickRowHeight; y < wallHeight; y += brickRowHeight) {
      let mortar;
      
      if (wallType === 'back') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, mortarHeight, mortarDepth),
          mortarMat
        );
        mortar.position.set(segmentX, y, -GRID.height / 2 + mortarDepth / 2);
      } else if (wallType === 'left') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(-GRID.width / 2 + mortarDepth / 2, y, segmentZ);
      } else if (wallType === 'right') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(GRID.width / 2 - mortarDepth / 2, y, segmentZ);
      }
      
      if (mortar) {
        scene.add(mortar);
        patterns.push(mortar);
      }
    }
    
    // Vertical mortar lines (staggered)
    const verticalSpacing = 0.35;
    let row = 0;
    for (let y = 0; y < wallHeight; y += brickRowHeight) {
      const offsetAmt = (row % 2 === 0) ? 0 : verticalSpacing / 2;
      for (let offset = -0.4 + offsetAmt; offset <= 0.4; offset += verticalSpacing) {
        let vMortar;
        
        if (wallType === 'back') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarHeight, brickRowHeight * 0.9, mortarDepth),
            mortarMat
          );
          vMortar.position.set(segmentX + offset, y + brickRowHeight / 2, -GRID.height / 2 + mortarDepth / 2);
        } else if (wallType === 'left') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
            mortarMat
          );
          vMortar.position.set(-GRID.width / 2 + mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
            mortarMat
          );
          vMortar.position.set(GRID.width / 2 - mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
        }
        
        if (vMortar) {
          scene.add(vMortar);
          patterns.push(vMortar);
        }
      }
      row++;
    }
  }
  
  if (pattern === 'wood') {
    const grooveMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
    const grooveWidth = 0.02;
    const grooveDepth = 0.015;
    const grooveSpacing = 0.3;
    
    const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
      let groove;
      
      if (wallType === 'back') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveWidth, wallHeight - 0.1, grooveDepth),
          grooveMat
        );
        groove.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + grooveDepth / 2);
      } else if (wallType === 'left') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
          grooveMat
        );
        groove.position.set(-GRID.width / 2 + grooveDepth / 2, wallHeight / 2, segmentZ + offset);
      } else if (wallType === 'right') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
          grooveMat
        );
        groove.position.set(GRID.width / 2 - grooveDepth / 2, wallHeight / 2, segmentZ + offset);
      }
      
      if (groove) {
        scene.add(groove);
        patterns.push(groove);
      }
    }
  }
  
  if (pattern === 'stone') {
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x505050 });
    const lineDepth = 0.015;
    const lineWidth = 0.03;
    const rowHeight = 0.5;
    
    // Horizontal lines
    for (let y = rowHeight; y < wallHeight; y += rowHeight) {
      let hLine;
      
      if (wallType === 'back') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, lineWidth, lineDepth),
          stoneMat
        );
        hLine.position.set(segmentX, y, -GRID.height / 2 + lineDepth / 2);
      } else if (wallType === 'left') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(-GRID.width / 2 + lineDepth / 2, y, segmentZ);
      } else if (wallType === 'right') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(GRID.width / 2 - lineDepth / 2, y, segmentZ);
      }
      
      if (hLine) {
        scene.add(hLine);
        patterns.push(hLine);
      }
    }
    
    // Staggered vertical lines
    let row = 0;
    for (let y = 0; y < wallHeight; y += rowHeight) {
      const offsetAmt = (row % 2 === 0) ? 0.15 : -0.15;
      let vLine;
      
      if (wallType === 'back') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineWidth, rowHeight * 0.9, lineDepth),
          stoneMat
        );
        vLine.position.set(segmentX + offsetAmt, y + rowHeight / 2, -GRID.height / 2 + lineDepth / 2);
      } else if (wallType === 'left') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
          stoneMat
        );
        vLine.position.set(-GRID.width / 2 + lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
      } else if (wallType === 'right') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
          stoneMat
        );
        vLine.position.set(GRID.width / 2 - lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
      }
      
      if (vLine) {
        scene.add(vLine);
        patterns.push(vLine);
      }
      row++;
    }
  }
  
  // Subway tile pattern - horizontal rectangular tiles with staggered grout
  if (pattern === 'subway') {
    const groutColor = wallpaper.groutColor || 0xCCCCCC;
    const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
    const groutDepth = 0.015;
    const tileHeight = 0.2;
    const tileWidth = 0.35;  // Slightly smaller tiles that fit better
    const groutWidth = 0.02;
    const segmentWidth = 1.1;
    
    // Horizontal grout lines (slightly smaller to avoid bleed)
    for (let y = tileHeight; y < wallHeight; y += tileHeight) {
      let hGrout;
      
      if (wallType === 'back') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 0.95, groutWidth, groutDepth),
          groutMat
        );
        hGrout.position.set(segmentX, y, -GRID.height / 2 + groutDepth / 2);
      } else if (wallType === 'left') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
          groutMat
        );
        hGrout.position.set(-GRID.width / 2 + groutDepth / 2, y, segmentZ);
      } else if (wallType === 'right') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
          groutMat
        );
        hGrout.position.set(GRID.width / 2 - groutDepth / 2, y, segmentZ);
      }
      
      if (hGrout) {
        scene.add(hGrout);
        patterns.push(hGrout);
      }
    }
    
    // Vertical grout lines (using same range as brick for alignment)
    let row = 0;
    for (let y = 0; y < wallHeight; y += tileHeight) {
      const stagger = (row % 2 === 0) ? 0 : tileWidth / 2;
      for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
        let vGrout;
        
        if (wallType === 'back') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutWidth, tileHeight * 0.95, groutDepth),
            groutMat
          );
          vGrout.position.set(segmentX + offset, y + tileHeight / 2, -GRID.height / 2 + groutDepth / 2);
        } else if (wallType === 'left') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
            groutMat
          );
          vGrout.position.set(-GRID.width / 2 + groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
            groutMat
          );
          vGrout.position.set(GRID.width / 2 - groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
        }
        
        if (vGrout) {
          scene.add(vGrout);
          patterns.push(vGrout);
        }
      }
      row++;
    }
  }
  
  // Wainscoting pattern
  if (pattern === 'wainscot') {
    const railHeight = wallHeight * 0.35;
    const bottomColor = wallpaper.bottomColor || 0x8B4513;
    const railColor = wallpaper.railColor || 0x5D3A1A;
    const woodMat = new THREE.MeshLambertMaterial({ color: bottomColor });
    const railMat = new THREE.MeshLambertMaterial({ color: railColor });
    const panelDepth = 0.025;
    const segmentWidth = 1.1;
    
    // Bottom wood panel
    let bottomPanel;
    if (wallType === 'back') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.02, railHeight, panelDepth),
        woodMat
      );
      bottomPanel.position.set(segmentX, railHeight / 2, -GRID.height / 2 + panelDepth / 2);
    } else if (wallType === 'left') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
        woodMat
      );
      bottomPanel.position.set(-GRID.width / 2 + panelDepth / 2, railHeight / 2, segmentZ);
    } else if (wallType === 'right') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
        woodMat
      );
      bottomPanel.position.set(GRID.width / 2 - panelDepth / 2, railHeight / 2, segmentZ);
    }
    
    if (bottomPanel) {
      scene.add(bottomPanel);
      patterns.push(bottomPanel);
    }
    
    // Vertical grooves
    // Use symmetrical positions for even panels
    const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
      let groove;
      const grooveMat = new THREE.MeshLambertMaterial({ color: railColor });
      
      if (wallType === 'back') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.015, railHeight - 0.1, 0.01),
          grooveMat
        );
        groove.position.set(segmentX + offset, railHeight / 2, -GRID.height / 2 + panelDepth + 0.005);
      } else if (wallType === 'left') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
          grooveMat
        );
        groove.position.set(-GRID.width / 2 + panelDepth + 0.005, railHeight / 2, segmentZ + offset);
      } else if (wallType === 'right') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
          grooveMat
        );
        groove.position.set(GRID.width / 2 - panelDepth - 0.005, railHeight / 2, segmentZ + offset);
      }
      
      if (groove) {
        scene.add(groove);
        patterns.push(groove);
      }
    }
    
    // Chair rail
    let chairRail;
    const railThickness = 0.06;
    if (wallType === 'back') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.05, railThickness, panelDepth * 1.5),
        railMat
      );
      chairRail.position.set(segmentX, railHeight, -GRID.height / 2 + panelDepth);
    } else if (wallType === 'left') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
        railMat
      );
      chairRail.position.set(-GRID.width / 2 + panelDepth, railHeight, segmentZ);
    } else if (wallType === 'right') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
        railMat
      );
      chairRail.position.set(GRID.width / 2 - panelDepth, railHeight, segmentZ);
    }
    
    if (chairRail) {
      scene.add(chairRail);
      patterns.push(chairRail);
    }
    
    // Baseboard
    let baseboard;
    if (wallType === 'back') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.05, 0.08, panelDepth * 1.3),
        railMat
      );
      baseboard.position.set(segmentX, 0.04, -GRID.height / 2 + panelDepth);
    } else if (wallType === 'left') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
        railMat
      );
      baseboard.position.set(-GRID.width / 2 + panelDepth, 0.04, segmentZ);
    } else if (wallType === 'right') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
        railMat
      );
      baseboard.position.set(GRID.width / 2 - panelDepth, 0.04, segmentZ);
    }
    
    if (baseboard) {
      scene.add(baseboard);
      patterns.push(baseboard);
    }
  }
  
  // Wainscot + Tile pattern
  if (pattern === 'wainscotTile') {
    const railHeight = wallHeight * 0.35;
    const bottomColor = wallpaper.bottomColor || 0x8B4513;
    const railColor = wallpaper.railColor || 0x5D3A1A;
    const groutColor = wallpaper.groutColor || 0xCCCCCC;
    const woodMat = new THREE.MeshLambertMaterial({ color: bottomColor });
    const railMat = new THREE.MeshLambertMaterial({ color: railColor });
    const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
    const panelDepth = 0.025;
    const groutDepth = 0.015;
    const segmentWidth = 1.1;
    
    // Bottom wood panel
    let bottomPanel;
    if (wallType === 'back') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.02, railHeight, panelDepth),
        woodMat
      );
      bottomPanel.position.set(segmentX, railHeight / 2, -GRID.height / 2 + panelDepth / 2);
    } else if (wallType === 'left') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
        woodMat
      );
      bottomPanel.position.set(-GRID.width / 2 + panelDepth / 2, railHeight / 2, segmentZ);
    } else if (wallType === 'right') {
      bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
        woodMat
      );
      bottomPanel.position.set(GRID.width / 2 - panelDepth / 2, railHeight / 2, segmentZ);
    }
    
    if (bottomPanel) {
      scene.add(bottomPanel);
      patterns.push(bottomPanel);
    }
    
    // Vertical grooves
    // Use symmetrical positions for even panels
    const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
      let groove;
      const grooveMat = new THREE.MeshLambertMaterial({ color: railColor });
      
      if (wallType === 'back') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.015, railHeight - 0.1, 0.01),
          grooveMat
        );
        groove.position.set(segmentX + offset, railHeight / 2, -GRID.height / 2 + panelDepth + 0.005);
      } else if (wallType === 'left') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
          grooveMat
        );
        groove.position.set(-GRID.width / 2 + panelDepth + 0.005, railHeight / 2, segmentZ + offset);
      } else if (wallType === 'right') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
          grooveMat
        );
        groove.position.set(GRID.width / 2 - panelDepth - 0.005, railHeight / 2, segmentZ + offset);
      }
      
      if (groove) {
        scene.add(groove);
        patterns.push(groove);
      }
    }
    
    // Chair rail
    let chairRail;
    const railThickness = 0.06;
    if (wallType === 'back') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.05, railThickness, panelDepth * 1.5),
        railMat
      );
      chairRail.position.set(segmentX, railHeight, -GRID.height / 2 + panelDepth);
    } else if (wallType === 'left') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
        railMat
      );
      chairRail.position.set(-GRID.width / 2 + panelDepth, railHeight, segmentZ);
    } else if (wallType === 'right') {
      chairRail = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
        railMat
      );
      chairRail.position.set(GRID.width / 2 - panelDepth, railHeight, segmentZ);
    }
    
    if (chairRail) {
      scene.add(chairRail);
      patterns.push(chairRail);
    }
    
    // Baseboard
    let baseboard;
    if (wallType === 'back') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(segmentWidth * 1.05, 0.08, panelDepth * 1.3),
        railMat
      );
      baseboard.position.set(segmentX, 0.04, -GRID.height / 2 + panelDepth);
    } else if (wallType === 'left') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
        railMat
      );
      baseboard.position.set(-GRID.width / 2 + panelDepth, 0.04, segmentZ);
    } else if (wallType === 'right') {
      baseboard = new THREE.Mesh(
        new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
        railMat
      );
      baseboard.position.set(GRID.width / 2 - panelDepth, 0.04, segmentZ);
    }
    
    if (baseboard) {
      scene.add(baseboard);
      patterns.push(baseboard);
    }
    
    // Subway tiles above chair rail
    const tileHeight = 0.2;
    const tileWidth = 0.35;  // Slightly smaller tiles that fit better
    const groutWidth = 0.02;
    
    // Use absolute row numbers for alignment (same approach as brick)
    const firstTileRow = Math.ceil(railHeight / tileHeight);
    
    // Horizontal grout lines - at absolute Y positions (start at firstTileRow for line above wood)
    for (let rowNum = firstTileRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      let hGrout;
      
      if (wallType === 'back') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 0.95, groutWidth, groutDepth),
          groutMat
        );
        hGrout.position.set(segmentX, y, -GRID.height / 2 + groutDepth / 2);
      } else if (wallType === 'left') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
          groutMat
        );
        hGrout.position.set(-GRID.width / 2 + groutDepth / 2, y, segmentZ);
      } else if (wallType === 'right') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
          groutMat
        );
        hGrout.position.set(GRID.width / 2 - groutDepth / 2, y, segmentZ);
      }
      
      if (hGrout) {
        scene.add(hGrout);
        patterns.push(hGrout);
      }
    }
    
    // Vertical grout lines (use absolute row numbers like brick for alignment)
    for (let rowNum = firstTileRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      const stagger = (rowNum % 2 === 0) ? 0 : tileWidth / 2;
      for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
        let vGrout;
        
        if (wallType === 'back') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutWidth, tileHeight * 0.95, groutDepth),
            groutMat
          );
          vGrout.position.set(segmentX + offset, y + tileHeight / 2, -GRID.height / 2 + groutDepth / 2);
        } else if (wallType === 'left') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
            groutMat
          );
          vGrout.position.set(-GRID.width / 2 + groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
            groutMat
          );
          vGrout.position.set(GRID.width / 2 - groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
        }
        
        if (vGrout) {
          scene.add(vGrout);
          patterns.push(vGrout);
        }
      }
    }
  }
  
  return patterns;
}

function createWalls(scene, windowMaterialsRef, wallSegmentsRef, doorPositions = [], wallpaperType = 'cream', paintedSegments = []) {
  // Create segmented walls - each segment is 1 tile wide
  // This allows us to remove segments where doors are placed
  // Each segment can have its own wallpaper color
  
  const wallHeight = 3;
  const wallThickness = 0.3;
  const segmentWidth = 1.1;  // Overlap to hide seams between segments
  
  // Get default wallpaper settings
  const defaultWallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const defaultInteriorColor = defaultWallpaper.color;
  const exteriorMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 }); // Warm taupe/stucco
  
  // Helper to get wallpaper for a specific segment
  const getSegmentWallpaper = (wall, position) => {
    const paint = paintedSegments.find(p => p.wall === wall && p.position === position);
    if (paint) {
      return WALLPAPERS[paint.wallpaper] || defaultWallpaper;
    }
    return defaultWallpaper;
  };
  
  // Initialize wall segments storage
  if (wallSegmentsRef) {
    wallSegmentsRef.current = {
      back: [],
      left: [],
      right: [],
      stripes: [], // For stripe pattern overlays
      patterns: [], // For brick/stone/wood pattern meshes
    };
  }
  
  // Helper to check if a door exists at this wall position
  const hasDoorAt = (wall, position) => {
    return doorPositions.some(d => d.wall === wall && Math.abs(d.wallPosition - position) < 0.5);
  };
  
  // Helper to create pattern overlays for a single wall segment
  // segmentPosition is the grid position (x for back wall, z for left/right)
  const createSegmentPatterns = (segmentWallpaper, wallType, segmentX, segmentZ, segmentWidth, segmentPosition) => {
    const patterns = [];
    const pattern = segmentWallpaper.pattern;
    
    // Helper to add userData to pattern mesh for tracking
    const addPatternUserData = (mesh) => {
      if (mesh) {
        mesh.userData = { wallType, segmentPosition, isPattern: true };
      }
      return mesh;
    };
    
    if (pattern === 'stripes' && segmentWallpaper.stripeColor) {
      // Vertical stripes on this segment
      const stripeMat = new THREE.MeshLambertMaterial({ color: segmentWallpaper.stripeColor });
      const stripeWidth = 0.06;
      const stripeDepth = 0.02;
      const stripeSpacing = 0.25;
      
      for (let offset = -0.3; offset <= 0.3; offset += stripeSpacing) {
        let stripe;
        
        if (wallType === 'back') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeWidth, wallHeight - 0.1, stripeDepth),
            stripeMat
          );
          stripe.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + stripeDepth / 2);
        } else if (wallType === 'left') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
            stripeMat
          );
          stripe.position.set(-GRID.width / 2 + stripeDepth / 2, wallHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          stripe = new THREE.Mesh(
            new THREE.BoxGeometry(stripeDepth, wallHeight - 0.1, stripeWidth),
            stripeMat
          );
          stripe.position.set(GRID.width / 2 - stripeDepth / 2, wallHeight / 2, segmentZ + offset);
        }
        
        if (stripe) {
          addPatternUserData(stripe);
          scene.add(stripe);
          patterns.push(stripe);
        }
      }
    }
    
    if (pattern === 'brick') {
      // Horizontal mortar lines for brick pattern
      const mortarMat = new THREE.MeshLambertMaterial({ color: 0xD3D3D3 });
      const mortarHeight = 0.025;
      const mortarDepth = 0.02;
      const brickRowHeight = 0.25;
      
      for (let y = brickRowHeight; y < wallHeight; y += brickRowHeight) {
        let mortar;
        
        if (wallType === 'back') {
          // Back wall: mortar runs along X axis - use slight overlap for seamless look
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 1.05, mortarHeight, mortarDepth),
            mortarMat
          );
          mortar.position.set(segmentX, y, -GRID.height / 2 + mortarDepth / 2);
        } else if (wallType === 'left') {
          // Left wall: mortar runs along Z axis, protrudes along +X
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
            mortarMat
          );
          mortar.position.set(-GRID.width / 2 + mortarDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          // Right wall: mortar runs along Z axis, protrudes along -X
          mortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
            mortarMat
          );
          mortar.position.set(GRID.width / 2 - mortarDepth / 2, y, segmentZ);
        }
        
        if (mortar) {
          addPatternUserData(mortar);
          scene.add(mortar);
          patterns.push(mortar);
        }
      }
      
      // Vertical mortar lines (staggered)
      const verticalSpacing = 0.35;
      let row = 0;
      for (let y = 0; y < wallHeight; y += brickRowHeight) {
        const offsetAmt = (row % 2 === 0) ? 0 : verticalSpacing / 2;
        for (let offset = -0.4 + offsetAmt; offset <= 0.4; offset += verticalSpacing) {
          let vMortar;
          
          if (wallType === 'back') {
            // Back wall: vertical mortar at X offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarHeight, brickRowHeight * 0.9, mortarDepth),
              mortarMat
            );
            vMortar.position.set(segmentX + offset, y + brickRowHeight / 2, -GRID.height / 2 + mortarDepth / 2);
          } else if (wallType === 'left') {
            // Left wall: vertical mortar at Z offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
              mortarMat
            );
            vMortar.position.set(-GRID.width / 2 + mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
          } else if (wallType === 'right') {
            // Right wall: vertical mortar at Z offset
            vMortar = new THREE.Mesh(
              new THREE.BoxGeometry(mortarDepth, brickRowHeight * 0.9, mortarHeight),
              mortarMat
            );
            vMortar.position.set(GRID.width / 2 - mortarDepth / 2, y + brickRowHeight / 2, segmentZ + offset);
          }
          
          if (vMortar) {
            addPatternUserData(vMortar);
            scene.add(vMortar);
            patterns.push(vMortar);
          }
        }
        row++;
      }
    }
    
    if (pattern === 'wood') {
      // Vertical grooves for wood paneling
      const grooveMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
      const grooveWidth = 0.02;
      const grooveDepth = 0.015;
      const grooveSpacing = 0.3;
      
      const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
        let groove;
        
        if (wallType === 'back') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveWidth, wallHeight - 0.1, grooveDepth),
            grooveMat
          );
          groove.position.set(segmentX + offset, wallHeight / 2, -GRID.height / 2 + grooveDepth / 2);
        } else if (wallType === 'left') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
            grooveMat
          );
          groove.position.set(-GRID.width / 2 + grooveDepth / 2, wallHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(grooveDepth, wallHeight - 0.1, grooveWidth),
            grooveMat
          );
          groove.position.set(GRID.width / 2 - grooveDepth / 2, wallHeight / 2, segmentZ + offset);
        }
        
        if (groove) {
          addPatternUserData(groove);
          scene.add(groove);
          patterns.push(groove);
        }
      }
    }
    
    if (pattern === 'stone') {
      // Irregular stone pattern with horizontal and staggered vertical lines
      const stoneMat = new THREE.MeshLambertMaterial({ color: 0x505050 });
      const lineDepth = 0.015;
      const lineWidth = 0.03;
      const rowHeight = 0.5;
      
      // Horizontal lines - use full segment width (with slight overlap) for seamless look
      for (let y = rowHeight; y < wallHeight; y += rowHeight) {
        let hLine;
        
        if (wallType === 'back') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 1.05, lineWidth, lineDepth),
            stoneMat
          );
          hLine.position.set(segmentX, y, -GRID.height / 2 + lineDepth / 2);
        } else if (wallType === 'left') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
            stoneMat
          );
          hLine.position.set(-GRID.width / 2 + lineDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          hLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
            stoneMat
          );
          hLine.position.set(GRID.width / 2 - lineDepth / 2, y, segmentZ);
        }
        
        if (hLine) {
          addPatternUserData(hLine);
          scene.add(hLine);
          patterns.push(hLine);
        }
      }
      
      // Staggered vertical lines
      let row = 0;
      for (let y = 0; y < wallHeight; y += rowHeight) {
        const offsetAmt = (row % 2 === 0) ? 0.15 : -0.15;
        let vLine;
        
        if (wallType === 'back') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineWidth, rowHeight * 0.9, lineDepth),
            stoneMat
          );
          vLine.position.set(segmentX + offsetAmt, y + rowHeight / 2, -GRID.height / 2 + lineDepth / 2);
        } else if (wallType === 'left') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
            stoneMat
          );
          vLine.position.set(-GRID.width / 2 + lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
        } else if (wallType === 'right') {
          vLine = new THREE.Mesh(
            new THREE.BoxGeometry(lineDepth, rowHeight * 0.9, lineWidth),
            stoneMat
          );
          vLine.position.set(GRID.width / 2 - lineDepth / 2, y + rowHeight / 2, segmentZ + offsetAmt);
        }
        
        if (vLine) {
          addPatternUserData(vLine);
          scene.add(vLine);
          patterns.push(vLine);
        }
        row++;
      }
    }
    
    // Subway tile pattern - horizontal rectangular tiles with staggered grout
    if (pattern === 'subway') {
      const groutColor = segmentWallpaper.groutColor || 0xCCCCCC;
      const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
      const groutDepth = 0.015;
      const tileHeight = 0.2;  // Each tile is 0.2 units tall
      const tileWidth = 0.35;  // Slightly smaller tiles that fit better in segment
      const groutWidth = 0.02;
      
      // Horizontal grout lines (slightly smaller than segment to avoid bleed)
      for (let y = tileHeight; y < wallHeight; y += tileHeight) {
        let hGrout;
        
        if (wallType === 'back') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 0.95, groutWidth, groutDepth),
            groutMat
          );
          hGrout.position.set(segmentX, y, -GRID.height / 2 + groutDepth / 2);
        } else if (wallType === 'left') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
            groutMat
          );
          hGrout.position.set(-GRID.width / 2 + groutDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
            groutMat
          );
          hGrout.position.set(GRID.width / 2 - groutDepth / 2, y, segmentZ);
        }
        
        if (hGrout) {
          addPatternUserData(hGrout);
          scene.add(hGrout);
          patterns.push(hGrout);
        }
      }
      
      // Vertical grout lines (staggered subway pattern, using same range as brick)
      let row = 0;
      for (let y = 0; y < wallHeight; y += tileHeight) {
        const stagger = (row % 2 === 0) ? 0 : tileWidth / 2;
        for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
          let vGrout;
          
          if (wallType === 'back') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutWidth, tileHeight * 0.95, groutDepth),
              groutMat
            );
            vGrout.position.set(segmentX + offset, y + tileHeight / 2, -GRID.height / 2 + groutDepth / 2);
          } else if (wallType === 'left') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
              groutMat
            );
            vGrout.position.set(-GRID.width / 2 + groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
          } else if (wallType === 'right') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
              groutMat
            );
            vGrout.position.set(GRID.width / 2 - groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
          }
          
          if (vGrout) {
            addPatternUserData(vGrout);
            scene.add(vGrout);
            patterns.push(vGrout);
          }
        }
        row++;
      }
    }
    
    // Wainscoting pattern - wood paneling on bottom 1/3, solid top, with chair rail
    if (pattern === 'wainscot') {
      const railHeight = wallHeight * 0.35;  // Chair rail at 35% height
      const bottomColor = segmentWallpaper.bottomColor || 0x8B4513;
      const railColor = segmentWallpaper.railColor || 0x5D3A1A;
      const woodMat = new THREE.MeshLambertMaterial({ color: bottomColor });
      const railMat = new THREE.MeshLambertMaterial({ color: railColor });
      const panelDepth = 0.025;
      
      // Bottom wood panel (covers bottom portion)
      let bottomPanel;
      if (wallType === 'back') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.02, railHeight, panelDepth),
          woodMat
        );
        bottomPanel.position.set(segmentX, railHeight / 2, -GRID.height / 2 + panelDepth / 2);
      } else if (wallType === 'left') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
          woodMat
        );
        bottomPanel.position.set(-GRID.width / 2 + panelDepth / 2, railHeight / 2, segmentZ);
      } else if (wallType === 'right') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
          woodMat
        );
        bottomPanel.position.set(GRID.width / 2 - panelDepth / 2, railHeight / 2, segmentZ);
      }
      
      if (bottomPanel) {
        addPatternUserData(bottomPanel);
        scene.add(bottomPanel);
        patterns.push(bottomPanel);
      }
      
      // Vertical grooves in bottom panel
      // Use symmetrical positions for even panels
      const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
        let groove;
        const grooveMat = new THREE.MeshLambertMaterial({ color: railColor });
        
        if (wallType === 'back') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.015, railHeight - 0.1, 0.01),
            grooveMat
          );
          groove.position.set(segmentX + offset, railHeight / 2, -GRID.height / 2 + panelDepth + 0.005);
        } else if (wallType === 'left') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
            grooveMat
          );
          groove.position.set(-GRID.width / 2 + panelDepth + 0.005, railHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
            grooveMat
          );
          groove.position.set(GRID.width / 2 - panelDepth - 0.005, railHeight / 2, segmentZ + offset);
        }
        
        if (groove) {
          addPatternUserData(groove);
          scene.add(groove);
          patterns.push(groove);
        }
      }
      
      // Chair rail molding
      let chairRail;
      const railThickness = 0.06;
      if (wallType === 'back') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, railThickness, panelDepth * 1.5),
          railMat
        );
        chairRail.position.set(segmentX, railHeight, -GRID.height / 2 + panelDepth);
      } else if (wallType === 'left') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
          railMat
        );
        chairRail.position.set(-GRID.width / 2 + panelDepth, railHeight, segmentZ);
      } else if (wallType === 'right') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
          railMat
        );
        chairRail.position.set(GRID.width / 2 - panelDepth, railHeight, segmentZ);
      }
      
      if (chairRail) {
        addPatternUserData(chairRail);
        scene.add(chairRail);
        patterns.push(chairRail);
      }
      
      // Baseboard molding
      let baseboard;
      if (wallType === 'back') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, 0.08, panelDepth * 1.3),
          railMat
        );
        baseboard.position.set(segmentX, 0.04, -GRID.height / 2 + panelDepth);
      } else if (wallType === 'left') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
          railMat
        );
        baseboard.position.set(-GRID.width / 2 + panelDepth, 0.04, segmentZ);
      } else if (wallType === 'right') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
          railMat
        );
        baseboard.position.set(GRID.width / 2 - panelDepth, 0.04, segmentZ);
      }
      
      if (baseboard) {
        addPatternUserData(baseboard);
        scene.add(baseboard);
        patterns.push(baseboard);
      }
    }
    
    // Wainscoting + Subway tile pattern
    if (pattern === 'wainscotTile') {
      const railHeight = wallHeight * 0.35;  // Chair rail at 35% height
      const bottomColor = segmentWallpaper.bottomColor || 0x8B4513;
      const railColor = segmentWallpaper.railColor || 0x5D3A1A;
      const groutColor = segmentWallpaper.groutColor || 0xCCCCCC;
      const woodMat = new THREE.MeshLambertMaterial({ color: bottomColor });
      const railMat = new THREE.MeshLambertMaterial({ color: railColor });
      const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
      const panelDepth = 0.025;
      const groutDepth = 0.015;
      
      // Bottom wood panel
      let bottomPanel;
      if (wallType === 'back') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.02, railHeight, panelDepth),
          woodMat
        );
        bottomPanel.position.set(segmentX, railHeight / 2, -GRID.height / 2 + panelDepth / 2);
      } else if (wallType === 'left') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
          woodMat
        );
        bottomPanel.position.set(-GRID.width / 2 + panelDepth / 2, railHeight / 2, segmentZ);
      } else if (wallType === 'right') {
        bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth, railHeight, segmentWidth * 1.02),
          woodMat
        );
        bottomPanel.position.set(GRID.width / 2 - panelDepth / 2, railHeight / 2, segmentZ);
      }
      
      if (bottomPanel) {
        addPatternUserData(bottomPanel);
        scene.add(bottomPanel);
        patterns.push(bottomPanel);
      }
      
      // Vertical grooves in bottom panel
      // Use symmetrical positions for even panels
      const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
        let groove;
        const grooveMat = new THREE.MeshLambertMaterial({ color: railColor });
        
        if (wallType === 'back') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.015, railHeight - 0.1, 0.01),
            grooveMat
          );
          groove.position.set(segmentX + offset, railHeight / 2, -GRID.height / 2 + panelDepth + 0.005);
        } else if (wallType === 'left') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
            grooveMat
          );
          groove.position.set(-GRID.width / 2 + panelDepth + 0.005, railHeight / 2, segmentZ + offset);
        } else if (wallType === 'right') {
          groove = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, railHeight - 0.1, 0.015),
            grooveMat
          );
          groove.position.set(GRID.width / 2 - panelDepth - 0.005, railHeight / 2, segmentZ + offset);
        }
        
        if (groove) {
          addPatternUserData(groove);
          scene.add(groove);
          patterns.push(groove);
        }
      }
      
      // Chair rail molding
      let chairRail;
      const railThickness = 0.06;
      if (wallType === 'back') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, railThickness, panelDepth * 1.5),
          railMat
        );
        chairRail.position.set(segmentX, railHeight, -GRID.height / 2 + panelDepth);
      } else if (wallType === 'left') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
          railMat
        );
        chairRail.position.set(-GRID.width / 2 + panelDepth, railHeight, segmentZ);
      } else if (wallType === 'right') {
        chairRail = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.5, railThickness, segmentWidth * 1.05),
          railMat
        );
        chairRail.position.set(GRID.width / 2 - panelDepth, railHeight, segmentZ);
      }
      
      if (chairRail) {
        addPatternUserData(chairRail);
        scene.add(chairRail);
        patterns.push(chairRail);
      }
      
      // Baseboard molding
      let baseboard;
      if (wallType === 'back') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, 0.08, panelDepth * 1.3),
          railMat
        );
        baseboard.position.set(segmentX, 0.04, -GRID.height / 2 + panelDepth);
      } else if (wallType === 'left') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
          railMat
        );
        baseboard.position.set(-GRID.width / 2 + panelDepth, 0.04, segmentZ);
      } else if (wallType === 'right') {
        baseboard = new THREE.Mesh(
          new THREE.BoxGeometry(panelDepth * 1.3, 0.08, segmentWidth * 1.05),
          railMat
        );
        baseboard.position.set(GRID.width / 2 - panelDepth, 0.04, segmentZ);
      }
      
      if (baseboard) {
        addPatternUserData(baseboard);
        scene.add(baseboard);
        patterns.push(baseboard);
      }
      
      // Subway tiles ABOVE the chair rail
      const tileHeight = 0.2;
      const tileWidth = 0.35;  // Slightly smaller tiles that fit better
      const groutWidth = 0.02;
      
      // Use absolute row numbers for alignment (same approach as brick)
      const firstTileRow = Math.ceil(railHeight / tileHeight);
      
      // Horizontal grout lines - at absolute Y positions (start at firstTileRow for line above wood)
      for (let rowNum = firstTileRow; rowNum * tileHeight < wallHeight; rowNum++) {
        const y = rowNum * tileHeight;
        let hGrout;
        
        if (wallType === 'back') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(segmentWidth * 0.95, groutWidth, groutDepth),
            groutMat
          );
          hGrout.position.set(segmentX, y, -GRID.height / 2 + groutDepth / 2);
        } else if (wallType === 'left') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
            groutMat
          );
          hGrout.position.set(-GRID.width / 2 + groutDepth / 2, y, segmentZ);
        } else if (wallType === 'right') {
          hGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 0.95),
            groutMat
          );
          hGrout.position.set(GRID.width / 2 - groutDepth / 2, y, segmentZ);
        }
        
        if (hGrout) {
          addPatternUserData(hGrout);
          scene.add(hGrout);
          patterns.push(hGrout);
        }
      }
      
      // Vertical grout lines (use absolute row numbers like brick for alignment)
      for (let rowNum = firstTileRow; rowNum * tileHeight < wallHeight; rowNum++) {
        const y = rowNum * tileHeight;
        const stagger = (rowNum % 2 === 0) ? 0 : tileWidth / 2;
        for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
          let vGrout;
          
          if (wallType === 'back') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutWidth, tileHeight * 0.95, groutDepth),
              groutMat
            );
            vGrout.position.set(segmentX + offset, y + tileHeight / 2, -GRID.height / 2 + groutDepth / 2);
          } else if (wallType === 'left') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
              groutMat
            );
            vGrout.position.set(-GRID.width / 2 + groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
          } else if (wallType === 'right') {
            vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(groutDepth, tileHeight * 0.95, groutWidth),
              groutMat
            );
            vGrout.position.set(GRID.width / 2 - groutDepth / 2, y + tileHeight / 2, segmentZ + offset);
          }
          
          if (vGrout) {
            addPatternUserData(vGrout);
            scene.add(vGrout);
            patterns.push(vGrout);
          }
        }
      }
    }
    
    return patterns;
  };
  
  // Helper to create a wall segment with proper face materials (per-segment color)
  // BoxGeometry face order: +X, -X, +Y, -Y, +Z, -Z (right, left, top, bottom, front, back)
  const createWallSegment = (width, height, depth, x, y, z, wallType, segmentPosition) => {
    const geo = new THREE.BoxGeometry(width, height, depth);
    
    // Get this segment's wallpaper color
    const segmentWallpaper = getSegmentWallpaper(wallType, segmentPosition);
    const interiorMat = new THREE.MeshLambertMaterial({ color: segmentWallpaper.color });
    
    let materials;
    if (wallType === 'back') {
      // Back wall: +Z face is interior (faces into cafe), -Z is exterior
      materials = [
        interiorMat,  // +X (right edge)
        interiorMat,  // -X (left edge)
        interiorMat,  // +Y (top)
        interiorMat,  // -Y (bottom)
        interiorMat,  // +Z (interior - faces into cafe)
        exteriorMat,  // -Z (exterior - faces outside)
      ];
    } else if (wallType === 'left') {
      // Left wall: +X face is interior, -X is exterior
      materials = [
        interiorMat,  // +X (interior - faces into cafe)
        exteriorMat,  // -X (exterior - faces outside)
        interiorMat,  // +Y (top) - cream
        interiorMat,  // -Y (bottom) - cream
        interiorMat,  // +Z (front edge) - cream
        interiorMat,  // -Z (back edge) - cream
      ];
    } else if (wallType === 'right') {
      // Right wall: -X face is interior, +X is exterior
      materials = [
        exteriorMat,  // +X (exterior - faces outside)
        interiorMat,  // -X (interior - faces into cafe)
        interiorMat,  // +Y (top) - cream
        interiorMat,  // -Y (bottom) - cream
        interiorMat,  // +Z (front edge) - cream
        interiorMat,  // -Z (back edge) - cream
      ];
    } else {
      // Default/corner - all interior color
      materials = [interiorMat, interiorMat, interiorMat, interiorMat, interiorMat, interiorMat];
    }
    
    const mesh = new THREE.Mesh(geo, materials);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    // Create pattern overlays for this segment if it has a pattern
    // The segment span is different for each wall type:
    // - Back wall: span is along X (width parameter)
    // - Left/Right walls: span is along Z (depth parameter)
    const segmentX = x;
    const segmentZ = z;
    const segmentSpan = (wallType === 'back') ? width : depth;
    const patternMeshes = createSegmentPatterns(segmentWallpaper, wallType, segmentX, segmentZ, segmentSpan, segmentPosition);
    if (patternMeshes.length > 0 && wallSegmentsRef) {
      wallSegmentsRef.current.patterns.push(...patternMeshes);
    }
    
    return mesh;
  };
  
  // Back wall segments (along X axis, at Z = -GRID.height/2)
  for (let x = 0; x < GRID.width; x++) {
    if (hasDoorAt('back', x)) continue;
    
    const segment = createWallSegment(
      segmentWidth, wallHeight, wallThickness,
      x - GRID.width / 2 + 0.5,
      wallHeight / 2,
      -GRID.height / 2 - wallThickness / 2,
      'back',
      x  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'back', position: x };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.back.push({ position: x, mesh: segment });
    }
  }
  
  // Left wall segments (along Z axis, at X = -GRID.width/2)
  for (let z = 0; z < GRID.height; z++) {
    if (hasDoorAt('left', z)) continue;
    
    const segment = createWallSegment(
      wallThickness, wallHeight, segmentWidth,
      -GRID.width / 2 - wallThickness / 2,
      wallHeight / 2,
      z - GRID.height / 2 + 0.5,
      'left',
      z  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'left', position: z };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.left.push({ position: z, mesh: segment });
    }
  }
  
  // Right wall segments (along Z axis, at X = GRID.width/2)
  for (let z = 0; z < GRID.height; z++) {
    if (hasDoorAt('right', z)) continue;
    
    const segment = createWallSegment(
      wallThickness, wallHeight, segmentWidth,
      GRID.width / 2 + wallThickness / 2,
      wallHeight / 2,
      z - GRID.height / 2 + 0.5,
      'right',
      z  // Pass segment position for per-segment coloring
    );
    segment.userData = { wall: 'right', position: z };
    scene.add(segment);
    
    if (wallSegmentsRef) {
      wallSegmentsRef.current.right.push({ position: z, mesh: segment });
    }
  }
  
  // Corner pieces - use default wallpaper color
  const cornerSize = wallThickness;
  
  // Back-left corner
  const blCorner = createVoxelBox(cornerSize, wallHeight, cornerSize, defaultInteriorColor,
    -GRID.width / 2 - cornerSize / 2, wallHeight / 2, -GRID.height / 2 - cornerSize / 2);
  scene.add(blCorner);
  
  // Back-right corner
  const brCorner = createVoxelBox(cornerSize, wallHeight, cornerSize, defaultInteriorColor,
    GRID.width / 2 + cornerSize / 2, wallHeight / 2, -GRID.height / 2 - cornerSize / 2);
  scene.add(brCorner);
  
  // Pattern overlays are now created per-segment in createWallSegment()
}

// Function to rebuild walls when doors or wallpaper changes
function rebuildWalls(scene, wallSegmentsRef, doorPositions, wallpaperType = 'cream', paintedSegments = []) {
  // Remove all existing wall segments
  if (wallSegmentsRef.current) {
    ['back', 'left', 'right'].forEach(wall => {
      (wallSegmentsRef.current[wall] || []).forEach(seg => {
        if (seg.mesh) scene.remove(seg.mesh);
      });
    });
    
    // Remove stripe overlays
    (wallSegmentsRef.current.stripes || []).forEach(stripe => {
      scene.remove(stripe);
    });
    
    // Remove pattern overlays
    (wallSegmentsRef.current.patterns || []).forEach(pattern => {
      scene.remove(pattern);
    });
  }
  
  // Also remove corner pieces (they have no userData.wall)
  const cornersToRemove = [];
  scene.children.forEach(child => {
    if (child.isMesh && child.geometry?.type === 'BoxGeometry' && !child.userData?.wall) {
      // Check if it looks like a wall corner (small box at wall height)
      if (child.position.y > 1 && child.position.y < 2) {
        const atCorner = (
          (Math.abs(child.position.x - (-GRID.width/2 - 0.15)) < 0.3 || 
           Math.abs(child.position.x - (GRID.width/2 + 0.15)) < 0.3) &&
          Math.abs(child.position.z - (-GRID.height/2 - 0.15)) < 0.3
        );
        if (atCorner) cornersToRemove.push(child);
      }
    }
  });
  cornersToRemove.forEach(c => scene.remove(c));
  
  // Recreate walls with new door positions, wallpaper, and painted segments
  createWalls(scene, null, wallSegmentsRef, doorPositions, wallpaperType, paintedSegments);
}

function createTree(scene, x, z, scale = 1) {
  // Trunk
  const trunkGeo = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 1.5 * scale, 8);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.set(x, 0.75 * scale, z);
  trunk.castShadow = true;
  scene.add(trunk);
  
  // Foliage layers (stacked cones for a fuller look)
  const foliageColors = [0x228B22, 0x2E8B2E, 0x32CD32];
  for (let i = 0; i < 3; i++) {
    const foliageGeo = new THREE.ConeGeometry(1.2 * scale - i * 0.2, 1.5 * scale - i * 0.2, 8);
    const foliageMat = new THREE.MeshLambertMaterial({ color: foliageColors[i % 3] });
    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
    foliage.position.set(x, 1.8 * scale + i * 0.6 * scale, z);
    foliage.castShadow = true;
    scene.add(foliage);
  }
}

function createBush(scene, x, z, scale = 1) {
  const bushGeo = new THREE.SphereGeometry(0.5 * scale, 8, 6);
  const bushMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
  const bush = new THREE.Mesh(bushGeo, bushMat);
  bush.position.set(x, 0.3 * scale, z);
  bush.scale.y = 0.7; // Flatten a bit
  bush.castShadow = true;
  scene.add(bush);
}

// ============================================
// DECORATION CREATION FUNCTIONS
// ============================================
function createDecoration(type, x, z, rotation = 0) {
  const group = new THREE.Group();
  group.position.set(x, 0, z);
  
  // Apply rotation (0-3 maps to 0, 90, 180, 270 degrees)
  group.rotation.y = rotation * (Math.PI / 2);
  
  switch (type) {
    case 'plant': {
      // Terracotta pot
      const potGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.25, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.125;
      pot.castShadow = true;
      group.add(pot);
      
      // Plant leaves (small sphere cluster)
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 5), leafMat);
      leaf1.position.set(0, 0.35, 0);
      leaf1.castShadow = true;
      group.add(leaf1);
      const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 5), leafMat);
      leaf2.position.set(0.08, 0.45, 0.05);
      group.add(leaf2);
      const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 5), leafMat);
      leaf3.position.set(-0.06, 0.42, -0.04);
      group.add(leaf3);
      break;
    }
    
    case 'plant2': {
      // Tall plant in white pot
      const potGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.35, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xF5F5DC });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.175;
      pot.castShadow = true;
      group.add(pot);
      
      // Tall leaves
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      for (let i = 0; i < 5; i++) {
        const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.5, 4), leafMat);
        const angle = (i / 5) * Math.PI * 2;
        leaf.position.set(Math.cos(angle) * 0.08, 0.55, Math.sin(angle) * 0.08);
        leaf.rotation.x = -0.2;
        leaf.rotation.z = Math.cos(angle) * 0.3;
        group.add(leaf);
      }
      break;
    }
    
    case 'cactus': {
      // Small pot
      const potGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.1;
      pot.castShadow = true;
      group.add(pot);
      
      // Cactus body
      const cactusMat = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8), cactusMat);
      body.position.y = 0.4;
      body.castShadow = true;
      group.add(body);
      
      // Arms
      const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.2, 6), cactusMat);
      arm1.position.set(0.12, 0.45, 0);
      arm1.rotation.z = -0.8;
      group.add(arm1);
      break;
    }
    
    case 'floorLamp': {
      // Base
      const baseGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 8);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.025;
      group.add(base);
      
      // Pole
      const poleGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.2, 8);
      const poleMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = 0.65;
      group.add(pole);
      
      // Lamp shade - cream colored, glows at night
      const shadeGeo = new THREE.CylinderGeometry(0.15, 0.28, 0.35, 8, 1, true);
      const shadeMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFF8DC, 
        emissive: 0xFFAA55,
        emissiveIntensity: 0.1, // Slight glow even during day
        side: THREE.DoubleSide
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.position.y = 1.2;
      group.add(shade);
      group.userData.lampMaterial = shadeMat; // Store for night glow
      
      // Bulb inside
      const bulbGeo = new THREE.SphereGeometry(0.08, 8, 6);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xFFFFAA,
        emissive: 0xFFDD88,
        emissiveIntensity: 0.2
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.y = 1.1;
      group.add(bulb);
      group.userData.bulbMaterial = bulbMat;
      
      // Point light for the lamp
      const lampLight = new THREE.PointLight(0xFFAA55, 0.3, 5, 2); // Slight glow during day
      lampLight.position.y = 1.1;
      group.add(lampLight);
      group.userData.lampLight = lampLight; // Store for night intensity
      break;
    }
    
    case 'rug': {
      // Oval rug - raised above floor tiles (tiles are 0.1 thick at y=0)
      const rugGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.04, 16);
      const rugMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.y = 0.08; // Above the 0.1 thick floor tiles
      rug.scale.set(1, 1, 0.6); // Make oval
      rug.receiveShadow = true;
      group.add(rug);
      
      // Inner pattern
      const innerGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.045, 16);
      const innerMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.position.y = 0.09;
      inner.scale.set(1, 1, 0.6);
      group.add(inner);
      break;
    }
    
    case 'window': {
      // Window frame
      const frameGeo = new THREE.BoxGeometry(1.5, 1.5, 0.1);
      const frameMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.trim });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.castShadow = true;
      group.add(frame);
      
      // Window glass (sky blue, slightly inset)
      const glassGeo = new THREE.BoxGeometry(1.2, 1.2, 0.08);
      const glassMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.window });
      const glass = new THREE.Mesh(glassGeo, glassMat);
      glass.position.y = 1.8;
      glass.position.z = 0.02;
      group.add(glass);
      
      // Window cross dividers
      const dividerMat = new THREE.MeshLambertMaterial({ color: COLORS.walls.trim });
      const hDivider = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.12), dividerMat);
      hDivider.position.set(0, 1.8, 0.03);
      group.add(hDivider);
      const vDivider = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.2, 0.12), dividerMat);
      vDivider.position.set(0, 1.8, 0.03);
      group.add(vDivider);
      break;
    }
    
    case 'picture': {
      // Wall art frame - larger and more visible
      const frameGeo = new THREE.BoxGeometry(1.0, 0.8, 0.08);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.castShadow = true;
      group.add(frame);
      
      // Canvas with random color for variety
      const colors = [0x87CEEB, 0xFFB6C1, 0x98FB98, 0xDDA0DD, 0xF0E68C, 0xFFDAB9];
      const canvasGeo = new THREE.BoxGeometry(0.8, 0.6, 0.09);
      const canvasMat = new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
      const canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.y = 1.8;
      group.add(canvas);
      break;
    }
    
    case 'flowers': {
      // Vase
      const vaseGeo = new THREE.CylinderGeometry(0.12, 0.08, 0.3, 8);
      const vaseMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const vase = new THREE.Mesh(vaseGeo, vaseMat);
      vase.position.y = 0.15;
      group.add(vase);
      
      // Flowers
      const flowerColors = [0xFF69B4, 0xFFB6C1, 0xFF1493, 0xFFC0CB, 0xFFFFFF];
      for (let i = 0; i < 7; i++) {
        const flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 6, 5),
          new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] })
        );
        const angle = (i / 7) * Math.PI * 2;
        const radius = 0.1 + Math.random() * 0.08;
        flower.position.set(Math.cos(angle) * radius, 0.4 + Math.random() * 0.15, Math.sin(angle) * radius);
        group.add(flower);
      }
      // Stems
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      for (let i = 0; i < 5; i++) {
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.2, 4), stemMat);
        stem.position.set((Math.random() - 0.5) * 0.1, 0.35, (Math.random() - 0.5) * 0.1);
        group.add(stem);
      }
      break;
    }
    
    case 'tulips': {
      // Pink pot
      const potGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.1;
      group.add(pot);
      
      // Tulip flowers
      const tulipMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * 0.06;
        const z = Math.sin(angle) * 0.06;
        // Stem
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.35, 4), stemMat);
        stem.position.set(x, 0.35, z);
        group.add(stem);
        // Tulip head
        const tulip = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), tulipMat);
        tulip.scale.set(0.8, 1.2, 0.8);
        tulip.position.set(x, 0.55, z);
        group.add(tulip);
      }
      break;
    }
    
    case 'sunflower': {
      // Terracotta pot
      const potGeo = new THREE.CylinderGeometry(0.18, 0.14, 0.25, 8);
      const potMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.125;
      group.add(pot);
      
      // Tall stem
      const stemGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.8, 6);
      const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.6;
      group.add(stem);
      
      // Sunflower head
      const centerGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.06, 12);
      const centerMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const center = new THREE.Mesh(centerGeo, centerMat);
      center.position.y = 1.0;
      center.rotation.x = Math.PI / 8;
      group.add(center);
      
      // Petals
      const petalMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      for (let i = 0; i < 12; i++) {
        const petal = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.18), petalMat);
        const angle = (i / 12) * Math.PI * 2;
        petal.position.set(Math.cos(angle) * 0.2, 1.0, Math.sin(angle) * 0.2);
        petal.rotation.y = -angle;
        petal.rotation.x = Math.PI / 8;
        group.add(petal);
      }
      break;
    }
    
    case 'candleTable': {
      // Small round table
      const tableGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.04, 12);
      const tableMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const table = new THREE.Mesh(tableGeo, tableMat);
      table.position.y = 0.5;
      group.add(table);
      
      // Table leg
      const legGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.5, 8);
      const leg = new THREE.Mesh(legGeo, tableMat);
      leg.position.y = 0.25;
      group.add(leg);
      
      // Candle
      const candleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 8);
      const candleMat = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
      const candle = new THREE.Mesh(candleGeo, candleMat);
      candle.position.y = 0.6;
      group.add(candle);
      
      // Flame
      const flameGeo = new THREE.ConeGeometry(0.02, 0.06, 6);
      const flameMat = new THREE.MeshStandardMaterial({ color: 0xFFA500, emissive: 0xFF6600, emissiveIntensity: 0.8 });
      const flame = new THREE.Mesh(flameGeo, flameMat);
      flame.position.y = 0.7;
      group.add(flame);
      
      // Light
      const candleLight = new THREE.PointLight(0xFFA500, 0.5, 3, 2);
      candleLight.position.y = 0.7;
      group.add(candleLight);
      break;
    }
    
    case 'fairyLights': {
      // String of lights on wall
      const wireMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const wireGeo = new THREE.BoxGeometry(1.5, 0.02, 0.02);
      const wire = new THREE.Mesh(wireGeo, wireMat);
      wire.position.y = 2.0;
      group.add(wire);
      
      // Bulbs along the wire with actual glow
      const bulbColors = [0xFF69B4, 0x87CEEB, 0x98FB98, 0xFFD700, 0xDDA0DD];
      for (let i = 0; i < 7; i++) {
        const color = bulbColors[i % bulbColors.length];
        const bulbGeo = new THREE.SphereGeometry(0.04, 6, 5);
        const bulbMat = new THREE.MeshStandardMaterial({ 
          color: color,
          emissive: color,
          emissiveIntensity: 0.8
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        const xPos = -0.6 + i * 0.2;
        const yPos = 2.0 - Math.sin(i * 0.5) * 0.1;
        bulb.position.set(xPos, yPos, 0.05);
        group.add(bulb);
        
        // Add actual point light every other bulb for performance
        if (i % 2 === 0) {
          const light = new THREE.PointLight(color, 0.4, 2.5, 2);
          light.position.set(xPos, yPos, 0.1);
          group.add(light);
        }
      }
      
      // Add a soft ambient fill light for overall glow
      const ambientGlow = new THREE.PointLight(0xFFB6C1, 0.3, 4, 2);
      ambientGlow.position.set(0, 1.8, 0.3);
      group.add(ambientGlow);
      break;
    }
    
    case 'pinkRug': {
      // Pink heart-inspired rug
      const rugGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.04, 16);
      const rugMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.y = 0.08;
      group.add(rug);
      
      // Inner pattern (white)
      const innerGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.045, 16);
      const innerMat = new THREE.MeshLambertMaterial({ color: 0xFFF0F5 });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.position.y = 0.09;
      group.add(inner);
      break;
    }
    
    case 'clock': {
      // Wall clock
      const clockGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 24);
      const clockMat = new THREE.MeshLambertMaterial({ color: 0xFFFAF0 });
      const clock = new THREE.Mesh(clockGeo, clockMat);
      clock.position.y = 1.8;
      clock.rotation.x = Math.PI / 2;
      group.add(clock);
      
      // Frame
      const frameGeo = new THREE.TorusGeometry(0.35, 0.04, 8, 24);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.8;
      frame.position.z = 0.04;
      group.add(frame);
      
      // Clock hands
      const handMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const hourHand = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.15, 0.02), handMat);
      hourHand.position.set(0, 1.85, 0.06);
      hourHand.rotation.z = 0.5;
      group.add(hourHand);
      const minHand = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.22, 0.02), handMat);
      minHand.position.set(0, 1.9, 0.06);
      minHand.rotation.z = -0.8;
      group.add(minHand);
      break;
    }
    
    case 'heart': {
      // Heart-shaped wall decoration
      const heartMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      // Left lobe
      const lobe1 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), heartMat);
      lobe1.position.set(-0.12, 1.9, 0);
      group.add(lobe1);
      // Right lobe
      const lobe2 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), heartMat);
      lobe2.position.set(0.12, 1.9, 0);
      group.add(lobe2);
      // Bottom point
      const point = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.35, 12), heartMat);
      point.position.set(0, 1.6, 0);
      point.rotation.z = Math.PI;
      group.add(point);
      break;
    }
    
    case 'star': {
      // Star decoration
      const starMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 });
      // Center
      const center = new THREE.Mesh(new THREE.OctahedronGeometry(0.15, 0), starMat);
      center.position.y = 1.8;
      center.rotation.z = Math.PI / 4;
      group.add(center);
      // Points
      for (let i = 0; i < 5; i++) {
        const point = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.25, 6), starMat);
        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
        point.position.set(Math.cos(angle) * 0.2, 1.8 + Math.sin(angle) * 0.2, 0.05);
        point.rotation.z = angle + Math.PI / 2;
        group.add(point);
      }
      break;
    }
    
    case 'menu': {
      // Menu board
      const boardGeo = new THREE.BoxGeometry(0.9, 1.1, 0.06);
      const boardMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const board = new THREE.Mesh(boardGeo, boardMat);
      board.position.y = 1.7;
      group.add(board);
      
      // Frame
      const frameGeo = new THREE.BoxGeometry(1.0, 1.2, 0.04);
      const frameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = 1.7;
      frame.position.z = -0.02;
      group.add(frame);
      
      // Text lines (simplified as white bars)
      const lineMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 5; i++) {
        const line = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.06, 0.01), lineMat);
        line.position.set(0, 2.0 - i * 0.18, 0.04);
        group.add(line);
      }
      break;
    }
    
    case 'jukebox': {
      // Main body
      const bodyGeo = new THREE.BoxGeometry(0.6, 1.2, 0.5);
      const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.6;
      group.add(body);
      
      // Curved top
      const topGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16, 1, false, 0, Math.PI);
      const topMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = 1.35;
      top.rotation.z = Math.PI / 2;
      top.rotation.y = Math.PI / 2;
      group.add(top);
      
      // Display window
      const windowGeo = new THREE.BoxGeometry(0.4, 0.3, 0.1);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, emissive: 0x4169E1, emissiveIntensity: 0.3 });
      const window = new THREE.Mesh(windowGeo, windowMat);
      window.position.set(0, 0.9, 0.25);
      group.add(window);
      
      // Buttons
      const buttonMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 3; i++) {
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.05, 8), buttonMat);
        btn.position.set(-0.12 + i * 0.12, 0.5, 0.28);
        btn.rotation.x = Math.PI / 2;
        group.add(btn);
      }
      break;
    }
    
    case 'aquarium': {
      // Glass tank
      const tankGeo = new THREE.BoxGeometry(0.8, 0.6, 0.4);
      const tankMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });
      const tank = new THREE.Mesh(tankGeo, tankMat);
      tank.position.y = 0.5;
      group.add(tank);
      
      // Water inside
      const waterGeo = new THREE.BoxGeometry(0.75, 0.5, 0.35);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, transparent: true, opacity: 0.5 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.position.y = 0.45;
      group.add(water);
      
      // Fish (simple colored spheres)
      const fishColors = [0xFF6347, 0xFFD700, 0xFF69B4];
      for (let i = 0; i < 3; i++) {
        const fish = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), new THREE.MeshLambertMaterial({ color: fishColors[i] }));
        fish.scale.set(1.5, 1, 0.6);
        fish.position.set(-0.2 + i * 0.2, 0.4 + Math.random() * 0.2, (Math.random() - 0.5) * 0.2);
        group.add(fish);
      }
      
      // Stand
      const standGeo = new THREE.BoxGeometry(0.85, 0.2, 0.45);
      const standMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.1;
      group.add(stand);
      break;
    }
    
    case 'fountain': {
      // Basin
      const basinGeo = new THREE.CylinderGeometry(0.4, 0.35, 0.15, 16);
      const basinMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const basin = new THREE.Mesh(basinGeo, basinMat);
      basin.position.y = 0.075;
      group.add(basin);
      
      // Water in basin
      const waterGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.1, 16);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, transparent: true, opacity: 0.6 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.position.y = 0.1;
      group.add(water);
      
      // Center spout
      const spoutGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8);
      const spout = new THREE.Mesh(spoutGeo, basinMat);
      spout.position.y = 0.35;
      group.add(spout);
      
      // Water jet (cone)
      const jetGeo = new THREE.ConeGeometry(0.05, 0.3, 8);
      const jetMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7 });
      const jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.y = 0.65;
      group.add(jet);
      break;
    }
    
    case 'cakeDisplay': {
      // Glass dome stand
      const standGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.1, 16);
      const standMat = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.05;
      group.add(stand);
      
      // Cake
      const cakeGeo = new THREE.CylinderGeometry(0.2, 0.22, 0.2, 16);
      const cakeMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const cake = new THREE.Mesh(cakeGeo, cakeMat);
      cake.position.y = 0.2;
      group.add(cake);
      
      // Frosting top
      const frostGeo = new THREE.CylinderGeometry(0.22, 0.2, 0.05, 16);
      const frostMat = new THREE.MeshLambertMaterial({ color: 0xFFF0F5 });
      const frost = new THREE.Mesh(frostGeo, frostMat);
      frost.position.y = 0.32;
      group.add(frost);
      
      // Cherry on top
      const cherryGeo = new THREE.SphereGeometry(0.04, 8, 6);
      const cherryMat = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const cherry = new THREE.Mesh(cherryGeo, cherryMat);
      cherry.position.y = 0.38;
      group.add(cherry);
      
      // Glass dome
      const domeGeo = new THREE.SphereGeometry(0.3, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
      const domeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.25 });
      const dome = new THREE.Mesh(domeGeo, domeMat);
      dome.position.y = 0.1;
      group.add(dome);
      break;
    }
    
    case 'gumball': {
      // Base
      const baseGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.15, 12);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0xDC143C });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.075;
      group.add(base);
      
      // Stand
      const standGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.3, 8);
      const standMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.3;
      group.add(stand);
      
      // Globe
      const globeGeo = new THREE.SphereGeometry(0.25, 16, 12);
      const globeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.4 });
      const globe = new THREE.Mesh(globeGeo, globeMat);
      globe.position.y = 0.7;
      group.add(globe);
      
      // Gumballs inside
      const gumColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF69B4, 0xFFA500];
      for (let i = 0; i < 15; i++) {
        const gum = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 6, 5),
          new THREE.MeshLambertMaterial({ color: gumColors[i % gumColors.length] })
        );
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const r = 0.1 + Math.random() * 0.1;
        gum.position.set(
          Math.sin(phi) * Math.cos(theta) * r,
          0.65 + Math.cos(phi) * r,
          Math.sin(phi) * Math.sin(theta) * r
        );
        group.add(gum);
      }
      
      // Top cap
      const capGeo = new THREE.CylinderGeometry(0.12, 0.15, 0.1, 12);
      const cap = new THREE.Mesh(capGeo, baseMat);
      cap.position.y = 0.98;
      group.add(cap);
      break;
    }
    
    case 'teddyBear': {
      const bearMat = new THREE.MeshLambertMaterial({ color: 0xD2691E });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 8), bearMat);
      body.position.y = 0.2;
      body.scale.set(1, 1.1, 0.9);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), bearMat);
      head.position.y = 0.45;
      group.add(head);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), bearMat);
      ear1.position.set(-0.1, 0.55, 0);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), bearMat);
      ear2.position.set(0.1, 0.55, 0);
      group.add(ear2);
      // Snout
      const snoutMat = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), snoutMat);
      snout.position.set(0, 0.42, 0.1);
      group.add(snout);
      // Nose
      const noseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), noseMat);
      nose.position.set(0, 0.44, 0.15);
      group.add(nose);
      // Eyes
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      eye1.position.set(-0.05, 0.48, 0.1);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      eye2.position.set(0.05, 0.48, 0.1);
      group.add(eye2);
      // Arms
      const arm1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 5), bearMat);
      arm1.scale.set(1, 1.5, 1);
      arm1.position.set(-0.18, 0.25, 0.05);
      group.add(arm1);
      const arm2 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 5), bearMat);
      arm2.scale.set(1, 1.5, 1);
      arm2.position.set(0.18, 0.25, 0.05);
      group.add(arm2);
      break;
    }
    
    case 'balloons': {
      // String anchor
      const anchorGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 8);
      const anchorMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const anchor = new THREE.Mesh(anchorGeo, anchorMat);
      anchor.position.y = 0.025;
      group.add(anchor);
      
      // Balloons
      const balloonColors = [0xFF69B4, 0x87CEEB, 0x98FB98, 0xFFD700, 0xDDA0DD];
      const stringMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      for (let i = 0; i < 5; i++) {
        // String
        const string = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.8 + i * 0.1, 4), stringMat);
        const xOff = (i - 2) * 0.15;
        string.position.set(xOff, 0.4 + i * 0.05, 0);
        group.add(string);
        
        // Balloon
        const balloon = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 10, 8),
          new THREE.MeshLambertMaterial({ color: balloonColors[i] })
        );
        balloon.scale.set(1, 1.3, 1);
        balloon.position.set(xOff, 0.9 + i * 0.1, 0);
        group.add(balloon);
      }
      break;
    }
    
    case 'giftBox': {
      // Box
      const boxGeo = new THREE.BoxGeometry(0.3, 0.25, 0.3);
      const boxMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = 0.125;
      group.add(box);
      
      // Ribbon vertical
      const ribbonMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.26, 0.31), ribbonMat);
      ribbon1.position.y = 0.125;
      group.add(ribbon1);
      
      // Ribbon horizontal
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(0.31, 0.05, 0.31), ribbonMat);
      ribbon2.position.y = 0.2;
      group.add(ribbon2);
      
      // Bow
      const bow1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), ribbonMat);
      bow1.scale.set(1.5, 0.8, 0.5);
      bow1.position.set(-0.08, 0.3, 0);
      group.add(bow1);
      const bow2 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), ribbonMat);
      bow2.scale.set(1.5, 0.8, 0.5);
      bow2.position.set(0.08, 0.3, 0);
      group.add(bow2);
      const bowCenter = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), ribbonMat);
      bowCenter.position.set(0, 0.3, 0);
      group.add(bowCenter);
      break;
    }
    
    // ===== PLUSHIE COLLECTION =====
    
    case 'catPlush': {
      const catMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 }); // Orange tabby
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), catMat);
      body.position.y = 0.15;
      body.scale.set(1, 0.9, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), catMat);
      head.position.set(0, 0.32, 0.08);
      group.add(head);
      // Ears
      const earMat = new THREE.MeshLambertMaterial({ color: 0xFFB347 });
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 4), earMat);
      ear1.position.set(-0.07, 0.42, 0.08);
      ear1.rotation.z = -0.2;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 4), earMat);
      ear2.position.set(0.07, 0.42, 0.08);
      ear2.rotation.z = 0.2;
      group.add(ear2);
      // Face
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), noseMat);
      nose.position.set(0, 0.3, 0.18);
      group.add(nose);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.34, 0.16);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.34, 0.16);
      group.add(eye2);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.015, 0.2, 6), catMat);
      tail.position.set(0, 0.15, -0.18);
      tail.rotation.x = 0.5;
      group.add(tail);
      break;
    }
    
    case 'dogPlush': {
      const dogMat = new THREE.MeshLambertMaterial({ color: 0xD2691E }); // Brown
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.16, 10, 8), dogMat);
      body.position.y = 0.16;
      body.scale.set(1.1, 0.9, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 10, 8), dogMat);
      head.position.set(0, 0.34, 0.06);
      group.add(head);
      // Snout
      const snoutMat = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), snoutMat);
      snout.scale.set(1, 0.7, 1.2);
      snout.position.set(0, 0.3, 0.15);
      group.add(snout);
      // Ears (floppy)
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), dogMat);
      ear1.scale.set(0.5, 1, 0.3);
      ear1.position.set(-0.12, 0.35, 0.02);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), dogMat);
      ear2.scale.set(0.5, 1, 0.3);
      ear2.position.set(0.12, 0.35, 0.02);
      group.add(ear2);
      // Nose
      const noseMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), noseMat);
      nose.position.set(0, 0.31, 0.2);
      group.add(nose);
      // Eyes
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      eye1.position.set(-0.045, 0.37, 0.14);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      eye2.position.set(0.045, 0.37, 0.14);
      group.add(eye2);
      break;
    }
    
    case 'bunnyPlush': {
      const bunnyMat = new THREE.MeshLambertMaterial({ color: 0xFFFAFA }); // White
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), bunnyMat);
      body.position.y = 0.14;
      body.scale.set(0.9, 1, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), bunnyMat);
      head.position.set(0, 0.32, 0.05);
      group.add(head);
      // Long ears (using cylinders with rounded ends via spheres)
      const earMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      // Left ear
      const ear1 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.18, 8), bunnyMat);
      ear1.position.set(-0.05, 0.5, 0);
      ear1.rotation.z = -0.15;
      group.add(ear1);
      const ear1Top = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), bunnyMat);
      ear1Top.position.set(-0.05, 0.59, -0.01);
      group.add(ear1Top);
      const ear1Inner = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.12, 6), earMat);
      ear1Inner.position.set(-0.05, 0.5, 0.02);
      ear1Inner.rotation.z = -0.15;
      group.add(ear1Inner);
      // Right ear
      const ear2 = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.18, 8), bunnyMat);
      ear2.position.set(0.05, 0.5, 0);
      ear2.rotation.z = 0.15;
      group.add(ear2);
      const ear2Top = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 5), bunnyMat);
      ear2Top.position.set(0.05, 0.59, -0.01);
      group.add(ear2Top);
      const ear2Inner = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.12, 6), earMat);
      ear2Inner.position.set(0.05, 0.5, 0.02);
      ear2Inner.rotation.z = 0.15;
      group.add(ear2Inner);
      // Face
      const noseMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), noseMat);
      nose.position.set(0, 0.3, 0.14);
      group.add(nose);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.035, 0.34, 0.12);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.035, 0.34, 0.12);
      group.add(eye2);
      // Fluffy tail
      const tail = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), bunnyMat);
      tail.position.set(0, 0.12, -0.15);
      group.add(tail);
      break;
    }
    
    case 'pandaPlush': {
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
      const blackMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.16, 10, 8), whiteMat);
      body.position.y = 0.16;
      body.scale.set(1, 0.95, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), whiteMat);
      head.position.set(0, 0.36, 0.04);
      group.add(head);
      // Ears (black)
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), blackMat);
      ear1.position.set(-0.1, 0.48, 0);
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), blackMat);
      ear2.position.set(0.1, 0.48, 0);
      group.add(ear2);
      // Eye patches (black)
      const patch1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), blackMat);
      patch1.scale.set(1.2, 0.9, 0.5);
      patch1.position.set(-0.055, 0.38, 0.1);
      group.add(patch1);
      const patch2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), blackMat);
      patch2.scale.set(1.2, 0.9, 0.5);
      patch2.position.set(0.055, 0.38, 0.1);
      group.add(patch2);
      // Eyes (white dots on patches)
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeWhite);
      eye1.position.set(-0.05, 0.38, 0.13);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeWhite);
      eye2.position.set(0.05, 0.38, 0.13);
      group.add(eye2);
      // Nose
      const nose = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), blackMat);
      nose.position.set(0, 0.33, 0.13);
      group.add(nose);
      break;
    }
    
    case 'penguinPlush': {
      const blackMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
      const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), blackMat);
      body.position.y = 0.16;
      body.scale.set(0.85, 1.1, 0.75);
      group.add(body);
      // White belly
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), whiteMat);
      belly.position.set(0, 0.14, 0.05);
      belly.scale.set(0.8, 1, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), blackMat);
      head.position.set(0, 0.32, 0);
      group.add(head);
      // White face
      const face = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), whiteMat);
      face.position.set(0, 0.3, 0.06);
      face.scale.set(1.2, 0.8, 0.5);
      group.add(face);
      // Beak
      const beak = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.05, 6), orangeMat);
      beak.position.set(0, 0.29, 0.1);
      beak.rotation.x = Math.PI / 2;
      group.add(beak);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeMat);
      eye1.position.set(-0.03, 0.33, 0.08);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 5), eyeMat);
      eye2.position.set(0.03, 0.33, 0.08);
      group.add(eye2);
      // Feet
      const foot1 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.06), orangeMat);
      foot1.position.set(-0.05, 0.01, 0.04);
      group.add(foot1);
      const foot2 = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.06), orangeMat);
      foot2.position.set(0.05, 0.01, 0.04);
      group.add(foot2);
      break;
    }
    
    case 'unicornPlush': {
      const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFAFA });
      const pinkMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const goldMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), whiteMat);
      body.position.y = 0.15;
      body.scale.set(1.1, 0.9, 0.8);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), whiteMat);
      head.position.set(0, 0.32, 0.08);
      group.add(head);
      // Horn (golden)
      const horn = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.15, 8), goldMat);
      horn.position.set(0, 0.45, 0.08);
      horn.rotation.x = -0.1;
      group.add(horn);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), whiteMat);
      ear1.position.set(-0.06, 0.42, 0.04);
      ear1.rotation.z = -0.3;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), whiteMat);
      ear2.position.set(0.06, 0.42, 0.04);
      ear2.rotation.z = 0.3;
      group.add(ear2);
      // Mane (rainbow-ish pink/purple)
      const maneMat = new THREE.MeshLambertMaterial({ color: 0xDDA0DD });
      for (let i = 0; i < 5; i++) {
        const mane = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 5), i % 2 === 0 ? pinkMat : maneMat);
        mane.position.set(0, 0.38 - i * 0.04, -0.02 - i * 0.02);
        group.add(mane);
      }
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.34, 0.15);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.34, 0.15);
      group.add(eye2);
      // Tail (fluffy rainbow)
      const tail = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 6), pinkMat);
      tail.scale.set(0.6, 1, 0.6);
      tail.position.set(0, 0.12, -0.18);
      group.add(tail);
      break;
    }
    
    case 'pigPlush': {
      const pinkMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
      const darkPink = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), pinkMat);
      body.position.y = 0.15;
      body.scale.set(1.1, 0.9, 0.9);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), pinkMat);
      head.position.set(0, 0.32, 0.06);
      group.add(head);
      // Snout
      const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.04, 8), darkPink);
      snout.position.set(0, 0.28, 0.15);
      snout.rotation.x = Math.PI / 2;
      group.add(snout);
      // Nostrils
      const nostrilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const nostril1 = new THREE.Mesh(new THREE.SphereGeometry(0.01, 4, 4), nostrilMat);
      nostril1.position.set(-0.02, 0.28, 0.17);
      group.add(nostril1);
      const nostril2 = new THREE.Mesh(new THREE.SphereGeometry(0.01, 4, 4), nostrilMat);
      nostril2.position.set(0.02, 0.28, 0.17);
      group.add(nostril2);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.06, 4), pinkMat);
      ear1.position.set(-0.08, 0.42, 0.02);
      ear1.rotation.z = -0.5;
      ear1.rotation.x = 0.3;
      group.add(ear1);
      const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.06, 4), pinkMat);
      ear2.position.set(0.08, 0.42, 0.02);
      ear2.rotation.z = 0.5;
      ear2.rotation.x = 0.3;
      group.add(ear2);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.04, 0.35, 0.13);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.04, 0.35, 0.13);
      group.add(eye2);
      // Curly tail
      const tail = new THREE.Mesh(new THREE.TorusGeometry(0.03, 0.01, 6, 8, Math.PI * 1.5), pinkMat);
      tail.position.set(0, 0.15, -0.16);
      tail.rotation.y = Math.PI / 2;
      group.add(tail);
      break;
    }
    
    case 'frogPlush': {
      const greenMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const lightGreen = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), greenMat);
      body.position.y = 0.12;
      body.scale.set(1.1, 0.8, 0.9);
      group.add(body);
      // Belly
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), lightGreen);
      belly.position.set(0, 0.1, 0.05);
      belly.scale.set(0.9, 0.7, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 8), greenMat);
      head.position.set(0, 0.24, 0.04);
      head.scale.set(1.1, 0.9, 1);
      group.add(head);
      // Big eyes (bulging)
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const eyeBall1 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), eyeWhite);
      eyeBall1.position.set(-0.06, 0.32, 0.08);
      group.add(eyeBall1);
      const eyeBall2 = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 6), eyeWhite);
      eyeBall2.position.set(0.06, 0.32, 0.08);
      group.add(eyeBall2);
      const pupilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const pupil1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil1.position.set(-0.06, 0.32, 0.12);
      group.add(pupil1);
      const pupil2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil2.position.set(0.06, 0.32, 0.12);
      group.add(pupil2);
      // Smile
      const smile = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.008, 6, 8, Math.PI), pupilMat);
      smile.position.set(0, 0.2, 0.1);
      smile.rotation.x = Math.PI;
      group.add(smile);
      break;
    }
    
    case 'duckPlush': {
      const yellowMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), yellowMat);
      body.position.y = 0.14;
      body.scale.set(1, 0.9, 0.85);
      group.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), yellowMat);
      head.position.set(0, 0.3, 0.06);
      group.add(head);
      // Beak
      const beak = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.025, 0.08), orangeMat);
      beak.position.set(0, 0.27, 0.14);
      group.add(beak);
      // Eyes
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye1.position.set(-0.035, 0.33, 0.12);
      group.add(eye1);
      const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 5), eyeMat);
      eye2.position.set(0.035, 0.33, 0.12);
      group.add(eye2);
      // Wing bumps
      const wing1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), yellowMat);
      wing1.scale.set(0.5, 0.8, 1);
      wing1.position.set(-0.12, 0.14, 0);
      group.add(wing1);
      const wing2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 5), yellowMat);
      wing2.scale.set(0.5, 0.8, 1);
      wing2.position.set(0.12, 0.14, 0);
      group.add(wing2);
      break;
    }
    
    case 'owlPlush': {
      const brownMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const tanMat = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 8), brownMat);
      body.position.y = 0.16;
      body.scale.set(0.9, 1.1, 0.8);
      group.add(body);
      // Belly pattern
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.09, 10, 8), tanMat);
      belly.position.set(0, 0.14, 0.06);
      belly.scale.set(0.9, 1, 0.5);
      group.add(belly);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 8), brownMat);
      head.position.set(0, 0.34, 0.02);
      group.add(head);
      // Ear tufts
      const tuft1 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), brownMat);
      tuft1.position.set(-0.08, 0.45, 0);
      tuft1.rotation.z = -0.2;
      group.add(tuft1);
      const tuft2 = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 4), brownMat);
      tuft2.position.set(0.08, 0.45, 0);
      tuft2.rotation.z = 0.2;
      group.add(tuft2);
      // Big eyes
      const eyeWhite = new THREE.MeshLambertMaterial({ color: 0xFFFFE0 });
      const eyeBall1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), eyeWhite);
      eyeBall1.position.set(-0.045, 0.36, 0.1);
      group.add(eyeBall1);
      const eyeBall2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), eyeWhite);
      eyeBall2.position.set(0.045, 0.36, 0.1);
      group.add(eyeBall2);
      const pupilMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const pupil1 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil1.position.set(-0.045, 0.36, 0.13);
      group.add(pupil1);
      const pupil2 = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 5), pupilMat);
      pupil2.position.set(0.045, 0.36, 0.13);
      group.add(pupil2);
      // Beak
      const beakMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      const beak = new THREE.Mesh(new THREE.ConeGeometry(0.02, 0.04, 4), beakMat);
      beak.position.set(0, 0.32, 0.12);
      beak.rotation.x = Math.PI / 2;
      group.add(beak);
      break;
    }
    
    default:
      break;
  }
  
  return group;
}

// Create 3D divider models - short barriers that block pathfinding
function createDivider(type, x, z, rotation = 0) {
  const group = new THREE.Group();
  group.position.set(x, 0, z);
  group.rotation.y = rotation * (Math.PI / 2); // 0 or 90 degrees
  
  switch (type) {
    case 'ropeStanchion': {
      // Two posts with velvet rope between them - full tile width
      const postMat = new THREE.MeshLambertMaterial({ color: 0xB8860B }); // Gold posts
      const ropeMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Dark red rope
      
      // Left post (at edge of tile)
      const post1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.7, 8), postMat);
      post1.position.set(-0.45, 0.35, 0);
      post1.castShadow = true;
      group.add(post1);
      
      // Post top ball
      const ball1 = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6), postMat);
      ball1.position.set(-0.45, 0.72, 0);
      group.add(ball1);
      
      // Right post (at edge of tile)
      const post2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.7, 8), postMat);
      post2.position.set(0.45, 0.35, 0);
      post2.castShadow = true;
      group.add(post2);
      
      // Post top ball
      const ball2 = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6), postMat);
      ball2.position.set(0.45, 0.72, 0);
      group.add(ball2);
      
      // Rope (full width)
      const ropeGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 8);
      const rope = new THREE.Mesh(ropeGeo, ropeMat);
      rope.position.set(0, 0.55, 0);
      rope.rotation.z = Math.PI / 2;
      group.add(rope);
      
      // Rope sag (small sphere in middle for visual sag effect)
      const sag = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 5), ropeMat);
      sag.position.set(0, 0.50, 0);
      group.add(sag);
      break;
    }
    
    case 'lowRailing': {
      // Simple wooden railing - full tile width, taller
      const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      
      // Two posts at tile edges
      const post1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.65, 0.08), woodMat);
      post1.position.set(-0.46, 0.325, 0);
      post1.castShadow = true;
      group.add(post1);
      
      const post2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.65, 0.08), woodMat);
      post2.position.set(0.46, 0.325, 0);
      post2.castShadow = true;
      group.add(post2);
      
      // Top rail (full width)
      const topRail = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.07, 0.07), woodMat);
      topRail.position.set(0, 0.62, 0);
      topRail.castShadow = true;
      group.add(topRail);
      
      // Middle rail
      const midRail = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.05, 0.05), woodMat);
      midRail.position.set(0, 0.35, 0);
      group.add(midRail);
      
      // Bottom rail
      const bottomRail = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.05, 0.05), woodMat);
      bottomRail.position.set(0, 0.12, 0);
      group.add(bottomRail);
      break;
    }
    
    case 'planterDivider': {
      // Long planter box with greenery - full tile width, taller
      const boxMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const greenMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      
      // Planter box (full tile width)
      const box = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.35, 0.35), boxMat);
      box.position.set(0, 0.175, 0);
      box.castShadow = true;
      group.add(box);
      
      // Soil
      const soilMat = new THREE.MeshLambertMaterial({ color: 0x3D2817 });
      const soil = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.06, 0.27), soilMat);
      soil.position.set(0, 0.38, 0);
      group.add(soil);
      
      // Plants - small bushes across full width
      for (let i = -0.35; i <= 0.35; i += 0.175) {
        const bush = new THREE.Mesh(new THREE.SphereGeometry(0.14, 6, 5), greenMat);
        bush.position.set(i, 0.52, 0);
        bush.scale.set(1, 0.9, 0.9);
        group.add(bush);
      }
      
      // Some variety - taller plants
      const tallPlant1 = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.3, 6), greenMat);
      tallPlant1.position.set(-0.2, 0.65, 0);
      group.add(tallPlant1);
      
      const tallPlant2 = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.3, 6), greenMat);
      tallPlant2.position.set(0.25, 0.65, 0);
      group.add(tallPlant2);
      break;
    }
    
    default:
      break;
  }
  
  return group;
}

// Create pattern overlays for a door header (wall section above door)
// This is separate from wall segment patterns because headers have different dimensions
function createDoorHeaderPatterns(scene, wallpaperType, wall, wallPosition) {
  const wallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const pattern = wallpaper.pattern;
  if (!pattern) return []; // No pattern for solid colors
  
  const patterns = [];
  const doorHeight = 2.2;
  const wallHeight = 3;
  const headerHeight = wallHeight - doorHeight; // 0.8
  const segmentWidth = 1.0; // Header is 1 unit wide
  
  // Calculate header center position based on wall
  let headerX, headerZ, zOffset, xOffset;
  if (wall === 'back') {
    headerX = wallPosition - GRID.width / 2 + 0.5;
    headerZ = -GRID.height / 2;
    zOffset = 0.02; // Pattern protrudes into cafe
    xOffset = 0;
  } else if (wall === 'left') {
    headerX = -GRID.width / 2;
    headerZ = wallPosition - GRID.height / 2 + 0.5;
    xOffset = 0.02;
    zOffset = 0;
  } else if (wall === 'right') {
    headerX = GRID.width / 2;
    headerZ = wallPosition - GRID.height / 2 + 0.5;
    xOffset = -0.02;
    zOffset = 0;
  }
  
  if (pattern === 'stripes' && wallpaper.stripeColor) {
    const stripeMat = new THREE.MeshLambertMaterial({ color: wallpaper.stripeColor });
    const stripeWidth = 0.06;
    const stripeDepth = 0.02;
    const stripeSpacing = 0.25;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    const stripeHeight = wallHeight - headerMinY - 0.05;
    const stripeY = headerMinY + stripeHeight / 2;
    
    for (let offset = -0.3; offset <= 0.3; offset += stripeSpacing) {
      let stripe;
      
      if (wall === 'back') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeWidth, stripeHeight, stripeDepth),
          stripeMat
        );
        stripe.position.set(headerX + offset, stripeY, headerZ + zOffset);
      } else if (wall === 'left') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, stripeHeight, stripeWidth),
          stripeMat
        );
        stripe.position.set(headerX + xOffset, stripeY, headerZ + offset);
      } else if (wall === 'right') {
        stripe = new THREE.Mesh(
          new THREE.BoxGeometry(stripeDepth, stripeHeight, stripeWidth),
          stripeMat
        );
        stripe.position.set(headerX + xOffset, stripeY, headerZ + offset);
      }
      
      if (stripe) {
        scene.add(stripe);
        patterns.push(stripe);
      }
    }
  }
  
  if (pattern === 'brick') {
    const mortarMat = new THREE.MeshLambertMaterial({ color: 0xD3D3D3 });
    const mortarHeight = 0.025;
    const mortarDepth = 0.02;
    const brickRowHeight = 0.25;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    
    // Horizontal mortar lines - use same absolute Y grid as wall segments
    // Wall segments place mortar at: brickRowHeight, 2*brickRowHeight, 3*brickRowHeight...
    // Find first mortar line that's above our minimum Y
    const firstRow = Math.ceil(headerMinY / brickRowHeight);
    for (let rowNum = firstRow; rowNum * brickRowHeight < wallHeight; rowNum++) {
      const y = rowNum * brickRowHeight;
      let mortar;
      
      if (wall === 'back') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, mortarHeight, mortarDepth),
          mortarMat
        );
        mortar.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        mortar = new THREE.Mesh(
          new THREE.BoxGeometry(mortarDepth, mortarHeight, segmentWidth * 1.05),
          mortarMat
        );
        mortar.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (mortar) {
        scene.add(mortar);
        patterns.push(mortar);
      }
    }
    
    // Vertical mortar lines - use same absolute Y grid and row stagger as wall segments
    const verticalSpacing = 0.35;
    const firstVertRow = Math.ceil(headerMinY / brickRowHeight);
    for (let rowNum = firstVertRow; rowNum * brickRowHeight < wallHeight; rowNum++) {
      const y = rowNum * brickRowHeight;
      const vHeight = Math.min(brickRowHeight * 0.9, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger pattern based on absolute row number (same as wall segments)
      const offsetAmt = (rowNum % 2 === 0) ? 0 : verticalSpacing / 2;
      for (let offset = -0.4 + offsetAmt; offset <= 0.4; offset += verticalSpacing) {
        let vMortar;
        
        if (wall === 'back') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarHeight, vHeight, mortarDepth),
            mortarMat
          );
          vMortar.position.set(headerX + offset, y + vHeight / 2, headerZ + zOffset);
        } else if (wall === 'left') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, vHeight, mortarHeight),
            mortarMat
          );
          vMortar.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        } else if (wall === 'right') {
          vMortar = new THREE.Mesh(
            new THREE.BoxGeometry(mortarDepth, vHeight, mortarHeight),
            mortarMat
          );
          vMortar.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        }
        
        if (vMortar) {
          scene.add(vMortar);
          patterns.push(vMortar);
        }
      }
    }
  }
  
  if (pattern === 'wood') {
    const grooveMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 });
    const grooveWidth = 0.02;
    const grooveDepth = 0.015;
    const grooveSpacing = 0.3;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    const grooveHeight = wallHeight - headerMinY - 0.05;
    const grooveY = headerMinY + grooveHeight / 2;
    
    const groovePositions = [-0.4, -0.13, 0.13, 0.4];
      for (const offset of groovePositions) {
      let groove;
      
      if (wall === 'back') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveWidth, grooveHeight, grooveDepth),
          grooveMat
        );
        groove.position.set(headerX + offset, grooveY, headerZ + zOffset);
      } else if (wall === 'left') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, grooveHeight, grooveWidth),
          grooveMat
        );
        groove.position.set(headerX + xOffset, grooveY, headerZ + offset);
      } else if (wall === 'right') {
        groove = new THREE.Mesh(
          new THREE.BoxGeometry(grooveDepth, grooveHeight, grooveWidth),
          grooveMat
        );
        groove.position.set(headerX + xOffset, grooveY, headerZ + offset);
      }
      
      if (groove) {
        scene.add(groove);
        patterns.push(groove);
      }
    }
  }
  
  if (pattern === 'stone') {
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x505050 });
    const lineDepth = 0.015;
    const lineWidth = 0.03;
    const rowHeight = 0.5;
    const headerMinY = doorHeight + 0.15; // Buffer to clear door frame
    
    // Horizontal lines - use full width (with slight overlap) for seamless look
    const firstRow = Math.ceil(headerMinY / rowHeight);
    for (let rowNum = firstRow; rowNum * rowHeight < wallHeight; rowNum++) {
      const y = rowNum * rowHeight;
      let hLine;
      
      if (wall === 'back') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, lineWidth, lineDepth),
          stoneMat
        );
        hLine.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        hLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, lineWidth, segmentWidth * 1.05),
          stoneMat
        );
        hLine.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (hLine) {
        scene.add(hLine);
        patterns.push(hLine);
      }
    }
    
    // Staggered vertical lines - use same absolute row numbers for stagger
    const firstVertRow = Math.ceil(headerMinY / rowHeight);
    for (let rowNum = firstVertRow; rowNum * rowHeight < wallHeight; rowNum++) {
      const y = rowNum * rowHeight;
      const vHeight = Math.min(rowHeight * 0.9, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger based on absolute row number (same as wall segments)
      const offsetAmt = (rowNum % 2 === 0) ? 0.15 : -0.15;
      let vLine;
      
      if (wall === 'back') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineWidth, vHeight, lineDepth),
          stoneMat
        );
        vLine.position.set(headerX + offsetAmt, y + vHeight / 2, headerZ + zOffset);
      } else if (wall === 'left') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, vHeight, lineWidth),
          stoneMat
        );
        vLine.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offsetAmt);
      } else if (wall === 'right') {
        vLine = new THREE.Mesh(
          new THREE.BoxGeometry(lineDepth, vHeight, lineWidth),
          stoneMat
        );
        vLine.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offsetAmt);
      }
      
      if (vLine) {
        scene.add(vLine);
        patterns.push(vLine);
      }
    }
  }
  
  // Subway tile pattern for door header
  if (pattern === 'subway') {
    const groutColor = wallpaper.groutColor || 0xCCCCCC;
    const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
    const groutDepth = 0.015;
    const tileHeight = 0.2;
    const tileWidth = 0.35;
    const groutWidth = 0.02;
    const headerMinY = doorHeight + 0.15;
    
    // Horizontal grout lines - use same absolute Y grid as wall segments
    const firstRow = Math.ceil(headerMinY / tileHeight);
    for (let rowNum = firstRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      let hGrout;
      
      if (wall === 'back') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, groutWidth, groutDepth),
          groutMat
        );
        hGrout.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 1.05),
          groutMat
        );
        hGrout.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 1.05),
          groutMat
        );
        hGrout.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (hGrout) {
        scene.add(hGrout);
        patterns.push(hGrout);
      }
    }
    
    // Vertical grout lines - use same absolute Y grid and row stagger as wall segments
    const firstVertRow = Math.ceil(headerMinY / tileHeight);
    for (let rowNum = firstVertRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      const vHeight = Math.min(tileHeight * 0.95, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger pattern based on absolute row number (same as wall segments)
      const stagger = (rowNum % 2 === 0) ? 0 : tileWidth / 2;
      for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
        let vGrout;
        
        if (wall === 'back') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutWidth, vHeight, groutDepth),
            groutMat
          );
          vGrout.position.set(headerX + offset, y + vHeight / 2, headerZ + zOffset);
        } else if (wall === 'left') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, vHeight, groutWidth),
            groutMat
          );
          vGrout.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        } else if (wall === 'right') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, vHeight, groutWidth),
            groutMat
          );
          vGrout.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        }
        
        if (vGrout) {
          scene.add(vGrout);
          patterns.push(vGrout);
        }
      }
    }
  }
  
  // Wainscoting pattern for door header (only solid color above, since wood panel is below door)
  // The header is above the door, so it's in the "upper" section - no wood panel needed
  if (pattern === 'wainscot') {
    // No pattern needed - wainscot above door is just solid color (the top section)
    // The chair rail is below the door height, so nothing to add here
  }
  
  // Wainscot + Tile pattern for door header (subway tiles above the door)
  if (pattern === 'wainscotTile') {
    const groutColor = wallpaper.groutColor || 0xCCCCCC;
    const groutMat = new THREE.MeshLambertMaterial({ color: groutColor });
    const groutDepth = 0.015;
    const tileHeight = 0.2;
    const tileWidth = 0.35;
    const groutWidth = 0.02;
    const headerMinY = doorHeight + 0.15;
    // For wainscotTile, tiles are above rail which is at 35% = 1.05m
    // Door is 2.2m so header is definitely above rail - show tiles
    
    // Horizontal grout lines - use same absolute Y grid as wall segments
    const firstRow = Math.ceil(headerMinY / tileHeight);
    for (let rowNum = firstRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      let hGrout;
      
      if (wall === 'back') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(segmentWidth * 1.05, groutWidth, groutDepth),
          groutMat
        );
        hGrout.position.set(headerX, y, headerZ + zOffset);
      } else if (wall === 'left') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 1.05),
          groutMat
        );
        hGrout.position.set(headerX + xOffset, y, headerZ);
      } else if (wall === 'right') {
        hGrout = new THREE.Mesh(
          new THREE.BoxGeometry(groutDepth, groutWidth, segmentWidth * 1.05),
          groutMat
        );
        hGrout.position.set(headerX + xOffset, y, headerZ);
      }
      
      if (hGrout) {
        scene.add(hGrout);
        patterns.push(hGrout);
      }
    }
    
    // Vertical grout lines - use same absolute Y grid and row stagger as wall segments
    const firstVertRow = Math.ceil(headerMinY / tileHeight);
    for (let rowNum = firstVertRow; rowNum * tileHeight < wallHeight; rowNum++) {
      const y = rowNum * tileHeight;
      const vHeight = Math.min(tileHeight * 0.95, wallHeight - y - 0.05);
      if (vHeight <= 0) continue;
      
      // Stagger pattern based on absolute row number (same as wall segments)
      const stagger = (rowNum % 2 === 0) ? 0 : tileWidth / 2;
      for (let offset = -0.4 + stagger; offset <= 0.4; offset += tileWidth) {
        let vGrout;
        
        if (wall === 'back') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutWidth, vHeight, groutDepth),
            groutMat
          );
          vGrout.position.set(headerX + offset, y + vHeight / 2, headerZ + zOffset);
        } else if (wall === 'left') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, vHeight, groutWidth),
            groutMat
          );
          vGrout.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        } else if (wall === 'right') {
          vGrout = new THREE.Mesh(
            new THREE.BoxGeometry(groutDepth, vHeight, groutWidth),
            groutMat
          );
          vGrout.position.set(headerX + xOffset, y + vHeight / 2, headerZ + offset);
        }
        
        if (vGrout) {
          scene.add(vGrout);
          patterns.push(vGrout);
        }
      }
    }
  }
  
  return patterns;
}

// Create a door for wall placement
function createDoor(type, wall, wallPosition, wallpaperType = 'cream') {
  const group = new THREE.Group();
  const doorType = DOORS[type] || DOORS.basicDoor;
  
  // Get wallpaper color for header
  const wallpaper = WALLPAPERS[wallpaperType] || WALLPAPERS.cream;
  const interiorColor = wallpaper.color;
  
  const frameMat = new THREE.MeshLambertMaterial({ color: doorType.frameColor });
  const doorMat = new THREE.MeshLambertMaterial({ 
    color: doorType.doorColor,
    transparent: doorType.isGlass || false,
    opacity: doorType.isGlass ? 0.4 : 1,
    side: doorType.isGlass ? THREE.DoubleSide : THREE.FrontSide,
  });
  // Slightly darker shade for panel insets (solid doors only)
  const panelMat = new THREE.MeshLambertMaterial({ 
    color: new THREE.Color(doorType.doorColor).multiplyScalar(0.8).getHex(),
  });
  
  // Door dimensions
  const doorWidth = 0.85;
  const doorHeight = 2.2;
  const frameWidth = 0.07;
  const frameDepth = 0.32;
  const wallThickness = 0.3;
  const wallHeight = 3;
  const panelThickness = 0.05;
  
  // Wall section above door - dual-sided like wall segments, using wallpaper color
  const headerHeight = wallHeight - doorHeight;
  const interiorWallMat = new THREE.MeshLambertMaterial({ color: interiorColor });
  const exteriorWallMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 }); // Taupe exterior
  
  // Header with dual-sided materials (wallpaper color inside, taupe outside)
  // BoxGeometry face order: +X, -X, +Y, -Y, +Z, -Z
  const headerMaterials = [
    interiorWallMat, // +X edge
    interiorWallMat, // -X edge  
    interiorWallMat, // +Y top
    interiorWallMat, // -Y bottom
    interiorWallMat, // +Z interior (faces into cafe)
    exteriorWallMat, // -Z exterior (faces outside)
  ];
  const header = new THREE.Mesh(
    new THREE.BoxGeometry(1.0, headerHeight, wallThickness),
    headerMaterials
  );
  header.position.set(0, doorHeight + headerHeight / 2, 0);
  header.castShadow = true;
  // Add userData so the header can be painted like a wall segment
  header.userData = { wall: wall, position: wallPosition, isDoorHeader: true };
  group.add(header);
  
  // Door frame - simple clean frame around opening
  // Left frame
  const leftFrame = new THREE.Mesh(
    new THREE.BoxGeometry(frameWidth, doorHeight, frameDepth),
    frameMat
  );
  leftFrame.position.set(-doorWidth / 2 - frameWidth / 2, doorHeight / 2, 0);
  leftFrame.castShadow = true;
  group.add(leftFrame);
  
  // Right frame
  const rightFrame = new THREE.Mesh(
    new THREE.BoxGeometry(frameWidth, doorHeight, frameDepth),
    frameMat
  );
  rightFrame.position.set(doorWidth / 2 + frameWidth / 2, doorHeight / 2, 0);
  rightFrame.castShadow = true;
  group.add(rightFrame);
  
  // Side wall fillers - dual-sided to fill gaps between door frame and wall segments
  // The wall opening is 1.0 wide, door + frame is ~0.99, so we need thin fillers
  const fillerWidth = (1.0 - doorWidth - frameWidth * 2) / 2 + 0.02; // Slight overlap
  const fillerMaterials = [
    interiorWallMat, // +X
    interiorWallMat, // -X
    interiorWallMat, // +Y
    interiorWallMat, // -Y
    interiorWallMat, // +Z interior
    exteriorWallMat, // -Z exterior
  ];
  
  // Left filler
  const leftFiller = new THREE.Mesh(
    new THREE.BoxGeometry(fillerWidth, doorHeight, wallThickness),
    fillerMaterials
  );
  leftFiller.position.set(-0.5 + fillerWidth / 2, doorHeight / 2, 0);
  group.add(leftFiller);
  
  // Right filler
  const rightFiller = new THREE.Mesh(
    new THREE.BoxGeometry(fillerWidth, doorHeight, wallThickness),
    fillerMaterials
  );
  rightFiller.position.set(0.5 - fillerWidth / 2, doorHeight / 2, 0);
  group.add(rightFiller);
  
  // Top frame
  const topFrame = new THREE.Mesh(
    new THREE.BoxGeometry(doorWidth + frameWidth * 2, frameWidth, frameDepth),
    frameMat
  );
  topFrame.position.set(0, doorHeight + frameWidth / 2, 0);
  topFrame.castShadow = true;
  group.add(topFrame);
  
  // Bottom threshold
  const threshold = new THREE.Mesh(
    new THREE.BoxGeometry(doorWidth + frameWidth * 2, 0.03, frameDepth + 0.05),
    frameMat
  );
  threshold.position.set(0, 0.015, 0.025);
  group.add(threshold);
  
  // Handle material (silver/chrome)
  const handleMat = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
  
  // Create door panel
  const doorPivot = new THREE.Group();
  doorPivot.name = 'doorPivot';
  doorPivot.position.set(-doorWidth / 2, 0, 0);  // Pivot at left edge of door opening
  
  // Panel should fill the frame opening completely
  const panelWidth = doorWidth;  // Full width - no gap
  const panelHeight = doorHeight - 0.05;
  
  // Main door slab
  const slab = new THREE.Mesh(
    new THREE.BoxGeometry(panelWidth, panelHeight, panelThickness),
    doorMat
  );
  slab.position.set(panelWidth / 2, panelHeight / 2 + 0.025, 0);
  slab.castShadow = true;
  doorPivot.add(slab);
  
  if (doorType.isGlass) {
    // Glass door - horizontal bar handle on BOTH sides
    // Front handle (inside cafe)
    const frontHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, 0.02, 0.03),
      handleMat
    );
    frontHandle.position.set(panelWidth - 0.18, doorHeight / 2, panelThickness / 2 + 0.02);
    doorPivot.add(frontHandle);
    
    // Back handle (outside cafe)
    const backHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, 0.02, 0.03),
      handleMat
    );
    backHandle.position.set(panelWidth - 0.18, doorHeight / 2, -panelThickness / 2 - 0.02);
    doorPivot.add(backHandle);
    
    // Handle mounting brackets
    const bracketMat = handleMat;
    const bracket1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.05), bracketMat);
    bracket1.position.set(panelWidth - 0.08, doorHeight / 2, panelThickness / 2 + 0.01);
    doorPivot.add(bracket1);
    const bracket2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.05), bracketMat);
    bracket2.position.set(panelWidth - 0.28, doorHeight / 2, panelThickness / 2 + 0.01);
    doorPivot.add(bracket2);
    
  } else {
    // Solid door - add decorative panels
    const insetPanelWidth = panelWidth - 0.1;
    const topPanelHeight = panelHeight * 0.4;
    const bottomPanelHeight = panelHeight * 0.3;
    
    // Top inset panel
    const topPanel = new THREE.Mesh(
      new THREE.BoxGeometry(insetPanelWidth, topPanelHeight, 0.01),
      panelMat
    );
    topPanel.position.set(panelWidth / 2, panelHeight - topPanelHeight / 2 - 0.15, panelThickness / 2 + 0.005);
    doorPivot.add(topPanel);
    
    // Bottom inset panel
    const bottomPanel = new THREE.Mesh(
      new THREE.BoxGeometry(insetPanelWidth, bottomPanelHeight, 0.01),
      panelMat
    );
    bottomPanel.position.set(panelWidth / 2, bottomPanelHeight / 2 + 0.15, panelThickness / 2 + 0.005);
    doorPivot.add(bottomPanel);
    
    // Vertical bar push handle (like commercial doors)
    const handleLength = 0.3;
    const pushHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.02, handleLength, 0.03),
      handleMat
    );
    pushHandle.position.set(panelWidth - 0.1, doorHeight / 2, panelThickness / 2 + 0.025);
    doorPivot.add(pushHandle);
    
    // Handle mounting brackets
    const topBracket = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.02, 0.04), handleMat);
    topBracket.position.set(panelWidth - 0.1, doorHeight / 2 + handleLength / 2 - 0.02, panelThickness / 2 + 0.01);
    doorPivot.add(topBracket);
    const bottomBracket = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.02, 0.04), handleMat);
    bottomBracket.position.set(panelWidth - 0.1, doorHeight / 2 - handleLength / 2 + 0.02, panelThickness / 2 + 0.01);
    doorPivot.add(bottomBracket);
  }
  
  group.add(doorPivot);
  
  // Welcome mat
  const matGeo = new THREE.BoxGeometry(0.5, 0.02, 0.3);
  const matMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
  const welcomeMat = new THREE.Mesh(matGeo, matMat);
  welcomeMat.position.set(0, 0.01, 0.3);
  group.add(welcomeMat);
  
  // Store door state for animation
  group.userData.isOpen = false;
  group.userData.openAmount = 0; // 0 = closed, 1 = fully open
  group.userData.isDouble = doorType.isDouble || false;
  
  // Position based on wall - must match exactly where wall segments are placed
  // Wall segments are at: x/z position + wallThickness/2 offset from grid edge
  let worldX, worldZ, rotation;
  
  if (wall === 'back') {
    worldX = wallPosition - GRID.width / 2 + 0.5;
    worldZ = -GRID.height / 2 - wallThickness / 2;  // Match wall segment Z position
    rotation = 0;
  } else if (wall === 'left') {
    worldX = -GRID.width / 2 - wallThickness / 2;   // Match wall segment X position
    worldZ = wallPosition - GRID.height / 2 + 0.5;
    rotation = Math.PI / 2;
  } else if (wall === 'right') {
    worldX = GRID.width / 2 + wallThickness / 2;    // Match wall segment X position
    worldZ = wallPosition - GRID.height / 2 + 0.5;
    rotation = -Math.PI / 2;
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = rotation;
  
  // Store grid position for proximity checks
  group.userData.wall = wall;
  group.userData.wallPosition = wallPosition;
  
  return group;
}

// Helper function to get door entry point in grid coordinates
function getDoorEntryPoint(door) {
  let gridX, gridZ;
  
  if (door.wall === 'back') {
    gridX = door.wallPosition;
    gridZ = 0; // Just inside the back wall
  } else if (door.wall === 'left') {
    gridX = 0; // Just inside the left wall
    gridZ = door.wallPosition;
  } else if (door.wall === 'right') {
    gridX = GRID.width - 1; // Just inside the right wall
    gridZ = door.wallPosition;
  }
  
  return { gridX, gridZ };
}

function createLampPost(scene, x, z, lampMaterialsRef, streetLightsRef) {
  // Pole
  const poleGeo = new THREE.CylinderGeometry(0.05, 0.08, 2.5, 8);
  const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.set(x, 1.25, z);
  scene.add(pole);
  
  // Lamp head - use StandardMaterial for dynamic emissive
  const lampGeo = new THREE.SphereGeometry(0.2, 8, 6);
  const lampMat = new THREE.MeshStandardMaterial({ 
    color: 0xFFF8DC, 
    emissive: 0xFFE4B5, 
    emissiveIntensity: 0.2 
  });
  const lamp = new THREE.Mesh(lampGeo, lampMat);
  lamp.position.set(x, 2.6, z);
  scene.add(lamp);
  if (lampMaterialsRef) lampMaterialsRef.current.push(lampMat);
  
  // Add actual point light for the lamp
  const pointLight = new THREE.PointLight(0xFFE4B5, 0, 15, 1); // intensity 0 initially, range 15, decay 1
  pointLight.position.set(x, 2.4, z);
  scene.add(pointLight);
  if (streetLightsRef) streetLightsRef.current.push(pointLight);
}

function createBench(scene, x, z, rotation = 0) {
  const group = new THREE.Group();
  
  // Seat
  const seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
  const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const seat = new THREE.Mesh(seatGeo, woodMat);
  seat.position.y = 0.4;
  group.add(seat);
  
  // Back
  const backGeo = new THREE.BoxGeometry(1.2, 0.5, 0.08);
  const back = new THREE.Mesh(backGeo, woodMat);
  back.position.set(0, 0.65, -0.18);
  group.add(back);
  
  // Legs
  const legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
  const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  [-0.5, 0.5].forEach(xOff => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(xOff, 0.2, 0);
    group.add(leg);
  });
  
  group.position.set(x, 0, z);
  group.rotation.y = rotation;
  group.castShadow = true;
  scene.add(group);
}

function createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef) {
  // Large grass ground
  const grassGeo = new THREE.PlaneGeometry(200, 200);
  const grassMat = new THREE.MeshStandardMaterial({ 
    color: 0x6CB06C,
    roughness: 0.9,
    metalness: 0
  });
  const grass = new THREE.Mesh(grassGeo, grassMat);
  grass.rotation.x = -Math.PI / 2;
  grass.position.y = -0.05;
  grass.receiveShadow = true;
  scene.add(grass);
  
  // Distant hills/mountains in the background
  const hillColors = [0x5B8C5B, 0x4A7A4A, 0x3D6B3D];
  
  // Back hills (behind kitchen)
  const hill1 = new THREE.Mesh(
    new THREE.ConeGeometry(15, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill1.position.set(-20, 2, -35);
  hill1.scale.y = 0.5;
  scene.add(hill1);
  
  const hill2 = new THREE.Mesh(
    new THREE.ConeGeometry(20, 12, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill2.position.set(5, 4, -40);
  hill2.scale.y = 0.5;
  scene.add(hill2);
  
  const hill3 = new THREE.Mesh(
    new THREE.ConeGeometry(18, 10, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[2] })
  );
  hill3.position.set(25, 3, -38);
  hill3.scale.y = 0.5;
  scene.add(hill3);
  
  // Side hills
  const hill4 = new THREE.Mesh(
    new THREE.ConeGeometry(12, 7, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[0] })
  );
  hill4.position.set(-35, 2, 0);
  hill4.scale.y = 0.5;
  scene.add(hill4);
  
  const hill5 = new THREE.Mesh(
    new THREE.ConeGeometry(14, 8, 8),
    new THREE.MeshLambertMaterial({ color: hillColors[1] })
  );
  hill5.position.set(35, 2.5, -5);
  hill5.scale.y = 0.5;
  scene.add(hill5);
  
  // Roads - horizontal road in front of cafe
  const roadMat = new THREE.MeshStandardMaterial({ 
    color: 0x3a3a3a,
    roughness: 0.95,
    metalness: 0
  });
  const frontRoad = new THREE.Mesh(new THREE.PlaneGeometry(100, 4), roadMat);
  frontRoad.rotation.x = -Math.PI / 2;
  frontRoad.position.set(0, -0.03, GRID.height / 2 + 4);
  frontRoad.receiveShadow = true;
  scene.add(frontRoad);
  
  // Road markings
  const markingMat = new THREE.MeshStandardMaterial({ 
    color: 0xDDDDDD,
    roughness: 0.8,
    metalness: 0
  });
  for (let i = -45; i < 45; i += 4) {
    const marking = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), markingMat);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(i, -0.02, GRID.height / 2 + 4);
    scene.add(marking);
  }
  
  // Side road
  const sideRoad = new THREE.Mesh(new THREE.PlaneGeometry(4, 60), roadMat);
  sideRoad.rotation.x = -Math.PI / 2;
  sideRoad.position.set(-GRID.width / 2 - 4, -0.03, 0);
  sideRoad.receiveShadow = true;
  scene.add(sideRoad);
  
  // Sidewalks - use StandardMaterial with high roughness to avoid glowing
  const sidewalkMat = new THREE.MeshStandardMaterial({ 
    color: 0x909090, // Darker gray
    roughness: 0.9,  // Very matte, no reflection
    metalness: 0
  });
  
  // Front sidewalk
  const frontSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(GRID.width + 4, 2), sidewalkMat);
  frontSidewalk.rotation.x = -Math.PI / 2;
  frontSidewalk.position.set(0, -0.04, GRID.height / 2 + 1.5);
  frontSidewalk.receiveShadow = true;
  scene.add(frontSidewalk);
  
  // Left sidewalk
  const leftSidewalk = new THREE.Mesh(new THREE.PlaneGeometry(2, GRID.height + 4), sidewalkMat);
  leftSidewalk.rotation.x = -Math.PI / 2;
  leftSidewalk.position.set(-GRID.width / 2 - 1.5, -0.04, 0);
  leftSidewalk.receiveShadow = true;
  scene.add(leftSidewalk);
  
  // === CAFE EXTERIOR ===
  // Wall segments now have dual-sided materials - no additional exterior needed
  // Foundation and caps removed for cleaner look
  
  // === PARK BEHIND CAFE (kitchen side) ===
  
  // Pond behind the cafe
  const pondGeo = new THREE.CircleGeometry(3, 16);
  const pondMat = new THREE.MeshLambertMaterial({ color: 0x4A90D9 });
  const pond = new THREE.Mesh(pondGeo, pondMat);
  pond.rotation.x = -Math.PI / 2;
  pond.position.set(0, -0.02, -GRID.height / 2 - 8);
  scene.add(pond);
  
  // Pond edge stones
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const stoneGeo = new THREE.SphereGeometry(0.3, 6, 4);
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
    const stone = new THREE.Mesh(stoneGeo, stoneMat);
    stone.position.set(
      Math.cos(angle) * 3.2,
      0.1,
      -GRID.height / 2 - 8 + Math.sin(angle) * 3.2
    );
    stone.scale.y = 0.5;
    scene.add(stone);
  }
  
  // Trees around the cafe - left side
  createTree(scene, -GRID.width / 2 - 5, -GRID.height / 2 - 3, 1.2);
  createTree(scene, -GRID.width / 2 - 7, 2, 1);
  createTree(scene, -GRID.width / 2 - 5, GRID.height / 2 - 2, 0.9);
  
  // Trees - right side
  createTree(scene, GRID.width / 2 + 4, -GRID.height / 2 - 2, 1.1);
  createTree(scene, GRID.width / 2 + 6, 3, 1);
  createTree(scene, GRID.width / 2 + 4, GRID.height / 2, 0.8);
  
  // Trees across the street (front)
  createTree(scene, -10, GRID.height / 2 + 9, 1.3);
  createTree(scene, 0, GRID.height / 2 + 10, 1.1);
  createTree(scene, 10, GRID.height / 2 + 9, 1.2);
  createTree(scene, -18, GRID.height / 2 + 8, 0.9);
  createTree(scene, 18, GRID.height / 2 + 8, 0.9);
  
  // Trees behind cafe (park area)
  createTree(scene, -6, -GRID.height / 2 - 5, 1);
  createTree(scene, 6, -GRID.height / 2 - 5, 1);
  createTree(scene, -4, -GRID.height / 2 - 12, 1.3);
  createTree(scene, 5, -GRID.height / 2 - 13, 1.2);
  createTree(scene, -10, -GRID.height / 2 - 10, 0.9);
  createTree(scene, 10, -GRID.height / 2 - 9, 1);
  
  // Distant trees
  createTree(scene, -25, -20, 1.5);
  createTree(scene, -20, -25, 1.3);
  createTree(scene, 25, -18, 1.4);
  createTree(scene, 20, -22, 1.2);
  createTree(scene, -30, 10, 1.3);
  createTree(scene, 28, 8, 1.4);
  
  // Bushes near the cafe entrance
  createBush(scene, -GRID.width / 2 - 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, GRID.width / 2 + 1, GRID.height / 2 + 0.5, 0.8);
  createBush(scene, -GRID.width / 2 - 1.5, GRID.height / 2 - 1, 0.6);
  createBush(scene, GRID.width / 2 + 1.5, GRID.height / 2 - 1, 0.6);
  
  // Bushes around the back/park
  createBush(scene, -GRID.width / 2 - 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, GRID.width / 2 + 2, -GRID.height / 2 - 2, 0.7);
  createBush(scene, -3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, 3, -GRID.height / 2 - 4, 0.6);
  createBush(scene, -2, -GRID.height / 2 - 12, 0.8);
  createBush(scene, 2, -GRID.height / 2 - 11, 0.7);
  
  // Lamp posts
  createLampPost(scene, -GRID.width / 2 - 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, GRID.width / 2 + 3, GRID.height / 2 + 1, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, -GRID.width / 2 - 7, -2, lampMaterialsRef, streetLightsRef);
  createLampPost(scene, 0, -GRID.height / 2 - 5, lampMaterialsRef, streetLightsRef); // Park lamp
  
  // Benches in park area
  createBench(scene, -5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, 5, GRID.height / 2 + 9, Math.PI);
  createBench(scene, -4, -GRID.height / 2 - 6, 0); // Behind cafe
  createBench(scene, 4, -GRID.height / 2 - 6, 0);  // Behind cafe
  
  // Small flower beds in front
  const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB, 0x00CED1, 0xFFA500];
  [-4, -2, 0, 2, 4].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.25, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff, 0.15, GRID.height / 2 + 1);
    flower.scale.y = 0.6;
    scene.add(flower);
  });
  
  // Flower bed behind cafe (near pond)
  [-2, -1, 0, 1, 2].forEach((xOff, i) => {
    const flowerGeo = new THREE.SphereGeometry(0.2, 6, 4);
    const flowerMat = new THREE.MeshLambertMaterial({ color: flowerColors[(i + 2) % flowerColors.length] });
    const flower = new THREE.Mesh(flowerGeo, flowerMat);
    flower.position.set(xOff * 1.5, 0.12, -GRID.height / 2 - 4);
    flower.scale.y = 0.5;
    scene.add(flower);
  });
  
  // Picnic table in the back park
  const picnicGroup = new THREE.Group();
  const tableMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  
  // Table top
  const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), tableMat);
  tableTop.position.y = 0.6;
  picnicGroup.add(tableTop);
  
  // Benches
  const bench1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench1.position.set(0, 0.35, 0.5);
  picnicGroup.add(bench1);
  const bench2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.3), tableMat);
  bench2.position.set(0, 0.35, -0.5);
  picnicGroup.add(bench2);
  
  // Legs
  const legMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
  [[-0.7, 0], [0.7, 0]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.8), legMat);
    leg.position.set(x, 0.3, z);
    picnicGroup.add(leg);
  });
  
  picnicGroup.position.set(8, 0, -GRID.height / 2 - 10);
  scene.add(picnicGroup);
}

function createStove(x, z, rotation = 0, style = 'basic') {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  const styleData = STOVE_STYLES[style] || STOVE_STYLES.basic;
  const stoveType = styleData.type || 'basic';
  
  // Helper for shiny materials
  const createShinyBox = (w, h, d, color, px, py, pz, shininess = 100) => {
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, d),
      new THREE.MeshPhongMaterial({ color, shininess, specular: 0x444444 })
    );
    mesh.position.set(px, py, pz);
    return mesh;
  };
  
  const createShinyCylinder = (rT, rB, h, color, px, py, pz, seg = 16, shininess = 100) => {
    const mesh = new THREE.Mesh(
      new THREE.CylinderGeometry(rT, rB, h, seg),
      new THREE.MeshPhongMaterial({ color, shininess, specular: 0x444444 })
    );
    mesh.position.set(px, py, pz);
    return mesh;
  };
  
  try {
  if (stoveType === 'basic') {
    // Basic stove - simple design
    const body = createVoxelBox(0.9, 0.8, 0.9, styleData.bodyColor, 0, 0.45, 0);
    group.add(body);
    const top = createVoxelBox(0.95, 0.05, 0.95, styleData.topColor, 0, 0.88, 0);
    group.add(top);
    // Burners
    for (let bx = -1; bx <= 1; bx += 2) {
      for (let bz = -1; bz <= 1; bz += 2) {
        const burner = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.02, 16),
          new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
        );
        burner.position.set(bx * 0.2, 0.91, bz * 0.2);
        burner.name = 'burner';
        group.add(burner);
      }
    }
    const door = createVoxelBox(0.6, 0.4, 0.05, styleData.doorColor, 0, 0.25, 0.45);
    group.add(door);
    const handle = createVoxelBox(0.3, 0.03, 0.03, 0x888888, 0, 0.35, 0.5);
    group.add(handle);
    
  } else if (stoveType === 'modern') {
    // Modern with grates
    group.add(createVoxelBox(0.9, 0.75, 0.9, styleData.bodyColor, 0, 0.375, 0));
    group.add(createVoxelBox(0.85, 0.02, 0.85, styleData.trimColor, 0, 0.76, 0));
    if (styleData.isShiny) {
      group.add(createShinyBox(0.92, 0.06, 0.92, styleData.topColor, 0, 0.81, 0, 120));
    } else {
      group.add(createVoxelBox(0.92, 0.06, 0.92, styleData.topColor, 0, 0.81, 0));
    }
    // Grates and burners
    for (let bx = -1; bx <= 1; bx += 2) {
      for (let bz = -1; bz <= 1; bz += 2) {
        const grate = new THREE.Mesh(
          new THREE.TorusGeometry(0.13, 0.015, 8, 16),
          new THREE.MeshLambertMaterial({ color: 0x222222 })
        );
        grate.rotation.x = Math.PI / 2;
        grate.position.set(bx * 0.22, 0.85, bz * 0.22);
        group.add(grate);
        group.add(createVoxelBox(0.24, 0.02, 0.02, 0x222222, bx * 0.22, 0.86, bz * 0.22));
        group.add(createVoxelBox(0.02, 0.02, 0.24, 0x222222, bx * 0.22, 0.86, bz * 0.22));
        const burner = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.01, 16),
          new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        burner.position.set(bx * 0.22, 0.84, bz * 0.22);
        burner.name = 'burner';
        group.add(burner);
      }
    }
    // Knobs
    for (let i = -1.5; i <= 1.5; i += 1) {
      group.add(createShinyCylinder(0.035, 0.035, 0.04, 0x111111, i * 0.18, 0.65, 0.47, 12, 50));
    }
    group.add(createVoxelBox(0.7, 0.45, 0.04, styleData.doorColor, 0, 0.28, 0.46));
    group.add(createVoxelBox(0.5, 0.25, 0.02, 0x334455, 0, 0.32, 0.48));
    group.add(createShinyBox(0.5, 0.025, 0.04, 0xaaaaaa, 0, 0.12, 0.5, 150));
    
  } else if (stoveType === 'professional') {
    // Professional range with legs
    const legColor = 0x222222;
    for (let lx of [-0.38, 0.38]) {
      for (let lz of [-0.38, 0.38]) {
        group.add(createVoxelBox(0.08, 0.15, 0.08, legColor, lx, 0.075, lz));
      }
    }
    group.add(createVoxelBox(0.92, 0.7, 0.92, styleData.bodyColor, 0, 0.5, 0));
    if (styleData.isShiny) {
      group.add(createShinyBox(0.88, 0.65, 0.02, styleData.panelColor, 0, 0.48, 0.46, 120));
      group.add(createShinyBox(0.96, 0.08, 0.96, styleData.topColor, 0, 0.89, 0, 100));
      group.add(createShinyBox(0.96, 0.2, 0.06, styleData.topColor, 0, 1.03, -0.45, 100));
    } else {
      group.add(createVoxelBox(0.88, 0.65, 0.02, styleData.panelColor, 0, 0.48, 0.46));
      group.add(createVoxelBox(0.96, 0.08, 0.96, styleData.topColor, 0, 0.89, 0));
      group.add(createVoxelBox(0.96, 0.2, 0.06, styleData.topColor, 0, 1.03, -0.45));
    }
    // Grates
    group.add(createVoxelBox(0.38, 0.03, 0.7, 0x1a1a1a, -0.24, 0.94, 0));
    group.add(createVoxelBox(0.38, 0.03, 0.7, 0x1a1a1a, 0.24, 0.94, 0));
    for (let i = -3; i <= 3; i++) {
      group.add(createVoxelBox(0.02, 0.04, 0.7, 0x1a1a1a, -0.24 + i * 0.06, 0.95, 0));
      group.add(createVoxelBox(0.02, 0.04, 0.7, 0x1a1a1a, 0.24 + i * 0.06, 0.95, 0));
    }
    // Burners (5 total)
    for (let bx = -1; bx <= 1; bx++) {
      for (let bz = -1; bz <= 1; bz += 2) {
        if (bx === 0 && bz === 1) continue;
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(0.09, 0.012, 8, 20),
          new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.set(bx * 0.28, 0.92, bz * 0.22);
        ring.name = 'burner';
        group.add(ring);
      }
    }
    // Knobs
    for (let i = 0; i < 5; i++) {
      group.add(createShinyCylinder(0.04, 0.04, 0.03, 0xdddddd, -0.36 + i * 0.18, 1.05, -0.42, 16, 150));
    }
    // Double doors
    group.add(createVoxelBox(0.35, 0.5, 0.03, 0x1a1a1a, -0.22, 0.4, 0.47));
    group.add(createVoxelBox(0.35, 0.5, 0.03, 0x1a1a1a, 0.22, 0.4, 0.47));
    group.add(createVoxelBox(0.22, 0.3, 0.01, 0x223344, -0.22, 0.42, 0.475));
    group.add(createVoxelBox(0.22, 0.3, 0.01, 0x223344, 0.22, 0.42, 0.475));
    group.add(createShinyBox(0.03, 0.2, 0.04, 0xcccccc, -0.02, 0.4, 0.5, 150));
    group.add(createShinyBox(0.03, 0.2, 0.04, 0xcccccc, 0.02, 0.4, 0.5, 150));
    
  } else if (stoveType === 'retro') {
    // Retro/vintage with chrome
    const c = styleData;
    // Chrome legs
    for (let lx of [-0.35, 0.35]) {
      for (let lz of [-0.35, 0.35]) {
        group.add(createShinyCylinder(0.06, 0.08, 0.12, c.chromeColor, lx, 0.06, lz, 12, 180));
      }
    }
    group.add(createVoxelBox(0.88, 0.65, 0.88, c.bodyColor, 0, 0.445, 0));
    group.add(createShinyBox(0.9, 0.02, 0.02, c.chromeColor, 0, 0.78, 0.44, 180));
    group.add(createShinyBox(0.9, 0.02, 0.02, c.chromeColor, 0, 0.55, 0.44, 180));
    group.add(createShinyBox(0.9, 0.05, 0.9, 0xf8f8f8, 0, 0.8, 0, 60));
    // Coil burners
    for (let bx = -1; bx <= 1; bx += 2) {
      for (let bz = -1; bz <= 1; bz += 2) {
        group.add(createShinyCylinder(0.14, 0.14, 0.02, c.chromeColor, bx * 0.22, 0.82, bz * 0.22, 16, 150));
        for (let r = 0.04; r <= 0.11; r += 0.035) {
          const coil = new THREE.Mesh(
            new THREE.TorusGeometry(r, 0.012, 6, 20),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
          );
          coil.rotation.x = Math.PI / 2;
          coil.position.set(bx * 0.22, 0.84, bz * 0.22);
          coil.name = 'burner';
          group.add(coil);
        }
      }
    }
    // Backsplash with clock
    group.add(createVoxelBox(0.9, 0.15, 0.04, c.bodyColor, 0, 0.95, -0.43));
    group.add(createShinyCylinder(0.05, 0.05, 0.02, 0xf8f8f8, 0, 0.95, -0.4, 16, 80));
    const clockRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.052, 0.006, 8, 24),
      new THREE.MeshPhongMaterial({ color: c.chromeColor, shininess: 180, specular: 0x444444 })
    );
    clockRing.position.set(0, 0.95, -0.39);
    group.add(clockRing);
    // Knobs
    for (let i = -1.5; i <= 1.5; i += 1) {
      group.add(createShinyCylinder(0.045, 0.05, 0.04, c.chromeColor, i * 0.18, 0.95, -0.38, 12, 180));
    }
    // Porthole door
    group.add(createVoxelBox(0.7, 0.42, 0.04, c.bodyColor, 0, 0.33, 0.45));
    const porthole = createShinyCylinder(0.12, 0.12, 0.02, 0x223344, 0, 0.38, 0.47, 20, 50);
    porthole.rotation.x = Math.PI / 2;
    group.add(porthole);
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(0.13, 0.018, 8, 24),
      new THREE.MeshPhongMaterial({ color: c.chromeColor, shininess: 200, specular: 0x666666 })
    );
    ring.position.set(0, 0.38, 0.48);
    group.add(ring);
    group.add(createShinyBox(0.4, 0.03, 0.05, c.chromeColor, 0, 0.16, 0.48, 180));
    
  } else if (stoveType === 'glasstop') {
    // Glass top modern
    const c = styleData;
    if (c.isShiny) {
      group.add(createShinyBox(0.88, 0.72, 0.88, c.bodyColor, 0, 0.36, 0, 100));
    } else {
      group.add(createVoxelBox(0.88, 0.72, 0.88, c.bodyColor, 0, 0.36, 0));
    }
    // Glossy black cooktop
    const cooktopMat = new THREE.MeshPhongMaterial({ color: 0x0a0a0a, shininess: 200, specular: 0x555555 });
    const cooktop = new THREE.Mesh(new THREE.BoxGeometry(0.88, 0.03, 0.88), cooktopMat);
    cooktop.position.set(0, 0.735, 0);
    group.add(cooktop);
    // Burner rings on top
    const burnerPositions = [
      { x: -0.22, z: -0.22, size: 0.13 }, { x: 0.22, z: -0.22, size: 0.11 },
      { x: -0.22, z: 0.22, size: 0.11 }, { x: 0.22, z: 0.22, size: 0.09 }
    ];
    const markingColor = 0x666666;
    const yPos = 0.751;
    for (const burner of burnerPositions) {
      for (const sizeMult of [1, 0.65, 0.35]) {
        const ringSize = burner.size * sizeMult;
        const thickness = sizeMult === 1 ? 0.012 : (sizeMult === 0.65 ? 0.01 : 0.008);
        const ringMesh = new THREE.Mesh(
          new THREE.RingGeometry(ringSize - thickness, ringSize, 32),
          new THREE.MeshBasicMaterial({ color: markingColor, side: THREE.DoubleSide })
        );
        ringMesh.rotation.x = -Math.PI / 2;
        ringMesh.position.set(burner.x, yPos, burner.z);
        ringMesh.name = sizeMult === 1 ? 'burner' : '';
        group.add(ringMesh);
      }
      const dot = new THREE.Mesh(
        new THREE.CircleGeometry(0.012, 16),
        new THREE.MeshBasicMaterial({ color: markingColor, side: THREE.DoubleSide })
      );
      dot.rotation.x = -Math.PI / 2;
      dot.position.set(burner.x, yPos, burner.z);
      group.add(dot);
    }
    // Frame border
    const frameH = 0.03, frameW = 0.03, frameY = 0.755;
    group.add(createShinyBox(0.92, frameH, frameW, c.frameColor, 0, frameY, 0.445, 120));
    group.add(createShinyBox(0.92, frameH, frameW, c.frameColor, 0, frameY, -0.445, 120));
    group.add(createShinyBox(frameW, frameH, 0.86, c.frameColor, 0.445, frameY, 0, 120));
    group.add(createShinyBox(frameW, frameH, 0.86, c.frameColor, -0.445, frameY, 0, 120));
    // Glass on top
    const glassMat = new THREE.MeshPhongMaterial({ 
      color: 0x88ccff, transparent: true, opacity: 0.35, shininess: 300, specular: 0xffffff, depthWrite: false
    });
    const glass = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.04, 0.92), glassMat);
    glass.position.set(0, 0.79, 0);
    glass.renderOrder = 1;
    group.add(glass);
    // Touch controls
    group.add(createShinyBox(0.6, 0.06, 0.015, 0x111111, 0, 0.72, 0.44, 80));
    const ledColors = [0x00ff00, 0x00ff00, 0x222222, 0x00ff00, 0x222222];
    for (let i = -2; i <= 2; i++) {
      const led = new THREE.Mesh(
        new THREE.CircleGeometry(0.012, 12),
        new THREE.MeshBasicMaterial({ color: ledColors[i + 2] })
      );
      led.position.set(i * 0.1, 0.72, 0.449);
      group.add(led);
    }
    // Oven
    group.add(createVoxelBox(0.75, 0.48, 0.03, 0x0a0a0a, 0, 0.28, 0.44));
    group.add(createShinyBox(0.5, 0.015, 0.03, 0x888888, 0, 0.55, 0.46, 150));
    
  } else if (stoveType === 'commercial') {
    // Commercial/restaurant style
    const c = styleData;
    group.add(createVoxelBox(0.94, 0.1, 0.94, 0x444444, 0, 0.05, 0));
    if (c.isShiny) {
      group.add(createShinyBox(0.92, 0.7, 0.92, c.bodyColor, 0, 0.45, 0, 100));
      group.add(createShinyBox(0.94, 0.1, 0.94, c.grillColor, 0, 0.85, 0, 60));
      group.add(createShinyBox(0.94, 0.3, 0.08, c.bodyColor, 0, 1.05, -0.43, 100));
      group.add(createShinyBox(0.9, 0.02, 0.15, c.bodyColor, 0, 1.22, -0.38, 100));
    } else {
      group.add(createVoxelBox(0.92, 0.7, 0.92, c.bodyColor, 0, 0.45, 0));
      group.add(createVoxelBox(0.94, 0.1, 0.94, c.grillColor, 0, 0.85, 0));
      group.add(createVoxelBox(0.94, 0.3, 0.08, c.bodyColor, 0, 1.05, -0.43));
      group.add(createVoxelBox(0.9, 0.02, 0.15, c.bodyColor, 0, 1.22, -0.38));
    }
    // Heavy grates
    group.add(createVoxelBox(0.8, 0.04, 0.8, 0x222222, 0, 0.92, 0));
    for (let i = -4; i <= 4; i++) {
      group.add(createVoxelBox(0.02, 0.05, 0.8, 0x222222, i * 0.09, 0.93, 0));
    }
    // Power burners
    for (let bx = -1; bx <= 1; bx += 2) {
      for (let bz = -1; bz <= 1; bz += 2) {
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(0.12, 0.02, 8, 24),
          new THREE.MeshLambertMaterial({ color: 0x3a3a3a })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.set(bx * 0.25, 0.89, bz * 0.25);
        ring.name = 'burner';
        group.add(ring);
      }
    }
    // Valve knobs
    for (let i = 0; i < 4; i++) {
      group.add(createVoxelBox(0.06, 0.06, 0.04, 0x333333, -0.3 + i * 0.2, 0.65, 0.48));
      if (c.isShiny) {
        group.add(createShinyBox(0.08, 0.02, 0.02, c.bodyColor, -0.3 + i * 0.2, 0.68, 0.5, 120));
      } else {
        group.add(createVoxelBox(0.08, 0.02, 0.02, c.bodyColor, -0.3 + i * 0.2, 0.68, 0.5));
      }
    }
    // Oven
    group.add(createVoxelBox(0.75, 0.5, 0.03, 0x1a1a1a, 0, 0.35, 0.46));
    group.add(createVoxelBox(0.55, 0.35, 0.01, 0x223344, 0, 0.38, 0.475));
    group.add(createShinyBox(0.03, 0.25, 0.05, c.isShiny ? c.bodyColor : 0x888888, 0, 0.35, 0.49, 150));
  }
  } catch (err) {
    console.error('Error creating stove style:', style, err);
    // Fallback to basic box if stove creation fails
    group.add(createVoxelBox(0.9, 0.8, 0.9, 0x505050, 0, 0.45, 0));
    group.add(createVoxelBox(0.95, 0.05, 0.95, 0x333333, 0, 0.88, 0));
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = getRotationAngle(rotation);
  return group;
}

function createCounter(x, z, rotation = 0, style = 'basic') {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  const styleData = COUNTER_STYLES[style] || COUNTER_STYLES.basic;
  const counterType = styleData.type || 'basic';
  
  // Helper for shiny materials
  const createShinyBox = (w, h, d, color, px, py, pz, shininess = 100) => {
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, d),
      new THREE.MeshPhongMaterial({ color, shininess, specular: 0x444444 })
    );
    mesh.position.set(px, py, pz);
    return mesh;
  };
  
  const createShinyCylinder = (rT, rB, h, color, px, py, pz, seg = 16, shininess = 100) => {
    const mesh = new THREE.Mesh(
      new THREE.CylinderGeometry(rT, rB, h, seg),
      new THREE.MeshPhongMaterial({ color, shininess, specular: 0x444444 })
    );
    mesh.position.set(px, py, pz);
    return mesh;
  };
  
  try {
  if (counterType === 'basic') {
    // Basic counter - simple cabinet design
    const c = styleData;
    group.add(createVoxelBox(0.9, 0.7, 0.9, c.cabinetColor, 0, 0.35, 0));
    group.add(createVoxelBox(0.95, 0.08, 0.95, c.topColor, 0, 0.74, 0));
    group.add(createVoxelBox(0.3, 0.04, 0.04, c.handleColor, 0, 0.45, 0.47));
    // Cabinet door lines
    group.add(createVoxelBox(0.02, 0.5, 0.02, 0x1a1a1a, -0.25, 0.35, 0.46));
    group.add(createVoxelBox(0.02, 0.5, 0.02, 0x1a1a1a, 0.25, 0.35, 0.46));
    
  } else if (counterType === 'modern') {
    // Modern counter - sleek push-open style
    const c = styleData;
    group.add(createShinyBox(0.9, 0.68, 0.9, c.cabinetColor, 0, 0.34, 0, 60));
    group.add(createShinyBox(0.95, 0.1, 0.95, c.topColor, 0, 0.73, 0, 80));
    // Accent strip
    group.add(createShinyBox(0.92, 0.02, 0.02, c.accentColor, 0, 0.5, 0.45, 100));
    // Subtle gap line
    group.add(createVoxelBox(0.88, 0.01, 0.01, 0x111111, 0, 0.35, 0.455));
    
  } else if (counterType === 'retro') {
    // Retro/vintage counter - pastel + chrome
    const c = styleData;
    // Chrome legs
    for (let lx of [-0.35, 0.35]) {
      for (let lz of [-0.35, 0.35]) {
        group.add(createShinyCylinder(0.05, 0.06, 0.1, c.chromeColor, lx, 0.05, lz, 12, 180));
      }
    }
    // Body
    group.add(createVoxelBox(0.88, 0.58, 0.88, c.bodyColor, 0, 0.39, 0));
    // Chrome trim strips
    group.add(createShinyBox(0.9, 0.02, 0.02, c.chromeColor, 0, 0.68, 0.44, 180));
    group.add(createShinyBox(0.9, 0.02, 0.02, c.chromeColor, 0, 0.15, 0.44, 180));
    // Countertop
    group.add(createShinyBox(0.92, 0.06, 0.92, c.topColor, 0, 0.73, 0, 100));
    // Chrome edge
    group.add(createShinyBox(0.94, 0.02, 0.94, c.chromeColor, 0, 0.77, 0, 150));
    // Chrome handle
    group.add(createShinyBox(0.35, 0.025, 0.04, c.chromeColor, 0, 0.45, 0.46, 180));
    // Decorative chrome circle
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.012, 8, 20),
      new THREE.MeshPhongMaterial({ color: c.chromeColor, shininess: 180, specular: 0x444444 })
    );
    ring.position.set(0.25, 0.45, 0.45);
    group.add(ring);
    
  } else if (counterType === 'wood') {
    // Wood & natural counter
    const c = styleData;
    // Cabinet with wood feel
    group.add(createVoxelBox(0.9, 0.68, 0.9, c.cabinetColor, 0, 0.34, 0));
    // Wooden countertop (butcher block style)
    group.add(createVoxelBox(0.95, 0.08, 0.95, c.topColor, 0, 0.72, 0));
    // Trim around edges
    group.add(createVoxelBox(0.92, 0.02, 0.02, c.trimColor, 0, 0.77, 0.47));
    group.add(createVoxelBox(0.92, 0.02, 0.02, c.trimColor, 0, 0.77, -0.47));
    group.add(createVoxelBox(0.02, 0.02, 0.92, c.trimColor, 0.47, 0.77, 0));
    group.add(createVoxelBox(0.02, 0.02, 0.92, c.trimColor, -0.47, 0.77, 0));
    // Wooden handle
    group.add(createVoxelBox(0.25, 0.04, 0.05, c.trimColor, 0, 0.45, 0.47));
    // Panel lines
    group.add(createVoxelBox(0.02, 0.5, 0.01, c.trimColor, -0.2, 0.35, 0.455));
    group.add(createVoxelBox(0.02, 0.5, 0.01, c.trimColor, 0.2, 0.35, 0.455));
    
  } else if (counterType === 'marble') {
    // Marble & luxury counter
    const c = styleData;
    // Elegant cabinet
    group.add(createShinyBox(0.9, 0.65, 0.9, c.cabinetColor, 0, 0.325, 0, 40));
    // Thick marble countertop
    group.add(createShinyBox(0.96, 0.12, 0.96, c.topColor, 0, 0.71, 0, 120));
    // Subtle veining effect (decorative lines)
    group.add(createVoxelBox(0.4, 0.005, 0.002, 0xaaaaaa, 0.1, 0.77, 0.1));
    group.add(createVoxelBox(0.3, 0.005, 0.002, 0xbbbbbb, -0.15, 0.77, -0.1));
    // Accent trim
    group.add(createShinyBox(0.92, 0.015, 0.015, c.accentColor, 0, 0.65, 0.44, 150));
    // Sleek handle
    group.add(createShinyBox(0.4, 0.015, 0.03, c.accentColor, 0, 0.45, 0.46, 150));
    
  } else if (counterType === 'commercial') {
    // Commercial/restaurant counter
    const c = styleData;
    // Heavy-duty base
    group.add(createShinyBox(0.92, 0.65, 0.92, c.bodyColor, 0, 0.325, 0, 100));
    // Reinforced top
    group.add(createShinyBox(0.96, 0.06, 0.96, c.topColor, 0, 0.68, 0, 120));
    // Backsplash
    group.add(createShinyBox(0.96, 0.15, 0.04, c.topColor, 0, 0.79, -0.46, 100));
    // Bottom shelf visible
    group.add(createShinyBox(0.8, 0.02, 0.8, c.trimColor, 0, 0.08, 0, 80));
    // Industrial handles
    group.add(createShinyBox(0.35, 0.04, 0.04, c.trimColor, -0.2, 0.45, 0.48, 150));
    group.add(createShinyBox(0.35, 0.04, 0.04, c.trimColor, 0.2, 0.45, 0.48, 150));
    // Vent holes (decorative)
    for (let i = -2; i <= 2; i++) {
      const vent = new THREE.Mesh(
        new THREE.CircleGeometry(0.02, 8),
        new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
      );
      vent.position.set(i * 0.12, 0.55, 0.461);
      group.add(vent);
    }
  }
  } catch (err) {
    console.error('Error creating counter style:', style, err);
    // Fallback to basic counter if creation fails
    group.add(createVoxelBox(0.9, 0.7, 0.9, COLORS.counter.cabinet, 0, 0.35, 0));
    group.add(createVoxelBox(1, 0.1, 1, COLORS.counter.top, 0, 0.75, 0));
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = getRotationAngle(rotation);
  return group;
}

function createTable(x, z, style = 'round', rotation = 0, hasBuiltInChair = false) {
  const group = new THREE.Group();
  const worldX = x - GRID.width / 2 + 0.5;
  const worldZ = z - GRID.height / 2 + 0.5;
  
  // Get style properties (with fallbacks for backwards compatibility)
  const styleData = TABLE_STYLES[style] || TABLE_STYLES.round;
  const shape = styleData.shape || 'round';
  const woodColor = styleData.woodColor || COLORS.table.wood;
  const clothColor = styleData.clothColor; // Can be null for no cloth
  const chairColor = styleData.chairColor || COLORS.chair.wood;
  const pattern = styleData.pattern;
  const material = styleData.material;
  
  // Table fills the tile (0.9 units to leave small gap)
  if (shape === 'round') {
    // Round table - fills tile
    const tableTopMat = material === 'marble' 
      ? new THREE.MeshLambertMaterial({ color: woodColor })
      : new THREE.MeshLambertMaterial({ color: woodColor });
    
    const tableTop = new THREE.Mesh(
      new THREE.CylinderGeometry(0.42, 0.42, 0.08, 16),
      tableTopMat
    );
    tableTop.position.y = 0.6;
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Tablecloth (only if clothColor is specified)
    if (clothColor !== null) {
      const cloth = new THREE.Mesh(
        new THREE.CylinderGeometry(0.45, 0.48, 0.03, 16),
        new THREE.MeshLambertMaterial({ color: clothColor })
      );
      cloth.position.y = 0.56;
      group.add(cloth);
    }
    
    // Pedestal - use wood color
    const pedestal = createVoxelBox(0.14, 0.5, 0.14, woodColor, 0, 0.28, 0);
    group.add(pedestal);
    
    // Base
    const base = new THREE.Mesh(
      new THREE.CylinderGeometry(0.22, 0.28, 0.06, 16),
      new THREE.MeshLambertMaterial({ color: woodColor })
    );
    base.position.y = 0.03;
    group.add(base);
    
  } else if (shape === 'square') {
    // Square table - fills tile edge to edge
    const tableTop = createVoxelBox(0.96, 0.08, 0.96, woodColor, 0, 0.6, 0);
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Tablecloth (only if clothColor is specified)
    if (clothColor !== null) {
      if (pattern === 'checkered') {
        // Checkered pattern - create multiple squares
        const clothBase = createVoxelBox(0.98, 0.02, 0.98, clothColor, 0, 0.565, 0);
        group.add(clothBase);
        // Add white squares for checkered effect
        const squareSize = 0.22;
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if ((i + j) % 2 === 0) {
              const square = createVoxelBox(squareSize, 0.01, squareSize, 0xFFFFFF, 
                (i - 1.5) * squareSize, 0.57, (j - 1.5) * squareSize);
              group.add(square);
            }
          }
        }
      } else {
        const cloth = createVoxelBox(0.98, 0.03, 0.98, clothColor, 0, 0.56, 0);
        group.add(cloth);
      }
    }
    
    // Four legs at corners - use wood color
    const legPositions = [[-0.40, -0.40], [0.40, -0.40], [-0.40, 0.40], [0.40, 0.40]];
    legPositions.forEach(([lx, lz]) => {
      const leg = createVoxelBox(0.08, 0.55, 0.08, woodColor, lx, 0.28, lz);
      group.add(leg);
    });
  } else if (shape === 'diner') {
    // 50s DINER TABLE - chrome pedestal with colored top
    const topColor = styleData.topColor || 0xf5f5f5;
    const variant = styleData.variant || 'classic';
    
    // Table top
    const tableTop = createVoxelBox(0.96, 0.05, 0.96, topColor, 0, 0.58, 0);
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Chrome trim around edges
    [[0, 0.47], [0, -0.47]].forEach(([x, z]) => {
      const trim = createVoxelBox(0.98, 0.03, 0.03, 0xc0c0c0, x, 0.56, z);
      group.add(trim);
    });
    [[0.47, 0], [-0.47, 0]].forEach(([x, z]) => {
      const trim = createVoxelBox(0.03, 0.03, 0.92, 0xc0c0c0, x, 0.56, z);
      group.add(trim);
    });
    
    // Chrome pedestal
    const pedestal = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08, 0.12, 0.5, 16),
      new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
    );
    pedestal.position.y = 0.28;
    group.add(pedestal);
    
    // Chrome base
    const base = new THREE.Mesh(
      new THREE.CylinderGeometry(0.25, 0.28, 0.06, 16),
      new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
    );
    base.position.y = 0.03;
    group.add(base);
    
    // Checkered pattern
    if (variant === 'checkered') {
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          if ((i + j) % 2 === 0) {
            const square = createVoxelBox(0.2, 0.01, 0.2, 0x222222, -0.3 + i * 0.2, 0.61, -0.3 + j * 0.2);
            group.add(square);
          }
        }
      }
    }
    
  } else if (shape === 'romantic') {
    // ROMANTIC TABLE - elegant with tablecloth and candle
    const clothCol = styleData.clothColor || 0xf8a0b0;
    const trimCol = styleData.trimColor || 0xfaf5f0;
    
    // Base table
    const tableBase = createVoxelBox(0.96, 0.04, 0.96, trimCol, 0, 0.52, 0);
    group.add(tableBase);
    
    // Colored tablecloth top
    const tableCloth = createVoxelBox(0.98, 0.02, 0.98, clothCol, 0, 0.56, 0);
    tableCloth.castShadow = true;
    group.add(tableCloth);
    
    // Trim edges
    [[0, 0.49], [0, -0.49]].forEach(([x, z]) => {
      group.add(createVoxelBox(1.0, 0.015, 0.03, trimCol, x, 0.545, z));
    });
    [[0.49, 0], [-0.49, 0]].forEach(([x, z]) => {
      group.add(createVoxelBox(0.03, 0.015, 0.94, trimCol, x, 0.545, z));
    });
    
    // Elegant candle at front edge
    const candleHolder = new THREE.Mesh(
      new THREE.CylinderGeometry(0.035, 0.04, 0.025, 12),
      new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
    );
    candleHolder.position.set(0, 0.585, 0.32);
    group.add(candleHolder);
    
    const candle = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.022, 0.08, 12),
      new THREE.MeshLambertMaterial({ color: 0xfffff0 })
    );
    candle.position.set(0, 0.635, 0.32);
    group.add(candle);
    
    const flame = new THREE.Mesh(
      new THREE.CylinderGeometry(0.008, 0.003, 0.025, 8),
      new THREE.MeshLambertMaterial({ color: 0xffa500 })
    );
    flame.position.set(0, 0.685, 0.32);
    group.add(flame);
    
    // Elegant turned legs
    [[-0.40, -0.40], [0.40, -0.40], [-0.40, 0.40], [0.40, 0.40]].forEach(([lx, lz]) => {
      // Top part
      const legTop = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.05, 0.12, 12),
        new THREE.MeshLambertMaterial({ color: trimCol })
      );
      legTop.position.set(lx, 0.44, lz);
      group.add(legTop);
      // Middle part
      const legMid = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.32, 12),
        new THREE.MeshLambertMaterial({ color: trimCol })
      );
      legMid.position.set(lx, 0.22, lz);
      group.add(legMid);
      // Bottom part
      const legBot = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.04, 0.08, 12),
        new THREE.MeshLambertMaterial({ color: trimCol })
      );
      legBot.position.set(lx, 0.04, lz);
      group.add(legBot);
    });
    
  } else if (shape === 'mediterranean') {
    // MEDITERRANEAN TABLE - decorative mosaic top
    const topCol = styleData.topColor || 0xdeb887;
    const accentCol = styleData.accentColor || 0xcd853f;
    const legCol = styleData.legColor || 0x8b4513;
    
    // Table top
    const tableTop = createVoxelBox(0.96, 0.06, 0.96, topCol, 0, 0.57, 0);
    tableTop.castShadow = true;
    group.add(tableTop);
    
    // Decorative mosaic pattern (checkered accent squares)
    for (let i = -2; i <= 2; i++) {
      for (let j = -2; j <= 2; j++) {
        if ((i + j) % 2 === 0) {
          const tile = createVoxelBox(0.17, 0.01, 0.17, accentCol, i * 0.18, 0.605, j * 0.18);
          group.add(tile);
        }
      }
    }
    
    // Four legs
    [[-0.40, -0.40], [0.40, -0.40], [-0.40, 0.40], [0.40, 0.40]].forEach(([lx, lz]) => {
      const leg = createVoxelBox(0.08, 0.54, 0.08, legCol, lx, 0.27, lz);
      group.add(leg);
    });
  }
  
  // Chair close to table edge (in adjacent tile but tucked under)
  // Only add built-in chair for legacy tables (hasBuiltInChair flag)
  // New tables use separate standalone chairs
  if (hasBuiltInChair) {
    const chair = createChair(chairColor);
    // Position at -0.55 so chair is at table edge, customer legs tucked under
    chair.position.set(-0.55, 0, 0);
    chair.rotation.y = Math.PI / 2; // Face the table
    group.add(chair);
  }
  
  group.position.set(worldX, 0, worldZ);
  group.rotation.y = rotation * (Math.PI / 2); // 0, 90, 180, 270 degrees
  return group;
}

// Create a standalone chair (for mix-and-match system)
// Rotation: 0=faces +Z, 1=faces -X, 2=faces -Z, 3=faces +X
function createStandaloneChair(gridX, gridZ, style = 'basicWood', rotation = 0) {
  const group = new THREE.Group();
  const worldX = gridX - GRID.width / 2 + 0.5;
  const worldZ = gridZ - GRID.height / 2 + 0.5;
  
  // Get style properties
  const styleData = CHAIR_STYLES[style] || CHAIR_STYLES.basicWood;
  const frameColor = styleData.color || 0xA0522D;
  const seatColor = styleData.seatColor || frameColor;
  const hasArmrests = styleData.hasArmrests || false;
  const renderType = styleData.renderType || 'default';
  
  if (renderType === 'diner') {
    // 50s DINER CHAIR - chrome frame with padded vinyl seat
    // Seat cushion (thick, rounded look)
    const seat1 = createVoxelBox(0.36, 0.08, 0.36, seatColor, 0, 0.44, 0);
    seat1.castShadow = true;
    group.add(seat1);
    const seat2 = createVoxelBox(0.32, 0.03, 0.32, seatColor, 0, 0.49, 0);
    group.add(seat2);
    
    // Back cushion
    const backCushion = createVoxelBox(0.34, 0.28, 0.06, seatColor, 0, 0.66, -0.17);
    backCushion.castShadow = true;
    group.add(backCushion);
    
    // Chrome back frame - two side supports
    [[-0.17, -0.19], [0.17, -0.19]].forEach(([x, z]) => {
      const support = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.02, 0.4, 12),
        new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
      );
      support.position.set(x, 0.6, z);
      group.add(support);
    });
    // Chrome top rail
    group.add(createVoxelBox(0.38, 0.025, 0.025, 0xc0c0c0, 0, 0.82, -0.19));
    
    // Chrome legs
    [[-0.14, -0.14], [0.14, -0.14], [-0.14, 0.14], [0.14, 0.14]].forEach(([lx, lz]) => {
      const leg = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.025, 0.4, 12),
        new THREE.MeshLambertMaterial({ color: 0xc0c0c0 })
      );
      leg.position.set(lx, 0.2, lz);
      group.add(leg);
    });
    
  } else if (renderType === 'romantic') {
    // ROMANTIC CHAIR - elegant with tufted seat and Queen Anne legs
    // Padded seat
    const seat1 = createVoxelBox(0.36, 0.06, 0.36, seatColor, 0, 0.43, 0);
    seat1.castShadow = true;
    group.add(seat1);
    const seat2 = createVoxelBox(0.32, 0.02, 0.32, seatColor, 0, 0.47, 0);
    group.add(seat2);
    
    // Button tufts on seat (3x3 grid)
    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        const tuft = new THREE.Mesh(
          new THREE.CylinderGeometry(0.012, 0.012, 0.015, 8),
          new THREE.MeshLambertMaterial({ color: frameColor })
        );
        tuft.position.set(i * 0.09, 0.485, j * 0.09);
        group.add(tuft);
      }
    }
    
    // Vertical padded back
    const back = createVoxelBox(0.34, 0.35, 0.05, seatColor, 0, 0.65, -0.17);
    back.castShadow = true;
    group.add(back);
    
    // Frame trim
    group.add(createVoxelBox(0.36, 0.025, 0.02, frameColor, 0, 0.84, -0.19));
    [[-0.18, 0], [0.18, 0]].forEach(([x, z]) => {
      group.add(createVoxelBox(0.025, 0.35, 0.02, frameColor, x, 0.65, -0.19));
    });
    
    // Elegant Queen Anne legs
    [[-0.13, -0.13], [0.13, -0.13], [-0.13, 0.13], [0.13, 0.13]].forEach(([lx, lz]) => {
      const legTop = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.035, 0.1, 12),
        new THREE.MeshLambertMaterial({ color: frameColor })
      );
      legTop.position.set(lx, 0.35, lz);
      group.add(legTop);
      
      const legMid = new THREE.Mesh(
        new THREE.CylinderGeometry(0.025, 0.025, 0.2, 12),
        new THREE.MeshLambertMaterial({ color: frameColor })
      );
      legMid.position.set(lx, 0.2, lz);
      group.add(legMid);
      
      const legBot = new THREE.Mesh(
        new THREE.CylinderGeometry(0.035, 0.03, 0.08, 12),
        new THREE.MeshLambertMaterial({ color: frameColor })
      );
      legBot.position.set(lx, 0.04, lz);
      group.add(legBot);
    });
    
  } else if (renderType === 'mediterranean') {
    // MEDITERRANEAN CHAIR - woven seat with ladder back
    // Woven seat (slatted pattern)
    const seatBase = createVoxelBox(0.36, 0.04, 0.36, seatColor, 0, 0.42, 0);
    seatBase.castShadow = true;
    group.add(seatBase);
    
    // Seat slats
    for (let i = -3; i <= 3; i++) {
      group.add(createVoxelBox(0.32, 0.01, 0.02, frameColor, 0, 0.445, i * 0.045));
    }
    
    // Ladder back - two vertical posts
    [[-0.15, -0.17], [0.15, -0.17]].forEach(([x, z]) => {
      group.add(createVoxelBox(0.04, 0.45, 0.04, frameColor, x, 0.62, z));
    });
    
    // Horizontal rungs on back
    [0.55, 0.68, 0.81].forEach(y => {
      group.add(createVoxelBox(0.26, 0.04, 0.02, frameColor, 0, y, -0.17));
    });
    
    // Turned legs
    [[-0.14, -0.14], [0.14, -0.14], [-0.14, 0.14], [0.14, 0.14]].forEach(([lx, lz]) => {
      const leg = new THREE.Mesh(
        new THREE.CylinderGeometry(0.025, 0.03, 0.4, 8),
        new THREE.MeshLambertMaterial({ color: frameColor })
      );
      leg.position.set(lx, 0.2, lz);
      group.add(leg);
    });
    
  } else {
    // DEFAULT CHAIR RENDERING
    // Seat (with optional cushion color)
    const seat = createVoxelBox(0.35, 0.06, 0.35, seatColor, 0, 0.35, 0);
    seat.castShadow = true;
    group.add(seat);
    
    // Back frame
    const back = createVoxelBox(0.35, 0.4, 0.06, frameColor, 0, 0.58, -0.17);
    back.castShadow = true;
    group.add(back);
    
    // Back slats (decorative)
    for (let i = -1; i <= 1; i++) {
      const slat = createVoxelBox(0.04, 0.32, 0.03, frameColor, i * 0.1, 0.54, -0.14);
      group.add(slat);
    }
    
    // Four legs
    const legPositions = [[-0.13, -0.13], [0.13, -0.13], [-0.13, 0.13], [0.13, 0.13]];
    legPositions.forEach(([lx, lz]) => {
      const leg = createVoxelBox(0.05, 0.35, 0.05, frameColor, lx, 0.175, lz);
      group.add(leg);
    });
    
    // Armrests (for executive/premium styles)
    if (hasArmrests) {
      // Left armrest
      const leftArm = createVoxelBox(0.05, 0.05, 0.25, frameColor, -0.2, 0.45, 0);
      const leftSupport = createVoxelBox(0.04, 0.15, 0.04, frameColor, -0.2, 0.38, 0.08);
      group.add(leftArm);
      group.add(leftSupport);
      // Right armrest
      const rightArm = createVoxelBox(0.05, 0.05, 0.25, frameColor, 0.2, 0.45, 0);
      const rightSupport = createVoxelBox(0.04, 0.15, 0.04, frameColor, 0.2, 0.38, 0.08);
      group.add(rightArm);
      group.add(rightSupport);
    }
  }
  
  group.position.set(worldX, 0, worldZ);
  // Chair rotation: 0=faces +Z, 1=faces -X, 2=faces -Z, 3=faces +X
  // The chair model has its back at -Z, so front naturally faces +Z at rotation 0
  group.rotation.y = rotation * (Math.PI / 2);
  return group;
}

function createChair(chairColor = COLORS.chair.wood) {
  const group = new THREE.Group();
  
  // Seat
  const seat = createVoxelBox(0.3, 0.05, 0.3, chairColor, 0, 0.35, 0);
  group.add(seat);
  
  // Back
  const back = createVoxelBox(0.3, 0.35, 0.05, chairColor, 0, 0.55, -0.15);
  group.add(back);
  
  // Legs
  const legPositions = [[-0.1, -0.1], [0.1, -0.1], [-0.1, 0.1], [0.1, 0.1]];
  legPositions.forEach(([lx, lz]) => {
    const leg = createVoxelBox(0.04, 0.32, 0.04, chairColor, lx, 0.16, lz);
    group.add(leg);
  });
  
  return group;
}

function createFoodPlate(recipeKey, plateColor = 0xFFFFF0) {
  const group = new THREE.Group();
  const recipe = RECIPES[recipeKey];
  
  // Plate color changes based on mastery level
  // Default: Ivory (0xFFFFF0)
  // Level 1: Light Blue (0x87CEEB)
  // Level 2: Royal Blue (0x4169E1)
  // Level 3: Gold (0xFFD700)
  const plate = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.32, 0.05, 16),
    new THREE.MeshLambertMaterial({ color: plateColor })
  );
  plate.position.y = 0;
  plate.castShadow = true;
  group.add(plate);
  
  // Food item colors for all recipes
  const foodColors = {
    // Level 1
    burger: 0x8B4513,
    salad: 0x228B22,
    // Level 2-3
    soup: 0xDAA520,
    pancakes: 0xDEB887,
    cake: 0xFFB6C1,
    tacos: 0xF4A460,
    // Level 4-5
    pizza: 0xFF6347,
    pasta: 0xFFE4B5,
    chicken: 0xD2691E,
    ramen: 0xFFDB58,
    // Level 6-7
    sushi: 0xFF6B6B,
    curry: 0xE59400,
    steak: 0x8B0000,
    lobster: 0xE74C3C,
    // Level 8-9
    paella: 0xFFD700,
    dimsum: 0xFFF8DC,
    bbqRibs: 0x5D3A1A,
    crabBisque: 0xFF7F50,
    // Level 10-12
    weddingCake: 0xFFF0F5,
    beef: 0x654321,
    feastPlatter: 0xDAA520,
    turkeyDinner: 0xCD853F,
  };
  
  const food = new THREE.Mesh(
    new THREE.SphereGeometry(0.18, 12, 12),
    new THREE.MeshLambertMaterial({ color: foodColors[recipeKey] || 0xffd700 })
  );
  food.scale.y = 0.5;
  food.position.y = 0.1;
  food.castShadow = true;
  group.add(food);
  
  // Add a little garnish/topping (varies by recipe type)
  const toppingColor = recipeKey.includes('salad') || recipeKey.includes('ramen') ? 0x00FF00 : 0xff0000;
  const topping = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 8, 8),
    new THREE.MeshLambertMaterial({ color: toppingColor })
  );
  topping.position.set(0, 0.18, 0);
  group.add(topping);
  
  return group;
}

// ============================================
// FULL COMBO CUSTOMER SYSTEM (v4 - with expressions)
// ============================================

const FULL_COMBO_PALETTES = {
  skinTones: [
    0xFFDBAC, 0xF5CFA0, 0xEAC086, 0xE0AC69, 0xC68642, 
    0x8D5524, 0x6B4423, 0x5C4033
  ],
  hairColors: [
    0x1a1a1a, 0x2C1810, 0x4A3728, 0x6B4423, 0x8B6914,
    0xB8860B, 0xDEB887, 0xD4A574, 0xA0522D, 0x800000
  ],
  shirtColors: [
    0x4a90d9, 0x50C878, 0xFF6B6B, 0xFFD93D, 0x9B59B6,
    0x1ABC9C, 0xE74C3C, 0x3498DB, 0xF39C12, 0x2ECC71,
    0xFF8C00, 0x00CED1, 0xDC143C, 0x9370DB
  ],
  pantsColors: [
    0x2d2d2d, 0x1a1a1a, 0x4a4a4a, 0x000080, 0x191970,
    0x8B4513, 0x556B2F, 0x2F4F4F, 0x696969, 0x483D8B
  ],
  shoeColors: [
    0x1a1a1a, 0x2d2d2d, 0x8B4513, 0x4a4a4a, 0x800000, 0x000080
  ]
};

// Create facial expression based on mood
function createFullComboFace(group, headY, mood, skinColor, hairColor) {
  // Eyes with whites
  group.add(createVoxelBox(0.045, 0.045, 0.01, 0xFFFFFF, -0.05, headY + 0.02, 0.1));
  group.add(createVoxelBox(0.045, 0.045, 0.01, 0xFFFFFF, 0.05, headY + 0.02, 0.1));
  
  // Iris
  group.add(createVoxelSphere(0.018, hairColor, -0.05, headY + 0.02, 0.11, 6));
  group.add(createVoxelSphere(0.018, hairColor, 0.05, headY + 0.02, 0.11, 6));
  
  // Pupil
  group.add(createVoxelSphere(0.01, 0x1a1a1a, -0.05, headY + 0.02, 0.115, 6));
  group.add(createVoxelSphere(0.01, 0x1a1a1a, 0.05, headY + 0.02, 0.115, 6));
  
  // Eye shine
  group.add(createVoxelSphere(0.005, 0xFFFFFF, -0.045, headY + 0.03, 0.12, 4));
  group.add(createVoxelSphere(0.005, 0xFFFFFF, 0.055, headY + 0.03, 0.12, 4));
  
  // Eyebrows - angle based on mood
  let browAngleL = 0, browAngleR = 0, browYOffset = 0;
  if (mood === 'angry') {
    browAngleL = -0.3;
    browAngleR = 0.3;
    browYOffset = -0.01;
  } else if (mood === 'sad') {
    browAngleL = 0.25;
    browAngleR = -0.25;
    browYOffset = -0.005;
  } else if (mood === 'annoyed') {
    browAngleL = -0.15;
    browAngleR = 0.15;
  }
  
  const leftBrow = createVoxelBox(0.045, 0.012, 0.015, hairColor, -0.05, headY + 0.065 + browYOffset, 0.1);
  leftBrow.rotation.z = browAngleL;
  const rightBrow = createVoxelBox(0.045, 0.012, 0.015, hairColor, 0.05, headY + 0.065 + browYOffset, 0.1);
  rightBrow.rotation.z = browAngleR;
  group.add(leftBrow, rightBrow);
  
  // Nose
  group.add(createVoxelBox(0.025, 0.035, 0.02, skinColor, 0, headY - 0.01, 0.1));
  
  // Mouth based on mood
  const mouthColor = 0xB35555;
  const mouthY = headY - 0.055;
  const mouthZ = 0.101;
  
  if (mood === 'happy') {
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, -0.03, mouthY + 0.006, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, -0.015, mouthY + 0.002, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0, mouthY - 0.004, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0.015, mouthY + 0.002, mouthZ));
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, 0.03, mouthY + 0.006, mouthZ));
  } else if (mood === 'neutral') {
    group.add(createVoxelBox(0.05, 0.008, 0.008, mouthColor, 0, mouthY, mouthZ));
  } else if (mood === 'annoyed') {
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, -0.02, mouthY - 0.003, mouthZ));
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, 0, mouthY + 0.002, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0.02, mouthY - 0.003, mouthZ));
  } else if (mood === 'angry') {
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, -0.03, mouthY - 0.010, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, -0.012, mouthY - 0.003, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0, mouthY + 0.006, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0.012, mouthY - 0.003, mouthZ));
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, 0.03, mouthY - 0.010, mouthZ));
    group.add(createVoxelBox(0.03, 0.012, 0.006, 0xFFFFFF, 0, mouthY + 0.016, mouthZ));
  } else if (mood === 'sad') {
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, -0.025, mouthY - 0.008, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, -0.01, mouthY - 0.002, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0, mouthY + 0.005, mouthZ));
    group.add(createVoxelBox(0.012, 0.008, 0.008, mouthColor, 0.01, mouthY - 0.002, mouthZ));
    group.add(createVoxelBox(0.015, 0.008, 0.008, mouthColor, 0.025, mouthY - 0.008, mouthZ));
    group.add(createVoxelSphere(0.008, 0x87CEEB, -0.065, headY - 0.01, 0.11, 6));
    group.add(createVoxelSphere(0.008, 0x87CEEB, 0.065, headY - 0.01, 0.11, 6));
  }
}

// Create hair style
function createFullComboHair(group, headY, hairColor, styleIndex) {
  const style = styleIndex % 6;
  
  switch(style) {
    case 0:
      group.add(createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, headY + 0.12, -0.01));
      group.add(createVoxelBox(0.04, 0.1, 0.16, hairColor, -0.1, headY + 0.04, -0.02));
      group.add(createVoxelBox(0.04, 0.1, 0.16, hairColor, 0.1, headY + 0.04, -0.02));
      group.add(createVoxelBox(0.18, 0.12, 0.04, hairColor, 0, headY + 0.02, -0.1));
      break;
    case 1:
      group.add(createVoxelBox(0.22, 0.06, 0.22, hairColor, 0, headY + 0.11, -0.01));
      group.add(createVoxelBox(0.05, 0.1, 0.05, hairColor, -0.06, headY + 0.16, 0));
      group.add(createVoxelBox(0.05, 0.12, 0.05, hairColor, 0.02, headY + 0.17, -0.02));
      group.add(createVoxelBox(0.05, 0.08, 0.05, hairColor, 0.07, headY + 0.14, 0.01));
      group.add(createVoxelBox(0.04, 0.08, 0.16, hairColor, -0.1, headY + 0.04, -0.02));
      group.add(createVoxelBox(0.04, 0.08, 0.16, hairColor, 0.1, headY + 0.04, -0.02));
      break;
    case 2:
      group.add(createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, headY + 0.12, -0.01));
      group.add(createVoxelBox(0.04, 0.14, 0.18, hairColor, -0.1, headY + 0.01, -0.02));
      group.add(createVoxelBox(0.04, 0.14, 0.18, hairColor, 0.1, headY + 0.01, -0.02));
      group.add(createVoxelBox(0.2, 0.25, 0.04, hairColor, 0, headY - 0.05, -0.1));
      break;
    case 3:
      group.add(createVoxelBox(0.21, 0.04, 0.21, hairColor, 0, headY + 0.1, 0));
      break;
    case 4:
      group.add(createVoxelBox(0.06, 0.15, 0.2, hairColor, 0, headY + 0.15, -0.01));
      group.add(createVoxelBox(0.04, 0.06, 0.16, hairColor, -0.1, headY + 0.04, -0.02));
      group.add(createVoxelBox(0.04, 0.06, 0.16, hairColor, 0.1, headY + 0.04, -0.02));
      break;
    case 5:
      group.add(createVoxelSphere(0.12, hairColor, 0, headY + 0.1, 0, 10));
      group.add(createVoxelSphere(0.06, hairColor, -0.1, headY + 0.06, 0, 8));
      group.add(createVoxelSphere(0.06, hairColor, 0.1, headY + 0.06, 0, 8));
      group.add(createVoxelSphere(0.05, hairColor, 0, headY + 0.02, -0.1, 8));
      break;
  }
}

// Main Full Combo customer creation function
// pose: 'standing', 'seated', 'carrying'
// mood: 'happy', 'neutral', 'annoyed', 'angry', 'sad'
function createFullComboCustomer(appearance = {}, pose = 'standing', mood = 'happy') {
  const group = new THREE.Group();
  
  const skinTones = FULL_COMBO_PALETTES.skinTones;
  const hairColors = FULL_COMBO_PALETTES.hairColors;
  const shirtColors = FULL_COMBO_PALETTES.shirtColors;
  const pantsColors = FULL_COMBO_PALETTES.pantsColors;
  const shoeColors = FULL_COMBO_PALETTES.shoeColors;
  
  const skin = skinTones[appearance.skinTone !== undefined ? appearance.skinTone % skinTones.length : Math.floor(Math.random() * skinTones.length)];
  const hair = hairColors[appearance.hairColor !== undefined ? appearance.hairColor % hairColors.length : Math.floor(Math.random() * hairColors.length)];
  const shirt = shirtColors[appearance.shirtColor !== undefined ? appearance.shirtColor % shirtColors.length : Math.floor(Math.random() * shirtColors.length)];
  const pants = pantsColors[appearance.pantsColor !== undefined ? appearance.pantsColor % pantsColors.length : Math.floor(Math.random() * pantsColors.length)];
  const shoes = shoeColors[appearance.shoeColor !== undefined ? appearance.shoeColor % shoeColors.length : Math.floor(Math.random() * shoeColors.length)];
  const hairStyle = appearance.hairStyle !== undefined ? appearance.hairStyle : Math.floor(Math.random() * 6);
  const isMale = appearance.isMale !== undefined ? appearance.isMale : Math.random() > 0.5;
  
  const headY = pose === 'seated' ? 0.94 : 0.74;
  const bodyY = pose === 'seated' ? 0.6 : 0.42;
  const armY = pose === 'seated' ? 0.54 : 0.38;
  
  // LEGS
  if (pose === 'seated') {
    group.add(createVoxelBox(0.24, 0.08, 0.16, pants, 0, 0.42, 0.02));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, pants, -0.08, 0.38, 0.08, 8));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, pants, 0.08, 0.38, 0.08, 8));
    group.add(createVoxelSphere(0.045, pants, -0.08, 0.34, 0.16, 8));
    group.add(createVoxelSphere(0.045, pants, 0.08, 0.34, 0.16, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, pants, -0.08, 0.18, 0.18, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, pants, 0.08, 0.18, 0.18, 8));
    group.add(createVoxelBox(0.08, 0.05, 0.12, shoes, -0.08, 0.04, 0.2));
    group.add(createVoxelBox(0.08, 0.05, 0.12, shoes, 0.08, 0.04, 0.2));
  } else {
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, pants, -0.08, 0.125, 0, 8));
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, pants, 0.08, 0.125, 0, 8));
    group.add(createVoxelBox(0.09, 0.06, 0.14, shoes, -0.08, 0.03, 0.02));
    group.add(createVoxelBox(0.09, 0.06, 0.14, shoes, 0.08, 0.03, 0.02));
  }
  
  // BODY
  const bodyWidth = isMale ? 0.28 : 0.24;
  group.add(createVoxelBox(bodyWidth, 0.28, 0.18, shirt, 0, bodyY - 0.02, 0));
  if (isMale) {
    group.add(createVoxelBox(0.34, 0.08, 0.18, shirt, 0, bodyY + 0.12, 0));
  } else {
    group.add(createVoxelBox(0.28, 0.08, 0.18, shirt, 0, bodyY + 0.12, 0));
  }
  group.add(createVoxelBox(0.08, 0.06, 0.08, skin, 0, bodyY + 0.19, 0));
  
  // ARMS
  const armOffset = isMale ? 0.21 : 0.18;
  if (pose === 'carrying') {
    group.add(createVoxelCylinder(0.04, 0.035, 0.22, shirt, -armOffset, armY, 0, 8));
    group.add(createVoxelBox(0.06, 0.06, 0.06, skin, -armOffset, armY - 0.14, 0));
    const rightArm = createVoxelCylinder(0.04, 0.035, 0.22, shirt, 0.12, armY + 0.04, 0.1, 8);
    rightArm.rotation.x = -0.8;
    group.add(rightArm);
    const plate = new THREE.Group();
    plate.add(createVoxelCylinder(0.1, 0.08, 0.02, 0xFFFFF0, 0, 0, 0));
    const food = createVoxelSphere(0.06, 0xCD853F, 0, 0.04, 0, 8);
    food.scale.y = 0.6;
    plate.add(food);
    plate.position.set(0.12, armY, 0.28);
    plate.name = 'carryPlate';
    group.add(plate);
  } else {
    const armZ = pose === 'seated' ? 0.08 : 0;
    group.add(createVoxelCylinder(0.04, 0.035, 0.22, shirt, -armOffset, armY, armZ, 8));
    group.add(createVoxelCylinder(0.04, 0.035, 0.22, shirt, armOffset, armY, armZ, 8));
    const handY = pose === 'seated' ? armY - 0.06 : armY - 0.14;
    const handZ = pose === 'seated' ? 0.16 : 0;
    group.add(createVoxelBox(0.06, 0.06, 0.06, skin, -armOffset, handY, handZ));
    group.add(createVoxelBox(0.06, 0.06, 0.06, skin, armOffset, handY, handZ));
  }
  
  // HEAD
  group.add(createVoxelBox(0.2, 0.2, 0.2, skin, 0, headY, 0));
  group.add(createVoxelBox(0.03, 0.06, 0.04, skin, -0.11, headY, 0));
  group.add(createVoxelBox(0.03, 0.06, 0.04, skin, 0.11, headY, 0));
  
  createFullComboFace(group, headY, mood, skin, hair);
  createFullComboHair(group, headY, hair, hairStyle);
  
  // ACCESSORIES
  const hatType = appearance.hat;
  const glassesType = appearance.glasses;
  const extraAccessory = appearance.accessory;
  const hatColors = [0xd94a4a, 0x4a90d9, 0x2d2d2d, 0xf5f5dc, 0x228B22, 0xffd700, 0xff69b4];
  const hatColor = hatColors[Math.floor(Math.random() * hatColors.length)];
  const hatYOffset = pose === 'seated' ? 0.94 : 0.74;
  
  if (hatType === 0) {
    group.add(createVoxelBox(0.24, 0.08, 0.24, hatColor, 0, hatYOffset + 0.16, 0));
    group.add(createVoxelBox(0.22, 0.02, 0.12, hatColor, 0, hatYOffset + 0.12, 0.14));
  } else if (hatType === 1) {
    group.add(createVoxelBox(0.24, 0.12, 0.24, hatColor, 0, hatYOffset + 0.16, 0));
    group.add(createVoxelBox(0.16, 0.04, 0.16, hatColor, 0, hatYOffset + 0.24, 0));
  } else if (hatType === 2) {
    group.add(createVoxelBox(0.2, 0.1, 0.2, 0xf5deb3, 0, hatYOffset + 0.18, 0));
    group.add(createVoxelBox(0.36, 0.02, 0.36, 0xf5deb3, 0, hatYOffset + 0.14, 0));
  } else if (hatType === 3) {
    group.add(createVoxelBox(0.22, 0.06, 0.22, 0xffffff, 0, hatYOffset + 0.14, 0));
    group.add(createVoxelBox(0.2, 0.14, 0.2, 0xffffff, 0, hatYOffset + 0.24, 0));
  } else if (hatType === 4) {
    group.add(createVoxelBox(0.24, 0.04, 0.24, hatColor, 0, hatYOffset + 0.08, 0));
  }
  
  const glassesY = headY + 0.02;
  if (glassesType === 0) {
    const leftLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, -0.05, glassesY, 0.1);
    leftLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const rightLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, 0.05, glassesY, 0.1);
    rightLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    group.add(leftLens, rightLens);
    group.add(createVoxelBox(0.04, 0.015, 0.02, 0x333333, 0, glassesY, 0.1));
    group.add(createVoxelBox(0.02, 0.015, 0.1, 0x333333, -0.09, glassesY, 0.05));
    group.add(createVoxelBox(0.02, 0.015, 0.1, 0x333333, 0.09, glassesY, 0.05));
  } else if (glassesType === 1) {
    group.add(createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, -0.05, glassesY, 0.1));
    group.add(createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, 0.05, glassesY, 0.1));
    group.add(createVoxelBox(0.04, 0.02, 0.02, 0x1a1a1a, 0, glassesY, 0.1));
  } else if (glassesType === 2) {
    group.add(createVoxelBox(0.065, 0.065, 0.015, 0x8B4513, -0.05, glassesY, 0.1));
    group.add(createVoxelBox(0.065, 0.065, 0.015, 0x8B4513, 0.05, glassesY, 0.1));
    group.add(createVoxelBox(0.03, 0.015, 0.015, 0x8B4513, 0, glassesY, 0.1));
  }
  
  const neckY = bodyY + 0.19;
  if (extraAccessory === 0) {
    group.add(createVoxelSphere(0.02, 0xffd700, -0.11, headY - 0.02, 0, 6));
    group.add(createVoxelSphere(0.02, 0xffd700, 0.11, headY - 0.02, 0, 6));
  } else if (extraAccessory === 1) {
    const necklace = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.01, 6, 12),
      new THREE.MeshLambertMaterial({ color: 0xffd700 })
    );
    necklace.position.set(0, neckY - 0.05, 0.08);
    necklace.rotation.x = Math.PI / 2;
    group.add(necklace);
  } else if (extraAccessory === 2) {
    group.add(createVoxelBox(0.03, 0.03, 0.02, 0xd94a4a, 0, neckY - 0.06, 0.1));
    group.add(createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, -0.04, neckY - 0.06, 0.1));
    group.add(createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, 0.04, neckY - 0.06, 0.1));
  } else if (extraAccessory === 3) {
    const scarfColors = [0xd94a4a, 0x4a90d9, 0x4ad94a, 0xffd700, 0x9b4ad9];
    const scarfColor = scarfColors[Math.floor(Math.random() * scarfColors.length)];
    group.add(createVoxelBox(0.26, 0.06, 0.18, scarfColor, 0, neckY - 0.06, 0.02));
    group.add(createVoxelBox(0.06, 0.15, 0.03, scarfColor, 0.08, neckY - 0.14, 0.12));
  }
  
  return group;
}

// ============================================
// VIP CHARACTER CREATION FUNCTIONS
// ============================================

// Ghost VIP - spooky translucent visitor
function createGhostVIP(pose = 'standing') {
  const group = new THREE.Group();
  const ghostColor = 0xE8E8FF;
  const headY = pose === 'seated' ? 0.85 : 0.65;
  const bodyY = pose === 'seated' ? 0.45 : 0.3;
  
  // Ghost body - wavy bottom shape
  const bodyMat = new THREE.MeshLambertMaterial({ color: ghostColor, transparent: true, opacity: 0.7 });
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.4, 12), bodyMat);
  body.position.set(0, bodyY, 0);
  group.add(body);
  
  // Wavy bottom tendrils
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2;
    const tendril = new THREE.Mesh(
      new THREE.ConeGeometry(0.05, 0.15, 6),
      bodyMat
    );
    tendril.position.set(Math.cos(angle) * 0.1, bodyY - 0.25, Math.sin(angle) * 0.1);
    tendril.rotation.x = Math.PI;
    group.add(tendril);
  }
  
  // Ghost head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 10), bodyMat);
  head.position.set(0, headY, 0);
  head.scale.set(1, 1.1, 0.9);
  group.add(head);
  
  // Glowing eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x00FFFF, emissive: 0x00FFFF, emissiveIntensity: 0.5 });
  const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), eyeMat);
  leftEye.position.set(-0.05, headY + 0.02, 0.12);
  const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), eyeMat);
  rightEye.position.set(0.05, headY + 0.02, 0.12);
  group.add(leftEye, rightEye);
  
  // Spooky mouth (O shape)
  const mouth = new THREE.Mesh(
    new THREE.TorusGeometry(0.03, 0.01, 6, 12),
    new THREE.MeshLambertMaterial({ color: 0x4a4a6a })
  );
  mouth.position.set(0, headY - 0.06, 0.13);
  mouth.rotation.x = Math.PI / 2;
  group.add(mouth);
  
  // Arms if not seated
  if (pose !== 'seated') {
    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.2, 8), bodyMat);
    leftArm.position.set(-0.15, bodyY + 0.05, 0);
    leftArm.rotation.z = 0.5;
    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.2, 8), bodyMat);
    rightArm.position.set(0.15, bodyY + 0.05, 0);
    rightArm.rotation.z = -0.5;
    group.add(leftArm, rightArm);
  }
  
  group.userData.isVIP = true;
  group.userData.vipType = 'ghost';
  return group;
}

// Alien VIP - green skin, big eyes
function createAlienVIP(pose = 'standing') {
  const group = new THREE.Group();
  const alienSkin = 0x7ED321;
  const headY = pose === 'seated' ? 0.85 : 0.68;
  const bodyY = pose === 'seated' ? 0.5 : 0.35;
  
  // Body (gray suit)
  group.add(createVoxelCylinder(0.08, 0.1, 0.3, 0x444444, 0, bodyY, 0, 10));
  
  // Legs
  if (pose === 'seated') {
    group.add(createVoxelBox(0.16, 0.05, 0.08, 0x444444, 0, 0.35, 0.04));
    group.add(createVoxelBox(0.05, 0.05, 0.18, alienSkin, -0.05, 0.35, 0.14));
    group.add(createVoxelBox(0.05, 0.05, 0.18, alienSkin, 0.05, 0.35, 0.14));
    group.add(createVoxelSphere(0.03, alienSkin, -0.05, 0.35, 0.24, 8));
    group.add(createVoxelSphere(0.03, alienSkin, 0.05, 0.35, 0.24, 8));
    group.add(createVoxelCylinder(0.025, 0.02, 0.24, alienSkin, -0.05, 0.20, 0.26, 8));
    group.add(createVoxelCylinder(0.025, 0.02, 0.24, alienSkin, 0.05, 0.20, 0.26, 8));
    group.add(createVoxelSphere(0.03, alienSkin, -0.05, 0.07, 0.28));
    group.add(createVoxelSphere(0.03, alienSkin, 0.05, 0.07, 0.28));
  } else {
    group.add(createVoxelCylinder(0.025, 0.02, 0.25, alienSkin, -0.06, 0.12, 0, 8));
    group.add(createVoxelCylinder(0.025, 0.02, 0.25, alienSkin, 0.06, 0.12, 0, 8));
    group.add(createVoxelSphere(0.03, alienSkin, -0.06, 0.02, 0.02));
    group.add(createVoxelSphere(0.03, alienSkin, 0.06, 0.02, 0.02));
  }
  
  // Arms
  group.add(createVoxelCylinder(0.02, 0.015, 0.2, alienSkin, -0.12, bodyY, 0, 8));
  group.add(createVoxelCylinder(0.02, 0.015, 0.2, alienSkin, 0.12, bodyY, 0, 8));
  
  // Big alien head
  const headGeo = new THREE.SphereGeometry(0.16, 14, 12);
  const head = new THREE.Mesh(headGeo, new THREE.MeshLambertMaterial({ color: alienSkin }));
  head.position.set(0, headY, 0);
  head.scale.set(0.9, 1.2, 0.85);
  group.add(head);
  
  // Big black eyes
  const eyeGeo = new THREE.SphereGeometry(0.06, 10, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.06, headY + 0.02, 0.1);
  leftEye.scale.set(1, 1.3, 0.5);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.06, headY + 0.02, 0.1);
  rightEye.scale.set(1, 1.3, 0.5);
  group.add(leftEye, rightEye);
  
  // Small mouth
  group.add(createVoxelBox(0.03, 0.01, 0.01, 0x4a6a4a, 0, headY - 0.08, 0.12));
  
  group.userData.isVIP = true;
  group.userData.vipType = 'alien';
  return group;
}

// Cat Person VIP - cat ears and whiskers
function createCatPersonVIP(pose = 'standing') {
  const group = new THREE.Group();
  const catColor = 0xFFB366;
  const headY = pose === 'seated' ? 0.94 : 0.74;
  const bodyY = pose === 'seated' ? 0.6 : 0.42;
  
  // Use base Full Combo body
  const baseCustomer = createFullComboCustomer({ skinTone: 3, hairColor: 4, shirtColor: 8 }, pose, 'happy');
  
  // Copy all children except head-related items (we'll add cat features)
  baseCustomer.children.forEach(child => {
    if (child.position.y < headY - 0.15) {
      group.add(child.clone());
    }
  });
  
  // Cat head
  group.add(createVoxelBox(0.2, 0.18, 0.18, catColor, 0, headY, 0));
  
  // Cat ears
  group.add(createVoxelCone(0.05, 0.1, catColor, -0.08, headY + 0.14, 0, 4));
  group.add(createVoxelCone(0.05, 0.1, catColor, 0.08, headY + 0.14, 0, 4));
  group.add(createVoxelCone(0.03, 0.06, 0xFFB6C1, -0.08, headY + 0.12, 0, 4));
  group.add(createVoxelCone(0.03, 0.06, 0xFFB6C1, 0.08, headY + 0.12, 0, 4));
  
  // Cat eyes (yellow with vertical pupils)
  group.add(createVoxelBox(0.045, 0.05, 0.01, 0xFFFF00, -0.05, headY + 0.02, 0.09));
  group.add(createVoxelBox(0.045, 0.05, 0.01, 0xFFFF00, 0.05, headY + 0.02, 0.09));
  group.add(createVoxelBox(0.015, 0.04, 0.01, 0x1a1a1a, -0.05, headY + 0.02, 0.1));
  group.add(createVoxelBox(0.015, 0.04, 0.01, 0x1a1a1a, 0.05, headY + 0.02, 0.1));
  
  // Cat nose
  group.add(createVoxelSphere(0.02, 0xFF69B4, 0, headY - 0.02, 0.1, 6));
  
  // Whiskers
  group.add(createVoxelBox(0.08, 0.005, 0.005, 0x1a1a1a, -0.1, headY - 0.02, 0.08));
  group.add(createVoxelBox(0.08, 0.005, 0.005, 0x1a1a1a, -0.1, headY - 0.035, 0.08));
  group.add(createVoxelBox(0.08, 0.005, 0.005, 0x1a1a1a, 0.1, headY - 0.02, 0.08));
  group.add(createVoxelBox(0.08, 0.005, 0.005, 0x1a1a1a, 0.1, headY - 0.035, 0.08));
  
  // Cat smile
  group.add(createVoxelBox(0.02, 0.008, 0.008, 0x1a1a1a, -0.02, headY - 0.055, 0.095));
  group.add(createVoxelBox(0.02, 0.008, 0.008, 0x1a1a1a, 0.02, headY - 0.055, 0.095));
  
  // Tail (if standing)
  if (pose !== 'seated') {
    const tail = createVoxelCylinder(0.02, 0.015, 0.25, catColor, 0, 0.25, -0.15, 8);
    tail.rotation.x = -0.5;
    group.add(tail);
  }
  
  group.userData.isVIP = true;
  group.userData.vipType = 'catPerson';
  return group;
}

// Wizard VIP - pointy hat, long beard, staff
function createWizardVIP(pose = 'standing') {
  const group = new THREE.Group();
  const robeColor = 0x4B0082;
  const headY = pose === 'seated' ? 0.94 : 0.74;
  const bodyY = pose === 'seated' ? 0.6 : 0.42;
  const armY = pose === 'seated' ? 0.54 : 0.38;
  const skin = 0xE8BEAC;
  
  // Legs
  if (pose === 'seated') {
    group.add(createVoxelBox(0.24, 0.08, 0.16, robeColor, 0, 0.42, 0.02));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, robeColor, -0.08, 0.38, 0.08, 8));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, robeColor, 0.08, 0.38, 0.08, 8));
    group.add(createVoxelSphere(0.045, robeColor, -0.08, 0.34, 0.16, 8));
    group.add(createVoxelSphere(0.045, robeColor, 0.08, 0.34, 0.16, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, robeColor, -0.08, 0.18, 0.18, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, robeColor, 0.08, 0.18, 0.18, 8));
    group.add(createVoxelBox(0.08, 0.05, 0.12, 0x1a1a1a, -0.08, 0.04, 0.2));
    group.add(createVoxelBox(0.08, 0.05, 0.12, 0x1a1a1a, 0.08, 0.04, 0.2));
  } else {
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, robeColor, -0.08, 0.125, 0, 8));
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, robeColor, 0.08, 0.125, 0, 8));
    group.add(createVoxelBox(0.09, 0.06, 0.14, 0x1a1a1a, -0.08, 0.03, 0.02));
    group.add(createVoxelBox(0.09, 0.06, 0.14, 0x1a1a1a, 0.08, 0.03, 0.02));
  }
  
  // Robe body
  group.add(createVoxelBox(0.28, 0.28, 0.18, robeColor, 0, bodyY - 0.02, 0));
  group.add(createVoxelBox(0.34, 0.08, 0.18, robeColor, 0, bodyY + 0.12, 0));
  group.add(createVoxelBox(0.08, 0.06, 0.08, skin, 0, bodyY + 0.19, 0));
  
  // Arms
  group.add(createVoxelCylinder(0.04, 0.035, 0.22, robeColor, -0.21, armY, 0, 8));
  group.add(createVoxelCylinder(0.04, 0.035, 0.22, robeColor, 0.21, armY, 0, 8));
  group.add(createVoxelBox(0.06, 0.06, 0.06, skin, -0.21, armY - 0.14, 0));
  group.add(createVoxelBox(0.06, 0.06, 0.06, skin, 0.21, armY - 0.14, 0));
  
  // Staff (standing only)
  if (pose !== 'seated') {
    group.add(createVoxelCylinder(0.015, 0.015, 0.6, 0x8B4513, 0.26, 0.35, 0, 8));
    group.add(createVoxelSphere(0.04, 0x00FFFF, 0.26, 0.68, 0, 8));
  }
  
  // Head
  group.add(createVoxelBox(0.2, 0.2, 0.2, skin, 0, headY, 0));
  
  // Face
  group.add(createVoxelBox(0.04, 0.04, 0.01, 0xFFFFFF, -0.05, headY + 0.02, 0.1));
  group.add(createVoxelBox(0.04, 0.04, 0.01, 0xFFFFFF, 0.05, headY + 0.02, 0.1));
  group.add(createVoxelSphere(0.015, 0x2d2d2d, -0.05, headY + 0.02, 0.11, 6));
  group.add(createVoxelSphere(0.015, 0x2d2d2d, 0.05, headY + 0.02, 0.11, 6));
  group.add(createVoxelBox(0.04, 0.01, 0.01, 0xCCCCCC, -0.05, headY + 0.055, 0.1));
  group.add(createVoxelBox(0.04, 0.01, 0.01, 0xCCCCCC, 0.05, headY + 0.055, 0.1));
  group.add(createVoxelBox(0.02, 0.03, 0.015, skin, 0, headY - 0.01, 0.1));
  group.add(createVoxelBox(0.04, 0.006, 0.006, 0xB35555, 0, headY - 0.05, 0.1));
  
  // Wizard hat
  group.add(createVoxelCylinder(0.14, 0.14, 0.04, robeColor, 0, headY + 0.1, 0, 16));
  group.add(createVoxelCone(0.1, 0.25, robeColor, 0, headY + 0.26, 0, 12));
  group.add(createVoxelSphere(0.02, 0xFFD700, 0.06, headY + 0.2, 0.08));
  
  // Long grey hair
  group.add(createVoxelBox(0.18, 0.08, 0.04, 0xCCCCCC, 0, headY + 0.06, -0.1));
  group.add(createVoxelBox(0.16, 0.12, 0.04, 0xCCCCCC, 0, headY - 0.04, -0.12));
  group.add(createVoxelBox(0.14, 0.15, 0.04, 0xCCCCCC, 0, headY - 0.18, -0.12));
  group.add(createVoxelBox(0.04, 0.1, 0.08, 0xCCCCCC, -0.1, headY - 0.02, -0.04));
  group.add(createVoxelBox(0.04, 0.1, 0.08, 0xCCCCCC, 0.1, headY - 0.02, -0.04));
  
  // Long beard
  group.add(createVoxelBox(0.12, 0.15, 0.04, 0xCCCCCC, 0, headY - 0.15, 0.06));
  group.add(createVoxelBox(0.08, 0.1, 0.04, 0xCCCCCC, 0, headY - 0.28, 0.05));
  
  group.userData.isVIP = true;
  group.userData.vipType = 'wizard';
  return group;
}

// Robot VIP - metallic body, antenna
function createRobotVIP(pose = 'standing') {
  const group = new THREE.Group();
  const metalColor = 0xC0C0C0;
  const accentColor = 0x00BFFF;
  const headY = pose === 'seated' ? 0.94 : 0.74;
  const bodyY = pose === 'seated' ? 0.6 : 0.42;
  
  // Legs
  if (pose === 'seated') {
    group.add(createVoxelBox(0.24, 0.08, 0.16, metalColor, 0, 0.42, 0.02));
    group.add(createVoxelBox(0.08, 0.05, 0.18, metalColor, -0.08, 0.38, 0.1));
    group.add(createVoxelBox(0.08, 0.05, 0.18, metalColor, 0.08, 0.38, 0.1));
    group.add(createVoxelBox(0.08, 0.22, 0.08, metalColor, -0.08, 0.2, 0.2));
    group.add(createVoxelBox(0.08, 0.22, 0.08, metalColor, 0.08, 0.2, 0.2));
    group.add(createVoxelBox(0.1, 0.06, 0.14, 0x2d2d2d, -0.08, 0.05, 0.22));
    group.add(createVoxelBox(0.1, 0.06, 0.14, 0x2d2d2d, 0.08, 0.05, 0.22));
  } else {
    group.add(createVoxelBox(0.1, 0.25, 0.1, metalColor, -0.08, 0.125, 0));
    group.add(createVoxelBox(0.1, 0.25, 0.1, metalColor, 0.08, 0.125, 0));
    group.add(createVoxelBox(0.12, 0.06, 0.16, 0x2d2d2d, -0.08, 0.03, 0.02));
    group.add(createVoxelBox(0.12, 0.06, 0.16, 0x2d2d2d, 0.08, 0.03, 0.02));
  }
  
  // Body
  group.add(createVoxelBox(0.28, 0.28, 0.18, metalColor, 0, bodyY - 0.02, 0));
  group.add(createVoxelBox(0.32, 0.08, 0.18, metalColor, 0, bodyY + 0.12, 0));
  
  // Chest panel
  group.add(createVoxelBox(0.12, 0.12, 0.02, 0x2d2d2d, 0, bodyY, 0.1));
  group.add(createVoxelSphere(0.02, 0xFF0000, -0.03, bodyY + 0.02, 0.12, 6));
  group.add(createVoxelSphere(0.02, 0x00FF00, 0.03, bodyY + 0.02, 0.12, 6));
  group.add(createVoxelSphere(0.02, accentColor, 0, bodyY - 0.02, 0.12, 6));
  
  // Arms
  group.add(createVoxelBox(0.08, 0.22, 0.08, metalColor, -0.2, bodyY - 0.05, 0));
  group.add(createVoxelBox(0.08, 0.22, 0.08, metalColor, 0.2, bodyY - 0.05, 0));
  group.add(createVoxelSphere(0.05, 0x2d2d2d, -0.2, bodyY - 0.18, 0, 8));
  group.add(createVoxelSphere(0.05, 0x2d2d2d, 0.2, bodyY - 0.18, 0, 8));
  
  // Head
  group.add(createVoxelBox(0.22, 0.2, 0.2, metalColor, 0, headY, 0));
  
  // Screen face
  group.add(createVoxelBox(0.16, 0.12, 0.02, 0x1a1a1a, 0, headY, 0.1));
  
  // LED eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: accentColor, emissive: accentColor, emissiveIntensity: 0.3 });
  const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, 0.01), eyeMat);
  leftEye.position.set(-0.04, headY + 0.02, 0.115);
  const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, 0.01), eyeMat);
  rightEye.position.set(0.04, headY + 0.02, 0.115);
  group.add(leftEye, rightEye);
  
  // LED mouth (happy arc made of segments)
  group.add(createVoxelBox(0.02, 0.01, 0.01, accentColor, -0.04, headY - 0.04, 0.115));
  group.add(createVoxelBox(0.04, 0.01, 0.01, accentColor, 0, headY - 0.05, 0.115));
  group.add(createVoxelBox(0.02, 0.01, 0.01, accentColor, 0.04, headY - 0.04, 0.115));
  
  // Antenna
  group.add(createVoxelCylinder(0.01, 0.01, 0.1, metalColor, 0, headY + 0.15, 0, 6));
  group.add(createVoxelSphere(0.025, 0xFF0000, 0, headY + 0.22, 0, 8));
  
  group.userData.isVIP = true;
  group.userData.vipType = 'robot';
  return group;
}

// Superhero VIP - cape, mask, emblem
function createSuperheroVIP(pose = 'standing') {
  const group = new THREE.Group();
  const heroColor = 0xCC0000;
  const accentColor = 0xFFD700;
  const headY = pose === 'seated' ? 0.94 : 0.74;
  const bodyY = pose === 'seated' ? 0.6 : 0.42;
  const armY = pose === 'seated' ? 0.54 : 0.38;
  const skin = 0xE8BEAC;
  
  // Legs
  if (pose === 'seated') {
    group.add(createVoxelBox(0.24, 0.08, 0.16, 0x000066, 0, 0.42, 0.02));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, 0x000066, -0.08, 0.38, 0.08, 8));
    group.add(createVoxelCylinder(0.05, 0.045, 0.18, 0x000066, 0.08, 0.38, 0.08, 8));
    group.add(createVoxelSphere(0.045, 0x000066, -0.08, 0.34, 0.16, 8));
    group.add(createVoxelSphere(0.045, 0x000066, 0.08, 0.34, 0.16, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, 0x000066, -0.08, 0.18, 0.18, 8));
    group.add(createVoxelCylinder(0.045, 0.04, 0.22, 0x000066, 0.08, 0.18, 0.18, 8));
    group.add(createVoxelBox(0.08, 0.05, 0.12, heroColor, -0.08, 0.04, 0.2));
    group.add(createVoxelBox(0.08, 0.05, 0.12, heroColor, 0.08, 0.04, 0.2));
  } else {
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, 0x000066, -0.08, 0.125, 0, 8));
    group.add(createVoxelCylinder(0.05, 0.04, 0.25, 0x000066, 0.08, 0.125, 0, 8));
    group.add(createVoxelBox(0.09, 0.06, 0.14, heroColor, -0.08, 0.03, 0.02));
    group.add(createVoxelBox(0.09, 0.06, 0.14, heroColor, 0.08, 0.03, 0.02));
  }
  
  // Body
  group.add(createVoxelBox(0.28, 0.28, 0.18, heroColor, 0, bodyY - 0.02, 0));
  group.add(createVoxelBox(0.34, 0.08, 0.18, heroColor, 0, bodyY + 0.12, 0));
  group.add(createVoxelBox(0.08, 0.06, 0.08, skin, 0, bodyY + 0.19, 0));
  
  // Chest emblem
  group.add(createVoxelBox(0.08, 0.08, 0.02, accentColor, 0, bodyY + 0.1, 0.1));
  // Belt
  group.add(createVoxelBox(0.28, 0.04, 0.19, accentColor, 0, bodyY - 0.12, 0));
  // Cape
  group.add(createVoxelBox(0.3, 0.4, 0.03, heroColor, 0, bodyY - 0.1, -0.12));
  
  // Arms
  group.add(createVoxelCylinder(0.04, 0.035, 0.22, heroColor, -0.21, armY, 0, 8));
  group.add(createVoxelCylinder(0.04, 0.035, 0.22, heroColor, 0.21, armY, 0, 8));
  group.add(createVoxelBox(0.06, 0.06, 0.06, skin, -0.21, armY - 0.14, 0));
  group.add(createVoxelBox(0.06, 0.06, 0.06, skin, 0.21, armY - 0.14, 0));
  
  // Head
  group.add(createVoxelBox(0.2, 0.2, 0.2, skin, 0, headY, 0));
  
  // Mask
  group.add(createVoxelBox(0.21, 0.06, 0.21, 0x000066, 0, headY + 0.03, 0));
  
  // Eyes
  group.add(createVoxelBox(0.04, 0.04, 0.01, 0xFFFFFF, -0.05, headY + 0.02, 0.1));
  group.add(createVoxelBox(0.04, 0.04, 0.01, 0xFFFFFF, 0.05, headY + 0.02, 0.1));
  group.add(createVoxelSphere(0.015, 0x2d2d2d, -0.05, headY + 0.02, 0.11, 6));
  group.add(createVoxelSphere(0.015, 0x2d2d2d, 0.05, headY + 0.02, 0.11, 6));
  
  // Nose and confident smirk
  group.add(createVoxelBox(0.025, 0.03, 0.02, skin, 0, headY - 0.01, 0.1));
  group.add(createVoxelBox(0.012, 0.006, 0.006, 0xB35555, -0.02, headY - 0.05, 0.101));
  group.add(createVoxelBox(0.012, 0.006, 0.006, 0xB35555, 0, headY - 0.055, 0.101));
  group.add(createVoxelBox(0.015, 0.006, 0.006, 0xB35555, 0.02, headY - 0.048, 0.101));
  
  // Hair
  group.add(createVoxelBox(0.2, 0.08, 0.18, 0x1a1a1a, 0, headY + 0.1, -0.01));
  
  group.userData.isVIP = true;
  group.userData.vipType = 'superhero';
  return group;
}

// VIP creation dispatcher
function createVIPCustomer(vipType, pose = 'standing') {
  switch(vipType) {
    case 'ghost': return createGhostVIP(pose);
    case 'alien': return createAlienVIP(pose);
    case 'catPerson': return createCatPersonVIP(pose);
    case 'wizard': return createWizardVIP(pose);
    case 'robot': return createRobotVIP(pose);
    case 'superhero': return createSuperheroVIP(pose);
    default: return createAlienVIP(pose);
  }
}

// List of VIP types for random selection
const VIP_TYPES = ['ghost', 'alien', 'catPerson', 'wizard', 'robot', 'superhero'];

// LEGACY: Original seated customer function
function createSeatedCustomer(appearance = {}) {
  const group = new THREE.Group();
  
  // Use appearance object or generate defaults for backwards compatibility
  const isMale = appearance.isMale !== undefined ? appearance.isMale : Math.random() > 0.5;
  
  // Expanded skin tone palette (more diverse range)
  const skinTones = [
    0xffe5d4, // Very light
    0xffdbac, // Light
    0xf5d0c5, // Light rosy
    0xe8beac, // Medium light
    0xd4a574, // Medium tan
    0xc68642, // Medium brown
    0x8d5524, // Brown
    0x6b4423, // Dark brown
  ];
  const skinColor = skinTones[appearance.skinTone !== undefined ? appearance.skinTone % skinTones.length : Math.floor(Math.random() * skinTones.length)];
  
  // Expanded outfit/shirt colors (brighter, more variety)
  const outfitColors = [
    0x4a90d9, // Blue
    0xd94a4a, // Red
    0x4ad94a, // Green
    0xd9d94a, // Yellow
    0x9b4ad9, // Purple
    0xd94a9b, // Pink
    0x4ad9d9, // Cyan
    0xff6b35, // Orange
    0x2d5a27, // Forest green
    0x8b4513, // Brown
    0xf5f5dc, // Cream/beige
    0x191970, // Navy
    0x800020, // Burgundy
    0x40826d, // Teal
  ];
  const outfitColor = outfitColors[appearance.shirtColor !== undefined ? appearance.shirtColor % outfitColors.length : Math.floor(Math.random() * outfitColors.length)];
  
  // Expanded pants colors
  const pantsColors = [
    0x2d2d2d, // Dark gray
    0x1a1a4e, // Navy
    0x4a3728, // Brown
    0x2d4a2d, // Dark green
    0x4a2d4a, // Dark purple
    0x1a1a1a, // Black
    0x6b5b4f, // Taupe
    0x4a4a4a, // Medium gray
    0x5c4033, // Coffee
    0x3d3d6b, // Denim blue
  ];
  const pantsColor = pantsColors[appearance.pantsColor !== undefined ? appearance.pantsColor % pantsColors.length : Math.floor(Math.random() * pantsColors.length)];
  
  // Expanded hair colors
  const hairColors = [
    0x2c1810, // Dark brown
    0x4a3728, // Medium brown
    0x8b4513, // Light brown
    0x1a1a1a, // Black
    0xd4a574, // Blonde
    0xc41e3a, // Red/auburn
    0xffd700, // Platinum blonde
    0x808080, // Gray
    0x654321, // Chestnut
    0xffa07a, // Strawberry blonde
  ];
  const hairColor = hairColors[appearance.hairColor !== undefined ? appearance.hairColor % hairColors.length : Math.floor(Math.random() * hairColors.length)];
  
  // Shoe colors
  const shoeColors = [0x1a1a1a, 0x3d3d3d, 0x8b4513, 0x2d2d4a, 0x4a2d2d, 0xf5f5dc];
  const shoeColor = shoeColors[appearance.shoeColor !== undefined ? appearance.shoeColor % shoeColors.length : Math.floor(Math.random() * shoeColors.length)];
  
  // Hair style
  const hairStyle = appearance.hairStyle !== undefined ? appearance.hairStyle : Math.floor(Math.random() * 6);
  
  // Body dimensions vary by gender
  const bodyWidth = isMale ? 0.28 : 0.24;
  const bodyDepth = isMale ? 0.2 : 0.16;
  const shoulderWidth = isMale ? 0.32 : 0.26;
  
  // Upper legs (horizontal, sitting on chair)
  const leftUpperLeg = createVoxelBox(0.1, 0.08, 0.22, pantsColor, -0.08, 0.38, 0.05);
  const rightUpperLeg = createVoxelBox(0.1, 0.08, 0.22, pantsColor, 0.08, 0.38, 0.05);
  group.add(leftUpperLeg, rightUpperLeg);
  
  // Lower legs (hanging down from chair)
  const leftLowerLeg = createVoxelBox(0.08, 0.25, 0.08, pantsColor, -0.08, 0.15, 0.18);
  const rightLowerLeg = createVoxelBox(0.08, 0.25, 0.08, pantsColor, 0.08, 0.15, 0.18);
  group.add(leftLowerLeg, rightLowerLeg);
  
  // Feet/Shoes
  const leftFoot = createVoxelBox(0.08, 0.05, 0.12, shoeColor, -0.08, 0.025, 0.2);
  const rightFoot = createVoxelBox(0.08, 0.05, 0.12, shoeColor, 0.08, 0.025, 0.2);
  group.add(leftFoot, rightFoot);
  
  // Body/Torso (sitting upright)
  const body = createVoxelBox(bodyWidth, 0.32, bodyDepth, outfitColor, 0, 0.6, -0.02);
  body.castShadow = true;
  group.add(body);
  
  // Shoulders (wider for males)
  if (isMale) {
    const shoulders = createVoxelBox(shoulderWidth, 0.08, bodyDepth, outfitColor, 0, 0.74, -0.02);
    group.add(shoulders);
  }
  
  // Arms
  const armColor = isMale ? outfitColor : skinColor; // Males have sleeves, females may have sleeveless
  const leftArm = createVoxelBox(0.07, 0.2, 0.07, armColor, isMale ? -0.19 : -0.16, 0.54, 0.1);
  leftArm.rotation.x = -0.3;
  const rightArm = createVoxelBox(0.07, 0.2, 0.07, armColor, isMale ? 0.19 : 0.16, 0.54, 0.1);
  rightArm.rotation.x = -0.3;
  group.add(leftArm, rightArm);
  
  // Hands
  const leftHand = createVoxelBox(0.055, 0.055, 0.055, skinColor, isMale ? -0.19 : -0.16, 0.46, 0.2);
  const rightHand = createVoxelBox(0.055, 0.055, 0.055, skinColor, isMale ? 0.19 : 0.16, 0.46, 0.2);
  group.add(leftHand, rightHand);
  
  // Neck
  const neck = createVoxelBox(0.08, 0.06, 0.08, skinColor, 0, 0.8, 0);
  group.add(neck);
  
  // Head
  const head = createVoxelBox(0.2, 0.2, 0.2, skinColor, 0, 0.94, 0);
  head.castShadow = true;
  group.add(head);
  
  // Hair - different styles (6 options)
  if (hairStyle === 0) {
    // Short hair (male style)
    const hair = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.06, -0.01);
    group.add(hair);
  } else if (hairStyle === 1) {
    // Long hair (female style)
    const hairTop = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.06, -0.01);
    const hairBack = createVoxelBox(0.2, 0.25, 0.06, hairColor, 0, 0.9, -0.12);
    group.add(hairTop, hairBack);
  } else if (hairStyle === 2) {
    // Ponytail
    const hairTop = createVoxelBox(0.22, 0.06, 0.2, hairColor, 0, 1.06, 0);
    const ponytail = createVoxelBox(0.08, 0.15, 0.08, hairColor, 0, 0.95, -0.15);
    group.add(hairTop, ponytail);
  } else if (hairStyle === 3) {
    // Bald/very short
    const hairStubble = createVoxelBox(0.21, 0.03, 0.21, hairColor, 0, 1.05, 0);
    group.add(hairStubble);
  } else {
    // Curly/afro style
    const hairAfro = createVoxelBox(0.26, 0.12, 0.26, hairColor, 0, 1.08, 0);
    group.add(hairAfro);
  }
  
  // === ACCESSORIES ===
  const hatType = appearance.hat;
  const glassesType = appearance.glasses;
  const extraAccessory = appearance.accessory;
  
  // Hat colors
  const hatColors = [0xd94a4a, 0x4a90d9, 0x2d2d2d, 0xf5f5dc, 0x228B22, 0xffd700, 0xff69b4];
  const hatColor = hatColors[Math.floor(Math.random() * hatColors.length)];
  
  // Hats (rendered on top of head, may cover hair)
  if (hatType === 0) {
    // Baseball cap
    const capTop = createVoxelBox(0.24, 0.08, 0.24, hatColor, 0, 1.1, 0);
    const brim = createVoxelBox(0.22, 0.02, 0.12, hatColor, 0, 1.06, 0.14);
    group.add(capTop, brim);
  } else if (hatType === 1) {
    // Beanie
    const beanie = createVoxelBox(0.24, 0.12, 0.24, hatColor, 0, 1.1, 0);
    const beanieTop = createVoxelBox(0.16, 0.04, 0.16, hatColor, 0, 1.18, 0);
    group.add(beanie, beanieTop);
  } else if (hatType === 2) {
    // Sun hat / wide brim
    const hatTop = createVoxelBox(0.2, 0.1, 0.2, 0xf5deb3, 0, 1.12, 0);
    const brim = createVoxelBox(0.36, 0.02, 0.36, 0xf5deb3, 0, 1.08, 0);
    group.add(hatTop, brim);
  } else if (hatType === 3) {
    // Chef toque (rare customer who's also a chef!)
    const toqueBase = createVoxelBox(0.22, 0.06, 0.22, 0xffffff, 0, 1.08, 0);
    const toquePuff = createVoxelBox(0.2, 0.14, 0.2, 0xffffff, 0, 1.18, 0);
    group.add(toqueBase, toquePuff);
  } else if (hatType === 4) {
    // Headband
    const headband = createVoxelBox(0.24, 0.04, 0.24, hatColor, 0, 1.02, 0);
    group.add(headband);
  }
  
  // Glasses
  if (glassesType === 0) {
    // Regular glasses
    const leftLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, -0.05, 0.96, 0.1);
    leftLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const rightLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, 0.05, 0.96, 0.1);
    rightLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const bridge = createVoxelBox(0.04, 0.015, 0.02, 0x333333, 0, 0.96, 0.1);
    const leftArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, -0.09, 0.96, 0.05);
    const rightArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, 0.09, 0.96, 0.05);
    group.add(leftLens, rightLens, bridge, leftArm, rightArm);
  } else if (glassesType === 1) {
    // Sunglasses
    const leftLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, -0.05, 0.96, 0.1);
    const rightLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, 0.05, 0.96, 0.1);
    const bridge = createVoxelBox(0.04, 0.02, 0.02, 0x1a1a1a, 0, 0.96, 0.1);
    group.add(leftLens, rightLens, bridge);
  } else if (glassesType === 2) {
    // Round hipster glasses
    const frameColor = 0x8B4513;
    const leftFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, -0.05, 0.96, 0.1);
    const rightFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, 0.05, 0.96, 0.1);
    const bridge = createVoxelBox(0.03, 0.015, 0.015, frameColor, 0, 0.96, 0.1);
    group.add(leftFrame, rightFrame, bridge);
  }
  
  // Extra accessories
  if (extraAccessory === 0) {
    // Earrings (small spheres)
    const earringMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
    const leftEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    leftEarring.position.set(-0.11, 0.92, 0);
    const rightEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    rightEarring.position.set(0.11, 0.92, 0);
    group.add(leftEarring, rightEarring);
  } else if (extraAccessory === 1) {
    // Necklace
    const necklace = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.01, 6, 12),
      new THREE.MeshLambertMaterial({ color: 0xffd700 })
    );
    necklace.position.set(0, 0.76, 0.08);
    necklace.rotation.x = Math.PI / 2;
    group.add(necklace);
  } else if (extraAccessory === 2) {
    // Bow tie
    const bowCenter = createVoxelBox(0.03, 0.03, 0.02, 0xd94a4a, 0, 0.76, 0.1);
    const bowLeft = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, -0.04, 0.76, 0.1);
    const bowRight = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, 0.04, 0.76, 0.1);
    group.add(bowCenter, bowLeft, bowRight);
  } else if (extraAccessory === 3) {
    // Scarf
    const scarfColors = [0xd94a4a, 0x4a90d9, 0x4ad94a, 0xffd700, 0x9b4ad9];
    const scarfColor = scarfColors[Math.floor(Math.random() * scarfColors.length)];
    const scarfWrap = createVoxelBox(0.26, 0.06, 0.18, scarfColor, 0, 0.76, 0.02);
    const scarfHang = createVoxelBox(0.06, 0.15, 0.03, scarfColor, 0.08, 0.68, 0.12);
    group.add(scarfWrap, scarfHang);
  }
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.022, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.05, 0.96, 0.09);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.05, 0.96, 0.09);
  group.add(leftEye, rightEye);
  
  // Simple smile
  const smileGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.9, 0.09);
  smile.rotation.x = Math.PI;
  smile.rotation.z = Math.PI;
  group.add(smile);
  
  return group;
}

function createStandingCustomer(appearance = {}) {
  const group = new THREE.Group();
  
  // Use appearance object or generate defaults for backwards compatibility
  const isMale = appearance.isMale !== undefined ? appearance.isMale : Math.random() > 0.5;
  
  // Same expanded palettes as seated customer
  const skinTones = [
    0xffe5d4, 0xffdbac, 0xf5d0c5, 0xe8beac, 
    0xd4a574, 0xc68642, 0x8d5524, 0x6b4423
  ];
  const skinColor = skinTones[appearance.skinTone !== undefined ? appearance.skinTone % skinTones.length : Math.floor(Math.random() * skinTones.length)];
  
  const outfitColors = [
    0x4a90d9, 0xd94a4a, 0x4ad94a, 0xd9d94a, 0x9b4ad9, 0xd94a9b, 0x4ad9d9,
    0xff6b35, 0x2d5a27, 0x8b4513, 0xf5f5dc, 0x191970, 0x800020, 0x40826d
  ];
  const outfitColor = outfitColors[appearance.shirtColor !== undefined ? appearance.shirtColor % outfitColors.length : Math.floor(Math.random() * outfitColors.length)];
  
  const pantsColors = [
    0x2d2d2d, 0x1a1a4e, 0x4a3728, 0x2d4a2d, 0x4a2d4a,
    0x1a1a1a, 0x6b5b4f, 0x4a4a4a, 0x5c4033, 0x3d3d6b
  ];
  const pantsColor = pantsColors[appearance.pantsColor !== undefined ? appearance.pantsColor % pantsColors.length : Math.floor(Math.random() * pantsColors.length)];
  
  const hairColors = [
    0x2c1810, 0x4a3728, 0x8b4513, 0x1a1a1a, 0xd4a574,
    0xc41e3a, 0xffd700, 0x808080, 0x654321, 0xffa07a
  ];
  const hairColor = hairColors[appearance.hairColor !== undefined ? appearance.hairColor % hairColors.length : Math.floor(Math.random() * hairColors.length)];
  
  const shoeColors = [0x1a1a1a, 0x3d3d3d, 0x8b4513, 0x2d2d4a, 0x4a2d2d, 0xf5f5dc];
  const shoeColor = shoeColors[appearance.shoeColor !== undefined ? appearance.shoeColor % shoeColors.length : Math.floor(Math.random() * shoeColors.length)];
  
  const hairStyle = appearance.hairStyle !== undefined ? appearance.hairStyle : Math.floor(Math.random() * 6);
  
  const bodyWidth = isMale ? 0.28 : 0.24;
  const bodyDepth = isMale ? 0.2 : 0.16;
  const shoulderWidth = isMale ? 0.32 : 0.26;
  
  // Standing legs (vertical)
  const leftLeg = createVoxelBox(0.09, 0.35, 0.09, pantsColor, -0.08, 0.175, 0);
  const rightLeg = createVoxelBox(0.09, 0.35, 0.09, pantsColor, 0.08, 0.175, 0);
  group.add(leftLeg, rightLeg);
  
  // Feet/Shoes
  const leftFoot = createVoxelBox(0.09, 0.05, 0.14, shoeColor, -0.08, 0.025, 0.02);
  const rightFoot = createVoxelBox(0.09, 0.05, 0.14, shoeColor, 0.08, 0.025, 0.02);
  group.add(leftFoot, rightFoot);
  
  // Body/Torso (standing upright)
  const body = createVoxelBox(bodyWidth, 0.35, bodyDepth, outfitColor, 0, 0.55, 0);
  body.castShadow = true;
  group.add(body);
  
  // Shoulders (wider for males)
  if (isMale) {
    const shoulders = createVoxelBox(shoulderWidth, 0.08, bodyDepth, outfitColor, 0, 0.71, 0);
    group.add(shoulders);
  }
  
  // Arms (hanging at sides)
  const armColor = isMale ? outfitColor : skinColor;
  const leftArm = createVoxelBox(0.07, 0.25, 0.07, armColor, isMale ? -0.19 : -0.16, 0.48, 0);
  const rightArm = createVoxelBox(0.07, 0.25, 0.07, armColor, isMale ? 0.19 : 0.16, 0.48, 0);
  group.add(leftArm, rightArm);
  
  // Hands
  const leftHand = createVoxelBox(0.055, 0.06, 0.055, skinColor, isMale ? -0.19 : -0.16, 0.34, 0);
  const rightHand = createVoxelBox(0.055, 0.06, 0.055, skinColor, isMale ? 0.19 : 0.16, 0.34, 0);
  group.add(leftHand, rightHand);
  
  // Neck
  const neck = createVoxelBox(0.08, 0.06, 0.08, skinColor, 0, 0.78, 0);
  group.add(neck);
  
  // Head
  const head = createVoxelBox(0.2, 0.2, 0.2, skinColor, 0, 0.92, 0);
  head.castShadow = true;
  group.add(head);
  
  // Hair - same styles as seated (6 options)
  if (hairStyle === 0) {
    const hair = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.04, -0.01);
    group.add(hair);
  } else if (hairStyle === 1) {
    const hairTop = createVoxelBox(0.22, 0.08, 0.22, hairColor, 0, 1.04, -0.01);
    const hairBack = createVoxelBox(0.2, 0.25, 0.06, hairColor, 0, 0.88, -0.12);
    group.add(hairTop, hairBack);
  } else if (hairStyle === 2) {
    const hairTop = createVoxelBox(0.22, 0.06, 0.2, hairColor, 0, 1.04, 0);
    const ponytail = createVoxelBox(0.08, 0.15, 0.08, hairColor, 0, 0.93, -0.15);
    group.add(hairTop, ponytail);
  } else if (hairStyle === 3) {
    const hairStubble = createVoxelBox(0.21, 0.03, 0.21, hairColor, 0, 1.03, 0);
    group.add(hairStubble);
  } else {
    const hairAfro = createVoxelBox(0.26, 0.12, 0.26, hairColor, 0, 1.06, 0);
    group.add(hairAfro);
  }
  
  // === ACCESSORIES (same as seated, adjusted Y positions for standing) ===
  const hatType = appearance.hat;
  const glassesType = appearance.glasses;
  const extraAccessory = appearance.accessory;
  
  // Hat colors
  const hatColors = [0xd94a4a, 0x4a90d9, 0x2d2d2d, 0xf5f5dc, 0x228B22, 0xffd700, 0xff69b4];
  const hatColor = hatColors[Math.floor(Math.random() * hatColors.length)];
  
  // Hats
  if (hatType === 0) {
    // Baseball cap
    const capTop = createVoxelBox(0.24, 0.08, 0.24, hatColor, 0, 1.08, 0);
    const brim = createVoxelBox(0.22, 0.02, 0.12, hatColor, 0, 1.04, 0.14);
    group.add(capTop, brim);
  } else if (hatType === 1) {
    // Beanie
    const beanie = createVoxelBox(0.24, 0.12, 0.24, hatColor, 0, 1.08, 0);
    const beanieTop = createVoxelBox(0.16, 0.04, 0.16, hatColor, 0, 1.16, 0);
    group.add(beanie, beanieTop);
  } else if (hatType === 2) {
    // Sun hat / wide brim
    const hatTop = createVoxelBox(0.2, 0.1, 0.2, 0xf5deb3, 0, 1.1, 0);
    const brim = createVoxelBox(0.36, 0.02, 0.36, 0xf5deb3, 0, 1.06, 0);
    group.add(hatTop, brim);
  } else if (hatType === 3) {
    // Chef toque
    const toqueBase = createVoxelBox(0.22, 0.06, 0.22, 0xffffff, 0, 1.06, 0);
    const toquePuff = createVoxelBox(0.2, 0.14, 0.2, 0xffffff, 0, 1.16, 0);
    group.add(toqueBase, toquePuff);
  } else if (hatType === 4) {
    // Headband
    const headband = createVoxelBox(0.24, 0.04, 0.24, hatColor, 0, 1.0, 0);
    group.add(headband);
  }
  
  // Glasses
  if (glassesType === 0) {
    // Regular glasses
    const leftLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, -0.05, 0.94, 0.1);
    leftLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const rightLens = createVoxelBox(0.06, 0.05, 0.02, 0x87CEEB, 0.05, 0.94, 0.1);
    rightLens.material = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
    const bridge = createVoxelBox(0.04, 0.015, 0.02, 0x333333, 0, 0.94, 0.1);
    const leftArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, -0.09, 0.94, 0.05);
    const rightArm = createVoxelBox(0.02, 0.015, 0.1, 0x333333, 0.09, 0.94, 0.05);
    group.add(leftLens, rightLens, bridge, leftArm, rightArm);
  } else if (glassesType === 1) {
    // Sunglasses
    const leftLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, -0.05, 0.94, 0.1);
    const rightLens = createVoxelBox(0.07, 0.05, 0.02, 0x1a1a1a, 0.05, 0.94, 0.1);
    const bridge = createVoxelBox(0.04, 0.02, 0.02, 0x1a1a1a, 0, 0.94, 0.1);
    group.add(leftLens, rightLens, bridge);
  } else if (glassesType === 2) {
    // Round hipster glasses
    const frameColor = 0x8B4513;
    const leftFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, -0.05, 0.94, 0.1);
    const rightFrame = createVoxelBox(0.065, 0.065, 0.015, frameColor, 0.05, 0.94, 0.1);
    const bridge = createVoxelBox(0.03, 0.015, 0.015, frameColor, 0, 0.94, 0.1);
    group.add(leftFrame, rightFrame, bridge);
  }
  
  // Extra accessories
  if (extraAccessory === 0) {
    // Earrings
    const earringMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
    const leftEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    leftEarring.position.set(-0.11, 0.9, 0);
    const rightEarring = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), earringMat);
    rightEarring.position.set(0.11, 0.9, 0);
    group.add(leftEarring, rightEarring);
  } else if (extraAccessory === 1) {
    // Necklace
    const necklace = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.01, 6, 12),
      new THREE.MeshLambertMaterial({ color: 0xffd700 })
    );
    necklace.position.set(0, 0.73, 0.08);
    necklace.rotation.x = Math.PI / 2;
    group.add(necklace);
  } else if (extraAccessory === 2) {
    // Bow tie
    const bowCenter = createVoxelBox(0.03, 0.03, 0.02, 0xd94a4a, 0, 0.73, 0.1);
    const bowLeft = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, -0.04, 0.73, 0.1);
    const bowRight = createVoxelBox(0.05, 0.04, 0.015, 0xd94a4a, 0.04, 0.73, 0.1);
    group.add(bowCenter, bowLeft, bowRight);
  } else if (extraAccessory === 3) {
    // Scarf
    const scarfColors = [0xd94a4a, 0x4a90d9, 0x4ad94a, 0xffd700, 0x9b4ad9];
    const scarfColor = scarfColors[Math.floor(Math.random() * scarfColors.length)];
    const scarfWrap = createVoxelBox(0.26, 0.06, 0.18, scarfColor, 0, 0.73, 0.02);
    const scarfHang = createVoxelBox(0.06, 0.15, 0.03, scarfColor, 0.08, 0.65, 0.12);
    group.add(scarfWrap, scarfHang);
  }
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.022, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.05, 0.94, 0.09);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.05, 0.94, 0.09);
  group.add(leftEye, rightEye);
  
  // Smile
  const smileGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.88, 0.09);
  smile.rotation.x = Math.PI;
  smile.rotation.z = Math.PI;
  group.add(smile);
  
  // Plate (for carrying food) - hidden by default, shown when hasPlate is true
  const plateGroup = new THREE.Group();
  plateGroup.name = 'carryPlate';
  
  const plate = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.16, 0.03, 12),
    new THREE.MeshLambertMaterial({ color: 0xffffff })
  );
  plate.position.y = 0;
  plateGroup.add(plate);
  
  // Food on plate
  const food = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 8, 6),
    new THREE.MeshLambertMaterial({ color: 0xCD853F })
  );
  food.position.y = 0.06;
  food.scale.y = 0.6;
  plateGroup.add(food);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front of customer, at hand height
  plateGroup.visible = false; // Hidden by default
  group.add(plateGroup);
  
  return group;
}

// Wrapper to create customer with specified pose and plate visibility
function createCustomer(appearance, pose = 'seated', hasPlate = false, mood = 'happy') {
  // Handle backwards compatibility - if appearance is a number, treat as colorIndex
  const appearanceObj = typeof appearance === 'number' ? {} : (appearance || {});
  
  // Check if this is a VIP customer
  if (appearanceObj.isVIP && appearanceObj.vipType) {
    const vipCustomer = createVIPCustomer(appearanceObj.vipType, pose);
    vipCustomer.userData.isVIP = true;
    vipCustomer.userData.vipType = appearanceObj.vipType;
    return vipCustomer;
  }
  
  // Use new Full Combo system for regular customers
  const customer = createFullComboCustomer(appearanceObj, pose, mood);
  
  // Show plate if carrying food (Full Combo already handles this in 'carrying' pose)
  if (pose === 'standing' && hasPlate) {
    const plateObj = customer.getObjectByName('carryPlate');
    if (plateObj) plateObj.visible = true;
  }
  
  return customer;
}

// Helper to convert patience to mood
function patienceToMood(patience) {
  if (patience >= 80) return 'happy';
  if (patience >= 60) return 'neutral';
  if (patience >= 40) return 'annoyed';
  if (patience >= 20) return 'angry';
  return 'sad';
}

function createChef(avatarOptions = {}) {
  const group = new THREE.Group();
  
  // Get colors from options with defaults
  const gender = avatarOptions.gender || 'female';
  const skinTone = AVATAR_OPTIONS.skinTones.find(s => s.id === avatarOptions.skinTone) || AVATAR_OPTIONS.skinTones[0];
  const hairColor = AVATAR_OPTIONS.hairColors.find(h => h.id === avatarOptions.hairColor) || AVATAR_OPTIONS.hairColors[1];
  const apronColor = AVATAR_OPTIONS.apronColors.find(a => a.id === avatarOptions.apronColor) || AVATAR_OPTIONS.apronColors[0];
  const outfitColor = AVATAR_OPTIONS.outfitColors.find(o => o.id === avatarOptions.outfitColor) || AVATAR_OPTIONS.outfitColors[0];
  const hairStyle = avatarOptions.hairStyle || 'short';
  
  // Legs (dark pants)
  const leftLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, -0.08, 0.125, 0);
  const rightLeg = createVoxelBox(0.1, 0.25, 0.1, 0x2d2d2d, 0.08, 0.125, 0);
  group.add(leftLeg, rightLeg);
  
  // Body (chef coat - customizable color)
  const bodyWidth = gender === 'female' ? 0.28 : 0.32;
  const body = createVoxelBox(bodyWidth, 0.4, 0.22, outfitColor.color, 0, 0.5, 0);
  group.add(body);
  
  // Apron (customizable color)
  const apron = createVoxelBox(0.26, 0.3, 0.05, apronColor.color, 0, 0.45, 0.1);
  group.add(apron);
  
  // Arms (same as outfit)
  const armOffset = gender === 'female' ? 0.20 : 0.24;
  const leftArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, -armOffset, 0.5, 0);
  const rightArm = createVoxelBox(0.1, 0.3, 0.1, outfitColor.color, armOffset, 0.5, 0);
  group.add(leftArm, rightArm);
  
  // Hands (skin color - customizable)
  const leftHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, -armOffset, 0.3, 0);
  const rightHand = createVoxelBox(0.08, 0.1, 0.08, skinTone.color, armOffset, 0.3, 0);
  group.add(leftHand, rightHand);
  
  // Head (skin - customizable)
  const head = createVoxelBox(0.26, 0.26, 0.26, skinTone.color, 0, 0.93, 0);
  group.add(head);
  
  // Hair (customizable color and style)
  if (hairStyle !== 'none') {
    if (hairStyle === 'short') {
      // Short hair peeking from under hat
      const hair = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hair);
    } else if (hairStyle === 'bun') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Bun behind hat
      const bunGeo = new THREE.SphereGeometry(0.12, 8, 6);
      const bunMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const bun = new THREE.Mesh(bunGeo, bunMat);
      bun.position.set(0, 1.2, -0.15);
      group.add(bun);
    } else if (hairStyle === 'ponytail') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Ponytail
      const tailGeo = new THREE.CylinderGeometry(0.06, 0.04, 0.35, 8);
      const tailMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.position.set(0, 1.0, -0.2);
      tail.rotation.x = 0.5;
      group.add(tail);
    } else if (hairStyle === 'long') {
      // Hair under hat
      const hairBase = createVoxelBox(0.27, 0.08, 0.27, hairColor.color, 0, 0.98, 0);
      group.add(hairBase);
      // Long flowing hair down both sides
      const longHairGeo = new THREE.BoxGeometry(0.08, 0.4, 0.1);
      const longHairMat = new THREE.MeshLambertMaterial({ color: hairColor.color });
      const leftHair = new THREE.Mesh(longHairGeo, longHairMat);
      leftHair.position.set(-0.16, 0.75, -0.02);
      group.add(leftHair);
      const rightHair = new THREE.Mesh(longHairGeo, longHairMat);
      rightHair.position.set(0.16, 0.75, -0.02);
      group.add(rightHair);
      // Back hair
      const backHairGeo = new THREE.BoxGeometry(0.24, 0.35, 0.08);
      const backHair = new THREE.Mesh(backHairGeo, longHairMat);
      backHair.position.set(0, 0.78, -0.14);
      group.add(backHair);
    }
  }
  
  // Chef Hat (white toque)
  const hatBase = createVoxelBox(0.28, 0.08, 0.28, 0xffffff, 0, 1.1, 0);
  group.add(hatBase);
  const hatTop = createVoxelBox(0.24, 0.2, 0.24, 0xffffff, 0, 1.25, 0);
  group.add(hatTop);
  const hatPuff = createVoxelBox(0.26, 0.1, 0.26, 0xffffff, 0, 1.38, 0);
  group.add(hatPuff);
  
  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.035, 8, 8);
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3d2314 });
  const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 0.95, 0.12);
  const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 0.95, 0.12);
  group.add(leftEye, rightEye);
  
  // Eyelashes for female
  if (gender === 'female') {
    const lashMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
    // Left eye lashes
    const leftLashGeo = new THREE.BoxGeometry(0.06, 0.01, 0.01);
    const leftLash = new THREE.Mesh(leftLashGeo, lashMat);
    leftLash.position.set(-0.07, 0.975, 0.13);
    group.add(leftLash);
    // Right eye lashes
    const rightLash = new THREE.Mesh(leftLashGeo, lashMat);
    rightLash.position.set(0.07, 0.975, 0.13);
    group.add(rightLash);
  }
  
  // Smile - happy face!
  const smileGeo = new THREE.TorusGeometry(0.05, 0.015, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0xcc6666 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, 0.86, 0.13);
  smile.rotation.z = Math.PI; // Curve faces up = smile :)
  group.add(smile);
  
  // Plate (carried in front when delivering food) - initially hidden
  const plateGroup = new THREE.Group();
  plateGroup.name = 'plate';
  
  // White plate
  const plateGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.04, 12);
  const plateMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plateGroup.add(plate);
  
  // Food on plate (colorful dome)
  const foodGeo = new THREE.SphereGeometry(0.08, 8, 6);
  const foodMat = new THREE.MeshLambertMaterial({ color: 0xE67E22 }); // Orange/brown food
  const food = new THREE.Mesh(foodGeo, foodMat);
  food.position.y = 0.06;
  food.scale.y = 0.6; // Flatten slightly
  plateGroup.add(food);
  
  // Green garnish
  const garnishGeo = new THREE.SphereGeometry(0.03, 6, 4);
  const garnishMat = new THREE.MeshLambertMaterial({ color: 0x2ECC71 });
  const garnish = new THREE.Mesh(garnishGeo, garnishMat);
  garnish.position.set(0.05, 0.1, 0);
  plateGroup.add(garnish);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front of chef at waist height
  plateGroup.visible = false; // Hidden by default
  group.add(plateGroup);
  
  // Cast shadow
  group.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
    }
  });
  
  return group;
}

// Create a waiter character (standing, with apron, can carry plate)
function createWaiter(carryingPlate = false, customization = {}) {
  const group = new THREE.Group();
  
  // Get customization values with defaults
  const skinIndex = customization.skin ?? 2;
  const hairIndex = customization.hair ?? 3;
  const hairStyleIndex = customization.hairStyle ?? 0;
  const outfitIndex = customization.outfit ?? 0;
  
  // Map indices to colors from AVATAR_OPTIONS
  const skinColor = AVATAR_OPTIONS.skinTones[skinIndex % AVATAR_OPTIONS.skinTones.length]?.color || 0xD2B48C;
  const hairColor = AVATAR_OPTIONS.hairColors[hairIndex % AVATAR_OPTIONS.hairColors.length]?.color || 0x2d1b0e;
  const vestColor = AVATAR_OPTIONS.outfitColors[outfitIndex % AVATAR_OPTIONS.outfitColors.length]?.color || 0x2d2d2d;
  
  // Fixed colors for uniform
  const shirtColor = 0xFFFFFF; // White shirt
  const apronColor = 0x1a1a1a; // Black apron
  const pantsColor = 0x2d2d2d; // Dark pants
  
  // Legs (dark pants)
  const leftLeg = createVoxelBox(0.1, 0.25, 0.1, pantsColor, -0.08, 0.125, 0);
  const rightLeg = createVoxelBox(0.1, 0.25, 0.1, pantsColor, 0.08, 0.125, 0);
  group.add(leftLeg, rightLeg);
  
  // Body (white shirt)
  const body = createVoxelBox(0.30, 0.4, 0.22, shirtColor, 0, 0.5, 0);
  group.add(body);
  
  // Vest (customizable color, over shirt)
  const vest = createVoxelBox(0.32, 0.35, 0.18, vestColor, 0, 0.52, 0.03);
  group.add(vest);
  
  // Waist apron (black, short)
  const apron = createVoxelBox(0.28, 0.2, 0.05, apronColor, 0, 0.38, 0.12);
  group.add(apron);
  
  // Arms (white shirt sleeves)
  const leftArm = createVoxelBox(0.1, 0.3, 0.1, shirtColor, -0.22, 0.5, 0);
  const rightArm = createVoxelBox(0.1, 0.3, 0.1, shirtColor, 0.22, 0.5, 0);
  group.add(leftArm, rightArm);
  
  // Hands (skin)
  const leftHand = createVoxelBox(0.08, 0.1, 0.08, skinColor, -0.22, 0.3, 0);
  const rightHand = createVoxelBox(0.08, 0.1, 0.08, skinColor, 0.22, 0.3, 0);
  group.add(leftHand, rightHand);
  
  // Head (skin)
  const head = createVoxelBox(0.26, 0.26, 0.26, skinColor, 0, 0.93, 0);
  group.add(head);
  
  // Hair based on style
  const hairStyle = AVATAR_OPTIONS.hairStyles[hairStyleIndex % AVATAR_OPTIONS.hairStyles.length]?.id || 'short';
  if (hairStyle !== 'none') {
    if (hairStyle === 'short') {
      const hair = createVoxelBox(0.27, 0.12, 0.27, hairColor, 0, 1.02, -0.02);
      group.add(hair);
    } else if (hairStyle === 'bun') {
      const hairTop = createVoxelBox(0.27, 0.1, 0.27, hairColor, 0, 1.02, -0.02);
      const bun = createVoxelBox(0.12, 0.12, 0.12, hairColor, 0, 1.08, -0.1);
      group.add(hairTop, bun);
    } else if (hairStyle === 'ponytail') {
      const hairTop = createVoxelBox(0.27, 0.1, 0.27, hairColor, 0, 1.02, -0.02);
      const tail = createVoxelBox(0.08, 0.2, 0.08, hairColor, 0, 0.92, -0.16);
      group.add(hairTop, tail);
    } else if (hairStyle === 'long') {
      const hairTop = createVoxelBox(0.28, 0.12, 0.28, hairColor, 0, 1.02, 0);
      const hairBack = createVoxelBox(0.26, 0.25, 0.08, hairColor, 0, 0.85, -0.12);
      const hairSideL = createVoxelBox(0.08, 0.2, 0.1, hairColor, -0.14, 0.85, 0.02);
      const hairSideR = createVoxelBox(0.08, 0.2, 0.1, hairColor, 0.14, 0.85, 0.02);
      group.add(hairTop, hairBack, hairSideL, hairSideR);
    }
  }
  
  // Face - adjusted for larger waiter head (0.26 vs 0.2)
  const headY = 0.93;
  const faceZ = 0.14; // Front of 0.26 head
  
  // Eyes with whites
  group.add(createVoxelBox(0.05, 0.05, 0.01, 0xFFFFFF, -0.07, headY + 0.02, faceZ));
  group.add(createVoxelBox(0.05, 0.05, 0.01, 0xFFFFFF, 0.07, headY + 0.02, faceZ));
  
  // Iris
  group.add(createVoxelSphere(0.02, hairColor, -0.07, headY + 0.02, faceZ + 0.01, 6));
  group.add(createVoxelSphere(0.02, hairColor, 0.07, headY + 0.02, faceZ + 0.01, 6));
  
  // Pupil
  group.add(createVoxelSphere(0.012, 0x1a1a1a, -0.07, headY + 0.02, faceZ + 0.015, 6));
  group.add(createVoxelSphere(0.012, 0x1a1a1a, 0.07, headY + 0.02, faceZ + 0.015, 6));
  
  // Eye shine
  group.add(createVoxelSphere(0.006, 0xFFFFFF, -0.065, headY + 0.03, faceZ + 0.02, 4));
  group.add(createVoxelSphere(0.006, 0xFFFFFF, 0.075, headY + 0.03, faceZ + 0.02, 4));
  
  // Eyebrows (friendly, slightly raised)
  group.add(createVoxelBox(0.05, 0.015, 0.015, hairColor, -0.07, headY + 0.07, faceZ));
  group.add(createVoxelBox(0.05, 0.015, 0.015, hairColor, 0.07, headY + 0.07, faceZ));
  
  // Nose
  group.add(createVoxelBox(0.03, 0.04, 0.025, skinColor, 0, headY - 0.01, faceZ));
  
  // Happy smile (box-based curve) - adjusted for larger waiter head
  const mouthColor = 0xCC4444;
  const mouthY = headY - 0.06;
  const mouthZ = 0.14; // Further out for larger head
  group.add(createVoxelBox(0.018, 0.012, 0.01, mouthColor, -0.04, mouthY + 0.008, mouthZ));
  group.add(createVoxelBox(0.015, 0.012, 0.01, mouthColor, -0.02, mouthY + 0.003, mouthZ));
  group.add(createVoxelBox(0.015, 0.012, 0.01, mouthColor, 0, mouthY - 0.005, mouthZ));
  group.add(createVoxelBox(0.015, 0.012, 0.01, mouthColor, 0.02, mouthY + 0.003, mouthZ));
  group.add(createVoxelBox(0.018, 0.012, 0.01, mouthColor, 0.04, mouthY + 0.008, mouthZ));
  
  // Bow tie (matches vest color)
  const bowTie = createVoxelBox(0.12, 0.06, 0.04, vestColor, 0, 0.72, 0.12);
  group.add(bowTie);
  
  // Carrying plate (only visible when carrying food)
  const plateGroup = new THREE.Group();
  plateGroup.name = 'carryPlate';
  
  // Plate
  const plateGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.03, 16);
  const plateMat = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plate.position.y = 0;
  plateGroup.add(plate);
  
  // Food on plate
  const foodGeo = new THREE.SphereGeometry(0.1, 8, 6);
  const foodMat = new THREE.MeshLambertMaterial({ color: 0xCD853F });
  const food = new THREE.Mesh(foodGeo, foodMat);
  food.position.y = 0.07;
  food.scale.y = 0.6;
  plateGroup.add(food);
  
  plateGroup.position.set(0, 0.45, 0.25); // In front at waist height
  plateGroup.visible = carryingPlate;
  group.add(plateGroup);
  
  // Cast shadow
  group.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
    }
  });
  
  return group;
}

function createSteamParticles() {
  const group = new THREE.Group();
  const particleCount = 15;
  
  // Create particles as small white spheres
  const particleGeo = new THREE.SphereGeometry(0.04, 6, 6);
  const particleMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.7 
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(particleGeo, particleMat.clone());
    // Randomize initial position around stove top
    particle.position.set(
      (Math.random() - 0.5) * 0.4,
      0.9 + Math.random() * 0.5, // Start above stove
      (Math.random() - 0.5) * 0.4
    );
    // Store velocity and life data
    particle.userData = {
      velocityY: 0.01 + Math.random() * 0.02,
      velocityX: (Math.random() - 0.5) * 0.005,
      velocityZ: (Math.random() - 0.5) * 0.005,
      life: Math.random(), // Stagger initial life so they don't all reset at once
      maxLife: 1,
    };
    group.add(particle);
  }
  
  return group;
}

function animateSteamParticles(steamGroup) {
  if (!steamGroup) return;
  
  steamGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Move particle
    particle.position.y += data.velocityY;
    particle.position.x += data.velocityX;
    particle.position.z += data.velocityZ;
    
    // Update life
    data.life += 0.02;
    
    // Fade out as life increases
    particle.material.opacity = Math.max(0, 0.7 * (1 - data.life / data.maxLife));
    
    // Scale up slightly as it rises
    const scale = 1 + (data.life / data.maxLife) * 0.5;
    particle.scale.setScalar(scale);
    
    // Reset particle when life expires
    if (data.life >= data.maxLife) {
      particle.position.set(
        (Math.random() - 0.5) * 0.4,
        0.9,
        (Math.random() - 0.5) * 0.4
      );
      particle.material.opacity = 0.7;
      particle.scale.setScalar(1);
      data.life = 0;
      data.velocityY = 0.01 + Math.random() * 0.02;
      data.velocityX = (Math.random() - 0.5) * 0.005;
      data.velocityZ = (Math.random() - 0.5) * 0.005;
    }
  });
}

function createSparkleParticles() {
  const group = new THREE.Group();
  const particleCount = 8; // Fewer particles
  
  // Create sparkle particles as small gold spheres
  const particleGeo = new THREE.SphereGeometry(0.045, 6, 6);
  
  for (let i = 0; i < particleCount; i++) {
    const particleMat = new THREE.MeshBasicMaterial({ 
      color: 0xffd700, // Gold
      transparent: true, 
      opacity: 0.9 
    });
    const particle = new THREE.Mesh(particleGeo, particleMat);
    
    // Position in a ring around the stove top
    const angle = (i / particleCount) * Math.PI * 2;
    const radius = 0.3;
    particle.position.set(
      Math.cos(angle) * radius,
      1.0 + Math.random() * 0.15,
      Math.sin(angle) * radius
    );
    
    // Store animation data - MUCH slower speeds
    particle.userData = {
      baseAngle: angle,
      radius: radius,
      baseY: 1.0 + (i % 3) * 0.1, // Stagger heights
      phase: (i / particleCount) * Math.PI * 2, // Evenly staggered phase
    };
    group.add(particle);
  }
  
  return group;
}

function animateSparkleParticles(sparkleGroup, time) {
  if (!sparkleGroup) return;
  
  const slowTime = time * 0.001; // Convert to seconds, much slower
  
  sparkleGroup.children.forEach(particle => {
    const data = particle.userData;
    
    // Very slow orbit around center
    const angle = data.baseAngle + slowTime * 0.3; // Slow rotation
    particle.position.x = Math.cos(angle) * data.radius;
    particle.position.z = Math.sin(angle) * data.radius;
    
    // Gentle float up and down
    particle.position.y = data.baseY + Math.sin(slowTime * 1.5 + data.phase) * 0.08;
    
    // Gentle twinkle effect (opacity pulsing)
    particle.material.opacity = 0.6 + Math.sin(slowTime * 2 + data.phase) * 0.35;
    
    // Subtle scale pulsing
    const scale = 0.9 + Math.sin(slowTime * 1.8 + data.phase) * 0.2;
    particle.scale.setScalar(scale);
  });
}

// ============================================
// MAIN COMPONENT
// ============================================
function CafeWorld3D() {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const objectsRef = useRef({ stoves: {}, counters: {}, tables: {}, chairs: {}, customers: {}, counterFood: {}, tableFood: {}, steamParticles: {}, sparkleParticles: {}, decorations: {}, dividers: {}, floorTiles: {} });
  const raycasterRef = useRef(new THREE.Raycaster());
  const mouseRef = useRef(new THREE.Vector2());
  const shopScrollRef = useRef(null); // For horizontal scroll in shop
  
  const [gameState, dispatch] = useReducer(gameReducer, initialState);
  const [selectedStove, setSelectedStove] = useState(null);
  const [cookbookPage, setCookbookPage] = useState(0);
  const [showShop, setShowShop] = useState(false);
  const [shopCategory, setShopCategory] = useState('stoves'); // 'stoves', 'counters', 'tables', etc.
  const [shopScrollPos, setShopScrollPos] = useState({ left: 0, max: 0 }); // Track scroll position
  const [showLevelUp, setShowLevelUp] = useState(false);
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [flyingCoins, setFlyingCoins] = useState([]); // [{id, startX, startY, startTime}]
  const [coinPop, setCoinPop] = useState(false);
  const [newPurchases, setNewPurchases] = useState([]); // [{id, type, time}]
  const [showSettings, setShowSettings] = useState(false);
  const [saveMessage, setSaveMessage] = useState(null); // {type: 'success'|'error', text: '...'}
  const [saveTextArea, setSaveTextArea] = useState(''); // For manual copy/paste
  const [showExportText, setShowExportText] = useState(false);
  const [placingDecoration, setPlacingDecoration] = useState(null); // Decoration type being placed
  const [placingDivider, setPlacingDivider] = useState(null); // Divider type being placed
  const [placingDoor, setPlacingDoor] = useState(null); // Door type being placed
  const [placingWallpaper, setPlacingWallpaper] = useState(null); // Wallpaper type being placed
  const [wallpaperSelection, setWallpaperSelection] = useState([]); // [{wall, position}, ...] segments selected for painting
  const wallpaperSelectionRef = useRef([]); // Ref to track selection immediately (React state is async)
  const [showWallpaperConfirm, setShowWallpaperConfirm] = useState(false); // Show confirm popup for wallpaper
  const [isPaintingWalls, setIsPaintingWalls] = useState(false); // True when left-click dragging to paint walls
  
  // Helper to clear wallpaper selection (clears both ref and state)
  const clearWallpaperSelection = () => {
    wallpaperSelectionRef.current = [];
    setWallpaperSelection([]);
  };
  
  const [placingFloorStyle, setPlacingFloorStyle] = useState(null); // Floor style being placed
  const [floorSelection, setFloorSelection] = useState([]); // [{gridX, gridZ}, ...] tiles selected for painting
  const [isDraggingFloor, setIsDraggingFloor] = useState(false); // True when dragging to select floor tiles
  const [showFloorConfirm, setShowFloorConfirm] = useState(false); // Show confirm popup for floor painting
  const [placingEquipment, setPlacingEquipment] = useState(null); // 'stove', 'counter', 'table', or 'chair'
  const [placingTableStyle, setPlacingTableStyle] = useState('square'); // Table style for placement
  const [placingChairStyle, setPlacingChairStyle] = useState('basicWood'); // Chair style for placement
  const [placingStoveStyle, setPlacingStoveStyle] = useState('basic'); // Stove style for placement
  const [placingCounterStyle, setPlacingCounterStyle] = useState('basic'); // Counter style for placement
  const [selectedCollectionVariant, setSelectedCollectionVariant] = useState({}); // {collectionKey: variantKey} for color selection
  const [placementRotation, setPlacementRotation] = useState(0); // 0, 1, 2, 3 = 0Â°, 90Â°, 180Â°, 270Â°
  const [placementLocked, setPlacementLocked] = useState(false); // Position locked, ready to rotate
  const [lockedPosition, setLockedPosition] = useState(null); // {gridX, gridZ} of locked position
  const [editMode, setEditMode] = useState(false); // Edit mode for deleting/moving objects
  const [selectedEditObject, setSelectedEditObject] = useState(null); // {type, id} - object selected in edit mode
  const [movingObject, setMovingObject] = useState(null); // {type, id, data} - object being moved
  const [autoServe, setAutoServe] = useState(false); // Auto-serve customers when food is ready
  const [soundEnabled, setSoundEnabled] = useState(true); // Audio toggle
  const [showCookbook, setShowCookbook] = useState(false); // Cookbook browse mode
  const [sceneReady, setSceneReady] = useState(false); // Scene initialization flag
  const [showAchievement, setShowAchievement] = useState(null); // Achievement popup {id, name, icon, reward}
  const [showTrophies, setShowTrophies] = useState(false); // Trophy panel
  const [showAudioSettings, setShowAudioSettings] = useState(false); // Audio settings panel
  const [showAvatarCustomize, setShowAvatarCustomize] = useState(false); // Avatar customization panel
  const [editingWaiter, setEditingWaiter] = useState(null); // Waiter being edited {id, name, showName, skin, hair, hairStyle, outfit}
  const [brightness, setBrightness] = useState(1.0); // Display brightness multiplier (0.5 - 1.5)
  const brightnessRef = useRef(1.0);
  const avatarPreviewRef = useRef(null); // Canvas for avatar preview
  const avatarPreviewSceneRef = useRef(null); // Three.js scene for preview
  const waiterPreviewRef = useRef(null); // Canvas for waiter preview
  const waiterPreviewSceneRef = useRef(null); // Three.js scene for waiter preview
  
  // Individual sound toggles
  const [soundToggles, setSoundToggles] = useState({
    cooking: true,
    foodReady: true,
    foodSpoiled: true,
    customerArrive: true,
    customerServed: true,
    customerHappy: true,
    customerAngry: true,
    coins: true,
    levelUp: true,
    purchase: true,
    achievement: true,
  });
  const previewDecorationRef = useRef(null); // Ghost preview during placement
  const previewDividerRef = useRef(null); // Ghost preview for divider placement
  const [cameraAngle, setCameraAngle] = useState(Math.PI / 4); // Horizontal rotation in radians (start at 45Â°)
  const cameraAngleRef = useRef(Math.PI / 4);
  const [cameraPitch, setCameraPitch] = useState(0.6); // Vertical angle (0.2 = low, 1.2 = high/top-down)
  const cameraPitchRef = useRef(0.6);
  const [zoomLevel, setZoomLevel] = useState(1); // 0.5 = zoomed in, 2 = zoomed out
  const zoomLevelRef = useRef(1);
  const [isDragging, setIsDragging] = useState(false);
  const lastMouseX = useRef(0);
  const lastMouseY = useRef(0);
  const lastPlacementGrid = useRef({ gridX: 0, gridZ: 0 }); // Track last grid position for rotation updates
  const [projectedPositions, setProjectedPositions] = useState({}); // {stove_1: {x, y}, table_2: {x, y}, etc}
  const [trashConfirm, setTrashConfirm] = useState(null); // {counterId, recipeName, servings} or null
  const [selectedCounterForTrash, setSelectedCounterForTrash] = useState(null); // counterId or null - shows trash button when selected
  const [hoveredWallSegment, setHoveredWallSegment] = useState(null); // {wall, position} for wall decoration preview
  const [timeOfDay, setTimeOfDay] = useState(10); // 0-24 hours (starts at 10am)
  const timeOfDayRef = useRef(10);
  const ambientLightRef = useRef(null);
  const sunLightRef = useRef(null);
  const sceneRef2 = useRef(null); // For background updates
  const windowMaterialsRef = useRef([]); // Store window glass materials for night glow
  const wallSegmentsRef = useRef({ back: [], left: [], right: [] }); // Store wall segment references for door gaps
  const wallpaperPreviewPatternsRef = useRef([]); // Store temporary preview pattern meshes
  const lampMaterialsRef = useRef([]); // Store lamp materials for night glow
  const interiorLightsRef = useRef([]); // Interior cafe lights
  const streetLightsRef = useRef([]); // Street lamp point lights
  const chefRef = useRef(null); // Chef avatar
  const gameStateRef = useRef(null); // Reference to current game state for animation loop
  const dispatchRef = useRef(null); // Reference to dispatch for animation loop
  const chefStateRef = useRef({
    targetX: 0,
    targetZ: 2,
    currentX: 0,
    currentZ: 2,
    idleTime: 0,
    state: 'idle', // 'idle', 'walking'
    task: null, // { type: 'cook', stoveId } or { type: 'deliver', stoveId } or { type: 'serve', tableId }
    carryingPlate: false, // true when carrying food to counter
    waypoints: [], // Array of {x, z} intermediate points to navigate around obstacles
    pendingServe: null, // { tableId, counterId } - set by animation loop, processed by game loop
  });
  
  // Pathfinding constants
  const DIVIDER_Z = -4; // Kitchen/dining divider z position in world coords
  const DOORWAY_X = 5.5; // Doorway gap position (right side)
  
  // Helper function to set chef target with proper A* pathfinding (same as customers)
  const setChefTargetWithPath = (targetX, targetZ, task = null) => {
    const chef = chefStateRef.current;
    const currentX = chef.currentX;
    const currentZ = chef.currentZ;
    
    // Convert world coordinates to grid coordinates
    const startGridX = Math.round(currentX + GRID.width / 2 - 0.5);
    const startGridZ = Math.round(currentZ + GRID.height / 2 - 0.5);
    const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
    const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
    
    // Build occupancy map from current game state
    const state = gameStateRef.current;
    const occupancyMap = buildOccupancyMap(state);
    
    // Find path using A* (same algorithm customers use)
    const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
    
    chef.waypoints = [];
    
    if (path && path.length > 1) {
      // Convert grid path back to world coordinates for waypoints
      // Skip first point (current position) and add rest as waypoints
      for (let i = 1; i < path.length; i++) {
        const worldX = path[i].gridX - GRID.width / 2 + 0.5;
        const worldZ = path[i].gridZ - GRID.height / 2 + 0.5;
        chef.waypoints.push({ x: worldX, z: worldZ });
      }
      
      // Start with first waypoint
      if (chef.waypoints.length > 0) {
        const first = chef.waypoints.shift();
        chef.targetX = first.x;
        chef.targetZ = first.z;
      }
    } else {
      // No path found or already at destination - try direct movement
      // (fallback for edge cases like standing on a decoration)
      chef.targetX = targetX;
      chef.targetZ = targetZ;
    }
    
    chef.task = task;
    chef.idleTime = 0;
  };
  
  // Keep ref in sync with state
  useEffect(() => {
    cameraAngleRef.current = cameraAngle;
  }, [cameraAngle]);
  
  
  useEffect(() => {
    cameraPitchRef.current = cameraPitch;
  }, [cameraPitch]);
  
  useEffect(() => {
    zoomLevelRef.current = zoomLevel;
  }, [zoomLevel]);
  
  useEffect(() => {
    timeOfDayRef.current = timeOfDay;
  }, [timeOfDay]);
  
  // Sync game state with ref for animation loop access
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);
  
  // Sync dispatch ref for animation loop access
  useEffect(() => {
    dispatchRef.current = dispatch;
  }, [dispatch]);
  
  // Chef behavior: Go to stove when cooking starts
  useEffect(() => {
    const cookingStove = gameState.stoves.find(s => s.state === 'cooking');
    const chef = chefStateRef.current;
    
    // If a stove is cooking and chef has no task, send chef there
    if (cookingStove && !chef.task && !chef.carryingPlate && gameStateRef.current) {
      const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'cook', stoveId: cookingStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'cooking').length]);
  
  // Chef behavior: Pick up ready food
  useEffect(() => {
    const readyStove = gameState.stoves.find(s => s.state === 'ready');
    const chef = chefStateRef.current;
    
    // If food is ready and chef isn't already carrying or picking up
    if (readyStove && !chef.carryingPlate && (!chef.task || chef.task.type === 'cook') && gameStateRef.current) {
      const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
      const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
      setChefTargetWithPath(stoveWorldX, stoveWorldZ + 0.6, { type: 'pickup', stoveId: readyStove.id });
    }
  }, [gameState.stoves.filter(s => s.state === 'ready').length]);
  
  // Sync sound state with global audio setting
  useEffect(() => {
    audioEnabled = soundEnabled;
  }, [soundEnabled]);
  
  // Sync individual sound toggles with global
  useEffect(() => {
    soundTogglesGlobal = { ...soundToggles };
  }, [soundToggles]);
  
  // Sync brightness ref with state
  useEffect(() => {
    brightnessRef.current = brightness;
  }, [brightness]);
  
  // Update chef avatar when customization changes
  useEffect(() => {
    if (chefRef.current && sceneRef2.current) {
      // Save chef position and state
      const oldPosition = chefRef.current.position.clone();
      const oldRotation = chefRef.current.rotation.y;
      
      // Remove old chef
      sceneRef2.current.remove(chefRef.current);
      
      // Create new chef with updated avatar options
      const newChef = createChef(gameState.avatar);
      newChef.position.copy(oldPosition);
      newChef.rotation.y = oldRotation;
      
      // Add to scene
      sceneRef2.current.add(newChef);
      chefRef.current = newChef;
    }
  }, [gameState.avatar]);
  
  // Avatar preview mini-scene
  useEffect(() => {
    if (!showAvatarCustomize || !avatarPreviewRef.current) return;
    
    const canvas = avatarPreviewRef.current;
    const width = 180;
    const height = 220;
    
    // Create mini renderer
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);
    
    // Create mini scene
    const scene = new THREE.Scene();
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
    camera.position.set(0, 1, 3.5);
    camera.lookAt(0, 0.7, 0);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 3, 2);
    scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(-2, 2, -2);
    scene.add(backLight);
    
    // Create chef preview
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, 0);
    scene.add(chef);
    
    // Store for cleanup
    avatarPreviewSceneRef.current = { renderer, scene, camera, chef };
    
    // Animation loop for gentle rotation
    let animationId;
    let rotation = 0;
    
    const animate = () => {
      rotation += 0.01;
      chef.rotation.y = Math.sin(rotation) * 0.5; // Gentle sway
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      cancelAnimationFrame(animationId);
      renderer.dispose();
    };
  }, [showAvatarCustomize, gameState.avatar]);
  
  // Waiter preview rendering - update when any appearance property changes
  const waiterSkin = editingWaiter?.skin;
  const waiterHair = editingWaiter?.hair;
  const waiterHairStyle = editingWaiter?.hairStyle;
  const waiterOutfit = editingWaiter?.outfit;
  
  useEffect(() => {
    if (!editingWaiter || !waiterPreviewRef.current) return;
    
    const canvas = waiterPreviewRef.current;
    const width = 160;
    const height = 200;
    
    // Create mini renderer
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);
    
    // Create mini scene
    const scene = new THREE.Scene();
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
    camera.position.set(0, 1, 3.5);
    camera.lookAt(0, 0.7, 0);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 3, 2);
    scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(-2, 2, -2);
    scene.add(backLight);
    
    // Create waiter preview - pass indices directly (createWaiter expects indices, not string IDs)
    const waiter = createWaiter(false, {
      skin: waiterSkin ?? 0,
      hair: waiterHair ?? 0,
      hairStyle: waiterHairStyle ?? 0,
      outfit: waiterOutfit ?? 0,
    });
    waiter.position.set(0, 0, 0);
    scene.add(waiter);
    
    // Store for cleanup
    waiterPreviewSceneRef.current = { renderer, scene, camera, waiter };
    
    // Animation loop for gentle rotation
    let animationId;
    let rotation = 0;
    
    const animate = () => {
      rotation += 0.01;
      waiter.rotation.y = Math.sin(rotation) * 0.5; // Gentle sway
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      cancelAnimationFrame(animationId);
      renderer.dispose();
    };
  }, [editingWaiter, waiterSkin, waiterHair, waiterHairStyle, waiterOutfit]);
  
  // Reset shop scroll position when opening shop or changing category
  useEffect(() => {
    if (showShop && shopScrollRef.current) {
      shopScrollRef.current.scrollLeft = 0;
      setShopScrollPos({ left: 0, max: shopScrollRef.current.scrollWidth - shopScrollRef.current.clientWidth });
    }
  }, [showShop, shopCategory]);
  
  // Update shop scroll max after items render
  useEffect(() => {
    if (showShop && shopScrollRef.current) {
      const updateMax = () => {
        setShopScrollPos(prev => ({
          ...prev,
          max: shopScrollRef.current.scrollWidth - shopScrollRef.current.clientWidth
        }));
      };
      // Small delay to let items render
      setTimeout(updateMax, 100);
    }
  }, [showShop, shopCategory]);
  
  // Mouse wheel zoom (disabled during placement modes)
  useEffect(() => {
    const handleWheel = (e) => {
      // Skip zoom if in any placement/move mode - let rotation handler take over
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        return; // Don't zoom during placement
      }
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.1 : -0.1;
      setZoomLevel(prev => Math.max(0.5, Math.min(1.5, prev + delta)));
    };
    
    const container = containerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
      return () => container.removeEventListener('wheel', handleWheel);
    }
  }, [placingEquipment, placingDecoration, placingDivider, movingObject]);
  
  // Right-click drag to rotate camera
  const handleMouseDown = (e) => {
    // Clear counter food selection when clicking on canvas (left click)
    if (e.button === 0) {
      setSelectedCounterForTrash(null);
    }
    
    if (e.button === 2) { // Right click - camera rotation
      e.preventDefault();
      setIsDragging(true);
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
    } else if (e.button === 0 && placingWallpaper) { // Left click with wallpaper selected
      e.preventDefault();
      setIsPaintingWalls(true);
      // Add the first segment to selection
      addWallSegmentToSelection(e);
    } else if (e.button === 0 && placingFloorStyle) { // Left click with floor style selected
      e.preventDefault();
      setIsDraggingFloor(true);
      // Add first tile to selection
      addFloorTileToSelection(e);
    }
  };
  
  // Helper function to add floor tile to selection
  const addFloorTileToSelection = (e) => {
    if (!placingFloorStyle || !containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Raycast against floor tiles - use recursive since tiles are now groups
    const floorTileObjects = Object.values(objectsRef.current.floorTiles || {});
    const intersects = raycasterRef.current.intersectObjects(floorTileObjects, true);
    
    if (intersects.length > 0) {
      // Find the parent group that has userData with gridX/gridZ
      let target = intersects[0].object;
      while (target && target.userData.gridX === undefined) {
        target = target.parent;
      }
      
      if (target && target.userData.gridX !== undefined) {
        const gridX = target.userData.gridX;
        const gridZ = target.userData.gridZ;
        
        // Add to selection if not already there
        setFloorSelection(prev => {
          const exists = prev.some(t => t.gridX === gridX && t.gridZ === gridZ);
          if (!exists) {
            return [...prev, { gridX, gridZ }];
          }
          return prev;
        });
      }
    }
  };
  
  // Helper function to add wall segment to selection at mouse position (for preview)
  const addWallSegmentToSelection = (e) => {
    if (!placingWallpaper || !containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Raycast against all objects in the scene
    const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
    
    // Find the first wall segment or door header we hit
    // Wall segments have: { wall, position }
    // Door headers have: { wall, position, isDoorHeader }
    // Door GROUPS have: { wall, wallPosition } - we want to skip these!
    let hitWallSegment = null;
    for (const hit of intersects) {
      let obj = hit.object;
      while (obj && !(obj.userData?.wall && obj.userData?.position !== undefined)) {
        obj = obj.parent;
      }
      if (obj && obj.userData?.wall && obj.userData?.position !== undefined) {
        hitWallSegment = obj;
        break;
      }
    }
    
    if (hitWallSegment) {
      const wall = hitWallSegment.userData.wall;
      const wallPosition = hitWallSegment.userData.position;
      
      // Add to selection if not already selected
      const alreadySelected = wallpaperSelectionRef.current.some(s => s.wall === wall && s.position === wallPosition);
      if (!alreadySelected) {
        const newSelection = [...wallpaperSelectionRef.current, { wall, position: wallPosition }];
        wallpaperSelectionRef.current = newSelection; // Update ref immediately
        setWallpaperSelection(newSelection); // Update state for UI
        SFX.click(); // Audio feedback
      }
    }
  };
  
  const handleMouseMove = (e) => {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX.current;
      const deltaY = e.clientY - lastMouseY.current;
      lastMouseX.current = e.clientX;
      lastMouseY.current = e.clientY;
      
      // Horizontal rotation (inverted for natural "grab and drag" feel)
      setCameraAngle(prev => prev - deltaX * 0.01);
      
      // Vertical rotation (inverted: drag up = look from above, drag down = look from ground)
      // Minimum 0.3 prevents looking "under" the world
      setCameraPitch(prev => Math.max(0.3, Math.min(1.4, prev - deltaY * 0.01)));
    }
    
    // Add wall segments to selection while dragging with wallpaper selected
    if (isPaintingWalls && placingWallpaper) {
      addWallSegmentToSelection(e);
    }
    
    // Add floor tiles to selection while dragging
    if (isDraggingFloor && placingFloorStyle) {
      addFloorTileToSelection(e);
    }
    
    // Update decoration preview position
    if (placingDecoration && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const decorType = DECORATIONS[placingDecoration];
        const isWallDecor = decorType.category === 'wall';
        
        // Calculate world position
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        if (isWallDecor) {
          // Wall decorations: Use wall segment raycasting (like wallpapers)
          const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
          
          // Find the first wall segment we hit
          let hitWallSegment = null;
          for (const hit of intersects) {
            let obj = hit.object;
            while (obj && !(obj.userData?.wall && obj.userData?.position !== undefined)) {
              obj = obj.parent;
            }
            if (obj && obj.userData?.wall && obj.userData?.position !== undefined) {
              hitWallSegment = obj;
              break;
            }
          }
          
          if (hitWallSegment) {
            const wall = hitWallSegment.userData.wall;
            const wallPosition = hitWallSegment.userData.position;
            
            // Update hovered wall segment state
            setHoveredWallSegment({ wall, position: wallPosition });
            
            // Position preview on the wall segment
            let previewX, previewZ, rotation;
            if (wall === 'back') {
              previewX = wallPosition - GRID.width / 2 + 0.5;
              previewZ = -GRID.height / 2 + 0.05;
              rotation = 0;
            } else if (wall === 'left') {
              previewX = -GRID.width / 2 + 0.05;
              previewZ = wallPosition - GRID.height / 2 + 0.5;
              rotation = Math.PI / 2;
            } else { // right
              previewX = GRID.width / 2 - 0.05;
              previewZ = wallPosition - GRID.height / 2 + 0.5;
              rotation = -Math.PI / 2;
            }
            
            previewDecorationRef.current.visible = true;
            previewDecorationRef.current.position.set(previewX, 0, previewZ);
            previewDecorationRef.current.rotation.y = rotation;
            
            // Check if this wall segment already has a decoration
            const alreadyHasDecor = gameState.decorations.some(d => 
              d.wall === wall && d.wallPosition === wallPosition
            );
            const canAfford = gameState.coins >= decorType.cost;
            const validPlacement = !alreadyHasDecor && canAfford;
            
            previewDecorationRef.current.traverse((child) => {
              if (child.isMesh && child.material) {
                child.material.transparent = true;
                child.material.opacity = 0.7;
                if (validPlacement) {
                  if (child.userData.originalColor !== undefined) {
                    child.material.color.setHex(child.userData.originalColor);
                  }
                } else {
                  child.material.color.setHex(0xFF0000);
                }
              }
            });
          } else {
            // Not hovering over a wall - hide preview
            previewDecorationRef.current.visible = false;
            setHoveredWallSegment(null);
          }
        } else {
          // Floor decoration logic (unchanged)
          // Check if valid area
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
          const validArea = inDiningArea;
          
          // Check for collisions (floor decorations only)
          let hasCollision = false;
          if (validArea) {
            const decorTaken = gameState.decorations.some(d => {
              const dt = DECORATIONS[d.type];
              return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
            });
            const tableTaken = gameState.tables.some(t => {
              const tiles = getTableTiles(t);
              return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
            });
            const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
            const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
            hasCollision = decorTaken || tableTaken || stoveTaken || counterTaken;
          }
          
          const validPlacement = validArea && !hasCollision;
          
          // Always show preview, tint based on validity
          previewDecorationRef.current.visible = true;
          previewDecorationRef.current.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.transparent = true;
              child.material.opacity = 0.7;
              if (validPlacement) {
                if (child.userData.originalColor !== undefined) {
                  child.material.color.setHex(child.userData.originalColor);
                }
              } else {
                child.material.color.setHex(0xFF0000);
              }
            }
          });
          
          previewDecorationRef.current.position.set(worldX, 0, worldZ);
          previewDecorationRef.current.rotation.y = 0;
        }
      }
    }
    
    // Update divider preview position
    if (placingDivider && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Dividers can go anywhere inside cafe
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        
        // Check for collisions
        let hasCollision = false;
        if (inCafe) {
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const validPlacement = inCafe && !hasCollision;
        
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = 0.7;
            if (validPlacement) {
              if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              child.material.color.setHex(0xFF0000);
            }
          }
        });
        
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        previewDecorationRef.current.rotation.y = (placementRotation % 2) * (Math.PI / 2);
      }
    }
    
    // Update equipment preview position
    if (placingEquipment && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        // Use locked position if placement is locked, otherwise calculate from mouse
        const useLockedPos = placementLocked && lockedPosition;
        const gridX = useLockedPos ? lockedPosition.gridX : Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = useLockedPos ? lockedPosition.gridZ : Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Store grid position for rotation updates
        lastPlacementGrid.current = { gridX, gridZ };
        
        // Helper to check for floor decoration collision
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        
        // Check for divider collision
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        
        // Check if valid placement
        let validPlacement = false;
        if (placingEquipment === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'counter') {
          // Counters can be placed anywhere in the cafe (buffet style!)
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => {
            // Check both table tile and chair tile
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          validPlacement = inCafe && notOnStove && notOnCounter && notOnTable && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'table') {
          // New system: tables occupy 1 tile only
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider;
        } else if (placingEquipment === 'chair') {
          // Chairs must be placed facing a table that doesn't already have a chair
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          
          // Check if chair would face a table
          const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
          const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
          const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
          
          validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider && tableAvailable;
        }
        
        // Always show preview, tint based on validity
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        
        // Apply rotation for all equipment types
        previewDecorationRef.current.rotation.y = placementRotation * (Math.PI / 2);
        
        // Color based on placement validity and lock state
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = placementLocked ? 0.85 : 0.7; // More solid when locked
            if (validPlacement) {
              // Green tint when locked and ready to place, original color otherwise
              if (placementLocked) {
                child.material.color.setHex(0x88FF88); // Light green when locked
              } else if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              // Tint red for invalid
              child.material.color.setHex(0xFF0000);
            }
          }
        });
      }
    }
    
    // Update preview position when moving objects (edit mode)
    if (movingObject && previewDecorationRef.current && containerRef.current && cameraRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      
      raycasterRef.current.setFromCamera(mouse, cameraRef.current);
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        const worldX = gridX - GRID.width / 2 + 0.5;
        const worldZ = gridZ - GRID.height / 2 + 0.5;
        
        // Helper to check collisions excluding the moving object
        const excludeId = movingObject.id;
        const hasCollision = (gx, gz, excludeType, excludeObjId) => {
          const decorTaken = gameState.decorations.some(d => {
            if (excludeType === 'decoration' && d.id === excludeObjId) return false;
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gx && d.gridZ === gz;
          });
          const dividerTaken = (gameState.dividers || []).some(d => {
            if (excludeType === 'divider' && d.id === excludeObjId) return false;
            return d.gridX === gx && d.gridZ === gz;
          });
          const tableTaken = gameState.tables.some(t => {
            if (excludeType === 'table' && t.id === excludeObjId) return false;
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gx && tile.gridZ === gz);
          });
          const stoveTaken = gameState.stoves.some(s => {
            if (excludeType === 'stove' && s.id === excludeObjId) return false;
            return s.gridX === gx && s.gridZ === gz;
          });
          const counterTaken = gameState.counters.some(c => {
            if (excludeType === 'counter' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          return decorTaken || dividerTaken || tableTaken || stoveTaken || counterTaken;
        };
        
        let validPlacement = false;
        
        if (movingObject.type === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          validPlacement = inKitchen && !hasCollision(gridX, gridZ, 'stove', excludeId);
        } else if (movingObject.type === 'counter') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'counter', excludeId);
        } else if (movingObject.type === 'table') {
          const chairTile = getChairTile(gridX, gridZ, placementRotation);
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          const chairInDining = chairTile.gridX >= 0 && chairTile.gridX <= GRID.width - 1 && 
            chairTile.gridZ >= 4 && chairTile.gridZ <= GRID.height - 1;
          const tableClear = !hasCollision(gridX, gridZ, 'table', excludeId);
          const chairClear = !hasCollision(chairTile.gridX, chairTile.gridZ, 'table', excludeId);
          validPlacement = inDining && chairInDining && tableClear && chairClear;
        } else if (movingObject.type === 'decoration') {
          const decorType = DECORATIONS[movingObject.data.decorationType];
          const isWallDecor = decorType?.category === 'wall';
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
          const validArea = isWallDecor ? inCafe : inDiningArea;
          validPlacement = validArea && (isWallDecor || !hasCollision(gridX, gridZ, 'decoration', excludeId));
        } else if (movingObject.type === 'divider') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'divider', excludeId);
        }
        
        // Show preview
        previewDecorationRef.current.visible = true;
        previewDecorationRef.current.position.set(worldX, 0, worldZ);
        // Dividers only use 0 or 90 degrees
        const rotationAngle = movingObject.type === 'divider' 
          ? (placementRotation % 2) * (Math.PI / 2)
          : placementRotation * (Math.PI / 2);
        previewDecorationRef.current.rotation.y = rotationAngle;
        
        // Color based on validity
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = 0.7;
            if (validPlacement) {
              child.material.color.setHex(0x88FF88); // Green for valid
            } else {
              child.material.color.setHex(0xFF0000); // Red for invalid
            }
          }
        });
      }
    }
  };
  
  const handleMouseUp = (e) => {
    if (e.button === 2) {
      setIsDragging(false);
    } else if (e.button === 0) {
      // Stop painting walls on left-click release and show confirm if segments selected
      // Check the ref since React state updates are async
      if (isPaintingWalls && wallpaperSelectionRef.current.length > 0) {
        setIsPaintingWalls(false);
        setShowWallpaperConfirm(true);
      } else {
        setIsPaintingWalls(false);
      }
      
      // Stop floor dragging and show confirm popup if tiles selected
      if (isDraggingFloor && floorSelection.length > 0) {
        setIsDraggingFloor(false);
        setShowFloorConfirm(true);
      } else {
        setIsDraggingFloor(false);
      }
    }
  };
  
  const handleContextMenu = (e) => {
    e.preventDefault(); // Prevent right-click menu
    
    // Right-click cancels placement or moving
    if (placingEquipment || placingDecoration || movingObject) {
      setPlacingEquipment(null);
      setPlacingDecoration(null);
      setMovingObject(null);
      setPlacementLocked(false);
      setLockedPosition(null);
      setPlacementRotation(0);
    }
  };
  
  // Check for level up
  const currentLevelXp = XP_LEVELS[gameState.level] || Infinity;
  useEffect(() => {
    if (gameState.xp >= currentLevelXp && gameState.level < XP_LEVELS.length) {
      dispatch({ type: 'LEVEL_UP' });
      setShowLevelUp(true);
      SFX.levelUp();
      setTimeout(() => setShowLevelUp(false), 3000);
    }
  }, [gameState.xp, currentLevelXp, gameState.level]);
  
  // Check for achievements
  const unlockAchievement = (id) => {
    if (!gameState.achievements.includes(id)) {
      dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: { achievementId: id } });
      const ach = ACHIEVEMENTS[id];
      setShowAchievement({ id, name: ach.name, icon: ach.icon, description: ach.description, reward: ach.reward });
      SFX.achievement();
      setTimeout(() => setShowAchievement(null), 4000);
    }
  };
  
  useEffect(() => {
    const { stats, achievements, stoves, tables, decorations, level } = gameState;
    
    // First Dish - Cook your first meal
    if (stats.dishesCooked >= 1 && !achievements.includes('firstDish')) {
      unlockAchievement('firstDish');
      return; // Only one achievement at a time
    }
    
    // First Customer - Serve your first customer
    if (stats.customersServed >= 1 && !achievements.includes('firstCustomer')) {
      unlockAchievement('firstCustomer');
      return;
    }
    
    // Busy Kitchen - All 3 stoves cooking
    const cookingStoves = stoves.filter(s => s.state === 'cooking').length;
    if (cookingStoves >= 3 && stoves.length >= 3 && !achievements.includes('busyKitchen')) {
      unlockAchievement('busyKitchen');
      return;
    }
    
    // Full House - All tables have customers
    const tablesWithCustomers = tables.filter(t => t.customer).length;
    if (tablesWithCustomers >= tables.length && tables.length >= 8 && !achievements.includes('fullHouse')) {
      unlockAchievement('fullHouse');
      return;
    }
    
    // Big Spender - Spend 5,000 coins total
    if (stats.totalSpent >= 5000 && !achievements.includes('bigSpender')) {
      unlockAchievement('bigSpender');
      return;
    }
    
    // Interior Designer - Place 5 decorations
    if (decorations.length >= 5 && !achievements.includes('decorator')) {
      unlockAchievement('decorator');
      return;
    }
    
    // Speedy Chef - Serve 10 customers in one session
    if (stats.customersServedSession >= 10 && !achievements.includes('speedyChef')) {
      unlockAchievement('speedyChef');
      return;
    }
    
    // Rising Chef - Reach level 5
    if (level >= 5 && !achievements.includes('chef')) {
      unlockAchievement('chef');
      return;
    }
    
    // Master Chef - Reach level 10
    if (level >= 10 && !achievements.includes('masterChef')) {
      unlockAchievement('masterChef');
      return;
    }
    
    // Cafe Mogul - Earn 10,000 coins total
    if (stats.totalEarned >= 10000 && !achievements.includes('mogul')) {
      unlockAchievement('mogul');
      return;
    }
    
    // Growing Business - Own 3 stoves and 10 tables
    if (stoves.length >= 3 && tables.length >= 10 && !achievements.includes('expansion')) {
      unlockAchievement('expansion');
      return;
    }
  }, [gameState.stats, gameState.stoves, gameState.tables, gameState.decorations, gameState.level, gameState.achievements]);
  
  // Night Owl achievement - needs timeOfDay check
  useEffect(() => {
    if (timeOfDay >= 22 || timeOfDay < 5) {
      // It's night time (10 PM - 5 AM)
      const recentlyServed = gameState.stats.customersServedSession > 0;
      if (recentlyServed && !gameState.achievements.includes('nightOwl')) {
        // Check if we just served someone
        const tablesEating = gameState.tables.filter(t => t.customer?.state === 'eating');
        if (tablesEating.length > 0) {
          unlockAchievement('nightOwl');
        }
      }
    }
  }, [timeOfDay, gameState.stats.customersServedSession, gameState.tables, gameState.achievements]);
  
  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current) return;
    
    // Scene - background matches grass color so horizon is invisible
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6CB06C);
    sceneRef.current = scene;
    sceneRef2.current = scene;
    
    // Orthographic camera (isometric view)
    const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
    const frustumSize = 8;
    const camera = new THREE.OrthographicCamera(
      -frustumSize * aspect, frustumSize * aspect,
      frustumSize, -frustumSize,
      0.1, 1000
    );
    camera.position.set(10, 10, 10);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    ambientLightRef.current = ambient;
    
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(8, 15, 8);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 100;
    sun.shadow.camera.left = -30;
    sun.shadow.camera.right = 30;
    sun.shadow.camera.top = 30;
    sun.shadow.camera.bottom = -30;
    scene.add(sun);
    sunLightRef.current = sun;
    
    // Clear material refs
    windowMaterialsRef.current = [];
    lampMaterialsRef.current = [];
    interiorLightsRef.current = [];
    streetLightsRef.current = [];
    
    // Create static environment (passes refs to store materials)
    createFloor(scene, gameStateRef.current?.floorTiles || {}, objectsRef);
    createWalls(scene, windowMaterialsRef, wallSegmentsRef, gameStateRef.current?.doors || [], gameStateRef.current?.wallpaper || 'cream', gameStateRef.current?.paintedSegments || []);
    createOutdoorEnvironment(scene, lampMaterialsRef, streetLightsRef);
    
    // Interior lighting handled by ambient light - no invisible point lights needed
    
    // Exterior lights around back/sides of cafe
    const exteriorLightPositions = [
      { x: -5, z: -GRID.height / 2 - 2 },  // Back left
      { x: 5, z: -GRID.height / 2 - 2 },   // Back right
      { x: -GRID.width / 2 - 2, z: -3 },   // Left side
      { x: -GRID.width / 2 - 2, z: 3 },    // Left side
      { x: GRID.width / 2 + 2, z: -3 },    // Right side  
      { x: GRID.width / 2 + 2, z: 3 },     // Right side
    ];
    
    exteriorLightPositions.forEach(pos => {
      const extLight = new THREE.PointLight(0xFFE4B5, 0, 10, 2); // Warm, invisible
      extLight.position.set(pos.x, 2.5, pos.z);
      scene.add(extLight);
      streetLightsRef.current.push(extLight);
    });
    
    // Create chef avatar
    const chef = createChef(gameState.avatar);
    chef.position.set(0, 0, -4); // Start in kitchen
    scene.add(chef);
    chefRef.current = chef;
    chefStateRef.current = {
      targetX: 0,
      targetZ: -4,
      currentX: 0,
      currentZ: -4,
      idleTime: 0,
      state: 'idle',
      task: null,
      carryingPlate: false,
      waypoints: [],
    };
    
    // Create waiters (one for each in the array)
    objectsRef.current.waiters = {};
    gameState.waiters.forEach(waiter => {
      const waiterObj = createWaiter(false, {
        skin: waiter.skin,
        hair: waiter.hair,
        hairStyle: waiter.hairStyle,
        outfit: waiter.outfit,
      });
      const waiterX = waiter.gridX - GRID.width / 2 + 0.5;
      const waiterZ = waiter.gridZ - GRID.height / 2 + 0.5;
      waiterObj.position.set(waiterX, 0, waiterZ);
      waiterObj.userData = { id: waiter.id, name: waiter.name, showName: waiter.showName };
      scene.add(waiterObj);
      objectsRef.current.waiters[waiter.id] = waiterObj;
    });
    
    // Animation loop
    let animationId;
    let currentZoom = 1; // Smooth zoom value
    const baseFrustumSize = 8;
    let lastProjectionUpdate = 0;
    const PROJECTION_UPDATE_INTERVAL = 16; // ~60fps for UI updates
    
    function animate() {
      animationId = requestAnimationFrame(animate);
      const time = Date.now();
      
      // Update camera position based on angle and pitch (spherical coordinates)
      const yaw = cameraAngleRef.current;
      const pitch = cameraPitchRef.current;
      const distance = 20; // Distance from center
      
      // Spherical to Cartesian conversion
      camera.position.x = Math.sin(yaw) * Math.cos(pitch) * distance;
      camera.position.z = Math.cos(yaw) * Math.cos(pitch) * distance;
      camera.position.y = Math.sin(pitch) * distance;
      camera.lookAt(0, 0, 0);
      
      // Smooth camera zoom
      const targetZoom = zoomLevelRef.current;
      const zoomDiff = targetZoom - currentZoom;
      if (Math.abs(zoomDiff) > 0.01) {
        currentZoom += zoomDiff * 0.15; // Smooth interpolation
        const newFrustumSize = baseFrustumSize * currentZoom;
        const aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
        camera.left = -newFrustumSize * aspect;
        camera.right = newFrustumSize * aspect;
        camera.top = newFrustumSize;
        camera.bottom = -newFrustumSize;
        camera.updateProjectionMatrix();
      }
      
      // === DAY/NIGHT CYCLE ===
      const tod = timeOfDayRef.current;
      
      // Calculate lighting based on time of day
      // 0-5: night, 5-7: dawn, 7-17: day, 17-19: dusk, 19-24: night
      let skyColor, ambientColor, ambientIntensity, sunIntensity, sunColor;
      let windowGlow = 0;
      let lampGlow = 0.2;
      
      if (tod >= 5 && tod < 7) {
        // Dawn - orange/pink transition
        const t = (tod - 5) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0x1a1a3a), // night
          new THREE.Color(0xFFB347), // dawn orange
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0x2a2a4a),
          new THREE.Color(0xffeedd),
          t
        );
        ambientIntensity = 0.3 + t * 0.2;
        sunIntensity = t * 0.5;
        sunColor = new THREE.Color(0xFFAA77);
        windowGlow = (1 - t) * 0.7;
        lampGlow = 1.2 - t * 1.2; // Lights fade off as sun rises
      } else if (tod >= 7 && tod < 17) {
        // Day - bright but not blinding
        const midday = 1 - Math.abs(tod - 12) / 5; // peaks at noon
        skyColor = new THREE.Color(0xADD8E6); // light blue
        ambientColor = new THREE.Color(0xffffff);
        ambientIntensity = 0.4 + midday * 0.1; // Reduced from 0.5+0.15
        sunIntensity = 0.5 + midday * 0.15; // Reduced from 0.7+0.2
        sunColor = new THREE.Color(0xffffff);
        windowGlow = 0;
        lampGlow = 0; // Lights off during day
      } else if (tod >= 17 && tod < 19) {
        // Dusk - orange/purple transition
        const t = (tod - 17) / 2; // 0 to 1
        skyColor = new THREE.Color().lerpColors(
          new THREE.Color(0xFFB347), // dusk orange
          new THREE.Color(0x4a3a6a), // purple
          t
        );
        ambientColor = new THREE.Color().lerpColors(
          new THREE.Color(0xffeedd),
          new THREE.Color(0x6a5a8a),
          t
        );
        ambientIntensity = 0.5 - t * 0.2;
        sunIntensity = 0.5 - t * 0.4;
        sunColor = new THREE.Color(0xFF7744);
        windowGlow = t * 0.7;
        lampGlow = 0.2 + t * 1.0; // Lights come on during dusk
      } else {
        // Night - dark sky, interior cozy but not blinding
        skyColor = new THREE.Color(0x1a1a3a);
        ambientColor = new THREE.Color(0xffeedd); // Warm white
        ambientIntensity = 0.3; // Noticeably dimmer than day
        sunIntensity = 0.02; // Barely any moonlight
        sunColor = new THREE.Color(0x8888aa);
        windowGlow = 0.7;
        lampGlow = 1.2; // Floor lamps glow at night
      }
      
      // Apply lighting changes (with brightness multiplier)
      const bright = brightnessRef.current;
      if (ambientLightRef.current) {
        ambientLightRef.current.color.copy(ambientColor);
        ambientLightRef.current.intensity = ambientIntensity * bright;
      }
      if (sunLightRef.current) {
        sunLightRef.current.color.copy(sunColor);
        sunLightRef.current.intensity = sunIntensity * bright;
        // Disable shadows at night so interior lights can illuminate properly
        sunLightRef.current.castShadow = sunIntensity > 0.2;
      }
      if (sceneRef2.current) {
        // Background stays grass-colored (darkens at night)
        const grassBg = tod >= 19 || tod < 5 ? 0x3a5a3a : 0x6CB06C;
        sceneRef2.current.background.setHex(grassBg);
      }
      
      // Update window glow (warm yellow at night)
      windowMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFDD88);
        mat.emissiveIntensity = windowGlow * bright;
      });
      
      // Update lamp glow (warm orange) - floor lamps etc
      lampMaterialsRef.current.forEach(mat => {
        mat.emissive.setHex(0xFFAA55); // Warm orange
        mat.emissiveIntensity = lampGlow * 0.6 * bright;
      });
      
      // Interior ceiling lights are constant (set at creation, not updated)
      // But floor lamp LIGHTS still need to be updated for night glow
      const floorLampIntensity = lampGlow * 0.8 * bright;
      interiorLightsRef.current.forEach(light => {
        light.intensity = floorLampIntensity;
      });
      
      // Update street lamp lights
      const streetIntensity = lampGlow * 1.5 * bright;
      streetLightsRef.current.forEach(light => {
        light.intensity = streetIntensity;
      });
      
      // Customers sit still (no animation needed)
      
      // Animate chef avatar
      if (chefRef.current) {
        const chef = chefStateRef.current;
        const speed = 0.03;
        
        // Move towards target
        const dx = chef.targetX - chef.currentX;
        const dz = chef.targetZ - chef.currentZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Update plate visibility
        const plateObj = chefRef.current.getObjectByName('plate');
        if (plateObj) {
          plateObj.visible = chef.carryingPlate;
        }
        
        if (dist > 0.1) {
          // Walking
          chef.state = 'walking';
          chef.currentX += (dx / dist) * speed;
          chef.currentZ += (dz / dist) * speed;
          
          // Face movement direction
          chefRef.current.rotation.y = Math.atan2(dx, dz);
          
          // Walking bob animation
          chefRef.current.position.y = Math.abs(Math.sin(time * 0.015)) * 0.08;
        } else {
          // Arrived at destination
          chef.state = 'idle';
          
          // Check if there are more waypoints
          if (chef.waypoints && chef.waypoints.length > 0) {
            const next = chef.waypoints.shift();
            chef.targetX = next.x;
            chef.targetZ = next.z;
            chef.state = 'walking';
            return; // Continue to next waypoint
          }
          
          // Handle task completion
          if (chef.task) {
            if (chef.task.type === 'deliver') {
              // Arrived at counter from stove - drop off plate
              chef.carryingPlate = false;
              chef.task = null;
            } else if (chef.task.type === 'pickup' && chef.task.tableId) {
              // Auto-serve flow: Arrived at counter to pick up food for customer
              const counter = gameStateRef.current.counters.find(c => c.id === chef.task.counterId);
              const targetTable = gameStateRef.current.tables.find(t => t.id === chef.task.tableId);
              
              if (counter && counter.dishes.length > 0 && targetTable && targetTable.customer?.state === 'waiting') {
                chef.carryingPlate = true;
                
                // Pathfind to the customer's table
                const chairTile = getChairTile(targetTable.gridX, targetTable.gridZ, targetTable.rotation || 0);
                const tableWorldX = chairTile.gridX - GRID.width / 2 + 0.5;
                const tableWorldZ = chairTile.gridZ - GRID.height / 2 + 0.5;
                
                // Calculate path using A*
                const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
                const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
                const endGridX = chairTile.gridX;
                const endGridZ = chairTile.gridZ;
                const occupancyMap = buildOccupancyMap(gameStateRef.current);
                const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
                
                chef.waypoints = [];
                if (path && path.length > 1) {
                  for (let i = 1; i < path.length; i++) {
                    chef.waypoints.push({ 
                      x: path[i].gridX - GRID.width / 2 + 0.5, 
                      z: path[i].gridZ - GRID.height / 2 + 0.5 
                    });
                  }
                  const first = chef.waypoints.shift();
                  chef.targetX = first.x;
                  chef.targetZ = first.z;
                } else {
                  chef.targetX = tableWorldX;
                  chef.targetZ = tableWorldZ;
                }
                
                // Set task to serve at table
                chef.task = { type: 'serve', counterId: chef.task.counterId, tableId: chef.task.tableId };
              } else {
                // No food or customer left, cancel task
                chef.carryingPlate = false;
                chef.task = null;
              }
            } else if (chef.task.type === 'pickup') {
              // Old flow: Arrived at stove - pick up plate to take to counter
              chef.carryingPlate = true;
              // Now go to counter using pathfinding
              const counters = gameStateRef.current.counters;
              if (counters.length > 0) {
                const counter = counters[0];
                const counterWorldX = counter.gridX - GRID.width / 2 + 0.5;
                const counterWorldZ = counter.gridZ - GRID.height / 2 + 0.5;
                
                // Calculate path using A*
                const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
                const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
                const endGridX = Math.round(counterWorldX + GRID.width / 2 - 0.5);
                const endGridZ = Math.round(counterWorldZ + GRID.height / 2 - 0.5);
                const occupancyMap = buildOccupancyMap(gameStateRef.current);
                const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
                
                chef.waypoints = [];
                if (path && path.length > 1) {
                  for (let i = 1; i < path.length; i++) {
                    chef.waypoints.push({ 
                      x: path[i].gridX - GRID.width / 2 + 0.5, 
                      z: path[i].gridZ - GRID.height / 2 + 0.5 
                    });
                  }
                  const first = chef.waypoints.shift();
                  chef.targetX = first.x;
                  chef.targetZ = first.z;
                } else {
                  chef.targetX = counterWorldX;
                  chef.targetZ = counterWorldZ;
                }
                chef.task = { type: 'deliver', counterId: counter.id };
              } else {
                chef.task = null;
              }
            } else if (chef.task.type === 'cook') {
              // Arrived at stove to cook - just hang out nearby
              chef.task = null;
            } else if (chef.task.type === 'serve') {
              // Arrived at table to serve customer - set pending serve for game loop to process
              const tableId = chef.task.tableId;
              const counterId = chef.task.counterId;
              
              // Set pending serve - game loop will dispatch the actual action
              chef.pendingServe = { tableId, counterId };
              
              chef.carryingPlate = false;
              chef.task = null;
            } else {
              chef.task = null;
            }
            chef.idleTime = 0;
          } else {
            chef.idleTime += 1;
          }
          
          // Gentle idle bob
          chefRef.current.position.y = Math.sin(time * 0.003) * 0.02;
          
          // Pick new target after idling (only if no task)
          if (!chef.task && chef.idleTime > 120) { // ~2 seconds at 60fps
            chef.idleTime = 0;
            
            // Prioritize going to active stoves or ready food
            const stoves = gameStateRef.current.stoves;
            const cookingStove = stoves.find(s => s.state === 'cooking');
            const readyStove = stoves.find(s => s.state === 'ready');
            
            if (readyStove && !chef.carryingPlate) {
              // Go pick up ready food - use pathfinding
              const stoveWorldX = readyStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = readyStove.gridZ - GRID.height / 2 + 0.5;
              const targetZ = stoveWorldZ + 0.5; // Stand in front
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(stoveWorldX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = stoveWorldX;
                chef.targetZ = targetZ;
              }
              chef.task = { type: 'pickup', stoveId: readyStove.id };
            } else if (cookingStove) {
              // Hang out near cooking stove - use pathfinding
              const stoveWorldX = cookingStove.gridX - GRID.width / 2 + 0.5;
              const stoveWorldZ = cookingStove.gridZ - GRID.height / 2 + 0.5;
              const targetX = stoveWorldX + (Math.random() - 0.5);
              const targetZ = stoveWorldZ + 0.8; // Stand in front
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = targetX;
                chef.targetZ = targetZ;
              }
            } else {
              // Stay in kitchen area when idle - use pathfinding
              const targetX = (Math.random() - 0.5) * 6; // Kitchen area x (slightly smaller range)
              const targetZ = -5 + Math.random() * 1.5; // Kitchen area z
              
              // Calculate path using A*
              const startGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
              const startGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
              const endGridX = Math.round(targetX + GRID.width / 2 - 0.5);
              const endGridZ = Math.round(targetZ + GRID.height / 2 - 0.5);
              const occupancyMap = buildOccupancyMap(gameStateRef.current);
              const path = findPath(occupancyMap, startGridX, startGridZ, endGridX, endGridZ, GRID.width, GRID.height);
              
              chef.waypoints = [];
              if (path && path.length > 1) {
                for (let i = 1; i < path.length; i++) {
                  chef.waypoints.push({ 
                    x: path[i].gridX - GRID.width / 2 + 0.5, 
                    z: path[i].gridZ - GRID.height / 2 + 0.5 
                  });
                }
                const first = chef.waypoints.shift();
                chef.targetX = first.x;
                chef.targetZ = first.z;
              } else {
                chef.targetX = targetX;
                chef.targetZ = targetZ;
              }
            }
          }
        }
        
        // Update position
        chefRef.current.position.x = chef.currentX;
        chefRef.current.position.z = chef.currentZ;
      }
      
      // Animate steam particles
      Object.values(objectsRef.current.steamParticles).forEach(steamGroup => {
        animateSteamParticles(steamGroup);
      });
      
      // Animate sparkle particles
      Object.values(objectsRef.current.sparkleParticles).forEach(sparkleGroup => {
        animateSparkleParticles(sparkleGroup, time);
      });
      
      // Animate purchase bounce-in effect
      const animatePurchase = (obj) => {
        if (obj && obj.userData && obj.userData.animateIn) {
          const { startTime, duration } = obj.userData.animateIn;
          const elapsed = time - startTime;
          const progress = Math.min(1, elapsed / duration);
          
          if (progress < 1) {
            // Elastic ease-out for bouncy effect
            const elasticOut = (t) => {
              const p = 0.4;
              return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
            };
            const scale = elasticOut(progress);
            obj.scale.setScalar(scale);
          } else {
            obj.scale.setScalar(1);
            delete obj.userData.animateIn;
          }
        }
      };
      
      Object.values(objectsRef.current.stoves).forEach(animatePurchase);
      Object.values(objectsRef.current.counters).forEach(animatePurchase);
      Object.values(objectsRef.current.tables).forEach(animatePurchase);
      Object.values(objectsRef.current.chairs || {}).forEach(animatePurchase);
      Object.values(objectsRef.current.decorations).forEach(animatePurchase);
      Object.values(objectsRef.current.dividers || {}).forEach(animatePurchase);
      Object.values(objectsRef.current.doors || {}).forEach(animatePurchase);
      
      // Animate doors opening/closing based on proximity to customers/chef
      Object.values(objectsRef.current.doors || {}).forEach(doorObj => {
        if (!doorObj || !doorObj.userData) return;
        
        const wall = doorObj.userData.wall;
        const wallPosition = doorObj.userData.wallPosition;
        if (!wall || wallPosition === undefined) return;
        
        // Get door grid position for proximity check
        let doorGridX, doorGridZ;
        if (wall === 'back') {
          doorGridX = wallPosition;
          doorGridZ = 0;
        } else if (wall === 'left') {
          doorGridX = 0;
          doorGridZ = wallPosition;
        } else if (wall === 'right') {
          doorGridX = GRID.width - 1;
          doorGridZ = wallPosition;
        }
        
        // Check if anyone is within 1.5 tiles of the door
        let someoneNear = false;
        
        // Check chef position
        const chef = chefStateRef.current;
        if (chef) {
          const chefGridX = Math.round(chef.currentX + GRID.width / 2 - 0.5);
          const chefGridZ = Math.round(chef.currentZ + GRID.height / 2 - 0.5);
          const chefDist = Math.abs(chefGridX - doorGridX) + Math.abs(chefGridZ - doorGridZ);
          if (chefDist <= 1.5) someoneNear = true;
        }
        
        // Check customer positions (customers in entering or leaving states)
        if (!someoneNear && gameStateRef.current) {
          gameStateRef.current.tables.forEach(table => {
            if (table.customer && (table.customer.state === 'entering' || table.customer.state === 'leaving')) {
              const path = table.customer.path;
              const progress = table.customer.walkProgress || 0;
              
              if (path && path.length >= 2) {
                // Calculate current position along path
                const totalSegments = path.length - 1;
                const progressPerSegment = 1 / totalSegments;
                const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
                const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
                
                const fromTile = path[currentSegmentIndex];
                const toTile = path[currentSegmentIndex + 1] || fromTile;
                
                const custGridX = fromTile.gridX + (toTile.gridX - fromTile.gridX) * segmentProgress;
                const custGridZ = fromTile.gridZ + (toTile.gridZ - fromTile.gridZ) * segmentProgress;
                
                const custDist = Math.abs(custGridX - doorGridX) + Math.abs(custGridZ - doorGridZ);
                if (custDist <= 1.5) someoneNear = true;
              }
            }
          });
        }
        
        // Animate door open/close
        const targetOpen = someoneNear ? 1 : 0;
        const currentOpen = doorObj.userData.openAmount || 0;
        const openSpeed = 0.08; // How fast the door opens/closes
        
        let newOpen = currentOpen;
        if (currentOpen < targetOpen) {
          newOpen = Math.min(targetOpen, currentOpen + openSpeed);
        } else if (currentOpen > targetOpen) {
          newOpen = Math.max(targetOpen, currentOpen - openSpeed);
        }
        doorObj.userData.openAmount = newOpen;
        
        // Apply rotation to door pivot(s)
        const maxAngle = Math.PI / 2; // 90 degrees fully open
        
        if (doorObj.userData.isDouble) {
          // Double doors - find both pivots
          const leftPivot = doorObj.getObjectByName('leftDoorPivot');
          const rightPivot = doorObj.getObjectByName('rightDoorPivot');
          if (leftPivot) leftPivot.rotation.y = newOpen * maxAngle; // Opens outward left
          if (rightPivot) rightPivot.rotation.y = -newOpen * maxAngle; // Opens outward right
        } else {
          // Single door - opens outward (away from cafe)
          const pivot = doorObj.getObjectByName('doorPivot');
          if (pivot) pivot.rotation.y = newOpen * maxAngle; // Opens outward
        }
      });
      
      // Update projected positions for UI overlays
      const newPositions = {};
      const tempVec = new THREE.Vector3();
      
      const projectWorldToScreen = (worldX, worldY, worldZ) => {
        tempVec.set(worldX, worldY, worldZ);
        tempVec.project(camera);
        return {
          x: (tempVec.x * 0.5 + 0.5) * 100,
          y: (-tempVec.y * 0.5 + 0.5) * 100
        };
      };
      
      // Project stove positions
      Object.entries(objectsRef.current.stoves).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`stove_${id}`] = pos;
        }
      });
      
      // Project counter positions
      Object.entries(objectsRef.current.counters).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`counter_${id}`] = pos;
        }
      });
      
      // Project table positions
      Object.entries(objectsRef.current.tables).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`table_${id}`] = pos;
        }
      });
      
      // Project waiter positions (for name labels)
      Object.entries(objectsRef.current.waiters || {}).forEach(([id, obj]) => {
        if (obj) {
          const pos = projectWorldToScreen(obj.position.x, obj.position.y + 1.5, obj.position.z);
          newPositions[`waiter_${id}`] = pos;
        }
      });
      
      // Project chef position (for name label)
      if (chefRef.current) {
        const pos = projectWorldToScreen(chefRef.current.position.x, chefRef.current.position.y + 1.5, chefRef.current.position.z);
        newPositions['chef'] = pos;
      }
      
      setProjectedPositions(newPositions);
      
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle resize
    function handleResize() {
      if (!containerRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      const newAspect = width / height;
      
      camera.left = -frustumSize * newAspect;
      camera.right = frustumSize * newAspect;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    window.addEventListener('resize', handleResize);
    
    // Mark scene as ready (triggers object creation)
    setSceneReady(true);
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
      setSceneReady(false);
    };
  }, []);
  
  // Update 3D objects when game state changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene || !sceneReady) return;
    
    // Cleanup: Remove 3D objects that no longer exist in state
    const stoveIds = new Set(gameState.stoves.map(s => s.id));
    Object.keys(objectsRef.current.stoves).forEach(id => {
      if (!stoveIds.has(id)) {
        scene.remove(objectsRef.current.stoves[id]);
        delete objectsRef.current.stoves[id];
        // Also cleanup associated particles
        if (objectsRef.current.steamParticles[id]) {
          scene.remove(objectsRef.current.steamParticles[id]);
          delete objectsRef.current.steamParticles[id];
        }
        if (objectsRef.current.sparkleParticles[id]) {
          scene.remove(objectsRef.current.sparkleParticles[id]);
          delete objectsRef.current.sparkleParticles[id];
        }
      }
    });
    
    const counterIds = new Set(gameState.counters.map(c => c.id));
    Object.keys(objectsRef.current.counters).forEach(id => {
      if (!counterIds.has(id)) {
        scene.remove(objectsRef.current.counters[id]);
        delete objectsRef.current.counters[id];
        if (objectsRef.current.counterFood[id]) {
          scene.remove(objectsRef.current.counterFood[id]);
          delete objectsRef.current.counterFood[id];
        }
      }
    });
    
    const tableIds = new Set(gameState.tables.map(t => t.id));
    Object.keys(objectsRef.current.tables).forEach(id => {
      if (!tableIds.has(id)) {
        scene.remove(objectsRef.current.tables[id]);
        delete objectsRef.current.tables[id];
        if (objectsRef.current.customers[id]) {
          scene.remove(objectsRef.current.customers[id]);
          delete objectsRef.current.customers[id];
        }
      }
    });
    
    // Update stoves
    gameState.stoves.forEach(stove => {
      let stoveObj = objectsRef.current.stoves[stove.id];
      const stoveStyle = stove.style || 'basic';
      
      // Recreate if style changed
      if (stoveObj && stoveObj.userData.style !== stoveStyle) {
        scene.remove(stoveObj);
        stoveObj = null;
        delete objectsRef.current.stoves[stove.id];
      }
      
      if (!stoveObj) {
        stoveObj = createStove(stove.gridX, stove.gridZ, stove.rotation || 0, stoveStyle);
        stoveObj.userData = { type: 'stove', id: stove.id, rotation: stove.rotation || 0, style: stoveStyle };
        scene.add(stoveObj);
        objectsRef.current.stoves[stove.id] = stoveObj;
        
        // Check if this is a new purchase (bought within last 500ms)
        const recentPurchase = newPurchases.find(p => p.type === 'stove' && Date.now() - p.time < 500);
        if (recentPurchase) {
          stoveObj.scale.setScalar(0);
          stoveObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Update burner colors based on state
      const burnerColor = stove.state === 'cooking' ? COLORS.stove.burnerOn : 
                          stove.state === 'ready' ? COLORS.readyGlow :
                          stove.state === 'spoiled' ? COLORS.dangerGlow : COLORS.stove.burnerOff;
      stoveObj.children.forEach(child => {
        if (child.name === 'burner' && child.material) {
          child.material.color.setHex(burnerColor);
          // Only set emissive if the material supports it (not MeshBasicMaterial)
          if (child.material.emissive !== undefined) {
            child.material.emissive = new THREE.Color(stove.state === 'cooking' ? 0x441111 : 0x000000);
          }
        }
      });
      
      // Handle steam particles
      const existingSteam = objectsRef.current.steamParticles[stove.id];
      if (stove.state === 'cooking' && !existingSteam) {
        // Add steam particles
        const steam = createSteamParticles();
        steam.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(steam);
        objectsRef.current.steamParticles[stove.id] = steam;
      } else if (stove.state !== 'cooking' && existingSteam) {
        // Remove steam particles
        scene.remove(existingSteam);
        delete objectsRef.current.steamParticles[stove.id];
      }
      
      // Handle sparkle particles for ready food
      const existingSparkle = objectsRef.current.sparkleParticles[stove.id];
      if (stove.state === 'ready' && !existingSparkle) {
        // Add sparkle particles
        const sparkle = createSparkleParticles();
        sparkle.position.set(
          stove.gridX - GRID.width / 2 + 0.5,
          0,
          stove.gridZ - GRID.height / 2 + 0.5
        );
        scene.add(sparkle);
        objectsRef.current.sparkleParticles[stove.id] = sparkle;
      } else if (stove.state !== 'ready' && existingSparkle) {
        // Remove sparkle particles
        scene.remove(existingSparkle);
        delete objectsRef.current.sparkleParticles[stove.id];
      }
    });
    
    // Update counters
    gameState.counters.forEach(counter => {
      let counterObj = objectsRef.current.counters[counter.id];
      const counterStyle = counter.style || 'basic';
      
      // Recreate if style changed
      if (counterObj && counterObj.userData.style !== counterStyle) {
        scene.remove(counterObj);
        counterObj = null;
        delete objectsRef.current.counters[counter.id];
      }
      
      if (!counterObj) {
        counterObj = createCounter(counter.gridX, counter.gridZ, counter.rotation || 0, counterStyle);
        counterObj.userData = { type: 'counter', id: counter.id, rotation: counter.rotation || 0, style: counterStyle };
        scene.add(counterObj);
        objectsRef.current.counters[counter.id] = counterObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'counter' && Date.now() - p.time < 500);
        if (recentPurchase) {
          counterObj.scale.setScalar(0);
          counterObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle food on counter
      const existingFood = objectsRef.current.counterFood[counter.id];
      const hasFood = counter.dishes.length > 0;
      
      // Create a unique key from dish to detect changes (include mastery level for plate color)
      const dish = hasFood ? counter.dishes[0] : null;
      const masteryLevel = dish ? getMasteryLevel(gameState.dishMastery, dish.recipe) : 0;
      const dishesKey = hasFood ? `${dish.recipe}:${dish.servings}:m${masteryLevel}` : '';
      
      if (hasFood && (!existingFood || existingFood.userData?.dishesKey !== dishesKey)) {
        // Remove old food visual if exists
        if (existingFood) {
          scene.remove(existingFood);
          delete objectsRef.current.counterFood[counter.id];
        }
        
        // Add food visual with mastery-colored plate
        const foodGroup = new THREE.Group();
        const plateColor = getMasteryPlateColor(gameState.dishMastery, dish.recipe);
        
        // Create main food plate with mastery color
        const food = createFoodPlate(dish.recipe, plateColor);
        food.position.y = 0.85;
        foodGroup.add(food);
        
        // Add stacked plates underneath for large servings
        if (dish.servings > 20) {
          const plate2 = createFoodPlate(dish.recipe, plateColor);
          plate2.position.set(0.08, 0.8, 0.08);
          plate2.scale.setScalar(0.9);
          foodGroup.add(plate2);
        }
        if (dish.servings > 50) {
          const plate3 = createFoodPlate(dish.recipe, plateColor);
          plate3.position.set(-0.08, 0.75, -0.08);
          plate3.scale.setScalar(0.8);
          foodGroup.add(plate3);
        }
        if (dish.servings > 100) {
          const plate4 = createFoodPlate(dish.recipe, plateColor);
          plate4.position.set(0.15, 0.7, 0);
          plate4.scale.setScalar(0.7);
          foodGroup.add(plate4);
        }
        
        foodGroup.position.set(
          counter.gridX - GRID.width / 2 + 0.5,
          0,
          counter.gridZ - GRID.height / 2 + 0.5
        );
        foodGroup.userData = { dishesKey };
        scene.add(foodGroup);
        objectsRef.current.counterFood[counter.id] = foodGroup;
      } else if (!hasFood && existingFood) {
        // Remove food visual
        scene.remove(existingFood);
        delete objectsRef.current.counterFood[counter.id];
      }
    });
    
    // Update tables
    gameState.tables.forEach(table => {
      let tableObj = objectsRef.current.tables[table.id];
      const style = table.style || 'round';
      const rotation = table.rotation || 0;
      
      // Check if table needs recreation (style or rotation changed)
      if (tableObj && (tableObj.userData.style !== style || tableObj.userData.rotation !== rotation)) {
        scene.remove(tableObj);
        delete objectsRef.current.tables[table.id];
        tableObj = null;
      }
      
      if (!tableObj) {
        tableObj = createTable(table.gridX, table.gridZ, style, rotation);
        tableObj.userData = { type: 'table', id: table.id, style, rotation };
        scene.add(tableObj);
        objectsRef.current.tables[table.id] = tableObj;
        
        // Check if this is a new purchase
        const recentPurchase = newPurchases.find(p => p.type === 'table' && Date.now() - p.time < 500);
        if (recentPurchase) {
          tableObj.scale.setScalar(0);
          tableObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
      
      // Handle customer at table
      const existingCustomer = objectsRef.current.customers[table.id];
      const isWalking = table.customer && (
        table.customer.state === 'walking_to_counter' || 
        table.customer.state === 'walking_to_table' ||
        table.customer.state === 'entering' ||
        table.customer.state === 'leaving'
      );
      const hasPlate = table.customer && (table.customer.state === 'walking_to_table' || table.customer.state === 'eating');
      const needsSeated = table.customer && !isWalking;
      const needsStanding = table.customer && isWalking;
      
      // Track current model type, plate state, and mood
      const currentPose = existingCustomer?.userData?.pose || 'seated';
      const currentHasPlate = existingCustomer?.userData?.hasPlate || false;
      const currentMood = existingCustomer?.userData?.mood || 'happy';
      const newMood = table.customer ? patienceToMood(table.customer.patience || 100) : 'happy';
      
      // Need to swap model if pose changes, plate status changes, or mood changes
      const needsModelSwap = table.customer && (
        !existingCustomer || 
        (needsStanding && currentPose === 'seated') || 
        (needsSeated && currentPose === 'standing') ||
        (needsStanding && hasPlate !== currentHasPlate) ||
        (currentMood !== newMood)
      );
      
      if (needsModelSwap) {
        // Need to create new customer or swap model
        if (existingCustomer) {
          scene.remove(existingCustomer);
        }
        
        const pose = isWalking ? 'standing' : 'seated';
        const mood = patienceToMood(table.customer.patience || 100);
        const customer = createCustomer(table.customer.appearance || {}, pose, hasPlate, mood);
        
        const tableStyle = table.style || 'round';
        const tableRotation = (table.rotation || 0) * (Math.PI / 2);
        
        // Calculate seat position - use stored chair position from customer data
        // New system: chairs are separate objects, customer walks to the chair tile
        const tableWorldX = table.gridX - GRID.width / 2 + 0.5;
        const tableWorldZ = table.gridZ - GRID.height / 2 + 0.5;
        
        // Use the stored chair position if available (new system)
        // Fall back to old calculation for legacy saves
        let seatX, seatZ;
        if (table.customer.chairX !== undefined && table.customer.chairZ !== undefined) {
          // New system: use actual chair tile position
          seatX = table.customer.chairX - GRID.width / 2 + 0.5;
          seatZ = table.customer.chairZ - GRID.height / 2 + 0.5;
        } else {
          // Legacy fallback: calculate from table rotation (for old saves)
          const seatOffset = 0.55;
          seatX = tableWorldX - seatOffset * Math.cos(tableRotation);
          seatZ = tableWorldZ + seatOffset * Math.sin(tableRotation);
        }
        
        customer.position.set(seatX, 0, seatZ);
        // Face toward table center
        const facingAngle = Math.atan2(tableWorldX - seatX, tableWorldZ - seatZ);
        customer.rotation.y = facingAngle;
        
        customer.userData = { 
          type: 'customer', 
          tableId: table.id,
          seatX: seatX,
          seatZ: seatZ,
          tableRotation: tableRotation,
          tableStyle: tableStyle,
          pose: pose,
          hasPlate: hasPlate,
          mood: mood,
          appearance: table.customer.appearance || {},
        };
        scene.add(customer);
        objectsRef.current.customers[table.id] = customer;
      }
      
      // Re-fetch customer reference after potential swap
      const currentCustomer = objectsRef.current.customers[table.id];
      
      // Update walking customer position with pathfinding through the gap
      if (currentCustomer && table.customer && isWalking) {
        const path = table.customer.path;
        const progress = table.customer.walkProgress || 0;
        
        // Path-based walking: progress 0-1 maps to walking through all path tiles
        if (path && path.length >= 2) {
          // Calculate which segment of the path we're on
          const totalSegments = path.length - 1;
          const progressPerSegment = 1 / totalSegments;
          const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
          const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
          
          // Get current and next tile
          const fromTile = path[currentSegmentIndex];
          const toTile = path[currentSegmentIndex + 1];
          
          // Convert grid to world coordinates
          const fromX = fromTile.gridX - GRID.width / 2 + 0.5;
          const fromZ = fromTile.gridZ - GRID.height / 2 + 0.5;
          const toX = toTile.gridX - GRID.width / 2 + 0.5;
          const toZ = toTile.gridZ - GRID.height / 2 + 0.5;
          
          // Interpolate position
          const currentX = fromX + (toX - fromX) * segmentProgress;
          const currentZ = fromZ + (toZ - fromZ) * segmentProgress;
          
          currentCustomer.position.set(currentX, 0, currentZ);
          
          // Face movement direction
          const dx = toX - fromX;
          const dz = toZ - fromZ;
          if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
            currentCustomer.rotation.y = Math.atan2(dx, dz);
          }
          
          // Walking bob animation
          currentCustomer.position.y = Math.abs(Math.sin(Date.now() * 0.012)) * 0.06;
        } else {
          // Fallback: no path, go directly (shouldn't happen but safety)
          const seatX = currentCustomer.userData.seatX;
          const seatZ = currentCustomer.userData.seatZ;
          const counter = gameState.counters.find(c => c.id === table.customer.targetCounterId);
          
          if (counter) {
            const counterX = counter.gridX - GRID.width / 2 + 0.5;
            const counterZ = counter.gridZ - GRID.height / 2 + 0.5 + 0.6;
            
            if (table.customer.state === 'walking_to_counter') {
              currentCustomer.position.set(
                seatX + (counterX - seatX) * progress,
                0,
                seatZ + (counterZ - seatZ) * progress
              );
            } else {
              currentCustomer.position.set(
                counterX + (seatX - counterX) * progress,
                0,
                counterZ + (seatZ - counterZ) * progress
              );
            }
          }
        }
      } else if (currentCustomer && table.customer && !isWalking) {
        // Sitting at table - ensure proper position and rotation
        const seatX = currentCustomer.userData.seatX;
        const seatZ = currentCustomer.userData.seatZ;
        currentCustomer.position.set(seatX, 0, seatZ);
        // Face toward table center
        const tableWorldX = table.gridX - GRID.width / 2 + 0.5;
        const tableWorldZ = table.gridZ - GRID.height / 2 + 0.5;
        currentCustomer.rotation.y = Math.atan2(tableWorldX - seatX, tableWorldZ - seatZ);
      }
      
      // Remove customer when they leave
      if (!table.customer && currentCustomer) {
        scene.remove(currentCustomer);
        delete objectsRef.current.customers[table.id];
      }
      
      // Handle food plate on table when customer is eating
      const existingTableFood = objectsRef.current.tableFood[table.id];
      const shouldHaveFood = table.customer && table.customer.state === 'eating';
      
      if (shouldHaveFood && !existingTableFood) {
        // Add food plate to table
        const foodPlate = new THREE.Group();
        
        const plate = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.2, 0.03, 12),
          new THREE.MeshLambertMaterial({ color: 0xffffff })
        );
        plate.castShadow = true;
        foodPlate.add(plate);
        
        // Food on plate
        const food = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 6),
          new THREE.MeshLambertMaterial({ color: 0xCD853F })
        );
        food.position.y = 0.07;
        food.scale.y = 0.6;
        foodPlate.add(food);
        
        const worldX = table.gridX - GRID.width / 2 + 0.5;
        const worldZ = table.gridZ - GRID.height / 2 + 0.5;
        foodPlate.position.set(worldX, 0.68, worldZ); // On top of table
        
        scene.add(foodPlate);
        objectsRef.current.tableFood[table.id] = foodPlate;
      } else if (!shouldHaveFood && existingTableFood) {
        // Remove food plate from table
        scene.remove(existingTableFood);
        delete objectsRef.current.tableFood[table.id];
      }
    });
    
    // Update standalone chairs (new mix-and-match system)
    const currentChairIds = new Set((gameState.chairs || []).map(c => c.id));
    
    // Remove chairs that no longer exist
    Object.entries(objectsRef.current.chairs || {}).forEach(([id, obj]) => {
      if (!currentChairIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.chairs[id];
      }
    });
    
    // Add/update chairs
    (gameState.chairs || []).forEach(chair => {
      let chairObj = objectsRef.current.chairs[chair.id];
      const style = chair.style || 'basicWood';
      const rotation = chair.rotation || 0;
      
      // Check if chair needs recreation (style or rotation changed)
      if (chairObj && (chairObj.userData.style !== style || chairObj.userData.rotation !== rotation)) {
        scene.remove(chairObj);
        delete objectsRef.current.chairs[chair.id];
        chairObj = null;
      }
      
      if (!chairObj) {
        chairObj = createStandaloneChair(chair.gridX, chair.gridZ, style, rotation);
        chairObj.userData = { type: 'chair', id: chair.id, style, rotation, gridX: chair.gridX, gridZ: chair.gridZ };
        scene.add(chairObj);
        objectsRef.current.chairs[chair.id] = chairObj;
        
        // Check if this is a new purchase (animate pop-in)
        const recentPurchase = newPurchases.find(p => p.type === 'chair' && Date.now() - p.time < 500);
        if (recentPurchase) {
          chairObj.scale.setScalar(0);
          chairObj.userData.animateIn = { startTime: Date.now(), duration: 600 };
        }
      }
    });
    
    // Update waiter positions and appearance (handle multiple waiters)
    // First, ensure all waiters have 3D objects
    const currentWaiterIds = new Set(gameState.waiters.map(w => w.id));
    
    // Remove waiter objects that no longer exist
    Object.entries(objectsRef.current.waiters || {}).forEach(([id, obj]) => {
      if (!currentWaiterIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.waiters[id];
      }
    });
    
    // Add new waiters that don't have objects yet (e.g., newly hired)
    gameState.waiters.forEach(waiter => {
      if (!objectsRef.current.waiters[waiter.id]) {
        const newWaiterObj = createWaiter(false, {
          skin: waiter.skin,
          hair: waiter.hair,
          hairStyle: waiter.hairStyle,
          outfit: waiter.outfit,
        });
        const waiterX = waiter.gridX - GRID.width / 2 + 0.5;
        const waiterZ = waiter.gridZ - GRID.height / 2 + 0.5;
        newWaiterObj.position.set(waiterX, 0, waiterZ);
        newWaiterObj.userData = { id: waiter.id, name: waiter.name, showName: waiter.showName };
        scene.add(newWaiterObj);
        objectsRef.current.waiters[waiter.id] = newWaiterObj;
      } else {
        // Update userData in case name/showName changed
        const waiterObj = objectsRef.current.waiters[waiter.id];
        waiterObj.userData.name = waiter.name;
        waiterObj.userData.showName = waiter.showName;
      }
    });
    
    // Update each waiter's position and appearance
    gameState.waiters.forEach(waiter => {
      const waiterObj = objectsRef.current.waiters[waiter.id];
      if (!waiterObj) return;
      
      const isCarrying = waiter.carryingFood !== null;
      
      // Show/hide carrying plate
      const plateGroup = waiterObj.getObjectByName('carryPlate');
      if (plateGroup) {
        plateGroup.visible = isCarrying;
      }
      
      // Update position based on path if walking
      const isWalking = waiter.state === 'walking_to_counter' || waiter.state === 'walking_to_table' || 
                        waiter.state === 'pacing' || waiter.state === 'returning';
      
      if (isWalking && waiter.path && waiter.path.length >= 2) {
        const path = waiter.path;
        const progress = waiter.walkProgress || 0;
        
        // Calculate which segment of the path we're on
        const totalSegments = path.length - 1;
        const progressPerSegment = 1 / totalSegments;
        const currentSegmentIndex = Math.min(Math.floor(progress / progressPerSegment), totalSegments - 1);
        const segmentProgress = (progress - (currentSegmentIndex * progressPerSegment)) / progressPerSegment;
        
        // Get current and next tile
        const fromTile = path[currentSegmentIndex];
        const toTile = path[currentSegmentIndex + 1];
        
        if (fromTile && toTile) {
          // Convert grid to world coordinates
          const fromX = (fromTile.gridX ?? fromTile.x) - GRID.width / 2 + 0.5;
          const fromZ = (fromTile.gridZ ?? fromTile.z) - GRID.height / 2 + 0.5;
          const toX = (toTile.gridX ?? toTile.x) - GRID.width / 2 + 0.5;
          const toZ = (toTile.gridZ ?? toTile.z) - GRID.height / 2 + 0.5;
          
          // Interpolate position
          const currentX = fromX + (toX - fromX) * segmentProgress;
          const currentZ = fromZ + (toZ - fromZ) * segmentProgress;
          
          waiterObj.position.set(currentX, 0, currentZ);
          
          // Face movement direction
          const dx = toX - fromX;
          const dz = toZ - fromZ;
          if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
            waiterObj.rotation.y = Math.atan2(dx, dz);
          }
          
          // Walking bob animation (offset by waiter index for variety)
          const waiterIndex = gameState.waiters.findIndex(w => w.id === waiter.id);
          waiterObj.position.y = Math.abs(Math.sin(Date.now() * 0.012 + waiterIndex * 0.5)) * 0.06;
        }
      } else if (isWalking && waiter.path && waiter.path.length === 1) {
        // Single tile path - just go there
        const tile = waiter.path[0];
        const worldX = (tile.gridX ?? tile.x) - GRID.width / 2 + 0.5;
        const worldZ = (tile.gridZ ?? tile.z) - GRID.height / 2 + 0.5;
        waiterObj.position.set(worldX, 0, worldZ);
      } else {
        // Idle at current grid position
        const worldX = waiter.gridX - GRID.width / 2 + 0.5;
        const worldZ = waiter.gridZ - GRID.height / 2 + 0.5;
        waiterObj.position.set(worldX, 0, worldZ);
        waiterObj.position.y = 0; // No bob when idle
      }
    });
    
    // Update decorations
    const currentDecorIds = new Set(gameState.decorations.map(d => d.id));
    
    // Remove decorations that no longer exist
    Object.entries(objectsRef.current.decorations).forEach(([id, obj]) => {
      if (!currentDecorIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.decorations[id];
      }
    });
    
    // Add new decorations
    gameState.decorations.forEach(decor => {
      if (!objectsRef.current.decorations[decor.id]) {
        const decorType = DECORATIONS[decor.type];
        const worldX = decor.gridX - GRID.width / 2 + 0.5;
        const worldZ = decor.gridZ - GRID.height / 2 + 0.5;
        
        const decorObj = createDecoration(decor.type, worldX, worldZ, decor.rotation || 0);
        decorObj.userData = { type: 'decoration', id: decor.id, decorType: decor.type, rotation: decor.rotation || 0 };
        
        // Wall decorations - use saved wall data if available, otherwise fallback to distance-based
        if (decorType.category === 'wall') {
          if (decor.wall && decor.wallPosition !== undefined) {
            // New system: use saved wall and wallPosition
            if (decor.wall === 'back') {
              decorObj.position.set(decor.wallPosition - GRID.width / 2 + 0.5, 0, -GRID.height / 2 + 0.02);
              decorObj.rotation.y = 0;
            } else if (decor.wall === 'left') {
              decorObj.position.set(-GRID.width / 2 + 0.02, 0, decor.wallPosition - GRID.height / 2 + 0.5);
              decorObj.rotation.y = Math.PI / 2;
            } else { // right
              decorObj.position.set(GRID.width / 2 - 0.02, 0, decor.wallPosition - GRID.height / 2 + 0.5);
              decorObj.rotation.y = -Math.PI / 2;
            }
          } else {
            // Legacy fallback: use distance-based detection
            const distToBack = decor.gridZ;
            const distToLeft = decor.gridX;
            const distToRight = GRID.width - 1 - decor.gridX;
            const minDist = Math.min(distToBack, distToLeft, distToRight);
            
            if (minDist === distToBack) {
              decorObj.position.set(decor.gridX - GRID.width / 2 + 0.5, 0, -GRID.height / 2 + 0.02);
              decorObj.rotation.y = 0;
            } else if (minDist === distToLeft) {
              decorObj.position.set(-GRID.width / 2 + 0.02, 0, decor.gridZ - GRID.height / 2 + 0.5);
              decorObj.rotation.y = Math.PI / 2;
            } else {
              decorObj.position.set(GRID.width / 2 - 0.02, 0, decor.gridZ - GRID.height / 2 + 0.5);
              decorObj.rotation.y = -Math.PI / 2;
            }
          }
        }
        
        scene.add(decorObj);
        objectsRef.current.decorations[decor.id] = decorObj;
        
        // If it's a floor lamp, hook up its material and light for night glow
        if (decor.type === 'floorLamp') {
          if (decorObj.userData.lampMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.lampMaterial);
          }
          if (decorObj.userData.bulbMaterial) {
            lampMaterialsRef.current.push(decorObj.userData.bulbMaterial);
          }
          if (decorObj.userData.lampLight) {
            interiorLightsRef.current.push(decorObj.userData.lampLight);
          }
        }
        
        // Bounce-in animation
        decorObj.scale.setScalar(0);
        decorObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
      }
    });
    
    // Update dividers
    const currentDividerIds = new Set((gameState.dividers || []).map(d => d.id));
    
    // Remove dividers that no longer exist
    Object.entries(objectsRef.current.dividers || {}).forEach(([id, obj]) => {
      if (!currentDividerIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.dividers[id];
      }
    });
    
    // Add new dividers
    (gameState.dividers || []).forEach(divider => {
      if (!objectsRef.current.dividers[divider.id]) {
        const worldX = divider.gridX - GRID.width / 2 + 0.5;
        const worldZ = divider.gridZ - GRID.height / 2 + 0.5;
        
        const dividerObj = createDivider(divider.type, worldX, worldZ, divider.rotation || 0);
        dividerObj.userData = { type: 'divider', id: divider.id, dividerType: divider.type };
        
        scene.add(dividerObj);
        objectsRef.current.dividers[divider.id] = dividerObj;
        
        // Bounce-in animation
        dividerObj.scale.setScalar(0);
        dividerObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
      }
    });
    
    // Handle doors
    if (!objectsRef.current.doors) objectsRef.current.doors = {};
    const currentDoorIds = new Set((gameState.doors || []).map(d => d.id));
    const previousDoorIds = new Set(Object.keys(objectsRef.current.doors || {}));
    
    // Check if doors have changed
    const doorsChanged = currentDoorIds.size !== previousDoorIds.size ||
      [...currentDoorIds].some(id => !previousDoorIds.has(id));
    
    // Check if wallpaper has changed
    const currentWallpaper = gameState.wallpaper || 'cream';
    const previousWallpaper = wallSegmentsRef.current?.wallpaper || 'cream';
    const wallpaperChanged = currentWallpaper !== previousWallpaper;
    
    // Check if painted segments have changed (use version counter for reliable detection)
    const currentPaintedSegments = gameState.paintedSegments || [];
    const currentPaintedVersion = gameState.paintedVersion || 0;
    const previousPaintedVersion = wallSegmentsRef.current?.paintedVersion || 0;
    const paintedSegmentsChanged = currentPaintedVersion !== previousPaintedVersion;
    
    // Check if floor tiles have changed
    const currentFloorVersion = gameState.floorVersion || 0;
    const previousFloorVersion = objectsRef.current.floorVersion || 0;
    const floorChanged = currentFloorVersion !== previousFloorVersion;
    
    // Update floor tiles if changed - recreate tiles with new styles
    if (floorChanged && objectsRef.current.floorTiles && sceneRef.current) {
      const floorTiles = gameState.floorTiles || {};
      Object.entries(objectsRef.current.floorTiles).forEach(([key, tile]) => {
        if (!tile) return;
        const [x, z] = key.split(',').map(Number);
        const isLight = (x + z) % 2 === 0;
        
        // Determine floor style
        const defaultStyle = z < 3 ? 'whiteTile' : 'woodLight';
        const styleKey = floorTiles[key] || defaultStyle;
        
        // Check if style changed
        if (tile.userData?.styleKey !== styleKey) {
          // Remove old tile
          scene.remove(tile);
          
          // Create new tile with new style
          const style = FLOOR_STYLES[styleKey] || FLOOR_STYLES[defaultStyle];
          const worldX = x - GRID.width / 2 + 0.5;
          const worldZ = z - GRID.height / 2 + 0.5;
          
          const newTile = createPatternedFloorTile(style, worldX, worldZ, isLight);
          newTile.userData = { gridX: x, gridZ: z, styleKey, style };
          scene.add(newTile);
          
          // Update reference
          objectsRef.current.floorTiles[key] = newTile;
        }
      });
      objectsRef.current.floorVersion = currentFloorVersion;
    }
    
    // Initialize door header patterns storage if needed
    if (!objectsRef.current.doorHeaderPatterns) objectsRef.current.doorHeaderPatterns = {};
    
    // Remove doors that no longer exist (and their header patterns)
    Object.entries(objectsRef.current.doors || {}).forEach(([id, obj]) => {
      if (!currentDoorIds.has(id)) {
        scene.remove(obj);
        delete objectsRef.current.doors[id];
        // Also remove header patterns for this door
        const headerPatterns = objectsRef.current.doorHeaderPatterns[id] || [];
        headerPatterns.forEach(p => scene.remove(p));
        delete objectsRef.current.doorHeaderPatterns[id];
      }
    });
    
    // Add new doors (or recreate if wallpaper changed)
    (gameState.doors || []).forEach(door => {
      const needsCreate = !objectsRef.current.doors[door.id];
      const needsRecreate = (wallpaperChanged || paintedSegmentsChanged) && objectsRef.current.doors[door.id];
      
      if (needsRecreate) {
        // Remove old door to recreate with new wallpaper color
        scene.remove(objectsRef.current.doors[door.id]);
        delete objectsRef.current.doors[door.id];
        // Also remove old header patterns
        const oldPatterns = objectsRef.current.doorHeaderPatterns[door.id] || [];
        oldPatterns.forEach(p => scene.remove(p));
        delete objectsRef.current.doorHeaderPatterns[door.id];
      }
      
      if (needsCreate || needsRecreate) {
        // Get wallpaper for this specific segment (check painted segments first, then default)
        const segmentPaint = currentPaintedSegments.find(
          p => p.wall === door.wall && p.position === door.wallPosition
        );
        const segmentWallpaper = segmentPaint ? segmentPaint.wallpaper : currentWallpaper;
        
        const doorObj = createDoor(door.type, door.wall, door.wallPosition, segmentWallpaper);
        doorObj.userData = { type: 'door', id: door.id, doorType: door.type, wall: door.wall, wallPosition: door.wallPosition };
        
        scene.add(doorObj);
        objectsRef.current.doors[door.id] = doorObj;
        
        // Create header patterns for this door (brick mortar, stripes, etc.)
        const headerPatterns = createDoorHeaderPatterns(scene, segmentWallpaper, door.wall, door.wallPosition);
        objectsRef.current.doorHeaderPatterns[door.id] = headerPatterns;
        
        // Bounce-in animation only for new doors, not recreated ones
        if (needsCreate && !needsRecreate) {
          doorObj.scale.setScalar(0);
          doorObj.userData.animateIn = { startTime: Date.now(), duration: 400 };
        }
      }
    });
    
    // Rebuild walls if doors, wallpaper, or painted segments have changed
    if ((doorsChanged || wallpaperChanged || paintedSegmentsChanged) && sceneRef.current && wallSegmentsRef.current) {
      rebuildWalls(sceneRef.current, wallSegmentsRef, gameState.doors || [], currentWallpaper, currentPaintedSegments);
      // Store current state to detect future changes
      if (wallSegmentsRef.current) {
        wallSegmentsRef.current.wallpaper = currentWallpaper;
        wallSegmentsRef.current.paintedVersion = currentPaintedVersion;
      }
    }
  }, [gameState, newPurchases, sceneReady]);
  
  // Highlight selected floor tiles during drag - show ACTUAL style preview by recreating tiles
  useEffect(() => {
    if (!objectsRef.current.floorTiles || !sceneRef.current) return;
    
    const scene = sceneRef.current;
    const floorTiles = gameState.floorTiles || {};
    const selectedSet = new Set(floorSelection.map(t => `${t.gridX},${t.gridZ}`));
    
    Object.entries(objectsRef.current.floorTiles).forEach(([key, tile]) => {
      if (!tile) return;
      const [x, z] = key.split(',').map(Number);
      const isLight = (x + z) % 2 === 0;
      const isSelected = selectedSet.has(key);
      
      // Determine which style to show
      let targetStyleKey;
      if (isSelected && placingFloorStyle) {
        // Preview the selected floor style
        targetStyleKey = placingFloorStyle;
      } else {
        // Show normal/current style
        const defaultStyle = z < 3 ? 'whiteTile' : 'woodLight';
        targetStyleKey = floorTiles[key] || defaultStyle;
      }
      
      // Check if we need to recreate the tile (style changed)
      const currentStyleKey = tile.userData?.styleKey;
      if (currentStyleKey !== targetStyleKey) {
        // Remove old tile
        scene.remove(tile);
        
        // Create new tile with target style
        const style = FLOOR_STYLES[targetStyleKey] || FLOOR_STYLES.woodLight;
        const worldX = x - GRID.width / 2 + 0.5;
        const worldZ = z - GRID.height / 2 + 0.5;
        
        const newTile = createPatternedFloorTile(style, worldX, worldZ, isLight);
        newTile.userData = { gridX: x, gridZ: z, styleKey: targetStyleKey, style };
        scene.add(newTile);
        
        // Update reference
        objectsRef.current.floorTiles[key] = newTile;
      }
    });
  }, [floorSelection, gameState.floorTiles, placingFloorStyle]);
  
  // Preview wallpaper on selected wall segments during drag
  // Shows both color AND pattern preview for accurate representation
  useEffect(() => {
    if (!wallSegmentsRef.current || !sceneRef.current) return;
    
    const scene = sceneRef.current;
    const paintedSegments = gameState.paintedSegments || [];
    const baseWallpaper = gameState.wallpaper || 'cream';
    const hasSelection = wallpaperSelection.length > 0 && placingWallpaper;
    const previewWallpaper = placingWallpaper ? WALLPAPERS[placingWallpaper] : null;
    
    // Create a set of selected segments for quick lookup
    const selectedSet = new Set(wallpaperSelection.map(s => `${s.wall},${s.position}`));
    
    // Helper to get original wallpaper for a segment
    const getOriginalWallpaper = (wall, position) => {
      const painted = paintedSegments.find(p => p.wall === wall && p.position === position);
      return painted ? WALLPAPERS[painted.wallpaper] : WALLPAPERS[baseWallpaper];
    };
    
    // STEP 1: Clean up old preview patterns
    wallpaperPreviewPatternsRef.current.forEach(mesh => {
      if (mesh) scene.remove(mesh);
    });
    wallpaperPreviewPatternsRef.current = [];
    
    // STEP 2: Hide/show existing patterns based on selection
    // Only hide patterns for selected segments (show patterns for non-selected segments)
    const patterns = wallSegmentsRef.current.patterns || [];
    const stripes = wallSegmentsRef.current.stripes || [];
    
    // For each pattern, check if it belongs to a selected segment
    patterns.forEach(p => { 
      if (!p) return;
      // If no userData, default to visible
      if (!p.userData?.isPattern) {
        p.visible = true;
        return;
      }
      // Check if this pattern's segment is selected
      const isSelectedSegment = selectedSet.has(`${p.userData.wallType},${p.userData.segmentPosition}`);
      // Hide if selected (we'll show preview patterns instead), show if not selected
      p.visible = !isSelectedSegment;
    });
    stripes.forEach(s => { 
      if (!s) return;
      if (!s.userData?.isPattern) {
        s.visible = true;
        return;
      }
      const isSelectedSegment = selectedSet.has(`${s.userData.wallType},${s.userData.segmentPosition}`);
      s.visible = !isSelectedSegment;
    });
    
    // STEP 3: Create preview patterns for selected segments
    if (hasSelection && previewWallpaper) {
      wallpaperSelection.forEach(({ wall, position }) => {
        const newPatterns = createWallpaperPreviewPatterns(scene, wall, position, previewWallpaper);
        wallpaperPreviewPatternsRef.current.push(...newPatterns);
      });
    }
    
    // STEP 4: Update all wall segments with preview or original colors
    ['back', 'left', 'right'].forEach(wallType => {
      const segments = wallSegmentsRef.current[wallType] || [];
      segments.forEach(({ position, mesh }) => {
        if (!mesh || !mesh.material) return;
        
        const key = `${wallType},${position}`;
        const isSelected = selectedSet.has(key);
        
        // Determine which wallpaper to show
        let targetWallpaper;
        if (isSelected && placingWallpaper) {
          targetWallpaper = WALLPAPERS[placingWallpaper];
        } else {
          targetWallpaper = getOriginalWallpaper(wallType, position);
        }
        
        if (!targetWallpaper) return;
        
        // Update the interior material color on all interior faces
        // The mesh has a materials array with 6 faces
        const newColor = new THREE.Color(targetWallpaper.color);
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach((mat, idx) => {
            // Skip the exterior face (varies by wall type)
            // Back wall: exterior is face 5 (-Z)
            // Left wall: exterior is face 1 (-X)
            // Right wall: exterior is face 0 (+X)
            const isExterior = (wallType === 'back' && idx === 5) ||
                               (wallType === 'left' && idx === 1) ||
                               (wallType === 'right' && idx === 0);
            if (!isExterior) {
              mat.color.copy(newColor);
            }
          });
        }
      });
    });
  }, [wallpaperSelection, placingWallpaper, gameState.paintedSegments, gameState.wallpaper]);
  
  // Clear stuck coins when tab becomes visible again (fixes AFK coin buildup)
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Tab is now visible - clear any stuck coins
        setFlyingCoins(prev => {
          // Only keep coins created in the last 2 seconds
          const now = Date.now();
          const recentCoins = prev.filter(coin => (now - coin.startTime) < 2000);
          // If we cleared some, log it
          if (recentCoins.length < prev.length) {
            console.log(`Cleared ${prev.length - recentCoins.length} stuck coins on tab focus`);
          }
          return recentCoins;
        });
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, []);
  
  // Create/destroy preview decoration when placement mode changes
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene) return;
    
    // Remove existing preview
    if (previewDecorationRef.current) {
      scene.remove(previewDecorationRef.current);
      previewDecorationRef.current = null;
    }
    
    // Create new preview if placing decoration
    if (placingDecoration) {
      const preview = createDecoration(placingDecoration, 0, 0);
      // Make it semi-transparent and store original colors
      preview.traverse(child => {
        if (child.isMesh && child.material) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
          // Store original color for later restoration
          child.userData.originalColor = child.material.color.getHex();
        }
      });
      preview.visible = false; // Hidden until mouse moves over valid area
      scene.add(preview);
      previewDecorationRef.current = preview;
    }
    
    // Create new preview if placing divider
    if (placingDivider) {
      const preview = createDivider(placingDivider, 0, 0, placementRotation);
      preview.traverse(child => {
        if (child.isMesh && child.material) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
          child.userData.originalColor = child.material.color.getHex();
        }
      });
      preview.visible = false;
      scene.add(preview);
      previewDecorationRef.current = preview;
    }
    
    // Create new preview if placing equipment
    if (placingEquipment) {
      let preview;
      if (placingEquipment === 'stove') {
        preview = createStove(0, 0, placementRotation, placingStoveStyle);
      } else if (placingEquipment === 'counter') {
        preview = createCounter(0, 0, placementRotation, placingCounterStyle);
      } else if (placingEquipment === 'table') {
        preview = createTable(0, 0, placingTableStyle, placementRotation);
      } else if (placingEquipment === 'chair') {
        preview = createStandaloneChair(0, 0, placingChairStyle, placementRotation);
      }
      
      if (preview) {
        // Make it semi-transparent and store original colors
        preview.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.5;
            // Store original color for later restoration
            child.userData.originalColor = child.material.color.getHex();
          }
        });
        preview.visible = false;
        scene.add(preview);
        previewDecorationRef.current = preview;
      }
    }
    
    // Create preview for moving objects (edit mode)
    if (movingObject) {
      let preview;
      if (movingObject.type === 'stove') {
        preview = createStove(0, 0, placementRotation, movingObject.data.style || 'basic');
      } else if (movingObject.type === 'counter') {
        preview = createCounter(0, 0, placementRotation, movingObject.data.style || 'basic');
      } else if (movingObject.type === 'table') {
        preview = createTable(0, 0, movingObject.data.style, placementRotation);
      } else if (movingObject.type === 'chair') {
        preview = createStandaloneChair(0, 0, movingObject.data.style, placementRotation);
      } else if (movingObject.type === 'decoration') {
        preview = createDecoration(movingObject.data.decorationType);
      } else if (movingObject.type === 'divider') {
        preview = createDivider(movingObject.data.dividerType, 0, 0, placementRotation);
      }
      
      if (preview) {
        // Make it semi-transparent
        preview.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.6;
            child.userData.originalColor = child.material.color.getHex();
          }
        });
        preview.visible = false;
        scene.add(preview);
        previewDecorationRef.current = preview;
      }
    }
    
    return () => {
      if (previewDecorationRef.current && scene) {
        scene.remove(previewDecorationRef.current);
        previewDecorationRef.current = null;
      }
    };
  }, [placingDecoration, placingDivider, placingEquipment, placingTableStyle, placingChairStyle, placingStoveStyle, placingCounterStyle, movingObject]); // Note: placementRotation removed - handled by separate effect
  
  // Keyboard handler for rotation while placing
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Shift+C = Clear stuck coins (debug helper)
      if (e.shiftKey && (e.key === 'c' || e.key === 'C')) {
        setFlyingCoins([]);
        console.log('Cleared flying coins');
        return;
      }
      
      // Escape cancels floor painting mode
      if (e.key === 'Escape') {
        if (showFloorConfirm) {
          setShowFloorConfirm(false);
          setFloorSelection([]);
          return;
        }
        if (placingFloorStyle) {
          setPlacingFloorStyle(null);
          setFloorSelection([]);
          return;
        }
        if (showWallpaperConfirm) {
          setShowWallpaperConfirm(false);
          clearWallpaperSelection();
          return;
        }
        if (placingWallpaper) {
          setPlacingWallpaper(null);
          clearWallpaperSelection();
          return;
        }
      }
      
      // Allow rotation for ALL placement modes (equipment, decoration, divider) and moving
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        if (e.key === 'r' || e.key === 'R') {
          setPlacementRotation((prev) => (prev + 1) % 4);
        } else if (e.key === 'Escape') {
          // Cancel placement/move entirely
          setPlacingEquipment(null);
          setPlacingDecoration(null);
          setPlacingDivider(null);
          setMovingObject(null);
          setPlacementLocked(false);
          setLockedPosition(null);
          setPlacementRotation(0);
        }
      }
    };
    
    // Scroll wheel for rotation in placement modes
    const handleWheel = (e) => {
      // Allow rotation for ALL placement modes and moving objects
      if (placingEquipment || placingDecoration || placingDivider || movingObject) {
        e.preventDefault();
        if (e.deltaY > 0) {
          setPlacementRotation((prev) => (prev + 1) % 4);
        } else {
          setPlacementRotation((prev) => (prev + 3) % 4); // +3 is same as -1 mod 4
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('wheel', handleWheel, { passive: false });
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('wheel', handleWheel);
    };
  }, [placingEquipment, placingDecoration, placingDivider, placementLocked, movingObject, placingFloorStyle, placingWallpaper, showFloorConfirm, showWallpaperConfirm]);
  
  // Update preview rotation and re-validate placement when placementRotation changes
  useEffect(() => {
    if (previewDecorationRef.current) {
      // Update rotation
      if (placingDivider) {
        previewDecorationRef.current.rotation.y = (placementRotation % 2) * (Math.PI / 2);
      } else if (placingEquipment || placingDecoration || movingObject) {
        previewDecorationRef.current.rotation.y = placementRotation * (Math.PI / 2);
      }
      
      // Re-validate placement at current position and update colors
      const { gridX, gridZ } = lastPlacementGrid.current;
      let validPlacement = false;
      
      if (placingEquipment === 'table') {
        // New system: tables occupy 1 tile only
        const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
        const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider;
      } else if (placingEquipment === 'chair') {
        // Chairs must be placed facing a table that doesn't already have a chair
        const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
        const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        const hasDivider = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
        
        // Check if chair would face a table
        const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
        const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
        const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
        
        validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && !hasFloorDecor && !hasDivider && tableAvailable;
      } else if (placingEquipment === 'stove') {
        const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        validPlacement = inKitchen && notOnCounter && notOnStove;
      } else if (placingEquipment === 'counter') {
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
        const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
        validPlacement = inCafe && notOnStove && notOnCounter;
      } else if (placingDecoration || placingDivider || movingObject) {
        // For now, keep it valid - mouse move will handle detailed checks
        validPlacement = true;
      }
      
      // Update preview colors based on validity
      if (placingEquipment) {
        previewDecorationRef.current.traverse((child) => {
          if (child.isMesh && child.material) {
            if (validPlacement) {
              if (child.userData.originalColor !== undefined) {
                child.material.color.setHex(child.userData.originalColor);
              }
            } else {
              child.material.color.setHex(0xFF0000);
            }
          }
        });
      }
    }
  }, [placementRotation, placingEquipment, placingDecoration, placingDivider, movingObject, gameState.tables, gameState.chairs, gameState.stoves, gameState.counters, gameState.decorations, gameState.dividers]);
  
  // Game tick - update timers, spawn customers, etc.
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
      
      // Progress time of day (1 real second = 2 game minutes, full day = 12 real minutes)
      setTimeOfDay(prev => {
        const newTime = prev + (2 / 60); // Add 2 minutes per second
        return newTime >= 24 ? newTime - 24 : newTime;
      });
      
      // Check cooking timers
      gameState.stoves.forEach(stove => {
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          // Use mastery-adjusted cook time (Level 3 mastery = 5% faster)
          const masteryCookTime = getCookTimeWithMastery(gameState.dishMastery, stove.recipe);
          
          if (elapsed >= masteryCookTime) {
            dispatch({ type: 'FINISH_COOKING', payload: { stoveId: stove.id } });
            SFX.foodReady();
          }
        } else if (stove.state === 'ready' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (Date.now() - stove.startTime) / 1000;
          // Spoil time is still based on original cook time (no bonus)
          if (elapsed >= recipe.cookTime * 2.2) {
            dispatch({ type: 'SPOIL_FOOD', payload: { stoveId: stove.id } });
            SFX.foodSpoiled();
          }
        }
      });
      
      // Update customer patience & movement
      gameState.tables.forEach(table => {
        if (table.customer) {
          // Customer entering - walking from door to table
          if (table.customer.state === 'entering') {
            const pathLength = table.customer.path?.length || 10;
            const speedPerTile = 0.12; // Slightly faster entry walk
            const progressIncrement = 1 / (pathLength * speedPerTile / 0.02);
            const newProgress = (table.customer.walkProgress || 0) + Math.min(progressIncrement, 0.05);
            if (newProgress >= 1) {
              dispatch({ type: 'CUSTOMER_REACHED_SEAT', payload: { tableId: table.id } });
            } else {
              dispatch({ type: 'UPDATE_WALK_PROGRESS', payload: { tableId: table.id, progress: newProgress } });
            }
          } else if (table.customer.state === 'waiting') {
            const elapsed = (Date.now() - table.customer.spawnTime) / 1000;
            const newPatience = Math.max(0, 100 - elapsed * 2);
            
            if (newPatience <= 0) {
              // Use new START_LEAVING action with happy=false
              dispatch({ type: 'START_LEAVING', payload: { tableId: table.id, happy: false } });
            } else if (Math.abs(newPatience - table.customer.patience) > 1) {
              dispatch({ type: 'UPDATE_CUSTOMER_PATIENCE', payload: { tableId: table.id, patience: newPatience } });
            }
            
            // Customers no longer walk to counter - waiter handles that now
            // (Waiter logic is below in the waiter tick section)
          } else if (table.customer.state === 'eating') {
            const elapsed = (Date.now() - table.customer.eatStartTime) / 1000;
            if (elapsed >= 4) {
              // Use new START_LEAVING action with happy=true
              dispatch({ type: 'START_LEAVING', payload: { tableId: table.id, happy: true } });
              
              // Spawn flying coin from table position (max 5 coins at once to prevent buildup)
              const screenPos = projectedPositions[`table_${table.id}`] || { x: 50, y: 50 };
              setFlyingCoins(prev => {
                const newCoin = {
                  id: Date.now(),
                  startX: screenPos.x,
                  startY: screenPos.y,
                  startTime: Date.now(),
                };
                // Keep only the 4 most recent coins + new one = max 5
                const recentCoins = prev.slice(-4);
                return [...recentCoins, newCoin];
              });
              
              SFX.customerHappy();
              SFX.coinEarn();
              setCoinPop(true);
              setTimeout(() => setCoinPop(false), 300);
            }
          } else if (table.customer.state === 'leaving') {
            // Customer walking from table back to door
            const pathLength = table.customer.path?.length || 10;
            const speedPerTile = 0.12;
            const progressIncrement = 1 / (pathLength * speedPerTile / 0.02);
            const newProgress = (table.customer.walkProgress || 0) + Math.min(progressIncrement, 0.05);
            if (newProgress >= 1) {
              // Customer reached door - remove them
              if (!table.customer.leavingHappy) {
                SFX.customerAngry();
              }
              dispatch({ type: 'CUSTOMER_LEFT', payload: { tableId: table.id } });
            } else {
              dispatch({ type: 'UPDATE_WALK_PROGRESS', payload: { tableId: table.id, progress: newProgress } });
            }
          } else if (table.customer.state === 'leavingHappy') {
            // Legacy state - keep for backwards compatibility
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_HAPPY', payload: { tableId: table.id } });
              SFX.customerHappy();
              SFX.coinEarn();
              // Trigger coin pop effect
              setCoinPop(true);
              setTimeout(() => setCoinPop(false), 300);
            }
          } else if (table.customer.state === 'leavingAngry') {
            // Legacy state - keep for backwards compatibility
            const elapsed = (Date.now() - table.customer.leaveStartTime) / 1000;
            if (elapsed >= 0.8) {
              dispatch({ type: 'CUSTOMER_LEAVE_ANGRY', payload: { tableId: table.id } });
              SFX.customerAngry();
            }
          }
        }
      });
      
      // Spawn customers at empty tables that have adjacent chairs
      // Tables without chairs won't receive customers (must buy a chair for the table!)
      const tablesWithChairs = gameState.tables.filter(t => {
        if (t.customer) return false; // Already has customer
        // Check if this table has an adjacent chair
        const chair = findChairForTable(t, gameState.chairs || []);
        return chair !== null;
      });
      const spawnChance = Math.max(0.01, 0.02 * (gameState.buzz / 50)); // Minimum 1% spawn rate
      if (tablesWithChairs.length > 0 && Math.random() < spawnChance) {
        const randomTable = tablesWithChairs[Math.floor(Math.random() * tablesWithChairs.length)];
        dispatch({ type: 'SPAWN_CUSTOMER', payload: { tableId: randomTable.id } });
        SFX.customerArrive();
      }
      
      // ============ WAITER LOGIC ============
      // Loop through ALL waiters - each operates independently
      // Locking: targetTableId prevents multiple waiters from serving same customer
      // IMPORTANT: Track tables claimed THIS TICK to prevent race conditions
      // (React state is async, so we need synchronous tracking within the loop)
      const tablesClaimedThisTick = [];
      
      gameState.waiters.forEach(waiter => {
        // Get list of tables already being served by OTHER waiters (from state)
        // PLUS tables claimed by earlier waiters in THIS tick (prevents sync/overlap)
        const lockedTableIds = [
          ...getLockedTableIds(gameState.waiters, waiter.id),
          ...tablesClaimedThisTick
        ];
        
        if (waiter.state === 'idle') {
          // Look for work: food on counter AND waiting customer (not locked by another waiter)
          const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
          const targetTable = getMostUrgentCustomer(gameState.tables, null, lockedTableIds);
          
          if (countersWithFood.length > 0 && targetTable) {
            // Work to do! Go get food for the most urgent unlocked customer
            // Pick a RANDOM counter (variety in what customers eat!)
            const counter = countersWithFood[Math.floor(Math.random() * countersWithFood.length)];
            
            const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
            const occupancyMap = buildOccupancyMap(gameState);
            occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
            
            const pathToCounter = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
              counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
            
            if (pathToCounter && pathToCounter.length > 0) {
              // CLAIM this table immediately (before state updates)
              tablesClaimedThisTick.push(targetTable.id);
              
              dispatch({ type: 'WAITER_GO_TO_COUNTER', payload: { 
                waiterId: waiter.id,
                counterId: counter.id, 
                tableId: targetTable.id,
                path: pathToCounter 
              }});
            }
          } else {
            // No work - pace near counters if not already there
            const isNearCounters = waiter.gridZ <= 2;
            
            if (!isNearCounters) {
              // Walk back to counter area
              const targetX = 9 + Math.floor(Math.random() * 5);
              const targetZ = 1;
              
              const occupancyMap = buildOccupancyMap(gameState);
              occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
              
              const path = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
                targetX, targetZ, GRID.width, GRID.height);
              
              if (path && path.length > 1) {
                dispatch({ type: 'WAITER_START_PACING', payload: { waiterId: waiter.id, path }});
              }
            } else if (Math.random() < 0.01) {
              // Occasionally pace to a nearby spot (1% chance per tick)
              const targetX = waiter.gridX + Math.floor(Math.random() * 5) - 2;
              const clampedX = Math.max(8, Math.min(14, targetX));
              
              const occupancyMap = buildOccupancyMap(gameState);
              occupancyMap.delete(getTileKey(waiter.gridX, waiter.gridZ));
              
              const path = findPath(occupancyMap, waiter.gridX, waiter.gridZ, 
                clampedX, waiter.gridZ, GRID.width, GRID.height);
              
              if (path && path.length > 1) {
                dispatch({ type: 'WAITER_START_PACING', payload: { waiterId: waiter.id, path }});
              }
            }
          }
        } else if (waiter.state === 'pacing' || waiter.state === 'returning') {
          // Walking (pacing or returning to counter area)
          const pathLength = waiter.path?.length || 1;
          const newProgress = (waiter.walkProgress || 0) + 0.02;
          
          if (newProgress >= 1) {
            const finalTile = waiter.path[waiter.path.length - 1];
            const newGridX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
            const newGridZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
            
            // If returning from delivery, immediately check for more work
            if (waiter.state === 'returning') {
              const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
              const targetTable = getMostUrgentCustomer(gameState.tables, null, lockedTableIds);
              
              if (countersWithFood.length > 0 && targetTable) {
                // CLAIM this table immediately (before state updates)
                tablesClaimedThisTick.push(targetTable.id);
                
                // Pick a RANDOM counter (variety!)
                const counter = countersWithFood[Math.floor(Math.random() * countersWithFood.length)];
                const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
                
                const occupancyMap = buildOccupancyMap(gameState);
                occupancyMap.delete(getTileKey(newGridX, newGridZ));
                
                const pathToCounter = findPath(occupancyMap, newGridX, newGridZ,
                  counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
                
                if (pathToCounter && pathToCounter.length > 0) {
                  dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { waiterId: waiter.id, gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
                  dispatch({ type: 'WAITER_GO_TO_COUNTER', payload: { 
                    waiterId: waiter.id,
                    counterId: counter.id, 
                    tableId: targetTable.id,
                    path: pathToCounter 
                  }});
                } else {
                  dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { waiterId: waiter.id, gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
                  dispatch({ type: 'WAITER_GO_IDLE', payload: { waiterId: waiter.id } });
                }
              } else {
                dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { waiterId: waiter.id, gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
                dispatch({ type: 'WAITER_GO_IDLE', payload: { waiterId: waiter.id } });
              }
            } else {
              dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { waiterId: waiter.id, gridX: newGridX, gridZ: newGridZ, walkProgress: 0 }});
              dispatch({ type: 'WAITER_GO_IDLE', payload: { waiterId: waiter.id } });
            }
          } else {
            const pathIndex = Math.floor(newProgress * pathLength);
            const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
            dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
              waiterId: waiter.id,
              gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
              gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
              walkProgress: newProgress
            }});
          }
        } else if (waiter.state === 'walking_to_counter') {
          // Walk to counter
          const pathLength = waiter.path?.length || 1;
          const newProgress = (waiter.walkProgress || 0) + 0.03;
          
          if (newProgress >= 1) {
            // Reached counter - pick up food and go to table
            const chair = findChairForTable(
              gameState.tables.find(t => t.id === waiter.targetTableId), 
              gameState.chairs || []
            );
            const table = gameState.tables.find(t => t.id === waiter.targetTableId);
            const customerX = chair ? chair.gridX : table?.gridX || waiter.gridX;
            const customerZ = chair ? chair.gridZ : table?.gridZ || waiter.gridZ;
            
            const finalTile = waiter.path[waiter.path.length - 1];
            const finalX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
            const finalZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
            
            const occupancyMap = buildOccupancyMap(gameState);
            occupancyMap.delete(getTileKey(finalX, finalZ)); // Clear waiter's current pos
            
            // Find an adjacent tile to deliver from (not ON the customer!)
            const deliveryTile = getDeliveryTile(occupancyMap, customerX, customerZ, GRID.width, GRID.height);
            occupancyMap.delete(getTileKey(deliveryTile.gridX, deliveryTile.gridZ));
            
            const pathToTable = findPath(occupancyMap, finalX, finalZ,
              deliveryTile.gridX, deliveryTile.gridZ, GRID.width, GRID.height);
            
            dispatch({ type: 'WAITER_PICKUP_AND_GO', payload: { 
              waiterId: waiter.id,
              counterId: waiter.targetCounterId, 
              tableId: waiter.targetTableId,
              pathToTable: pathToTable || []
            }});
          } else {
            const pathIndex = Math.floor(newProgress * pathLength);
            const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
            dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
              waiterId: waiter.id,
              gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
              gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
              walkProgress: newProgress
            }});
          }
        } else if (waiter.state === 'walking_to_table') {
          // Walk to table
          const pathLength = waiter.path?.length || 1;
          const newProgress = (waiter.walkProgress || 0) + 0.03;
          
          if (newProgress >= 1) {
            // Reached table - serve customer
            const finalTile = waiter.path[waiter.path.length - 1];
            const waiterX = finalTile?.gridX ?? finalTile?.x ?? waiter.gridX;
            const waiterZ = finalTile?.gridZ ?? finalTile?.z ?? waiter.gridZ;
            
            // Check for NEXT job - filter out current customer AND locked customers
            const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
            const nextTable = getMostUrgentCustomer(gameState.tables, waiter.targetTableId, lockedTableIds);
            
            const occupancyMap = buildOccupancyMap(gameState);
            occupancyMap.delete(getTileKey(waiterX, waiterZ));
            
            if (countersWithFood.length > 0 && nextTable) {
              // CLAIM this table immediately (before state updates)
              tablesClaimedThisTick.push(nextTable.id);
              
              // MORE WORK! Go directly to counter with food
              // Pick a RANDOM counter (variety!)
              const counter = countersWithFood[Math.floor(Math.random() * countersWithFood.length)];
              const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
              
              occupancyMap.delete(getTileKey(counterTile.gridX, counterTile.gridZ));
              
              const pathToCounter = findPath(occupancyMap, waiterX, waiterZ,
                counterTile.gridX, counterTile.gridZ, GRID.width, GRID.height);
              
              if (pathToCounter && pathToCounter.length > 0) {
                dispatch({ type: 'WAITER_SERVE_AND_CONTINUE', payload: { 
                  waiterId: waiter.id,
                  tableId: waiter.targetTableId,
                  finalX: waiterX,
                  finalZ: waiterZ,
                  nextCounterId: counter.id,
                  nextTableId: nextTable.id,
                  pathToCounter: pathToCounter
                }});
                SFX.customerServed();
              } else {
                const targetX = 9 + Math.floor(Math.random() * 5);
                const targetZ = 1;
                occupancyMap.delete(getTileKey(targetX, targetZ));
                const returnPath = findPath(occupancyMap, waiterX, waiterZ, targetX, targetZ, GRID.width, GRID.height);
                
                dispatch({ type: 'WAITER_SERVE_AND_RETURN', payload: { 
                  waiterId: waiter.id,
                  tableId: waiter.targetTableId,
                  finalX: waiterX,
                  finalZ: waiterZ,
                  returnPath: returnPath || []
                }});
                SFX.customerServed();
              }
            } else {
              // No more work - return to counter area
              const targetX = 9 + Math.floor(Math.random() * 5);
              const targetZ = 1;
              occupancyMap.delete(getTileKey(targetX, targetZ));
              const returnPath = findPath(occupancyMap, waiterX, waiterZ, targetX, targetZ, GRID.width, GRID.height);
              
              dispatch({ type: 'WAITER_SERVE_AND_RETURN', payload: { 
                waiterId: waiter.id,
                tableId: waiter.targetTableId,
                finalX: waiterX,
                finalZ: waiterZ,
                returnPath: returnPath || []
              }});
              SFX.customerServed();
            }
          } else {
            const pathIndex = Math.floor(newProgress * pathLength);
            const currentTile = waiter.path[Math.min(pathIndex, waiter.path.length - 1)];
            dispatch({ type: 'WAITER_UPDATE_POSITION', payload: { 
              waiterId: waiter.id,
              gridX: currentTile?.gridX ?? currentTile?.x ?? waiter.gridX, 
              gridZ: currentTile?.gridZ ?? currentTile?.z ?? waiter.gridZ,
              walkProgress: newProgress
            }});
          }
        }
      }); // End waiters forEach
      
      // Process chef's pending serve action (set by animation loop when chef reaches table)
      if (chefStateRef.current?.pendingServe) {
        const { tableId, counterId } = chefStateRef.current.pendingServe;
        const table = gameState.tables.find(t => t.id === tableId);
        const counter = gameState.counters.find(c => c.id === counterId);
        
        if (table && table.customer?.state === 'waiting' && counter && counter.dishes.length > 0) {
          dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId, counterId } });
          SFX.customerServed();
        }
        
        // Clear the pending serve
        chefStateRef.current.pendingServe = null;
      }
      
      // Auto-serve customers if enabled - chef picks up food and delivers to tables
      if (autoServe && chefStateRef.current) {
        const chef = chefStateRef.current;
        
        // If chef is idle and not carrying food and has no task, look for food to pick up
        if (chef.state === 'idle' && !chef.task && !chef.carryingPlate) {
          const countersWithFood = gameState.counters.filter(c => c.dishes.length > 0);
          const targetTable = getMostUrgentCustomer(gameState.tables); // Prioritize by patience!
          
          if (countersWithFood.length > 0 && targetTable) {
            // Find counter with food and serve most urgent customer
            // Pick a RANDOM counter (variety!)
            const counter = countersWithFood[Math.floor(Math.random() * countersWithFood.length)];
            
            // Get interaction tile in front of counter
            const counterTile = getInteractionTile('counter', counter.gridX, counter.gridZ, counter.rotation || 0);
            const targetX = counterTile.gridX - GRID.width / 2 + 0.5;
            const targetZ = counterTile.gridZ - GRID.height / 2 + 0.5;
            
            // Assign task: pickup food then deliver to table (animation loop handles the rest)
            setChefTargetWithPath(targetX, targetZ, { 
              type: 'pickup', 
              counterId: counter.id, 
              tableId: targetTable.id 
            });
          }
        }
      }
      
      // Clean up finished flying coins (aggressive cleanup to prevent buildup)
      setFlyingCoins(prev => {
        const now = Date.now();
        // Remove coins older than 1 second
        let filtered = prev.filter(coin => (now - coin.startTime) < 1000);
        // Also cap at max 5 coins just in case
        if (filtered.length > 5) {
          filtered = filtered.slice(-5);
        }
        return filtered;
      });
      
      // Clean up old purchase records
      setNewPurchases(prev => prev.filter(p => Date.now() - p.time < 1000));
    }, 100);
    
    return () => clearInterval(interval);
  }, [gameState, autoServe]);
  
  // Handle clicks
  const handleClick = (e) => {
    if (!containerRef.current || !cameraRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    
    // Handle divider placement mode
    if (placingDivider) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Dividers can go anywhere inside cafe
        const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
        
        // Check for collisions
        let hasCollision = false;
        if (inCafe) {
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = dividerTaken || decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const dividerType = DIVIDERS[placingDivider];
        const validPlacement = inCafe && !hasCollision;
        
        if (validPlacement && gameState.coins >= dividerType.cost) {
          dispatch({ 
            type: 'PLACE_DIVIDER', 
            payload: { dividerType: placingDivider, gridX, gridZ, rotation: placementRotation % 2 } 
          });
          SFX.purchase();
          // Stay in placement mode - only exit if can't afford another
          if (gameState.coins - dividerType.cost < dividerType.cost) {
            setPlacingDivider(null);
            setPlacementRotation(0);
          }
        } else {
          SFX.error();
        }
      }
      return;
    }
    
    // Handle door placement mode - doors go on walls
    if (placingDoor) {
      // Raycast against all objects in the scene to find wall segments
      const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);
      
      // Find the first wall segment we hit
      let hitWallSegment = null;
      for (const hit of intersects) {
        let obj = hit.object;
        // Walk up parent chain to find wall userData
        while (obj && !obj.userData?.wall) {
          obj = obj.parent;
        }
        if (obj && obj.userData?.wall) {
          hitWallSegment = obj;
          break;
        }
      }
      
      if (hitWallSegment) {
        const wall = hitWallSegment.userData.wall;
        const wallPosition = hitWallSegment.userData.position;
        
        // Check if exact position already has a door
        const doorTaken = (gameState.doors || []).some(d => 
          d.wall === wall && d.wallPosition === wallPosition
        );
        
        const doorType = DOORS[placingDoor];
        const validPlacement = !doorTaken;
        
        if (validPlacement && gameState.coins >= doorType.cost) {
          dispatch({ 
            type: 'PLACE_DOOR', 
            payload: { doorType: placingDoor, wall, wallPosition } 
          });
          SFX.purchase();
          // Exit placement mode after placing a door
          setPlacingDoor(null);
        } else {
          SFX.error();
        }
      } else {
        // Didn't click on a wall segment
        SFX.error();
      }
      return;
    }
    
    // Wallpaper painting is now handled via mouseDown/mouseMove for drag support
    // Skip the old click handler for wallpaper
    if (placingWallpaper) {
      return; // Handled by addWallSegmentToSelection in mouseDown/mouseMove
    }
    
    // Handle decoration placement mode
    if (placingDecoration) {
      const decorType = DECORATIONS[placingDecoration];
      const isWallDecor = decorType.category === 'wall';
      
      if (isWallDecor) {
        // Wall decorations: Use the tracked hovered wall segment (same as preview)
        if (hoveredWallSegment) {
          const { wall, position: wallPosition } = hoveredWallSegment;
          
          // Check if this wall segment already has a decoration
          const alreadyHasDecor = gameState.decorations.some(d => 
            d.wall === wall && d.wallPosition === wallPosition
          );
          
          // Convert wall position to grid coordinates for storage
          let gridX, gridZ;
          if (wall === 'back') {
            gridX = wallPosition;
            gridZ = 0;
          } else if (wall === 'left') {
            gridX = 0;
            gridZ = wallPosition;
          } else { // right
            gridX = GRID.width - 1;
            gridZ = wallPosition;
          }
          
          if (!alreadyHasDecor && gameState.coins >= decorType.cost) {
            dispatch({ 
              type: 'PLACE_DECORATION', 
              payload: { decorationType: placingDecoration, gridX, gridZ, wall, wallPosition } 
            });
            SFX.purchase();
            if (gameState.coins - decorType.cost < decorType.cost) {
              setPlacingDecoration(null);
            }
          } else {
            SFX.error();
          }
        } else {
          SFX.error(); // Not hovering over a wall segment
        }
        return;
      }
      
      // Floor decorations: Raycast against the floor to find placement position
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        // Convert world position to grid position
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Floor decorations go in dining area + divider row (gridZ >= 3)
        const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
        
        // Check for collisions with other floor objects
        let hasCollision = false;
        if (inDiningArea) {
          const decorTaken = gameState.decorations.some(d => {
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
          });
          const tableTaken = gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          const stoveTaken = gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const counterTaken = gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          hasCollision = decorTaken || tableTaken || stoveTaken || counterTaken;
        }
        
        const validPlacement = inDiningArea && !hasCollision;
        
        if (validPlacement && gameState.coins >= decorType.cost) {
          dispatch({ 
            type: 'PLACE_DECORATION', 
            payload: { decorationType: placingDecoration, gridX, gridZ, rotation: placementRotation } 
          });
          SFX.purchase();
          // Stay in placement mode - only exit if can't afford another
          if (gameState.coins - decorType.cost < decorType.cost) {
            setPlacingDecoration(null);
          }
        } else {
          // Play error sound when placement fails
          SFX.error();
        }
      }
      return;
    }
    
    // Handle equipment placement mode
    if (placingEquipment) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Validate placement based on equipment type
        let validPlacement = false;
        let actionType = '';
        let cost = 0;
        
        // Helper to check for floor decoration collision
        const hasFloorDecor = gameState.decorations.some(d => {
          const dt = DECORATIONS[d.type];
          return dt.category !== 'wall' && d.gridX === gridX && d.gridZ === gridZ;
        });
        
        if (placingEquipment === 'stove') {
          // Stoves go in kitchen (gridZ 0-2), and not on counter row
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          validPlacement = inKitchen && notOnCounter && notOnStove && !hasFloorDecor && gameState.stoves.length < 8;
          actionType = 'BUY_STOVE';
          cost = STOVE_STYLES[placingStoveStyle]?.cost || 500;
        } else if (placingEquipment === 'counter') {
          // Counters can be placed anywhere in cafe (buffet style!)
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => {
            const tiles = getTableTiles(t);
            return tiles.some(tile => tile.gridX === gridX && tile.gridZ === gridZ);
          });
          validPlacement = inCafe && notOnStove && notOnCounter && notOnTable && !hasFloorDecor && gameState.counters.length < 6;
          actionType = 'BUY_COUNTER';
          cost = COUNTER_STYLES[placingCounterStyle]?.cost || 400;
        } else if (placingEquipment === 'table') {
          // New system: Tables occupy just 1 tile (chairs are placed separately)
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          
          // Check tile is not occupied by existing tables
          const notOnExistingTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          
          // Check not on chairs
          const notOnChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          
          // Check not on stoves/counters
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnDivider = !(gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          
          validPlacement = inDining && notOnExistingTable && notOnChair && notOnStove && notOnCounter && notOnDivider && !hasFloorDecor && gameState.tables.length < 15;
          actionType = 'BUY_TABLE';
          cost = TABLE_STYLES[placingTableStyle]?.cost || 300;
        } else if (placingEquipment === 'chair') {
          // Chairs must be placed facing a table that doesn't already have a chair
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          
          // Check tile is not occupied
          const notOnExistingChair = !(gameState.chairs || []).some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnTable = !gameState.tables.some(t => t.gridX === gridX && t.gridZ === gridZ);
          const notOnStove = !gameState.stoves.some(s => s.gridX === gridX && s.gridZ === gridZ);
          const notOnCounter = !gameState.counters.some(c => c.gridX === gridX && c.gridZ === gridZ);
          const notOnDivider = !(gameState.dividers || []).some(d => d.gridX === gridX && d.gridZ === gridZ);
          
          // Check if chair would face a table that's available
          const facingTile = getChairFacingTile(gridX, gridZ, placementRotation);
          const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
          const tableAvailable = facingTable && !isTableLinkedToChair(gameState.chairs || [], facingTable.id);
          
          const chairCount = (gameState.chairs || []).length;
          validPlacement = inDining && notOnExistingChair && notOnTable && notOnStove && notOnCounter && notOnDivider && !hasFloorDecor && chairCount < 15 && tableAvailable;
          actionType = 'BUY_CHAIR';
          cost = CHAIR_STYLES[placingChairStyle]?.cost || 100;
        }
        
        if (validPlacement && gameState.coins >= cost) {
          // TWO-CLICK SYSTEM for tables: first click locks position, second click confirms
          if (placingEquipment === 'table' && !placementLocked) {
            // First click - lock position for rotation
            setPlacementLocked(true);
            setLockedPosition({ gridX, gridZ });
            SFX.uiClick?.(); // Optional click sound
            return;
          }
          
          // Second click (or non-table equipment) - confirm placement
          const finalGridX = placementLocked ? lockedPosition.gridX : gridX;
          const finalGridZ = placementLocked ? lockedPosition.gridZ : gridZ;
          
          // Include rotation for all equipment types
          const payload = { gridX: finalGridX, gridZ: finalGridZ, rotation: placementRotation };
          if (placingEquipment === 'stove') {
            payload.style = placingStoveStyle;
          } else if (placingEquipment === 'counter') {
            payload.style = placingCounterStyle;
          } else if (placingEquipment === 'table') {
            payload.style = placingTableStyle;
          } else if (placingEquipment === 'chair') {
            payload.style = placingChairStyle;
            // Find and link to the table this chair is facing
            const facingTile = getChairFacingTile(finalGridX, finalGridZ, placementRotation);
            const facingTable = findTableAtPosition(gameState.tables, facingTile.gridX, facingTile.gridZ);
            if (facingTable) {
              payload.linkedTableId = facingTable.id;
            }
          }
          dispatch({ type: actionType, payload });
          SFX.purchase();
          setNewPurchases(prev => [...prev, { type: placingEquipment, time: Date.now() }]);
          setPlacingEquipment(null);
          setPlacementLocked(false);
          setLockedPosition(null);
          setPlacementRotation(0);
        } else {
          // Play error sound when placement fails
          SFX.error();
        }
      }
      return;
    }
    
    // Handle moving objects (edit mode)
    if (movingObject) {
      const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectPoint = new THREE.Vector3();
      raycasterRef.current.ray.intersectPlane(floorPlane, intersectPoint);
      
      if (intersectPoint) {
        const gridX = Math.round(intersectPoint.x + GRID.width / 2 - 0.5);
        const gridZ = Math.round(intersectPoint.z + GRID.height / 2 - 0.5);
        
        // Exclude the current object from collision detection
        const excludeId = movingObject.id;
        
        // Helper to check for collisions
        const hasCollision = (gx, gz, excludeType, excludeObjId) => {
          const decorTaken = gameState.decorations.some(d => {
            if (excludeType === 'decoration' && d.id === excludeObjId) return false;
            const dt = DECORATIONS[d.type];
            return dt.category !== 'wall' && d.gridX === gx && d.gridZ === gz;
          });
          const tableTaken = gameState.tables.some(t => {
            if (excludeType === 'table' && t.id === excludeObjId) return false;
            return t.gridX === gx && t.gridZ === gz; // Tables now occupy 1 tile
          });
          const chairTaken = (gameState.chairs || []).some(c => {
            if (excludeType === 'chair' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          const stoveTaken = gameState.stoves.some(s => {
            if (excludeType === 'stove' && s.id === excludeObjId) return false;
            return s.gridX === gx && s.gridZ === gz;
          });
          const counterTaken = gameState.counters.some(c => {
            if (excludeType === 'counter' && c.id === excludeObjId) return false;
            return c.gridX === gx && c.gridZ === gz;
          });
          const dividerTaken = (gameState.dividers || []).some(d => d.gridX === gx && d.gridZ === gz);
          return decorTaken || tableTaken || chairTaken || stoveTaken || counterTaken || dividerTaken;
        };
        
        let validPlacement = false;
        
        if (movingObject.type === 'stove') {
          const inKitchen = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= 2;
          validPlacement = inKitchen && !hasCollision(gridX, gridZ, 'stove', excludeId);
        } else if (movingObject.type === 'counter') {
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          validPlacement = inCafe && !hasCollision(gridX, gridZ, 'counter', excludeId);
        } else if (movingObject.type === 'table') {
          // New system: tables occupy just 1 tile
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          validPlacement = inDining && !hasCollision(gridX, gridZ, 'table', excludeId);
        } else if (movingObject.type === 'chair') {
          // Chairs occupy 1 tile
          const inDining = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 4 && gridZ <= GRID.height - 1;
          validPlacement = inDining && !hasCollision(gridX, gridZ, 'chair', excludeId);
        } else if (movingObject.type === 'decoration') {
          const decorType = DECORATIONS[movingObject.data.decorationType];
          const isWallDecor = decorType?.category === 'wall';
          const inCafe = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 0 && gridZ <= GRID.height - 1;
          const inDiningArea = gridX >= 0 && gridX <= GRID.width - 1 && gridZ >= 3 && gridZ <= GRID.height - 1;
          const validArea = isWallDecor ? inCafe : inDiningArea;
          validPlacement = validArea && (isWallDecor || !hasCollision(gridX, gridZ, 'decoration', excludeId));
        }
        
        if (validPlacement) {
          // Remove old and add new at new position (no refund for moving)
          if (movingObject.type === 'stove') {
            dispatch({ type: 'REMOVE_STOVE', payload: { stoveId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_STOVE', payload: { gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'counter') {
            dispatch({ type: 'REMOVE_COUNTER', payload: { counterId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_COUNTER', payload: { gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'table') {
            dispatch({ type: 'REMOVE_TABLE', payload: { tableId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_TABLE', payload: { gridX, gridZ, style: movingObject.data.style, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'chair') {
            dispatch({ type: 'REMOVE_CHAIR', payload: { chairId: excludeId, noRefund: true } });
            dispatch({ type: 'BUY_CHAIR', payload: { gridX, gridZ, style: movingObject.data.style, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'decoration') {
            dispatch({ type: 'REMOVE_DECORATION', payload: { decorationId: excludeId, noRefund: true } });
            dispatch({ type: 'PLACE_DECORATION', payload: { decorationType: movingObject.data.decorationType, gridX, gridZ, rotation: placementRotation, free: true } });
          } else if (movingObject.type === 'divider') {
            dispatch({ type: 'REMOVE_DIVIDER', payload: { dividerId: excludeId, noRefund: true } });
            dispatch({ type: 'PLACE_DIVIDER', payload: { dividerType: movingObject.data.dividerType, gridX, gridZ, rotation: placementRotation % 2, free: true } });
          }
          SFX.purchase();
          setMovingObject(null);
          setPlacementRotation(0);
        } else {
          SFX.error();
        }
      }
      return;
    }
    
    // Handle edit mode - click to select objects
    if (editMode && !movingObject) {
      const allEditableObjects = [
        ...Object.values(objectsRef.current.stoves),
        ...Object.values(objectsRef.current.counters),
        ...Object.values(objectsRef.current.tables),
        ...Object.values(objectsRef.current.chairs || {}),
        ...Object.values(objectsRef.current.decorations || {}),
        ...Object.values(objectsRef.current.dividers || {}),
        ...Object.values(objectsRef.current.doors || {}),
      ].filter(Boolean);
      
      const intersects = raycasterRef.current.intersectObjects(allEditableObjects, true);
      
      if (intersects.length > 0) {
        let obj = intersects[0].object;
        while (obj && !obj.userData?.type) {
          obj = obj.parent;
        }
        
        if (obj?.userData) {
          const { type, id } = obj.userData;
          // Toggle selection or select new
          if (selectedEditObject?.type === type && selectedEditObject?.id === id) {
            setSelectedEditObject(null); // Deselect if clicking same object
          } else {
            setSelectedEditObject({ type, id });
            SFX.uiClick?.();
          }
          return;
        }
      }
      
      // Clicked empty space - deselect
      setSelectedEditObject(null);
      return;
    }
    
    const allObjects = [
      ...Object.values(objectsRef.current.stoves),
      ...Object.values(objectsRef.current.counters),
      ...Object.values(objectsRef.current.tables),
      ...Object.values(objectsRef.current.customers),
    ].filter(Boolean);
    
    const intersects = raycasterRef.current.intersectObjects(allObjects, true);
    
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && !obj.userData?.type) {
        obj = obj.parent;
      }
      
      if (obj?.userData) {
        const { type, id, tableId } = obj.userData;
        
        if (type === 'stove') {
          const stove = gameState.stoves.find(s => s.id === id);
          if (stove.state === 'empty') {
            setSelectedStove(id);
          } else if (stove.state === 'ready') {
            // First, try to find a counter with the SAME recipe (for stacking)
            let counter = gameState.counters.find(c => c.dishes.length > 0 && c.dishes[0].recipe === stove.recipe);
            // If no matching recipe counter, find an EMPTY counter
            if (!counter) {
              counter = gameState.counters.find(c => c.dishes.length === 0);
            }
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: id, counterId: counter.id } });
              SFX.serveToCounter();
            }
          } else if (stove.state === 'spoiled') {
            dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: id } });
          }
        } else if (type === 'customer') {
          const table = gameState.tables.find(t => t.id === tableId);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        } else if (type === 'table') {
          // Also allow clicking on tables to serve customers!
          const table = gameState.tables.find(t => t.id === id);
          if (table?.customer?.state === 'waiting') {
            const counter = gameState.counters.find(c => c.dishes.length > 0);
            if (counter) {
              dispatch({ type: 'SERVE_CUSTOMER', payload: { tableId: id, counterId: counter.id } });
              SFX.customerServed();
            }
          }
        }
      }
    }
  };
  
  const handleRecipeSelect = (recipeKey) => {
    if (selectedStove) {
      dispatch({ type: 'START_COOKING', payload: { stoveId: selectedStove, recipeKey } });
      SFX.cookStart();
      setSelectedStove(null);
      setShowCookbook(false);
    }
  };
  
  // Export save - generate JSON for copying
  const handleExportSave = () => {
    const saveData = {
      version: 7, // Version 7: Added floorTiles and floorVersion
      timestamp: Date.now(),
      gameState: {
        coins: gameState.coins,
        xp: gameState.xp,
        level: gameState.level,
        buzz: gameState.buzz,
        avatar: gameState.avatar, // Save avatar customization
        stats: gameState.stats,
        achievements: gameState.achievements,
        // Save full stove state (cooking items will finish immediately on load since time passed)
        stoves: gameState.stoves.map(s => ({ 
          id: s.id, 
          gridX: s.gridX, 
          gridZ: s.gridZ,
          rotation: s.rotation || 0,
          style: s.style || 'basic',
          state: s.state,
          recipe: s.recipe,
          startTime: s.startTime,
          servingsLeft: s.servingsLeft,
        })),
        // Save counter dishes
        counters: gameState.counters.map(c => ({ 
          id: c.id, 
          gridX: c.gridX, 
          gridZ: c.gridZ,
          rotation: c.rotation || 0,
          style: c.style || 'basic',
          dishes: c.dishes,
        })),
        // Save tables (customers will be cleared since they're transient)
        tables: gameState.tables.map(t => ({ 
          id: t.id, gridX: t.gridX, gridZ: t.gridZ, style: t.style, rotation: t.rotation || 0, customer: null 
        })),
        // Save decorations (include wall/wallPosition for wall decorations)
        decorations: gameState.decorations.map(d => ({
          id: d.id, type: d.type, gridX: d.gridX, gridZ: d.gridZ, rotation: d.rotation || 0,
          ...(d.wall && { wall: d.wall, wallPosition: d.wallPosition })
        })),
        // Save dividers
        dividers: (gameState.dividers || []).map(d => ({
          id: d.id, type: d.type, gridX: d.gridX, gridZ: d.gridZ, rotation: d.rotation
        })),
        // Save doors
        doors: (gameState.doors || []).map(d => ({
          id: d.id, type: d.type, wall: d.wall, wallPosition: d.wallPosition
        })),
        // Save chairs (separate from tables)
        chairs: (gameState.chairs || []).map(c => ({
          id: c.id, gridX: c.gridX, gridZ: c.gridZ, style: c.style || 'basicWood', rotation: c.rotation || 0, linkedTableId: c.linkedTableId
        })),
        // Save waiters (hired staff) with customization
        waiters: (gameState.waiters || []).map(w => ({
          id: w.id, gridX: w.gridX, gridZ: w.gridZ,
          name: w.name || '', showName: w.showName || false,
          skin: w.skin ?? 2, hair: w.hair ?? 3, hairStyle: w.hairStyle ?? 0, outfit: w.outfit ?? 0
        })),
        maxWaiters: gameState.maxWaiters || 5,
        // Save dish mastery progress
        dishMastery: gameState.dishMastery || {},
        // Save wall customization
        wallpaper: gameState.wallpaper || 'cream',
        paintedSegments: gameState.paintedSegments || [],
        paintedVersion: gameState.paintedVersion || 0,
        // Save floor customization
        floorTiles: gameState.floorTiles || {},
        floorVersion: gameState.floorVersion || 0,
      },
      // Save audio and display settings
      audioSettings: {
        masterEnabled: soundEnabled,
        soundToggles: soundToggles,
      },
      displaySettings: {
        brightness: brightness,
      },
    };
    
    const json = JSON.stringify(saveData);
    setSaveTextArea(json);
    setShowExportText(true);
    setSaveMessage({ type: 'success', text: 'Save generated! Copy the text below.' });
  };
  
  // Import save from textarea
  const handleImportSave = () => {
    try {
      if (!saveTextArea.trim()) {
        throw new Error('Paste save data first');
      }
      
      const saveData = JSON.parse(saveTextArea);
      
      // Validate save data
      if (!saveData.version || !saveData.gameState) {
        throw new Error('Invalid save format');
      }
      
      const gs = saveData.gameState;
      if (typeof gs.coins !== 'number' || typeof gs.level !== 'number') {
        throw new Error('Invalid save data');
      }
      
      // Clear any stuck UI animations before loading
      setFlyingCoins([]);
      setNewPurchases([]);
      
      // Load the save via dispatch
      dispatch({ type: 'LOAD_SAVE', payload: gs });
      
      // Restore audio settings if present
      if (saveData.audioSettings) {
        if (typeof saveData.audioSettings.masterEnabled === 'boolean') {
          setSoundEnabled(saveData.audioSettings.masterEnabled);
          audioEnabled = saveData.audioSettings.masterEnabled;
        }
        if (saveData.audioSettings.soundToggles) {
          const loadedToggles = { ...soundToggles, ...saveData.audioSettings.soundToggles };
          setSoundToggles(loadedToggles);
          Object.assign(soundTogglesGlobal, loadedToggles);
        }
      }
      
      // Restore display settings if present
      if (saveData.displaySettings) {
        if (typeof saveData.displaySettings.brightness === 'number') {
          setBrightness(saveData.displaySettings.brightness);
          brightnessRef.current = saveData.displaySettings.brightness;
        }
      }
      
      setSaveMessage({ type: 'success', text: 'Game loaded successfully!' });
      setSaveTextArea('');
      setShowExportText(false);
      
      // Clear coins again after a short delay (in case any were created during load)
      setTimeout(() => setFlyingCoins([]), 100);
      
      setTimeout(() => {
        setShowSettings(false);
        setSaveMessage(null);
      }, 1500);
    } catch (err) {
      setSaveMessage({ type: 'error', text: 'Failed: ' + err.message });
    }
  };
  
  // Calculate XP progress
  const prevLevelXp = XP_LEVELS[gameState.level - 1] || 0;
  const xpProgress = ((gameState.xp - prevLevelXp) / (currentLevelXp - prevLevelXp)) * 100;
  
  // Get total food available
  const totalFood = gameState.counters.reduce((sum, c) => sum + c.dishes.reduce((s, d) => s + d.servings, 0), 0);
  
  return (
    <div style={{ width: '100%', height: '100vh', position: 'relative', fontFamily: "'Segoe UI', sans-serif", overflow: 'hidden' }}>
      {/* CSS Animations */}
      <style>{`
        @keyframes pulse {
          0%, 100% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.05); }
        }
        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes jumpOut {
          0% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
          30% { transform: translateX(-50%) translateY(-20px) scale(1.2); opacity: 1; }
          100% { transform: translateX(-50%) translateY(-40px) scale(0.5); opacity: 0; }
        }
        @keyframes stomp {
          0%, 100% { transform: translateX(-50%) translateY(0) rotate(0deg); }
          25% { transform: translateX(-50%) translateY(2px) rotate(-5deg); }
          75% { transform: translateX(-50%) translateY(2px) rotate(5deg); }
        }
        @keyframes coinPop {
          0% { transform: scale(1); }
          50% { transform: scale(1.3); }
          100% { transform: scale(1); }
        }
        @keyframes coinFly {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(0.5); opacity: 0.8; }
        }
        @keyframes bounceIn {
          0% { transform: scale(0.5); opacity: 0; }
          60% { transform: scale(1.1); opacity: 1; }
          100% { transform: scale(1); }
        }
        @keyframes slideDown {
          0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
          60% { transform: translateX(-50%) translateY(5px); opacity: 1; }
          100% { transform: translateX(-50%) translateY(0); }
        }
      `}</style>
      
      {/* 3D Canvas */}
      <div 
        ref={containerRef} 
        onClick={handleClick}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onContextMenu={handleContextMenu}
        style={{ 
          width: '100%', 
          height: '100%', 
          cursor: isDragging ? 'grabbing' : 'pointer' 
        }}
      />
      
      {/* Header UI - Stats Only */}
      <div style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        padding: '12px 20px',
        background: 'linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        alignItems: 'center',
        gap: '15px',
        color: 'white',
      }}>
        {/* Cafe Name & Level */}
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ fontSize: '24px' }}>â˜•</span>
          <div>
            <div style={{ fontWeight: 'bold', fontSize: '18px' }}>Elly's Cafe</div>
            <div style={{ fontSize: '12px', opacity: 0.8 }}>Level {gameState.level}</div>
          </div>
        </div>
        
        {/* XP Bar */}
        <div style={{ flex: 1, maxWidth: '180px' }}>
          <div style={{ fontSize: '11px', marginBottom: '4px' }}>XP: {gameState.xp} / {currentLevelXp}</div>
          <div style={{ background: 'rgba(255,255,255,0.2)', borderRadius: '10px', height: '8px', overflow: 'hidden' }}>
            <div style={{ 
              width: `${Math.min(100, xpProgress)}%`, 
              height: '100%', 
              background: `linear-gradient(90deg, ${COLORS.ui.purple}, ${COLORS.ui.blue})`,
              borderRadius: '10px',
              transition: 'width 0.3s ease',
            }} />
          </div>
        </div>
        
        {/* Coins */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(255,215,0,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(255,215,0,0.3)',
          animation: coinPop ? 'coinPop 0.3s ease-out' : 'none',
        }}>
          <span style={{ fontSize: '18px' }}>ðŸª™</span>
          <span style={{ fontWeight: 'bold', color: COLORS.ui.gold }}>{gameState.coins.toLocaleString()}</span>
        </div>
        
        {/* Buzz Rating */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(34,197,94,0.2)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(34,197,94,0.3)',
        }}>
          <span style={{ fontSize: '16px' }}>â­</span>
          <span style={{ fontWeight: 'bold', color: '#22c55e' }}>{gameState.buzz}</span>
        </div>
        
        {/* Food Ready */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(139,69,19,0.3)',
          padding: '6px 14px',
          borderRadius: '20px',
          border: '1px solid rgba(139,69,19,0.4)',
        }}>
          <span style={{ fontSize: '16px' }}>ðŸ½ï¸</span>
          <span style={{ fontWeight: 'bold' }}>{totalFood}</span>
        </div>
        
        {/* Spacer */}
        <div style={{ flex: 1 }} />
        
        {/* Time Display */}
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: '6px',
          background: 'rgba(0,0,0,0.3)',
          padding: '6px 12px',
          borderRadius: '20px',
        }}>
          <span style={{ fontSize: '16px' }}>
            {timeOfDay >= 5 && timeOfDay < 7 ? 'ðŸŒ…' : 
             timeOfDay >= 7 && timeOfDay < 17 ? 'â˜€ï¸' : 
             timeOfDay >= 17 && timeOfDay < 19 ? 'ðŸŒ‡' : 'ðŸŒ™'}
          </span>
          <span style={{ fontWeight: 'bold', fontSize: '13px' }}>
            {Math.floor(timeOfDay % 12 || 12)}:{String(Math.floor((timeOfDay % 1) * 60)).padStart(2, '0')} 
            {timeOfDay >= 12 ? ' PM' : ' AM'}
          </span>
        </div>
        
        {/* Auto-Serve Toggle */}
        <button
          onClick={() => setAutoServe(!autoServe)}
          style={{
            background: autoServe ? 'rgba(34, 197, 94, 0.4)' : 'rgba(0,0,0,0.3)',
            border: autoServe ? '1px solid rgba(34, 197, 94, 0.6)' : '1px solid rgba(255,255,255,0.2)',
            padding: '6px 10px',
            borderRadius: '20px',
            color: 'white',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '5px',
            fontSize: '12px',
          }}
          title={autoServe ? 'Chef is auto-serving customers' : 'Click to enable auto-serve'}
        >
          <span>ðŸ§‘â€ðŸ³</span>
          <span style={{ 
            width: '8px', 
            height: '8px', 
            borderRadius: '50%', 
            background: autoServe ? '#4ade80' : 'rgba(255,255,255,0.3)',
            boxShadow: autoServe ? '0 0 6px #4ade80' : 'none',
          }}></span>
        </button>
      </div>
      
      {/* Edit Mode Banner */}
      {editMode && (
        <div style={{
          position: 'absolute',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'linear-gradient(135deg, #ef4444, #dc2626)',
          color: 'white',
          padding: '12px 24px',
          borderRadius: '12px',
          fontWeight: 'bold',
          fontSize: '14px',
          boxShadow: '0 4px 20px rgba(239, 68, 68, 0.5)',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          zIndex: 100,
          animation: 'pulse 2s infinite',
        }}>
          <span style={{ fontSize: '20px' }}>âœï¸</span>
          <div>
            <div>EDIT MODE</div>
            <div style={{ fontSize: '11px', opacity: 0.9 }}>Click object to select â€¢ Move or Delete</div>
          </div>
          <button
            onClick={() => {
              setEditMode(false);
              setSelectedEditObject(null);
            }}
            style={{
              background: 'rgba(0,0,0,0.3)',
              border: 'none',
              color: 'white',
              padding: '6px 12px',
              borderRadius: '6px',
              cursor: 'pointer',
              marginLeft: '8px',
            }}
          >
            âŒ Exit
          </button>
        </div>
      )}
      
      {/* Moving Object Banner */}
      {movingObject && (
        <div style={{
          position: 'absolute',
          top: '70px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
          color: 'white',
          padding: '12px 24px',
          borderRadius: '12px',
          fontWeight: 'bold',
          fontSize: '14px',
          boxShadow: '0 4px 20px rgba(59, 130, 246, 0.5)',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          zIndex: 100,
          animation: 'pulse 2s infinite',
        }}>
          <span style={{ fontSize: '20px' }}>âœ‹</span>
          <div>
            <div>MOVING {movingObject.type.toUpperCase()}</div>
            <div style={{ fontSize: '11px', opacity: 0.9 }}>Click to place â€¢ R to rotate â€¢ ESC/Right-click to cancel</div>
          </div>
          <button
            onClick={() => {
              setMovingObject(null);
              setPlacementRotation(0);
            }}
            style={{
              background: 'rgba(0,0,0,0.3)',
              border: 'none',
              color: 'white',
              padding: '6px 12px',
              borderRadius: '6px',
              cursor: 'pointer',
              marginLeft: '8px',
            }}
          >
            âŒ Cancel
          </button>
        </div>
      )}
      
      {/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          MAIN BOTTOM BAR - Clean organized icons like original Cafe World
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */}
      <div style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        height: showShop ? 'auto' : '70px',
        background: 'linear-gradient(to bottom, #f5e6d3, #e8d4be)',
        borderTop: '3px solid #8B4513',
        zIndex: 90,
        boxShadow: '0 -4px 15px rgba(0,0,0,0.2)',
      }}>
        {/* Main Icon Bar - Always visible */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '8px',
          padding: '8px 15px',
          height: '54px',
        }}>
          {/* Left side - Main action buttons */}
          <div style={{ display: 'flex', gap: '6px' }}>
            {/* Decor/Shop Button */}
            <button
              onClick={() => {
                setShowShop(!showShop);
                if (showShop) {
                  setPlacingEquipment(null);
                  setPlacingDecoration(null);
                  setPlacingWallpaper(null);
                  clearWallpaperSelection();
                  setShowWallpaperConfirm(false);
                  setPlacingFloorStyle(null);
                  setFloorSelection([]);
                  setShowFloorConfirm(false);
                }
              }}
              style={{
                background: showShop ? '#4CAF50' : 'linear-gradient(135deg, #8B5A2B, #A0522D)',
                color: 'white',
                border: 'none',
                padding: '10px 18px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                boxShadow: showShop ? '0 0 0 3px rgba(76,175,80,0.4)' : '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="Shop - Buy furniture & decorations"
            >
              ðŸª‘ {showShop ? 'Close' : 'Shop'}
            </button>
            
            {/* Edit Mode Button */}
            <button
              onClick={() => {
                if (editMode) {
                  setSelectedEditObject(null);
                }
                setEditMode(!editMode);
                // Clear ALL placement modes when toggling edit
                setPlacingDecoration(null);
                setPlacingEquipment(null);
                setPlacingWallpaper(null);
                clearWallpaperSelection();
                setShowWallpaperConfirm(false);
                setPlacingDivider(null);
                setPlacingDoor(null);
                setPlacingFloorStyle(null);
                setFloorSelection([]);
                setShowShop(false);
              }}
              style={{
                background: editMode ? '#ef4444' : 'linear-gradient(135deg, #f97316, #ea580c)',
                color: 'white',
                border: 'none',
                padding: '10px 16px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: editMode ? '0 0 0 3px rgba(239,68,68,0.4)' : '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="Edit/Move/Delete items"
            >
              âœï¸ {editMode ? 'Done' : 'Edit'}
            </button>
            
            {/* Cookbook Button */}
            <button
              onClick={() => setShowCookbook(true)}
              style={{
                background: 'linear-gradient(135deg, #7c3aed, #6d28d9)',
                color: 'white',
                border: 'none',
                padding: '10px 16px',
                borderRadius: '10px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
                fontSize: '14px',
              }}
              title="View all recipes"
            >
              ðŸ“– Recipes
            </button>
          </div>
          
          {/* Center - Cafe Info */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '15px',
            padding: '0 20px',
            borderLeft: '1px solid rgba(139,69,19,0.3)',
            borderRight: '1px solid rgba(139,69,19,0.3)',
            marginLeft: '10px',
            marginRight: '10px',
          }}>
            <div style={{ textAlign: 'center', fontSize: '13px' }}>
              <div style={{ fontWeight: 'bold', color: '#5D3A1A' }}>Tables</div>
              <div style={{ color: '#8B4513' }}>{gameState.tables.length}/15</div>
            </div>
            <div style={{ textAlign: 'center', fontSize: '13px' }}>
              <div style={{ fontWeight: 'bold', color: '#5D3A1A' }}>Stoves</div>
              <div style={{ color: '#8B4513' }}>{gameState.stoves.length}/8</div>
            </div>
          </div>
          
          {/* Right side - Utility buttons */}
          <div style={{ display: 'flex', gap: '6px' }}>
            {/* Camera Controls */}
            <div style={{
              display: 'flex',
              gap: '3px',
              background: 'rgba(139,69,19,0.15)',
              padding: '5px',
              borderRadius: '8px',
            }}>
              <button onClick={() => setCameraAngle(prev => prev + Math.PI/6)} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }} title="Rotate Left">â†º</button>
              <button onClick={() => { setCameraAngle(Math.PI / 4); setCameraPitch(0.6); }} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontSize: '12px' }} title="Reset View">âŒ‚</button>
              <button onClick={() => setCameraAngle(prev => prev - Math.PI/6)} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }} title="Rotate Right">â†»</button>
              <div style={{ width: '1px', background: 'rgba(139,69,19,0.3)', margin: '2px' }} />
              <button onClick={() => setZoomLevel(Math.max(0.5, zoomLevel - 0.25))} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: zoomLevel > 0.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel > 0.5 ? 1 : 0.5, fontWeight: 'bold' }} title="Zoom In">+</button>
              <button onClick={() => setZoomLevel(Math.min(1.5, zoomLevel + 0.25))} style={{ background: 'transparent', color: '#5D3A1A', border: 'none', padding: '5px 8px', borderRadius: '6px', cursor: zoomLevel < 1.5 ? 'pointer' : 'not-allowed', opacity: zoomLevel < 1.5 ? 1 : 0.5, fontWeight: 'bold' }} title="Zoom Out">âˆ’</button>
            </div>
            
            {/* Volume Toggle */}
            <button
              onClick={() => {
                setSoundEnabled(!soundEnabled);
                audioEnabled = !soundEnabled;
              }}
              style={{
                background: soundEnabled ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'linear-gradient(135deg, #6b7280, #4b5563)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                fontSize: '16px',
              }}
              title={soundEnabled ? 'Sound ON - Click to mute' : 'Sound OFF - Click to unmute'}
            >
              {soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡'}
            </button>
            
            {/* Trophy/Achievements */}
            <button
              onClick={() => setShowTrophies(true)}
              style={{
                background: 'linear-gradient(135deg, #fbbf24, #f59e0b)',
                color: '#5D3A1A',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '4px',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                fontWeight: 'bold',
                fontSize: '13px',
              }}
              title="Achievements"
            >
              ðŸ† {gameState.achievements.length}/{Object.keys(ACHIEVEMENTS).length}
            </button>
            
            {/* Avatar Customize */}
            <button
              onClick={() => setShowAvatarCustomize(true)}
              style={{
                background: 'linear-gradient(135deg, #F472B6, #EC4899)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Customize Chef"
            >
              ðŸ‘©â€ðŸ³
            </button>
            
            {/* Save/Load */}
            <button
              onClick={() => setShowSettings(true)}
              style={{
                background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Save/Load Game"
            >
              ðŸ’¾
            </button>
            
            {/* Audio/Settings */}
            <button
              onClick={() => setShowAudioSettings(true)}
              style={{
                background: 'linear-gradient(135deg, #6b7280, #4b5563)',
                color: 'white',
                border: 'none',
                padding: '8px 12px',
                borderRadius: '8px',
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
              title="Settings"
            >
              âš™ï¸
            </button>
          </div>
        </div>
        
        {/* Shop Panel Content - Shows below the bar when shop is open */}
        {showShop && (
          <>
            {/* Category Tabs */}
            <div style={{
              display: 'flex',
              gap: '5px',
              padding: '0 10px',
              borderTop: '1px solid rgba(139,69,19,0.2)',
              borderBottom: '2px solid #d4c4a8',
              background: 'rgba(255,255,255,0.3)',
            }}>
              {(() => {
                // Calculate item counts for each category (collections count as 1, not N variants)
                const categoryCounts = {
                  stoves: Object.keys(STOVE_STYLES).length - STOVE_COLLECTION_VARIANTS.length + Object.keys(STOVE_COLLECTIONS).length,
                  counters: Object.keys(COUNTER_STYLES).length - COUNTER_COLLECTION_VARIANTS.length + Object.keys(COUNTER_COLLECTIONS).length,
                  tables: Object.keys(TABLE_STYLES).length - TABLE_COLLECTION_VARIANTS.length + Object.keys(TABLE_COLLECTIONS).length,
                  chairs: Object.keys(CHAIR_STYLES).length - CHAIR_COLLECTION_VARIANTS.length + Object.keys(CHAIR_COLLECTIONS).length,
                  staff: 1, // Waiter
                  decor: Object.keys(DECORATIONS).length,
                  dividers: Object.keys(DIVIDERS).length,
                  doors: Object.keys(DOORS).length,
                  walls: Object.keys(WALLPAPERS).length - WALLPAPER_COLLECTION_VARIANTS.length + Object.keys(WALLPAPER_COLLECTIONS).length,
                  floors: Object.keys(FLOOR_STYLES).length - FLOOR_COLLECTION_VARIANTS.length + Object.keys(FLOOR_COLLECTIONS).length,
                };
                return [
                { id: 'stoves', icon: 'ðŸ”¥', label: 'Stoves' },
                { id: 'counters', icon: 'ðŸ½ï¸', label: 'Counters' },
                { id: 'tables', icon: 'ðŸª‘', label: 'Tables' },
                { id: 'chairs', icon: 'ðŸ’º', label: 'Chairs' },
                { id: 'staff', icon: 'ðŸ‘”', label: 'Staff' },
                { id: 'decor', icon: 'ðŸŒ¸', label: 'Decor' },
                { id: 'dividers', icon: 'ðŸš§', label: 'Dividers' },
                { id: 'doors', icon: 'ðŸšª', label: 'Doors' },
                { id: 'walls', icon: 'ðŸŽ¨', label: 'Walls' },
                { id: 'floors', icon: 'ðŸŸ«', label: 'Floors' },
              ].map(cat => (
                <button
                  key={cat.id}
                  onClick={() => {
                    setShopCategory(cat.id);
                    // Clear floor painting mode when switching away from floors
                    if (cat.id !== 'floors') {
                      setPlacingFloorStyle(null);
                      setFloorSelection([]);
                    }
                    // Clear wallpaper mode when switching away from walls
                    if (cat.id !== 'walls') {
                      setPlacingWallpaper(null);
                      clearWallpaperSelection();
                      setShowWallpaperConfirm(false);
                    }
                  }}
                  style={{
                    padding: '10px 20px',
                    border: 'none',
                    borderRadius: '8px 8px 0 0',
                    background: shopCategory === cat.id ? '#fff' : 'transparent',
                    cursor: 'pointer',
                    fontWeight: shopCategory === cat.id ? 'bold' : 'normal',
                    color: shopCategory === cat.id ? '#8B4513' : '#666',
                    borderBottom: shopCategory === cat.id ? '3px solid #4CAF50' : '3px solid transparent',
                    marginBottom: '-2px',
                    fontSize: '14px',
                    transition: 'all 0.15s',
                  }}
                >
                  {cat.icon} {cat.label} <span style={{ 
                    fontSize: '10px', 
                    color: shopCategory === cat.id ? '#4CAF50' : '#999',
                    marginLeft: '2px'
                  }}>({categoryCounts[cat.id]})</span>
                </button>
              ));
              })()}
            </div>
            
            {/* Placement Hint */}
            {(placingEquipment || placingDecoration || placingDivider) && (
              <div style={{
                background: '#e8f5e9',
                padding: '8px 15px',
                textAlign: 'center',
                borderTop: '1px solid #c8e6c9',
                color: '#2e7d32',
                fontSize: '13px',
                fontWeight: 'bold',
              }}>
                ðŸ‘† Click to place â€¢ Press R to rotate â€¢ Click item again to deselect
              </div>
            )}
            
            {/* Wallpaper Placement Hint */}
            {placingWallpaper && (
              <div style={{
                background: '#f3e5f5',
                padding: '8px 15px',
                textAlign: 'center',
                borderTop: '1px solid #e1bee7',
                color: '#7b1fa2',
                fontSize: '13px',
                fontWeight: 'bold',
              }}>
                ðŸŽ¨ Click and DRAG to preview walls, release to confirm! (ðŸª™{WALLPAPERS[placingWallpaper]?.cost}/segment) â€¢ Press ESC to cancel
              </div>
            )}
            
            {/* Floor Painting Hint */}
            {placingFloorStyle && (
              <div style={{
                background: '#fff3e0',
                padding: '8px 15px',
                textAlign: 'center',
                borderTop: '1px solid #ffe0b2',
                color: '#e65100',
                fontSize: '13px',
                fontWeight: 'bold',
              }}>
                ðŸŸ« Click and DRAG to preview tiles, release to confirm! (ðŸª™{FLOOR_STYLES[placingFloorStyle]?.cost}/tile) â€¢ Press ESC to cancel
              </div>
            )}
            
            {/* Items Row */}
            <div style={{ 
              display: 'flex',
              alignItems: 'stretch',
              background: '#fff',
            }}>
              {/* Left Arrow */}
              <div 
                onClick={() => {
                  if (shopScrollRef.current && shopScrollPos.left > 0) {
                    shopScrollRef.current.scrollBy({ left: -200, behavior: 'smooth' });
                  }
                }}
                style={{
                  width: '45px',
                  background: shopScrollPos.left > 0 
                    ? 'linear-gradient(135deg, #e8a849 0%, #d4892a 100%)'
                    : '#ccc',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  cursor: shopScrollPos.left > 0 ? 'pointer' : 'default',
                  fontSize: '24px',
                  color: 'white',
                  fontWeight: 'bold',
                }}
              >â—€</div>
              
              {/* Scrollable Items Container */}
              <div 
                ref={shopScrollRef}
                onScroll={(e) => {
                  const el = e.target;
                  setShopScrollPos({
                    left: el.scrollLeft,
                    max: el.scrollWidth - el.clientWidth
                  });
                }}
                onWheel={(e) => {
                  // Allow horizontal scrolling with mouse wheel
                  if (shopScrollRef.current) {
                    e.preventDefault();
                    shopScrollRef.current.scrollLeft += e.deltaY;
                  }
                }}
                style={{
                  flex: 1,
                  display: 'flex',
                  gap: '12px',
                  padding: '15px 20px',
                  overflowX: 'auto',
                  background: 'linear-gradient(180deg, #fffcf5 0%, #fff8ed 100%)',
                  scrollbarWidth: 'none',
                }}
              >
              {/* Stoves Category */}
              {shopCategory === 'stoves' && (
                <>
                  {/* Individual stoves (not in collections) */}
                  {Object.entries(STOVE_STYLES)
                    .filter(([key]) => !STOVE_COLLECTION_VARIANTS.includes(key))
                    .map(([key, stoveStyle]) => {
                    const canAfford = gameState.coins >= stoveStyle.cost && gameState.stoves.length < 8;
                    const isSelected = placingEquipment === 'stove' && placingStoveStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingStoveStyle('basic');
                            } else {
                              setPlacingEquipment('stove');
                              setPlacingStoveStyle(key);
                              setPlacingDecoration(null);
                              setPlacingDivider(null);
                              setPlacingDoor(null);
                              setPlacingWallpaper(null);
                              setPlacingFloorStyle(null);
                              setFloorSelection([]);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{stoveStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{stoveStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{gameState.stoves.length}/8</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {stoveStyle.cost}</div>
                      </div>
                    );
                  })}
                  
                  {/* Stove Collections */}
                  {Object.entries(STOVE_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`stove_${collKey}`] || collection.variants[0];
                    const canAfford = gameState.coins >= collection.cost && gameState.stoves.length < 8;
                    const isSelected = placingEquipment === 'stove' && collection.variants.includes(placingStoveStyle);
                    const selectedIdx = collection.variants.indexOf(selectedVariant);
                    return (
                      <div
                        key={collKey}
                        style={{
                          minWidth: '120px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div 
                          onClick={() => {
                            if (canAfford) {
                              if (isSelected) {
                                setPlacingEquipment(null);
                                setPlacingStoveStyle('basic');
                              } else {
                                setPlacingEquipment('stove');
                                setPlacingStoveStyle(selectedVariant);
                                setPlacingDecoration(null);
                                setPlacingDivider(null);
                                setPlacingDoor(null);
                                setPlacingWallpaper(null);
                                setPlacingFloorStyle(null);
                                setFloorSelection([]);
                              }
                            }
                          }}
                          style={{ cursor: canAfford ? 'pointer' : 'not-allowed' }}
                        >
                          <div style={{ fontSize: '32px', marginBottom: '5px' }}>{collection.icon}</div>
                          <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                          <div style={{ fontSize: '10px', color: '#666' }}>{gameState.stoves.length}/8</div>
                          <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {collection.cost}</div>
                        </div>
                        {/* Color swatches */}
                        <div style={{ display: 'flex', gap: '3px', justifyContent: 'center', marginTop: '8px', flexWrap: 'wrap' }}>
                          {collection.colors.map((color, idx) => (
                            <div
                              key={idx}
                              onClick={(e) => {
                                e.stopPropagation();
                                if (canAfford) {
                                  const newVariant = collection.variants[idx];
                                  setSelectedCollectionVariant(prev => ({ ...prev, [`stove_${collKey}`]: newVariant }));
                                  // Always select this item for placement when clicking swatch
                                  setPlacingEquipment('stove');
                                  setPlacingStoveStyle(newVariant);
                                  setPlacingCounterStyle(null);
                                  setPlacingTableStyle(null);
                                  setPlacingChairStyle(null);
                                  setPlacingWallpaper(null);
                                  setPlacingFloor(null);
                                  setPlacingDoor(null);
                                  setPlacingDivider(null);
                                  setPlacingDecoration(null);
                                }
                              }}
                              title={collection.colorNames[idx]}
                              style={{
                                width: '16px',
                                height: '16px',
                                borderRadius: '3px',
                                background: `#${color.toString(16).padStart(6, '0')}`,
                                border: idx === selectedIdx ? '2px solid #4CAF50' : '1px solid #999',
                                cursor: canAfford ? 'pointer' : 'not-allowed',
                                boxShadow: idx === selectedIdx ? '0 0 4px rgba(76,175,80,0.5)' : 'none',
                              }}
                            />
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Counters Category */}
              {shopCategory === 'counters' && (
                <>
                  {/* Individual counters (not in collections) */}
                  {Object.entries(COUNTER_STYLES)
                    .filter(([key]) => !COUNTER_COLLECTION_VARIANTS.includes(key))
                    .map(([key, counterStyle]) => {
                    const canAfford = gameState.coins >= counterStyle.cost && gameState.counters.length < 6;
                    const isSelected = placingEquipment === 'counter' && placingCounterStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingCounterStyle('basic');
                            } else {
                              setPlacingEquipment('counter');
                              setPlacingCounterStyle(key);
                              setPlacingDecoration(null);
                              setPlacingDivider(null);
                              setPlacingDoor(null);
                              setPlacingWallpaper(null);
                              setPlacingFloorStyle(null);
                              setFloorSelection([]);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{counterStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{counterStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{gameState.counters.length}/6</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {counterStyle.cost}</div>
                      </div>
                    );
                  })}
                  
                  {/* Counter Collections */}
                  {Object.entries(COUNTER_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`counter_${collKey}`] || collection.variants[0];
                    const canAfford = gameState.coins >= collection.cost && gameState.counters.length < 6;
                    const isSelected = placingEquipment === 'counter' && collection.variants.includes(placingCounterStyle);
                    const selectedIdx = collection.variants.indexOf(selectedVariant);
                    return (
                      <div
                        key={collKey}
                        style={{
                          minWidth: '120px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div 
                          onClick={() => {
                            if (canAfford) {
                              if (isSelected) {
                                setPlacingEquipment(null);
                                setPlacingCounterStyle('basic');
                              } else {
                                setPlacingEquipment('counter');
                                setPlacingCounterStyle(selectedVariant);
                                setPlacingDecoration(null);
                                setPlacingDivider(null);
                                setPlacingDoor(null);
                                setPlacingWallpaper(null);
                                setPlacingFloorStyle(null);
                                setFloorSelection([]);
                              }
                            }
                          }}
                          style={{ cursor: canAfford ? 'pointer' : 'not-allowed' }}
                        >
                          <div style={{ fontSize: '32px', marginBottom: '5px' }}>{collection.icon}</div>
                          <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                          <div style={{ fontSize: '10px', color: '#666' }}>{gameState.counters.length}/6</div>
                          <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {collection.cost}</div>
                        </div>
                        {/* Color swatches */}
                        <div style={{ display: 'flex', gap: '3px', justifyContent: 'center', marginTop: '8px', flexWrap: 'wrap' }}>
                          {collection.colors.map((color, idx) => (
                            <div
                              key={idx}
                              onClick={(e) => {
                                e.stopPropagation();
                                if (canAfford) {
                                  const newVariant = collection.variants[idx];
                                  setSelectedCollectionVariant(prev => ({ ...prev, [`counter_${collKey}`]: newVariant }));
                                  // Always select this item for placement when clicking swatch
                                  setPlacingEquipment('counter');
                                  setPlacingCounterStyle(newVariant);
                                  setPlacingStoveStyle(null);
                                  setPlacingTableStyle(null);
                                  setPlacingChairStyle(null);
                                  setPlacingWallpaper(null);
                                  setPlacingFloor(null);
                                  setPlacingDoor(null);
                                  setPlacingDivider(null);
                                  setPlacingDecoration(null);
                                }
                              }}
                              title={collection.colorNames[idx]}
                              style={{
                                width: '16px',
                                height: '16px',
                                borderRadius: '3px',
                                background: `#${color.toString(16).padStart(6, '0')}`,
                                border: idx === selectedIdx ? '2px solid #4CAF50' : '1px solid #999',
                                cursor: canAfford ? 'pointer' : 'not-allowed',
                                boxShadow: idx === selectedIdx ? '0 0 4px rgba(76,175,80,0.5)' : 'none',
                              }}
                            />
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Tables Category */}
              {shopCategory === 'tables' && (
                <>
                  {/* Individual tables (not in collections) */}
                  {Object.entries(TABLE_STYLES)
                    .filter(([key]) => !TABLE_COLLECTION_VARIANTS.includes(key))
                    .map(([key, tableStyle]) => {
                    const canAfford = gameState.coins >= tableStyle.cost && gameState.tables.length < 15;
                    const isSelected = placingEquipment === 'table' && placingTableStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingTableStyle('square');
                            } else {
                              setPlacingEquipment('table');
                              setPlacingTableStyle(key);
                              setPlacingDecoration(null);
                              setPlacingFloorStyle(null);
                              setFloorSelection([]);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{tableStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{tableStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{gameState.tables.length}/15</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {tableStyle.cost}</div>
                      </div>
                    );
                  })}
                  
                  {/* Table Collections */}
                  {Object.entries(TABLE_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`table_${collKey}`] || collection.variants[0];
                    const canAfford = gameState.coins >= collection.cost && gameState.tables.length < 15;
                    const isSelected = placingEquipment === 'table' && collection.variants.includes(placingTableStyle);
                    const selectedIdx = collection.variants.indexOf(selectedVariant);
                    return (
                      <div
                        key={collKey}
                        style={{
                          minWidth: '120px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div 
                          onClick={() => {
                            if (canAfford) {
                              if (isSelected) {
                                setPlacingEquipment(null);
                                setPlacingTableStyle('square');
                              } else {
                                setPlacingEquipment('table');
                                setPlacingTableStyle(selectedVariant);
                                setPlacingDecoration(null);
                                setPlacingFloorStyle(null);
                                setFloorSelection([]);
                              }
                            }
                          }}
                          style={{ cursor: canAfford ? 'pointer' : 'not-allowed' }}
                        >
                          <div style={{ fontSize: '32px', marginBottom: '5px' }}>{collection.icon}</div>
                          <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                          <div style={{ fontSize: '10px', color: '#666' }}>{gameState.tables.length}/15</div>
                          <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {collection.cost}</div>
                        </div>
                        {/* Color swatches */}
                        <div style={{ display: 'flex', gap: '3px', justifyContent: 'center', marginTop: '8px', flexWrap: 'wrap' }}>
                          {collection.colors.map((color, idx) => (
                            <div
                              key={idx}
                              onClick={(e) => {
                                e.stopPropagation();
                                if (canAfford) {
                                  const newVariant = collection.variants[idx];
                                  setSelectedCollectionVariant(prev => ({ ...prev, [`table_${collKey}`]: newVariant }));
                                  // Always select this item for placement when clicking swatch
                                  setPlacingEquipment('table');
                                  setPlacingTableStyle(newVariant);
                                  setPlacingStoveStyle(null);
                                  setPlacingCounterStyle(null);
                                  setPlacingChairStyle(null);
                                  setPlacingWallpaper(null);
                                  setPlacingFloor(null);
                                  setPlacingDoor(null);
                                  setPlacingDivider(null);
                                  setPlacingDecoration(null);
                                }
                              }}
                              title={collection.colorNames[idx]}
                              style={{
                                width: '16px',
                                height: '16px',
                                borderRadius: '3px',
                                background: `#${color.toString(16).padStart(6, '0')}`,
                                border: idx === selectedIdx ? '2px solid #4CAF50' : '1px solid #999',
                                cursor: canAfford ? 'pointer' : 'not-allowed',
                                boxShadow: idx === selectedIdx ? '0 0 4px rgba(76,175,80,0.5)' : 'none',
                              }}
                            />
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Chairs Category (Mix & Match with Tables) */}
              {shopCategory === 'chairs' && (
                <>
                  {/* Individual chairs (not in collections) */}
                  {Object.entries(CHAIR_STYLES)
                    .filter(([key]) => !CHAIR_COLLECTION_VARIANTS.includes(key))
                    .map(([key, chairStyle]) => {
                    const chairCount = (gameState.chairs || []).length;
                    const canAfford = gameState.coins >= chairStyle.cost && chairCount < 15;
                    const isSelected = placingEquipment === 'chair' && placingChairStyle === key;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected) {
                              setPlacingEquipment(null);
                              setPlacingChairStyle('basicWood');
                            } else {
                              setPlacingEquipment('chair');
                              setPlacingChairStyle(key);
                              setPlacingDecoration(null);
                              setPlacingFloorStyle(null);
                              setFloorSelection([]);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div style={{ fontSize: '32px', marginBottom: '5px' }}>{chairStyle.icon}</div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{chairStyle.name}</div>
                        <div style={{ fontSize: '10px', color: '#666' }}>{chairCount}/15</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {chairStyle.cost}</div>
                      </div>
                    );
                  })}
                  
                  {/* Chair Collections */}
                  {Object.entries(CHAIR_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`chair_${collKey}`] || collection.variants[0];
                    const chairCount = (gameState.chairs || []).length;
                    const canAfford = gameState.coins >= collection.cost && chairCount < 15;
                    const isSelected = placingEquipment === 'chair' && collection.variants.includes(placingChairStyle);
                    const selectedIdx = collection.variants.indexOf(selectedVariant);
                    return (
                      <div
                        key={collKey}
                        style={{
                          minWidth: '120px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        <div 
                          onClick={() => {
                            if (canAfford) {
                              if (isSelected) {
                                setPlacingEquipment(null);
                                setPlacingChairStyle('basicWood');
                              } else {
                                setPlacingEquipment('chair');
                                setPlacingChairStyle(selectedVariant);
                                setPlacingDecoration(null);
                                setPlacingFloorStyle(null);
                                setFloorSelection([]);
                              }
                            }
                          }}
                          style={{ cursor: canAfford ? 'pointer' : 'not-allowed' }}
                        >
                          <div style={{ fontSize: '32px', marginBottom: '5px' }}>{collection.icon}</div>
                          <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                          <div style={{ fontSize: '10px', color: '#666' }}>{chairCount}/15</div>
                          <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {collection.cost}</div>
                        </div>
                        {/* Color swatches */}
                        <div style={{ display: 'flex', gap: '3px', justifyContent: 'center', marginTop: '8px', flexWrap: 'wrap' }}>
                          {collection.colors.map((color, idx) => (
                            <div
                              key={idx}
                              onClick={(e) => {
                                e.stopPropagation();
                                if (canAfford) {
                                  const newVariant = collection.variants[idx];
                                  setSelectedCollectionVariant(prev => ({ ...prev, [`chair_${collKey}`]: newVariant }));
                                  // Always select this item for placement when clicking swatch
                                  setPlacingEquipment('chair');
                                  setPlacingChairStyle(newVariant);
                                  setPlacingStoveStyle(null);
                                  setPlacingCounterStyle(null);
                                  setPlacingTableStyle(null);
                                  setPlacingWallpaper(null);
                                  setPlacingFloor(null);
                                  setPlacingDoor(null);
                                  setPlacingDivider(null);
                                  setPlacingDecoration(null);
                                  setFloorSelection([]);
                                }
                              }}
                              title={collection.colorNames[idx]}
                              style={{
                                width: '16px',
                                height: '16px',
                                borderRadius: '3px',
                                background: `#${color.toString(16).padStart(6, '0')}`,
                                border: idx === selectedIdx ? '2px solid #4CAF50' : '1px solid #999',
                                cursor: canAfford ? 'pointer' : 'not-allowed',
                                boxShadow: idx === selectedIdx ? '0 0 4px rgba(76,175,80,0.5)' : 'none',
                              }}
                            />
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {/* Staff Category - Hire Waiters */}
              {shopCategory === 'staff' && (
                <>
                  <div style={{ 
                    minWidth: '130px', 
                    padding: '12px', 
                    background: '#f3e5f5', 
                    borderRadius: '8px', 
                    textAlign: 'center',
                  }}>
                    <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#7b1fa2' }}>
                      ðŸ‘” Staff
                    </div>
                    <div style={{ fontSize: '12px', color: '#9c27b0', marginTop: '4px' }}>
                      {gameState.waiters.length} / {gameState.maxWaiters}
                    </div>
                  </div>
                  
                  {/* Current Waiters */}
                  {gameState.waiters.map((waiter, index) => (
                    <div
                      key={waiter.id}
                      onClick={() => setEditingWaiter(waiter)}
                      style={{
                        minWidth: '120px',
                        padding: '12px',
                        border: '2px solid #ce93d8',
                        borderRadius: '10px',
                        background: '#fce4ec',
                        textAlign: 'center',
                        cursor: 'pointer',
                        transition: 'all 0.2s',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>ðŸ§‘â€ðŸ³</div>
                      <div style={{ fontSize: '12px', fontWeight: 'bold' }}>
                        {waiter.name || `Waiter #${index + 1}`}
                      </div>
                      <div style={{ 
                        fontSize: '10px', 
                        color: waiter.state === 'idle' ? '#4CAF50' : '#2196F3',
                        marginTop: '4px',
                      }}>
                        {waiter.state === 'idle' ? 'ðŸ˜Š Ready' : 
                         waiter.state === 'walking_to_counter' ? 'ðŸš¶ To Counter' :
                         waiter.state === 'walking_to_table' ? 'ðŸ½ï¸ Serving' :
                         waiter.state === 'returning' ? 'â†©ï¸ Returning' :
                         waiter.state === 'pacing' ? 'ðŸš¶ Pacing' : 'âœ“ Active'}
                      </div>
                      <div style={{ fontSize: '9px', color: '#9c27b0', marginTop: '4px' }}>
                        âœï¸ Click to edit
                      </div>
                    </div>
                  ))}
                  
                  {/* Hire New Waiter Button */}
                  {gameState.waiters.length < gameState.maxWaiters && (
                    <div
                      onClick={() => {
                        const cost = gameState.waiters.length * 1000;
                        if (gameState.coins >= cost) {
                          dispatch({ type: 'HIRE_WAITER' });
                          SFX.purchase();
                        }
                      }}
                      style={{
                        minWidth: '120px',
                        padding: '12px',
                        border: gameState.coins >= gameState.waiters.length * 1000 
                          ? '3px dashed #4CAF50' 
                          : '3px dashed #ccc',
                        borderRadius: '10px',
                        background: gameState.coins >= gameState.waiters.length * 1000 
                          ? '#e8f5e9' 
                          : '#f5f5f5',
                        cursor: gameState.coins >= gameState.waiters.length * 1000 
                          ? 'pointer' 
                          : 'not-allowed',
                        opacity: gameState.coins >= gameState.waiters.length * 1000 ? 1 : 0.6,
                        textAlign: 'center',
                        transition: 'all 0.2s',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>âž•</div>
                      <div style={{ fontSize: '12px', fontWeight: 'bold', color: '#2e7d32' }}>
                        Hire Waiter
                      </div>
                      <div style={{ fontSize: '14px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>
                        ðŸª™ {gameState.waiters.length * 1000}
                      </div>
                      <div style={{ fontSize: '10px', color: '#666', marginTop: '4px' }}>
                        #{gameState.waiters.length + 1} of {gameState.maxWaiters}
                      </div>
                    </div>
                  )}
                  
                  {gameState.waiters.length >= gameState.maxWaiters && (
                    <div style={{
                      minWidth: '150px',
                      padding: '15px',
                      background: '#fff3e0',
                      borderRadius: '10px',
                      textAlign: 'center',
                    }}>
                      <div style={{ fontSize: '24px' }}>âœ¨</div>
                      <div style={{ fontSize: '12px', color: '#e65100', fontWeight: 'bold' }}>
                        Max Staff Reached!
                      </div>
                    </div>
                  )}
                </>
              )}
              
              {/* Decor Category */}
              {shopCategory === 'decor' && (
                <>
                  {Object.entries(DECORATIONS).map(([key, decor]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= decor.cost) {
                          setPlacingDecoration(placingDecoration === key ? null : key);
                          setPlacingEquipment(null);
                          setPlacingDivider(null);
                          setPlacingDoor(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDecoration === key ? '3px solid #4CAF50' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDecoration === key ? '#e8f5e9' : (gameState.coins >= decor.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= decor.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= decor.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDecoration === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{decor.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{decor.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{decor.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {decor.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {/* Dividers Category */}
              {shopCategory === 'dividers' && (
                <>
                  <div style={{ 
                    minWidth: '200px', 
                    padding: '8px', 
                    background: '#fff8e1', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: '#8B4513',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    ðŸš§ Dividers block customers but are short enough to see over!
                  </div>
                  {Object.entries(DIVIDERS).map(([key, divider]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= divider.cost) {
                          setPlacingDivider(placingDivider === key ? null : key);
                          setPlacingDoor(null);
                          setPlacingDecoration(null);
                          setPlacingEquipment(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDivider === key ? '3px solid #4CAF50' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDivider === key ? '#e8f5e9' : (gameState.coins >= divider.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= divider.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= divider.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDivider === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{divider.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{divider.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{divider.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {divider.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {/* Doors Category */}
              {shopCategory === 'doors' && (
                <>
                  <div style={{ 
                    minWidth: '250px', 
                    padding: '8px', 
                    background: '#e3f2fd', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: '#1565c0',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    ðŸšª Place doors on walls for customers to enter! Click a wall after selecting.
                  </div>
                  {Object.entries(DOORS).map(([key, door]) => (
                    <div
                      key={key}
                      onClick={() => {
                        if (gameState.coins >= door.cost) {
                          setPlacingDoor(placingDoor === key ? null : key);
                          setPlacingDivider(null);
                          setPlacingDecoration(null);
                          setPlacingEquipment(null);
                          setPlacingWallpaper(null);
                        }
                      }}
                      style={{
                        minWidth: '100px',
                        padding: '10px',
                        border: placingDoor === key ? '3px solid #2196F3' : '2px solid #ddd',
                        borderRadius: '10px',
                        background: placingDoor === key ? '#e3f2fd' : (gameState.coins >= door.cost ? '#fffaf5' : '#f0f0f0'),
                        cursor: gameState.coins >= door.cost ? 'pointer' : 'not-allowed',
                        opacity: gameState.coins >= door.cost ? 1 : 0.5,
                        textAlign: 'center',
                        transition: 'all 0.15s',
                        transform: placingDoor === key ? 'scale(1.05)' : 'scale(1)',
                      }}
                    >
                      <div style={{ fontSize: '32px', marginBottom: '5px' }}>{door.icon}</div>
                      <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{door.name}</div>
                      <div style={{ fontSize: '10px', color: '#22c55e' }}>+{door.buzz} Buzz</div>
                      <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>ðŸª™ {door.cost}</div>
                    </div>
                  ))}
                </>
              )}
              
              {shopCategory === 'walls' && (
                <>
                  <div style={{ 
                    minWidth: '280px', 
                    padding: '8px', 
                    background: placingWallpaper ? '#e8f5e9' : '#f3e5f5', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: placingWallpaper ? '#2e7d32' : '#7b1fa2',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    {placingWallpaper 
                      ? `ðŸŽ¨ Click and DRAG to preview! Release to see cost. ðŸª™${WALLPAPERS[placingWallpaper]?.cost}/segment`
                      : `ðŸŽ¨ Select a wallpaper, then drag across walls to preview!`
                    }
                  </div>
                  {/* Individual wallpapers not in collections */}
                  {Object.entries(WALLPAPERS)
                    .filter(([key]) => !WALLPAPER_COLLECTION_VARIANTS.includes(key))
                    .map(([key, wallpaper]) => {
                    const isCurrentWallpaper = (gameState.wallpaper || 'cream') === key;
                    const isSelected = placingWallpaper === key;
                    const canAfford = gameState.coins >= wallpaper.cost;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (isSelected) {
                            setPlacingWallpaper(null);
                            clearWallpaperSelection();
                          } else if (canAfford || wallpaper.cost === 0) {
                            setPlacingWallpaper(key);
                            clearWallpaperSelection();
                            setPlacingDoor(null);
                            setPlacingDivider(null);
                            setPlacingDecoration(null);
                            setPlacingEquipment(null);
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : (isCurrentWallpaper ? '3px solid #9c27b0' : '2px solid #ddd'),
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (isCurrentWallpaper ? '#f3e5f5' : (canAfford || wallpaper.cost === 0 ? '#fffaf5' : '#f0f0f0')),
                          cursor: (canAfford || wallpaper.cost === 0) ? 'pointer' : 'not-allowed',
                          opacity: (canAfford || wallpaper.cost === 0) ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.08)' : (isCurrentWallpaper ? 'scale(1.02)' : 'scale(1)'),
                        }}
                      >
                        <div style={{ 
                          width: '50px', 
                          height: '50px', 
                          margin: '0 auto 5px',
                          borderRadius: '8px',
                          border: '2px solid #ccc',
                          background: wallpaper.pattern === 'stripes' 
                            ? `repeating-linear-gradient(90deg, #${wallpaper.color.toString(16).padStart(6, '0')}, #${wallpaper.color.toString(16).padStart(6, '0')} 8px, #${wallpaper.stripeColor.toString(16).padStart(6, '0')} 8px, #${wallpaper.stripeColor.toString(16).padStart(6, '0')} 12px)`
                            : wallpaper.pattern === 'brick'
                            ? `repeating-linear-gradient(0deg, #${wallpaper.color.toString(16).padStart(6, '0')}, #${wallpaper.color.toString(16).padStart(6, '0')} 10px, #d3d3d3 10px, #d3d3d3 12px)`
                            : `#${wallpaper.color.toString(16).padStart(6, '0')}`,
                          position: 'relative',
                        }}>
                          {isCurrentWallpaper && (
                            <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', fontSize: '20px' }}>âœ“</div>
                          )}
                        </div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{wallpaper.name}</div>
                        {wallpaper.buzz > 0 && <div style={{ fontSize: '10px', color: '#22c55e' }}>+{wallpaper.buzz} Buzz</div>}
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>
                          {isCurrentWallpaper ? 'âœ“ Current' : (wallpaper.cost === 0 ? 'Free' : `ðŸª™ ${wallpaper.cost}`)}
                        </div>
                      </div>
                    );
                  })}
                  {/* Wallpaper Collections with color swatches */}
                  {Object.entries(WALLPAPER_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`wall_${collKey}`] || collection.variants[0];
                    const selectedIdx = collection.variants.indexOf(selectedVariant);
                    const isSelected = placingWallpaper === selectedVariant;
                    const canAfford = gameState.coins >= collection.cost;
                    
                    return (
                      <div key={collKey} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                        <div
                          onClick={() => {
                            if (canAfford) {
                              if (isSelected) {
                                setPlacingWallpaper(null);
                                clearWallpaperSelection();
                              } else {
                                setPlacingWallpaper(selectedVariant);
                                clearWallpaperSelection();
                                setPlacingDoor(null);
                                setPlacingDivider(null);
                                setPlacingDecoration(null);
                                setPlacingEquipment(null);
                              }
                            }
                          }}
                          style={{
                            minWidth: '100px',
                            padding: '10px',
                            border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                            borderRadius: '10px',
                            background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                            cursor: canAfford ? 'pointer' : 'not-allowed',
                            opacity: canAfford ? 1 : 0.5,
                            textAlign: 'center',
                            transition: 'all 0.15s',
                            transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                          }}
                        >
                          <div style={{ fontSize: '28px', marginBottom: '5px' }}>{collection.icon}</div>
                          <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                          <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold' }}>ðŸª™ {collection.cost}</div>
                        </div>
                        {/* Color swatches */}
                        <div style={{ display: 'flex', gap: '3px', marginTop: '5px', flexWrap: 'wrap', justifyContent: 'center', maxWidth: '100px' }}>
                          {collection.colors.map((color, idx) => (
                            <div
                              key={idx}
                              onClick={(e) => {
                                e.stopPropagation();
                                const newVariant = collection.variants[idx];
                                setSelectedCollectionVariant(prev => ({ ...prev, [`wall_${collKey}`]: newVariant }));
                                // Always select this wallpaper for placement when clicking swatch
                                setPlacingWallpaper(newVariant);
                                clearWallpaperSelection();
                                setPlacingEquipment(null);
                                setPlacingStoveStyle(null);
                                setPlacingCounterStyle(null);
                                setPlacingTableStyle(null);
                                setPlacingChairStyle(null);
                                setPlacingFloor(null);
                                setPlacingDoor(null);
                                setPlacingDivider(null);
                                setPlacingDecoration(null);
                              }}
                              title={collection.colorNames[idx]}
                              style={{
                                width: '16px',
                                height: '16px',
                                borderRadius: '3px',
                                background: `#${color.toString(16).padStart(6, '0')}`,
                                border: idx === selectedIdx ? '2px solid #4CAF50' : '1px solid #999',
                                cursor: 'pointer',
                                boxShadow: idx === selectedIdx ? '0 0 4px rgba(76,175,80,0.5)' : 'none',
                              }}
                            />
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              
              {shopCategory === 'floors' && (
                <>
                  <div style={{ 
                    minWidth: '320px', 
                    padding: '8px', 
                    background: placingFloorStyle ? '#e8f5e9' : '#fff3e0', 
                    borderRadius: '8px', 
                    marginBottom: '8px',
                    fontSize: '12px',
                    color: placingFloorStyle ? '#2e7d32' : '#e65100',
                    textAlign: 'center',
                    alignSelf: 'center',
                  }}>
                    {placingFloorStyle 
                      ? `ðŸŸ« Click and DRAG to preview! Release to see cost. ðŸª™${FLOOR_STYLES[placingFloorStyle]?.cost}/tile`
                      : `ðŸŸ« Select a floor style, then drag across tiles to preview!`
                    }
                  </div>
                  {/* Floor Collections */}
                  {Object.entries(FLOOR_COLLECTIONS).map(([collKey, collection]) => {
                    const selectedVariant = selectedCollectionVariant[`floor_${collKey}`] || collection.variants[0];
                    const variantStyle = FLOOR_STYLES[selectedVariant];
                    const isSelected = placingFloorStyle && collection.variants.includes(placingFloorStyle);
                    const canAfford = gameState.coins >= (variantStyle?.cost || collection.cost);
                    
                    return (
                      <div
                        key={collKey}
                        onClick={() => {
                          if (canAfford) {
                            if (isSelected && placingFloorStyle === selectedVariant) {
                              // Deselect
                              setPlacingFloorStyle(null);
                              setFloorSelection([]);
                            } else {
                              // Select this floor collection for placement
                              setPlacingFloorStyle(selectedVariant);
                              setFloorSelection([]);
                              setPlacingWallpaper(null);
                              setPlacingDoor(null);
                              setPlacingDivider(null);
                              setPlacingDecoration(null);
                              setPlacingEquipment(null);
                            }
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford ? '#fffaf5' : '#f0f0f0'),
                          cursor: canAfford ? 'pointer' : 'not-allowed',
                          opacity: canAfford ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                        }}
                      >
                        {/* Floor preview using selected variant colors */}
                        <div style={{ 
                          width: '50px', 
                          height: '50px', 
                          margin: '0 auto 5px',
                          borderRadius: '8px',
                          border: '2px solid #ccc',
                          background: variantStyle ? `
                            linear-gradient(45deg, 
                              #${variantStyle.color1.toString(16).padStart(6, '0')} 25%, 
                              #${variantStyle.color2.toString(16).padStart(6, '0')} 25%, 
                              #${variantStyle.color2.toString(16).padStart(6, '0')} 50%, 
                              #${variantStyle.color1.toString(16).padStart(6, '0')} 50%, 
                              #${variantStyle.color1.toString(16).padStart(6, '0')} 75%, 
                              #${variantStyle.color2.toString(16).padStart(6, '0')} 75%
                            )` : '#ccc',
                          backgroundSize: '20px 20px',
                          position: 'relative',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          fontSize: '24px',
                        }}>
                          {collection.icon}
                          {isSelected && (
                            <div style={{
                              position: 'absolute',
                              top: '-5px',
                              right: '-5px',
                              background: '#4CAF50',
                              borderRadius: '50%',
                              width: '20px',
                              height: '20px',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              color: 'white',
                              fontSize: '12px',
                            }}>âœ“</div>
                          )}
                        </div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{collection.name}</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '2px' }}>
                          ðŸª™ {variantStyle?.cost || collection.cost}/tile
                        </div>
                        
                        {/* Color/Pattern swatches */}
                        <div style={{ 
                          display: 'flex', 
                          gap: '3px', 
                          marginTop: '5px', 
                          justifyContent: 'center',
                          flexWrap: 'wrap',
                          maxWidth: '90px',
                        }}>
                          {collection.swatchType === 'pattern' ? (
                            // Pattern-based swatches (wood, checkered, disco, starlight)
                            collection.variants.map((variant, idx) => {
                              const vStyle = FLOOR_STYLES[variant];
                              const vCanAfford = gameState.coins >= (vStyle?.cost || 0);
                              return (
                                <div
                                  key={variant}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (vCanAfford) {
                                      setSelectedCollectionVariant(prev => ({ ...prev, [`floor_${collKey}`]: variant }));
                                      // Auto-select for placement
                                      setPlacingFloorStyle(variant);
                                      setFloorSelection([]);
                                      setPlacingWallpaper(null);
                                      setPlacingDoor(null);
                                      setPlacingDivider(null);
                                      setPlacingDecoration(null);
                                      setPlacingEquipment(null);
                                    }
                                  }}
                                  title={collection.patternNames?.[idx] || variant}
                                  style={{
                                    width: '18px',
                                    height: '18px',
                                    borderRadius: '3px',
                                    background: `#${(collection.baseColor || 0x888888).toString(16).padStart(6, '0')}`,
                                    border: selectedVariant === variant ? '2px solid #4CAF50' : '1px solid #999',
                                    cursor: vCanAfford ? 'pointer' : 'not-allowed',
                                    opacity: vCanAfford ? 1 : 0.5,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '10px',
                                  }}
                                >
                                  {collection.patternIcons?.[idx] || ''}
                                </div>
                              );
                            })
                          ) : collection.swatchType === 'colorPair' ? (
                            // Color pair swatches with Sm/Lg toggle (tiles with sizes)
                            collection.colors.map((color, idx) => {
                              const smVariant = collection.variants[idx * 2];
                              const lgVariant = collection.variants[idx * 2 + 1];
                              const isSmSelected = selectedVariant === smVariant;
                              const isLgSelected = selectedVariant === lgVariant;
                              const isThisColor = isSmSelected || isLgSelected;
                              const vStyle = FLOOR_STYLES[smVariant];
                              const vCanAfford = gameState.coins >= (vStyle?.cost || 0);
                              return (
                                <div
                                  key={idx}
                                  style={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    gap: '1px',
                                  }}
                                >
                                  <div
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (vCanAfford) {
                                        // Toggle between Sm and Lg, or select Sm by default
                                        const newVariant = isSmSelected ? lgVariant : smVariant;
                                        setSelectedCollectionVariant(prev => ({ ...prev, [`floor_${collKey}`]: newVariant }));
                                        // Auto-select for placement
                                        setPlacingFloorStyle(newVariant);
                                        setFloorSelection([]);
                                        setPlacingWallpaper(null);
                                        setPlacingDoor(null);
                                        setPlacingDivider(null);
                                        setPlacingDecoration(null);
                                        setPlacingEquipment(null);
                                      }
                                    }}
                                    title={`${collection.colorNames[idx]} (click to toggle Sm/Lg)`}
                                    style={{
                                      width: '18px',
                                      height: '18px',
                                      borderRadius: '3px',
                                      background: `#${color.toString(16).padStart(6, '0')}`,
                                      border: isThisColor ? '2px solid #4CAF50' : '1px solid #999',
                                      cursor: vCanAfford ? 'pointer' : 'not-allowed',
                                      opacity: vCanAfford ? 1 : 0.5,
                                    }}
                                  />
                                  {isThisColor && (
                                    <div style={{ fontSize: '7px', color: '#666' }}>
                                      {isLgSelected ? 'Lg' : 'Sm'}
                                    </div>
                                  )}
                                </div>
                              );
                            })
                          ) : (
                            // Standard color swatches (carpet, marble, granite)
                            collection.variants.map((variant, idx) => {
                              const vStyle = FLOOR_STYLES[variant];
                              const vCanAfford = gameState.coins >= (vStyle?.cost || 0);
                              return (
                                <div
                                  key={variant}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    if (vCanAfford) {
                                      setSelectedCollectionVariant(prev => ({ ...prev, [`floor_${collKey}`]: variant }));
                                      // Auto-select for placement
                                      setPlacingFloorStyle(variant);
                                      setFloorSelection([]);
                                      setPlacingWallpaper(null);
                                      setPlacingDoor(null);
                                      setPlacingDivider(null);
                                      setPlacingDecoration(null);
                                      setPlacingEquipment(null);
                                    }
                                  }}
                                  title={collection.colorNames?.[idx] || variant}
                                  style={{
                                    width: '18px',
                                    height: '18px',
                                    borderRadius: '3px',
                                    background: `#${(collection.colors?.[idx] || 0x888888).toString(16).padStart(6, '0')}`,
                                    border: selectedVariant === variant ? '2px solid #4CAF50' : '1px solid #999',
                                    cursor: vCanAfford ? 'pointer' : 'not-allowed',
                                    opacity: vCanAfford ? 1 : 0.5,
                                  }}
                                />
                              );
                            })
                          )}
                        </div>
                      </div>
                    );
                  })}
                  
                  {/* Individual floors not in collections */}
                  {Object.entries(FLOOR_STYLES)
                    .filter(([key]) => !FLOOR_COLLECTION_VARIANTS.includes(key))
                    .map(([key, style]) => {
                    const isSelected = placingFloorStyle === key;
                    const canAfford = gameState.coins >= style.cost;
                    return (
                      <div
                        key={key}
                        onClick={() => {
                          if (isSelected) {
                            // Deselect
                            setPlacingFloorStyle(null);
                            setFloorSelection([]);
                          } else if (canAfford || style.cost === 0) {
                            // Select this floor style for placement
                            setPlacingFloorStyle(key);
                            setFloorSelection([]);
                            setPlacingWallpaper(null);
                            setPlacingDoor(null);
                            setPlacingDivider(null);
                            setPlacingDecoration(null);
                            setPlacingEquipment(null);
                          }
                        }}
                        style={{
                          minWidth: '100px',
                          padding: '10px',
                          border: isSelected ? '3px solid #4CAF50' : '2px solid #ddd',
                          borderRadius: '10px',
                          background: isSelected ? '#e8f5e9' : (canAfford || style.cost === 0 ? '#fffaf5' : '#f0f0f0'),
                          cursor: (canAfford || style.cost === 0) ? 'pointer' : 'not-allowed',
                          opacity: (canAfford || style.cost === 0) ? 1 : 0.5,
                          textAlign: 'center',
                          transition: 'all 0.15s',
                          transform: isSelected ? 'scale(1.08)' : 'scale(1)',
                        }}
                      >
                        {/* Floor tile preview - checkerboard pattern */}
                        <div style={{ 
                          width: '50px', 
                          height: '50px', 
                          margin: '0 auto 5px',
                          borderRadius: '8px',
                          border: '2px solid #ccc',
                          background: `
                            linear-gradient(45deg, 
                              #${style.color1.toString(16).padStart(6, '0')} 25%, 
                              #${style.color2.toString(16).padStart(6, '0')} 25%, 
                              #${style.color2.toString(16).padStart(6, '0')} 50%, 
                              #${style.color1.toString(16).padStart(6, '0')} 50%, 
                              #${style.color1.toString(16).padStart(6, '0')} 75%, 
                              #${style.color2.toString(16).padStart(6, '0')} 75%
                            )`,
                          backgroundSize: '20px 20px',
                          position: 'relative',
                        }}>
                          {isSelected && (
                            <div style={{
                              position: 'absolute',
                              top: '-5px',
                              right: '-5px',
                              background: '#4CAF50',
                              borderRadius: '50%',
                              width: '20px',
                              height: '20px',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              color: 'white',
                              fontSize: '12px',
                            }}>ðŸŽ¨</div>
                          )}
                        </div>
                        <div style={{ fontSize: '11px', fontWeight: 'bold' }}>{style.name}</div>
                        <div style={{ fontSize: '12px', color: '#D4A574', fontWeight: 'bold', marginTop: '5px' }}>
                          {style.cost === 0 ? 'Free' : `ðŸª™ ${style.cost}/tile`}
                        </div>
                      </div>
                    );
                  })}
                </>
              )}
              </div>
              
              {/* Right Arrow */}
              <div 
                onClick={() => {
                  if (shopScrollRef.current && shopScrollPos.left < shopScrollPos.max - 5) {
                    shopScrollRef.current.scrollBy({ left: 200, behavior: 'smooth' });
                  }
                }}
                style={{
                  width: '45px',
                  background: shopScrollPos.left < shopScrollPos.max - 5
                    ? 'linear-gradient(135deg, #e8a849 0%, #d4892a 100%)'
                    : '#ccc',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  cursor: shopScrollPos.left < shopScrollPos.max - 5 ? 'pointer' : 'default',
                  fontSize: '24px',
                  color: 'white',
                  fontWeight: 'bold',
                }}
              >â–¶</div>
            </div>
          </>
        )}
      </div>
      
      {/* Stove Status Indicators - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.stoves.map(stove => {
        const screenPos = projectedPositions[`stove_${stove.id}`];
        if (!screenPos) return null;
        
        if (stove.state === 'cooking' && stove.startTime) {
          const recipe = RECIPES[stove.recipe];
          const elapsed = (currentTime - stove.startTime) / 1000;
          // Use mastery-adjusted cook time for progress calculation
          const masteryCookTime = getCookTimeWithMastery(gameState.dishMastery, stove.recipe);
          const progress = Math.min(100, (elapsed / masteryCookTime) * 100);
          const remaining = Math.max(0, masteryCookTime - elapsed);
          
          return (
            <div key={stove.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -100%)',
              background: 'rgba(0,0,0,0.85)',
              padding: '4px 8px',
              borderRadius: '6px',
              color: 'white',
              fontSize: '11px',
              textAlign: 'center',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
            }}>
              <span style={{ fontSize: '14px' }}>{recipe.icon}</span>
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '2px' }}>
                <div style={{ 
                  background: 'rgba(255,255,255,0.2)', 
                  borderRadius: '3px', 
                  height: '4px', 
                  width: '40px',
                  overflow: 'hidden',
                }}>
                  <div style={{ 
                    width: `${progress}%`, 
                    height: '100%', 
                    background: COLORS.ui.green,
                    transition: 'width 0.1s linear',
                  }} />
                </div>
                <div style={{ fontSize: '9px', opacity: 0.8 }}>{formatTimeDisplay(remaining)}</div>
              </div>
            </div>
          );
        }
        
        if (stove.state === 'ready') {
          const recipe = RECIPES[stove.recipe];
          const handleServeToCounter = () => {
            // First, try to find a counter with the SAME recipe (for stacking)
            let counter = gameState.counters.find(c => c.dishes.length > 0 && c.dishes[0].recipe === stove.recipe);
            // If no matching recipe counter, find an EMPTY counter
            if (!counter) {
              counter = gameState.counters.find(c => c.dishes.length === 0);
            }
            if (counter) {
              dispatch({ type: 'SERVE_TO_COUNTER', payload: { stoveId: stove.id, counterId: counter.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleServeToCounter}
              title={`Serve ${stove.servingsLeft} ${recipe.name} to counter`}
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: 'rgba(34, 197, 94, 0.95)',
                padding: '5px 10px',
                borderRadius: '8px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 2px 8px rgba(34, 197, 94, 0.4)',
                border: '2px solid rgba(255,255,255,0.5)',
                cursor: 'pointer',
                animation: 'pulse 2s infinite',
              }}>
              <span style={{ fontSize: '18px' }}>{recipe.icon}</span>
              <span>âœ“{stove.servingsLeft}</span>
            </button>
          );
        }
        
        if (stove.state === 'spoiled') {
          const handleClean = () => {
            if (gameState.coins >= 15) {
              dispatch({ type: 'CLEAN_STOVE', payload: { stoveId: stove.id } });
            }
          };
          
          return (
            <button 
              key={stove.id} 
              onClick={handleClean}
              disabled={gameState.coins < 15}
              title="Click to clean (15ðŸª™)"
              style={{
                position: 'absolute',
                left: `${screenPos.x}%`,
                top: `${screenPos.y}%`,
                transform: 'translate(-50%, -100%)',
                background: 'rgba(239, 68, 68, 0.95)',
                padding: '5px 10px',
                borderRadius: '8px',
                color: 'white',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                display: 'flex',
                alignItems: 'center',
                gap: '4px',
                boxShadow: '0 2px 8px rgba(239, 68, 68, 0.4)',
                border: '2px solid rgba(255,255,255,0.5)',
                cursor: gameState.coins >= 15 ? 'pointer' : 'not-allowed',
                opacity: gameState.coins >= 15 ? 1 : 0.7,
              }}>
              <span style={{ fontSize: '16px' }}>ðŸ—‘ï¸</span>
              <span>15ðŸª™</span>
            </button>
          );
        }
        
        return null;
      })}
      
      {/* Waiter Name Labels - floating above waiters when showName is enabled */}
      {!isDragging && gameState.waiters.map(waiter => {
        if (!waiter.showName || !waiter.name) return null;
        const screenPos = projectedPositions[`waiter_${waiter.id}`];
        if (!screenPos) return null;
        
        return (
          <div
            key={`waiter-name-${waiter.id}`}
            style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -130%)',
              background: 'rgba(147, 51, 234, 0.9)',
              padding: '3px 10px',
              borderRadius: '12px',
              color: 'white',
              fontSize: '11px',
              fontWeight: 'bold',
              textAlign: 'center',
              whiteSpace: 'nowrap',
              boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
              border: '1px solid rgba(255,255,255,0.3)',
              pointerEvents: 'none',
            }}
          >
            {waiter.name}
          </div>
        );
      })}
      
      {/* Chef Name Label - floating above chef when showName is enabled */}
      {!isDragging && gameState.avatar.showName && gameState.avatar.name && (() => {
        const screenPos = projectedPositions['chef'];
        if (!screenPos) return null;
        
        return (
          <div
            style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -130%)',
              background: 'linear-gradient(135deg, rgba(236, 72, 153, 0.9), rgba(244, 114, 182, 0.9))',
              padding: '3px 10px',
              borderRadius: '12px',
              color: 'white',
              fontSize: '11px',
              fontWeight: 'bold',
              textAlign: 'center',
              whiteSpace: 'nowrap',
              boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
              border: '1px solid rgba(255,255,255,0.3)',
              pointerEvents: 'none',
            }}
          >
            {gameState.avatar.name}
          </div>
        );
      })()}
      
      {/* EDIT MODE - Single selected object popup */}
      {editMode && !isDragging && !movingObject && selectedEditObject && (() => {
        const { type, id } = selectedEditObject;
        let screenPos, canDelete, canMove, name, deleteAction, refund;
        
        if (type === 'stove') {
          const stove = gameState.stoves.find(s => s.id === id);
          if (!stove) return null;
          screenPos = projectedPositions[`stove_${id}`];
          canDelete = gameState.stoves.length > 1 && stove.state === 'empty';
          canMove = stove.state === 'empty';
          name = 'ðŸ”¥ Stove';
          refund = 250;
          deleteAction = () => dispatch({ type: 'REMOVE_STOVE', payload: { stoveId: id } });
        } else if (type === 'counter') {
          const counter = gameState.counters.find(c => c.id === id);
          if (!counter) return null;
          screenPos = projectedPositions[`counter_${id}`];
          canDelete = gameState.counters.length > 1 && counter.dishes.length === 0;
          canMove = counter.dishes.length === 0;
          name = 'ðŸ½ï¸ Counter';
          refund = 200;
          deleteAction = () => dispatch({ type: 'REMOVE_COUNTER', payload: { counterId: id } });
        } else if (type === 'table') {
          const table = gameState.tables.find(t => t.id === id);
          if (!table) return null;
          screenPos = projectedPositions[`table_${id}`];
          canDelete = gameState.tables.length > 1 && !table.customer;
          canMove = !table.customer;
          const tableStyleData = TABLE_STYLES[table.style] || TABLE_STYLES.round;
          name = `ðŸ½ï¸ ${tableStyleData.name}`;
          refund = Math.floor(tableStyleData.cost * 0.5); // 50% refund based on table cost
          deleteAction = () => dispatch({ type: 'REMOVE_TABLE', payload: { tableId: id } });
        } else if (type === 'chair') {
          const chair = (gameState.chairs || []).find(c => c.id === id);
          if (!chair) return null;
          const chairStyleData = CHAIR_STYLES[chair.style] || CHAIR_STYLES.basicWood;
          const worldX = chair.gridX - GRID.width / 2 + 0.5;
          const worldZ = chair.gridZ - GRID.height / 2 + 0.5;
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.4, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `ðŸª‘ ${chairStyleData.name}`;
          refund = Math.floor(chairStyleData.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_CHAIR', payload: { chairId: id } });
        } else if (type === 'decoration') {
          const decor = gameState.decorations.find(d => d.id === id);
          if (!decor) return null;
          const decorType = DECORATIONS[decor.type];
          const worldX = decor.gridX - GRID.width / 2 + 0.5;
          const worldZ = decor.gridZ - GRID.height / 2 + 0.5;
          // Calculate screen position
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.5, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `${decorType.icon} ${decorType.name}`;
          refund = Math.floor(decorType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DECORATION', payload: { decorationId: id } });
        } else if (type === 'divider') {
          const divider = (gameState.dividers || []).find(d => d.id === id);
          if (!divider) return null;
          const dividerType = DIVIDERS[divider.type];
          const worldX = divider.gridX - GRID.width / 2 + 0.5;
          const worldZ = divider.gridZ - GRID.height / 2 + 0.5;
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 0.3, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = true;
          name = `${dividerType.icon} ${dividerType.name}`;
          refund = Math.floor(dividerType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DIVIDER', payload: { dividerId: id } });
        } else if (type === 'door') {
          const door = (gameState.doors || []).find(d => d.id === id);
          if (!door) return null;
          const doorType = DOORS[door.type];
          // Calculate world position based on wall
          let worldX, worldZ;
          if (door.wall === 'back') {
            worldX = door.wallPosition - GRID.width / 2 + 0.5;
            worldZ = -GRID.height / 2 - 0.15;
          } else if (door.wall === 'left') {
            worldX = -GRID.width / 2 - 0.15;
            worldZ = door.wallPosition - GRID.height / 2 + 0.5;
          } else if (door.wall === 'right') {
            worldX = GRID.width / 2 + 0.15;
            worldZ = door.wallPosition - GRID.height / 2 + 0.5;
          }
          if (cameraRef.current) {
            const vec = new THREE.Vector3(worldX, 1.5, worldZ);
            vec.project(cameraRef.current);
            screenPos = { x: (vec.x * 0.5 + 0.5) * 100, y: (-vec.y * 0.5 + 0.5) * 100 };
          }
          canDelete = true;
          canMove = false; // Doors can't be moved, only deleted and re-placed
          name = `ðŸšª ${doorType.name}`;
          refund = Math.floor(doorType.cost * 0.5);
          deleteAction = () => dispatch({ type: 'REMOVE_DOOR', payload: { doorId: id } });
        }
        
        if (!screenPos) return null;
        
        return (
          <div style={{
            position: 'absolute',
            left: `${screenPos.x}%`,
            top: `${screenPos.y - 8}%`,
            transform: 'translate(-50%, -100%)',
            background: 'rgba(0, 0, 0, 0.9)',
            padding: '8px 12px',
            borderRadius: '8px',
            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
            zIndex: 200,
          }}>
            <div style={{ color: 'white', fontSize: '12px', fontWeight: 'bold', marginBottom: '8px', textAlign: 'center' }}>
              {name}
            </div>
            <div style={{ display: 'flex', gap: '6px' }}>
              <button
                onClick={() => {
                  if (canMove) {
                    const obj = type === 'stove' ? gameState.stoves.find(s => s.id === id) :
                                type === 'counter' ? gameState.counters.find(c => c.id === id) :
                                type === 'table' ? gameState.tables.find(t => t.id === id) :
                                type === 'chair' ? (gameState.chairs || []).find(c => c.id === id) :
                                type === 'divider' ? (gameState.dividers || []).find(d => d.id === id) :
                                gameState.decorations.find(d => d.id === id);
                    if (obj) {
                      const moveData = type === 'decoration' 
                        ? { ...obj, decorationType: obj.type }
                        : type === 'divider'
                        ? { ...obj, dividerType: obj.type }
                        : { ...obj };
                      setMovingObject({ type, id, data: moveData });
                      setPlacementRotation(obj.rotation || 0);
                      setSelectedEditObject(null);
                      SFX.uiClick?.();
                    }
                  }
                }}
                disabled={!canMove}
                style={{
                  background: canMove ? '#3b82f6' : '#6b7280',
                  color: 'white',
                  border: 'none',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  fontSize: '11px',
                  fontWeight: 'bold',
                  cursor: canMove ? 'pointer' : 'not-allowed',
                }}
              >
                âœ‹ Move
              </button>
              {(type === 'table' || type === 'chair') && (
                <button
                  onClick={() => {
                    if (canMove) {
                      if (type === 'table') {
                        dispatch({ type: 'ROTATE_TABLE', payload: { tableId: id } });
                      } else if (type === 'chair') {
                        dispatch({ type: 'ROTATE_CHAIR', payload: { chairId: id } });
                      }
                      SFX.uiClick?.();
                    }
                  }}
                  disabled={!canMove}
                  style={{
                    background: canMove ? '#2563eb' : '#6b7280',
                    color: 'white',
                    border: 'none',
                    padding: '6px 10px',
                    borderRadius: '6px',
                    fontSize: '11px',
                    fontWeight: 'bold',
                    cursor: canMove ? 'pointer' : 'not-allowed',
                  }}
                >
                  ðŸ”„
                </button>
              )}
              <button
                onClick={() => {
                  if (canDelete) {
                    deleteAction();
                    setSelectedEditObject(null);
                    SFX.error();
                  }
                }}
                disabled={!canDelete}
                style={{
                  background: canDelete ? '#dc2626' : '#6b7280',
                  color: 'white',
                  border: 'none',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  fontSize: '11px',
                  fontWeight: 'bold',
                  cursor: canDelete ? 'pointer' : 'not-allowed',
                }}
              >
                ðŸ—‘ï¸ +{refund}ðŸª™
              </button>
            </div>
          </div>
        );
      })()}
      
      {/* Counter Food Labels - hidden while dragging to prevent jitter */}
      {!isDragging && gameState.counters.map(counter => {
        if (counter.dishes.length === 0) return null;
        const screenPos = projectedPositions[`counter_${counter.id}`];
        if (!screenPos) return null;
        
        const dish = counter.dishes[0];
        const recipe = RECIPES[dish.recipe];
        const isSelected = selectedCounterForTrash === counter.id;
        
        return (
          <div key={counter.id} style={{
            position: 'absolute',
            left: `${screenPos.x}%`,
            top: `${screenPos.y}%`,
            transform: 'translate(-50%, -100%)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
          }}>
            {/* Clickable food badge - click to show/hide trash option */}
            <div 
              onClick={(e) => {
                e.stopPropagation();
                setSelectedCounterForTrash(isSelected ? null : counter.id);
              }}
              style={{
                background: isSelected ? 'rgba(239, 68, 68, 0.9)' : 'rgba(46, 139, 87, 0.9)',
                padding: '4px 8px',
                borderRadius: '6px',
                color: 'white',
                fontSize: '12px',
                textAlign: 'center',
                display: 'flex',
                alignItems: 'center',
                gap: '4px',
                cursor: 'pointer',
                transition: 'all 0.15s',
                border: isSelected ? '2px solid #fff' : '2px solid transparent',
              }}
              title={isSelected ? 'Click to cancel' : 'Click to manage food'}
            >
              <span style={{ fontSize: '16px' }}>{recipe.icon}</span>
              <span>{dish.servings}</span>
            </div>
            {/* Trash button - only visible when this counter is selected */}
            {isSelected && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setTrashConfirm({ counterId: counter.id, recipeName: recipe.name, servings: dish.servings, icon: recipe.icon });
                  setSelectedCounterForTrash(null);
                }}
                style={{
                  background: 'rgba(239, 68, 68, 0.95)',
                  border: '2px solid #fff',
                  borderRadius: '6px',
                  padding: '4px 8px',
                  cursor: 'pointer',
                  fontSize: '12px',
                  color: 'white',
                  fontWeight: 'bold',
                  animation: 'pulse 0.5s ease-in-out',
                }}
                title={`Trash ${dish.servings} ${recipe.name}`}
              >
                ðŸ—‘ï¸
              </button>
            )}
          </div>
        );
      })}
      
      {/* Customer Status Indicators - CLICKABLE - hidden while dragging */}
      {!isDragging && gameState.tables.map(table => {
        if (!table.customer) return null;
        const screenPos = projectedPositions[`table_${table.id}`];
        if (!screenPos) return null;
        
        if (table.customer.state === 'waiting') {
          const patience = table.customer.patience;
          const barColor = patience > 60 ? COLORS.ui.green : patience > 30 ? '#eab308' : COLORS.ui.red;
          const hasFood = totalFood > 0;
          
          // Dynamic emoji based on patience
          const emoji = patience > 60 ? 'ðŸ˜Š' : patience > 30 ? 'ðŸ˜' : 'ðŸ˜ ';
          
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: '2px',
              pointerEvents: 'none',
            }}>
              {/* Emoji + optional "ready to order" icon */}
              <div style={{ 
                fontSize: '18px', 
                transition: 'transform 0.2s ease',
                transform: patience < 30 ? 'scale(1.1)' : 'scale(1)',
                filter: patience < 30 ? 'drop-shadow(0 0 3px red)' : 'none',
                display: 'flex',
                alignItems: 'center',
                gap: '2px',
              }}>
                {emoji}
                {hasFood && <span style={{ fontSize: '12px' }}>ðŸš¶</span>}
              </div>
              
              {/* Compact patience bar */}
              <div style={{ 
                width: '32px',
                background: 'rgba(0,0,0,0.4)', 
                borderRadius: '3px', 
                height: '4px',
                overflow: 'hidden',
              }}>
                <div style={{ 
                  width: `${patience}%`, 
                  height: '100%', 
                  background: barColor,
                  transition: 'width 0.1s linear, background 0.3s ease',
                }} />
              </div>
            </div>
          );
        }
        
        if (table.customer.state === 'walking_to_counter') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ 
                fontSize: '14px',
                background: 'rgba(59, 130, 246, 0.85)',
                borderRadius: '50%',
                width: '22px',
                height: '22px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}>ðŸš¶</div>
            </div>
          );
        }
        
        if (table.customer.state === 'walking_to_table') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ 
                fontSize: '14px',
                background: 'rgba(34, 197, 94, 0.85)',
                borderRadius: '50%',
                width: '22px',
                height: '22px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}>ðŸ½ï¸</div>
            </div>
          );
        }
        
        if (table.customer.state === 'eating') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '16px' }}>ðŸ˜‹</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingHappy') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              animation: 'jumpOut 0.8s ease-out forwards',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '18px' }}>ðŸ˜„ðŸ’š</div>
            </div>
          );
        }
        
        if (table.customer.state === 'leavingAngry') {
          return (
            <div key={table.id} style={{
              position: 'absolute',
              left: `${screenPos.x}%`,
              top: `${screenPos.y}%`,
              transform: 'translate(-50%, -50%)',
              textAlign: 'center',
              animation: 'stomp 0.2s ease-in-out 4',
              pointerEvents: 'none',
            }}>
              <div style={{ fontSize: '18px' }}>ðŸ˜¡ðŸ’”</div>
            </div>
          );
        }
        
        return null;
      })}
      
      {/* Flying Coins Animation */}
      {flyingCoins.filter(coin => {
        const now = Date.now();
        const elapsed = (now - coin.startTime) / 1000;
        // Remove if: animation done (>0.85s), OR invalid/future startTime, OR very old (>5s safety)
        if (elapsed < 0 || elapsed > 5 || !coin.startTime) return false;
        return elapsed < 0.85;
      }).map(coin => {
        const elapsed = (Date.now() - coin.startTime) / 1000;
        const duration = 0.8;
        const progress = Math.min(1, Math.max(0, elapsed / duration)); // Clamp to 0-1
        
        // Ease out curve for smooth deceleration
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        // Calculate position (fly from table to header COIN area)
        // Based on header layout: Cafe name/level (left) | XP bar | Coins | Buzz | Food | Time (right)
        const targetX = 36; // Coins display position (fine-tuned)
        const targetY = 2.5;  // Top of screen %
        const currentX = coin.startX + (targetX - coin.startX) * easeOut;
        const currentY = coin.startY + (targetY - coin.startY) * easeOut;
        
        // Arc effect - rise up in an arc
        const arcHeight = -12 * Math.sin(progress * Math.PI);
        
        return (
          <div
            key={coin.id}
            style={{
              position: 'absolute',
              left: `${currentX}%`,
              top: `${currentY + arcHeight}%`,
              transform: 'translate(-50%, -50%)',
              fontSize: '24px',
              pointerEvents: 'none',
              zIndex: 200,
              opacity: 1 - progress * 0.3,
              filter: `drop-shadow(0 2px 4px rgba(0,0,0,0.3))`,
            }}
          >
            ðŸª™
          </div>
        );
      })}
      
      {/* Stats Footer */}
      <div style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: '10px 20px',
        background: 'linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%)',
        display: 'flex',
        justifyContent: 'center',
        gap: '30px',
        color: 'white',
        fontSize: '13px',
      }}>
        <div>ðŸ³ Dishes: {gameState.stats.dishesCooked}</div>
        <div>ðŸ˜Š Served: {gameState.stats.customersServed}</div>
        <div>ðŸ’° Earned: ${gameState.stats.totalEarned}</div>
      </div>
      
      {/* Cookbook Modal */}
      {(selectedStove || showCookbook) && (() => {
        const recipeEntries = Object.entries(RECIPES);
        const recipesPerPage = 4;
        const totalPages = Math.ceil(recipeEntries.length / recipesPerPage);
        const startIdx = cookbookPage * recipesPerPage;
        const pageRecipes = recipeEntries.slice(startIdx, startIdx + recipesPerPage);
        const isBrowseMode = showCookbook && !selectedStove; // Browse mode = no stove selected
        
        // Use slightly different format for cookbook (more readable)
        const formatCookTime = (seconds) => {
          if (seconds < 60) return `${seconds} secs`;
          if (seconds < 3600) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return secs > 0 ? `${mins}m ${secs}s` : `${mins} mins`;
          }
          const hours = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          if (mins > 0) return `${hours}h ${mins}m`;
          return `${hours} hour${hours > 1 ? 's' : ''}`;
        };
        
        const closeCookbook = () => {
          setSelectedStove(null);
          setShowCookbook(false);
          setCookbookPage(0);
        };
        
        return (
          <div style={{
            position: 'absolute',
            inset: 0,
            background: 'rgba(0,0,0,0.7)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 100,
          }} onClick={closeCookbook}>
            <div 
              style={{
                background: 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)',
                borderRadius: '20px',
                padding: '0',
                maxWidth: '620px',
                width: '95%',
                overflow: 'hidden',
                boxShadow: '0 10px 40px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.5)',
                border: '5px solid #b45309',
              }} 
              onClick={e => e.stopPropagation()}
              onWheel={(e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.deltaY > 0) {
                  // Scroll down = next page
                  setCookbookPage(p => Math.min(totalPages - 1, p + 1));
                } else if (e.deltaY < 0) {
                  // Scroll up = previous page
                  setCookbookPage(p => Math.max(0, p - 1));
                }
              }}
            >
              
              {/* Cookbook Header */}
              <div style={{
                background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                padding: '12px 20px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                borderBottom: '3px solid #92400e',
              }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '28px' }}>ðŸ“–</span>
                  <h2 style={{ 
                    margin: 0, 
                    color: '#451a03',
                    fontWeight: 'bold',
                    fontSize: '22px',
                    textShadow: '1px 1px 0 rgba(255,255,255,0.3)',
                    letterSpacing: '2px',
                  }}>{isBrowseMode ? 'RECIPE BOOK' : 'COOKBOOK'}</h2>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                  <div style={{ 
                    background: 'rgba(255,255,255,0.4)', 
                    padding: '6px 14px', 
                    borderRadius: '14px',
                    fontWeight: 'bold',
                    color: '#451a03',
                    fontSize: '15px',
                    boxShadow: 'inset 0 1px 2px rgba(0,0,0,0.1)',
                  }}>
                    ðŸª™ {gameState.coins.toLocaleString()}
                  </div>
                  <button
                    onClick={closeCookbook}
                    style={{
                      background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                      border: '2px solid #991b1b',
                      borderRadius: '50%',
                      width: '34px',
                      height: '34px',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '20px',
                      fontWeight: 'bold',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >Ã—</button>
                </div>
              </div>
              
              {/* Content Area with Navigation */}
              <div style={{ 
                display: 'flex', 
                alignItems: 'stretch',
                padding: '15px 10px',
                gap: '10px',
                minHeight: '380px',
              }}>
                
                {/* Left Arrow */}
                <button
                  onClick={() => setCookbookPage(p => Math.max(0, p - 1))}
                  disabled={cookbookPage === 0}
                  style={{
                    background: cookbookPage === 0 ? '#d1d5db' : 'linear-gradient(135deg, #f59e0b, #d97706)',
                    border: cookbookPage === 0 ? '2px solid #9ca3af' : '2px solid #92400e',
                    borderRadius: '10px',
                    width: '44px',
                    color: cookbookPage === 0 ? '#9ca3af' : 'white',
                    cursor: cookbookPage === 0 ? 'not-allowed' : 'pointer',
                    fontSize: '24px',
                    fontWeight: 'bold',
                    boxShadow: cookbookPage === 0 ? 'none' : '0 2px 6px rgba(0,0,0,0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >â—€</button>
                
                {/* Recipe Grid - 2x2 */}
                <div style={{
                  flex: 1,
                  display: 'grid',
                  gridTemplateColumns: 'repeat(2, 1fr)',
                  gridTemplateRows: 'repeat(2, 1fr)',
                  gap: '12px',
                }}>
                  {pageRecipes.map(([key, recipe]) => {
                    const totalRevenue = recipe.servings * recipe.revenue;
                    const profit = totalRevenue - recipe.cost;
                    const isUnlocked = recipe.level <= gameState.level;
                    const canAfford = gameState.coins >= recipe.cost;
                    const isNew = recipe.level === gameState.level && recipe.level > 1;
                    
                    if (!isUnlocked) {
                      return (
                        <div
                          key={key}
                          style={{
                            background: 'linear-gradient(135deg, #e5e7eb, #d1d5db)',
                            borderRadius: '14px',
                            padding: '12px',
                            border: '3px dashed #9ca3af',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            opacity: 0.7,
                          }}
                        >
                          <span style={{ fontSize: '48px', filter: 'grayscale(1) brightness(1.3)', marginBottom: '8px' }}>
                            {recipe.icon}
                          </span>
                          <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#6b7280', marginBottom: '4px' }}>
                            {recipe.name}
                          </div>
                          <div style={{
                            background: '#6b7280',
                            color: 'white',
                            padding: '4px 12px',
                            borderRadius: '10px',
                            fontSize: '12px',
                            fontWeight: 'bold',
                          }}>
                            ðŸ”’ Level {recipe.level}
                          </div>
                        </div>
                      );
                    }
                    
                    return (
                      <div
                        key={key}
                        style={{
                          background: 'linear-gradient(135deg, #fff 0%, #fef9c3 100%)',
                          borderRadius: '14px',
                          padding: '12px',
                          border: isNew ? '3px solid #f59e0b' : '3px solid #a3a3a3',
                          display: 'flex',
                          flexDirection: 'column',
                          boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                          position: 'relative',
                        }}
                      >
                        {/* NEW Badge */}
                        {isNew && (
                          <div style={{
                            position: 'absolute',
                            top: -8,
                            right: -8,
                            background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                            color: 'white',
                            fontSize: '10px',
                            fontWeight: 'bold',
                            padding: '3px 8px',
                            borderRadius: '8px',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                            animation: 'pulse 1s infinite',
                          }}>
                            NEW!
                          </div>
                        )}
                        
                        {/* Recipe Name */}
                        <div style={{
                          fontWeight: 'bold',
                          fontSize: '14px',
                          color: '#1f2937',
                          marginBottom: '6px',
                          textAlign: 'center',
                        }}>
                          {recipe.name}
                        </div>
                        
                        {/* Icon and Cost */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '8px' }}>
                          <div style={{
                            background: 'linear-gradient(135deg, #dbeafe, #bfdbfe)',
                            borderRadius: '10px',
                            padding: '8px',
                            border: '2px solid #93c5fd',
                          }}>
                            <span style={{ fontSize: '36px' }}>{recipe.icon}</span>
                          </div>
                          
                          <div style={{ flex: 1, fontSize: '12px', color: '#4b5563' }}>
                            <div style={{ marginBottom: '2px' }}>
                              <strong>Cost:</strong>{' '}
                              <span style={{
                                background: '#fef3c7',
                                padding: '2px 6px',
                                borderRadius: '6px',
                                color: '#92400e',
                                fontWeight: 'bold',
                              }}>ðŸª™ {recipe.cost}</span>
                            </div>
                            <div><strong>Servings:</strong> {recipe.servings}</div>
                          </div>
                        </div>
                        
                        {/* Earnings Info */}
                        <div style={{
                          background: '#f0fdf4',
                          borderRadius: '8px',
                          padding: '6px 8px',
                          marginBottom: '8px',
                          fontSize: '11px',
                          border: '1px solid #bbf7d0',
                        }}>
                          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '2px' }}>
                            <span>Earns:</span>
                            <span style={{ color: '#15803d', fontWeight: 'bold' }}>
                              ðŸª™ {recipe.revenue} per serving
                            </span>
                          </div>
                          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                            <span></span>
                            <span style={{ color: '#166534', fontWeight: 'bold' }}>
                              ðŸª™ {totalRevenue} total
                            </span>
                          </div>
                        </div>
                        
                        {/* Ready Time & XP */}
                        <div style={{
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          fontSize: '11px',
                          marginBottom: '8px',
                          padding: '4px 8px',
                          background: 'linear-gradient(135deg, #fef3c7, #fde68a)',
                          borderRadius: '6px',
                          border: '1px solid #fbbf24',
                        }}>
                          <div>
                            <span style={{ color: '#78350f' }}>â±ï¸ </span>
                            <span style={{ color: '#dc2626', fontWeight: 'bold' }}>
                              {formatCookTime(recipe.cookTime)}
                            </span>
                          </div>
                          <div>
                            <span style={{ color: '#78350f' }}>â­ </span>
                            <span style={{ color: '#7c3aed', fontWeight: 'bold' }}>
                              +{recipe.xp} XP
                            </span>
                          </div>
                        </div>
                        
                        {/* Mastery Progress */}
                        {(() => {
                          const mastery = gameState.dishMastery?.[key] || { cooked: 0 };
                          const level = getMasteryLevel(gameState.dishMastery, key);
                          const nextLevel = level < 3 ? level + 1 : 3;
                          const nextThreshold = level < 3 ? MASTERY_LEVELS[nextLevel].cooksRequired : MASTERY_LEVELS[3].cooksRequired;
                          const prevThreshold = level > 0 ? MASTERY_LEVELS[level].cooksRequired : 0;
                          const progressInLevel = level < 3 
                            ? ((mastery.cooked - prevThreshold) / (nextThreshold - prevThreshold)) * 100
                            : 100;
                          
                          const plateColors = {
                            0: '#FFFAF0', // Ivory (default)
                            1: '#87CEEB', // Light blue
                            2: '#4169E1', // Royal blue  
                            3: '#FFD700', // Gold
                          };
                          
                          return (
                            <div style={{
                              background: level > 0 
                                ? `linear-gradient(135deg, ${level === 3 ? '#fef3c7' : level === 2 ? '#dbeafe' : '#e0f2fe'}, white)`
                                : '#f9fafb',
                              borderRadius: '8px',
                              padding: '6px 8px',
                              marginBottom: '8px',
                              fontSize: '10px',
                              border: `1px solid ${level === 3 ? '#fbbf24' : level === 2 ? '#60a5fa' : level === 1 ? '#7dd3fc' : '#e5e7eb'}`,
                            }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '3px' }}>
                                {/* Plate indicator */}
                                <div style={{
                                  width: '14px',
                                  height: '14px',
                                  borderRadius: '50%',
                                  background: plateColors[level],
                                  border: `2px solid ${level === 3 ? '#b8860b' : level === 2 ? '#1e40af' : level === 1 ? '#0284c7' : '#d1d5db'}`,
                                  boxShadow: level === 3 ? '0 0 4px #fbbf24' : 'none',
                                }} />
                                <span style={{ fontWeight: 'bold', color: '#374151' }}>
                                  {level === 0 ? 'No Mastery' : MASTERY_LEVELS[level].name}
                                </span>
                                <span style={{ marginLeft: 'auto', color: '#6b7280' }}>
                                  {mastery.cooked}/{level < 3 ? nextThreshold : 'âœ“'}
                                </span>
                              </div>
                              
                              {/* Progress bar */}
                              <div style={{
                                background: '#e5e7eb',
                                borderRadius: '4px',
                                height: '4px',
                                overflow: 'hidden',
                              }}>
                                <div style={{
                                  width: `${Math.min(100, progressInLevel)}%`,
                                  height: '100%',
                                  background: level === 3 ? '#fbbf24' : level === 2 ? '#3b82f6' : level === 1 ? '#38bdf8' : '#9ca3af',
                                  transition: 'width 0.3s ease',
                                }} />
                              </div>
                              
                              {/* Bonus indicators */}
                              {level > 0 && (
                                <div style={{ display: 'flex', gap: '6px', marginTop: '4px', flexWrap: 'wrap' }}>
                                  {level >= 1 && (
                                    <span style={{ 
                                      background: '#dcfce7', 
                                      color: '#15803d', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% Servings</span>
                                  )}
                                  {level >= 2 && (
                                    <span style={{ 
                                      background: '#ede9fe', 
                                      color: '#6d28d9', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% XP</span>
                                  )}
                                  {level >= 3 && (
                                    <span style={{ 
                                      background: '#fef3c7', 
                                      color: '#b45309', 
                                      padding: '1px 4px', 
                                      borderRadius: '4px',
                                      fontSize: '9px',
                                      fontWeight: 'bold',
                                    }}>+5% Speed</span>
                                  )}
                                </div>
                              )}
                            </div>
                          );
                        })()}
                        
                        {/* Buy Button - Only in cooking mode */}
                        {!isBrowseMode ? (
                          <button
                            onClick={() => handleRecipeSelect(key)}
                            disabled={!canAfford}
                            style={{
                              background: canAfford 
                                ? 'linear-gradient(135deg, #22c55e, #16a34a)' 
                                : 'linear-gradient(135deg, #9ca3af, #6b7280)',
                              border: canAfford ? '2px solid #15803d' : '2px solid #4b5563',
                              borderRadius: '10px',
                              padding: '8px 0',
                              color: 'white',
                              fontWeight: 'bold',
                              fontSize: '14px',
                              cursor: canAfford ? 'pointer' : 'not-allowed',
                              boxShadow: canAfford ? '0 2px 6px rgba(0,0,0,0.2)' : 'none',
                              letterSpacing: '1px',
                            }}
                          >
                            {canAfford ? 'COOK!' : 'Need ðŸª™' + recipe.cost}
                          </button>
                        ) : (
                          <div style={{
                            background: 'linear-gradient(135deg, #e5e7eb, #d1d5db)',
                            border: '2px solid #9ca3af',
                            borderRadius: '10px',
                            padding: '8px 0',
                            color: '#6b7280',
                            fontWeight: 'bold',
                            fontSize: '12px',
                            textAlign: 'center',
                            letterSpacing: '0.5px',
                          }}>
                            Click stove to cook
                          </div>
                        )}
                      </div>
                    );
                  })}
                  
                  {/* Fill empty slots */}
                  {[...Array(recipesPerPage - pageRecipes.length)].map((_, i) => (
                    <div key={`empty-${i}`} style={{
                      background: 'rgba(0,0,0,0.05)',
                      borderRadius: '14px',
                      border: '3px dashed #d1d5db',
                    }} />
                  ))}
                </div>
                
                {/* Right Arrow */}
                <button
                  onClick={() => setCookbookPage(p => Math.min(totalPages - 1, p + 1))}
                  disabled={cookbookPage >= totalPages - 1}
                  style={{
                    background: cookbookPage >= totalPages - 1 ? '#d1d5db' : 'linear-gradient(135deg, #f59e0b, #d97706)',
                    border: cookbookPage >= totalPages - 1 ? '2px solid #9ca3af' : '2px solid #92400e',
                    borderRadius: '10px',
                    width: '44px',
                    color: cookbookPage >= totalPages - 1 ? '#9ca3af' : 'white',
                    cursor: cookbookPage >= totalPages - 1 ? 'not-allowed' : 'pointer',
                    fontSize: '24px',
                    fontWeight: 'bold',
                    boxShadow: cookbookPage >= totalPages - 1 ? 'none' : '0 2px 6px rgba(0,0,0,0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >â–¶</button>
              </div>
              
              {/* Page Indicator */}
              <div style={{
                background: 'rgba(0,0,0,0.1)',
                padding: '10px',
                textAlign: 'center',
                borderTop: '2px solid rgba(0,0,0,0.1)',
              }}>
                <span style={{ color: '#78350f', fontSize: '14px' }}>
                  Page {cookbookPage + 1} of {totalPages}
                </span>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '6px', marginTop: '6px' }}>
                  {[...Array(totalPages)].map((_, i) => (
                    <button
                      key={i}
                      onClick={() => setCookbookPage(i)}
                      style={{
                        width: '10px',
                        height: '10px',
                        borderRadius: '50%',
                        border: 'none',
                        background: i === cookbookPage ? '#d97706' : '#d1d5db',
                        cursor: 'pointer',
                        padding: 0,
                      }}
                    />
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      })()}
      
      {/* Decoration Placement Mode UI - Only when shop is closed */}
      {placingDecoration && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #e8f5e9, #c8e6c9)',
          borderTop: '3px solid #4CAF50',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {DECORATIONS[placingDecoration].icon}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#2e7d32' }}>
              Placing: {DECORATIONS[placingDecoration].name} (ðŸª™{DECORATIONS[placingDecoration].cost})
            </div>
            <div style={{ fontSize: '13px', color: '#558b2f' }}>
              {DECORATIONS[placingDecoration].category === 'wall' 
                ? 'Click on wall to place â€¢ Auto-faces the wall!'
                : 'Click on the floor to place â€¢ Keep clicking to place more!'}
            </div>
          </div>
          <button
            onClick={() => setPlacingDecoration(null)}
            style={{
              background: '#4CAF50',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            âœ“ Done
          </button>
        </div>
      )}
      
      {/* Divider Placement Mode UI */}
      {placingDivider && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #fff3e0, #ffe0b2)',
          borderTop: '3px solid #ff9800',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {DIVIDERS[placingDivider].icon}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#e65100' }}>
              Placing: {DIVIDERS[placingDivider].name} (ðŸª™{DIVIDERS[placingDivider].cost})
            </div>
            <div style={{ fontSize: '13px', color: '#f57c00' }}>
              Click to place â€¢ R to rotate â€¢ Keep clicking to place more!
            </div>
          </div>
          <button
            onClick={() => {
              setPlacingDivider(null);
              setPlacementRotation(0);
            }}
            style={{
              background: '#ff9800',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            âœ“ Done
          </button>
        </div>
      )}
      
      {/* Equipment Placement Mode UI - Only when shop is closed */}
      {placingEquipment && !showShop && (
        <div style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(to bottom, #fff3e0, #ffe0b2)',
          borderTop: '3px solid #FF9800',
          padding: '15px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '20px',
          zIndex: 100,
          boxShadow: '0 -4px 20px rgba(0,0,0,0.2)',
        }}>
          <div style={{ fontSize: '36px' }}>
            {placingEquipment === 'stove' ? (STOVE_STYLES[placingStoveStyle]?.icon || 'ðŸ”¥') : placingEquipment === 'counter' ? (COUNTER_STYLES[placingCounterStyle]?.icon || 'ðŸ½ï¸') : placingEquipment === 'chair' ? 'ðŸª‘' : 'ðŸ½ï¸'}
          </div>
          <div>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: '#e65100' }}>
              Placing: {placingEquipment === 'stove' ? `${STOVE_STYLES[placingStoveStyle]?.name || 'Stove'} (ðŸª™${STOVE_STYLES[placingStoveStyle]?.cost || 500})` 
                : placingEquipment === 'counter' ? `${COUNTER_STYLES[placingCounterStyle]?.name || 'Counter'} (ðŸª™${COUNTER_STYLES[placingCounterStyle]?.cost || 400})` 
                : placingEquipment === 'chair' ? `Chair (ðŸª™${CHAIR_STYLES[placingChairStyle]?.cost || 100})`
                : `Table (ðŸª™${TABLE_STYLES[placingTableStyle]?.cost || 300})`}
            </div>
            <div style={{ fontSize: '13px', color: '#f57c00' }}>
              {placingEquipment === 'table' 
                ? 'Click in DINING area â€¢ R to rotate'
                : placingEquipment === 'chair'
                ? 'Click in DINING area â€¢ Place next to table â€¢ R to rotate'
                : placingEquipment === 'counter'
                ? 'Click anywhere â€¢ R to rotate â€¢ Customers pick up from front'
                : 'Click in KITCHEN area â€¢ R to rotate â€¢ Chef interacts from front'}
            </div>
          </div>
          <button
            onClick={() => {
              setPlacingEquipment(null);
              setPlacementRotation(0);
            }}
            style={{
              background: '#ff9800',
              color: 'white',
              border: 'none',
              padding: '10px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            âœ“ Done
          </button>
        </div>
      )}
      
      {/* Settings/Save Modal */}
      {showSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 100,
        }} onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}>
          <div style={{
            background: 'white',
            borderRadius: '16px',
            padding: '20px',
            maxWidth: '400px',
            width: '90%',
          }} onClick={e => e.stopPropagation()}>
            <h2 style={{ margin: '0 0 15px', textAlign: 'center' }}>ðŸ’¾ Save / Load</h2>
            
            {saveMessage && (
              <div style={{
                marginBottom: '15px',
                padding: '10px',
                borderRadius: '8px',
                background: saveMessage.type === 'success' ? '#dcfce7' : '#fef2f2',
                color: saveMessage.type === 'success' ? '#166534' : '#991b1b',
                textAlign: 'center',
                fontSize: '14px',
              }}>
                {saveMessage.type === 'success' ? 'âœ…' : 'âŒ'} {saveMessage.text}
              </div>
            )}
            
            <div style={{ display: 'grid', gap: '10px' }}>
              <button
                onClick={handleExportSave}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '12px',
                  padding: '12px',
                  border: '2px solid #22c55e',
                  borderRadius: '10px',
                  background: '#f0fdf4',
                  cursor: 'pointer',
                }}
              >
                <span style={{ fontSize: '24px' }}>ðŸ“¤</span>
                <div style={{ flex: 1, textAlign: 'left' }}>
                  <div style={{ fontWeight: 'bold' }}>Export Save</div>
                  <div style={{ fontSize: '11px', color: '#666' }}>Generate save data to copy</div>
                </div>
              </button>
              
              {showExportText && (
                <div style={{ position: 'relative' }}>
                  <textarea
                    value={saveTextArea}
                    readOnly
                    onClick={(e) => e.target.select()}
                    style={{
                      width: '100%',
                      height: '60px',
                      padding: '8px',
                      border: '2px solid #22c55e',
                      borderRadius: '8px',
                      fontFamily: 'monospace',
                      fontSize: '10px',
                      resize: 'none',
                      background: '#f0fdf4',
                    }}
                  />
                  <div style={{ fontSize: '11px', color: '#666', marginTop: '4px' }}>
                    ðŸ‘† Click to select, then Ctrl+C / Cmd+C to copy
                  </div>
                </div>
              )}
              
              <div style={{ borderTop: '1px solid #e0e0e0', margin: '5px 0' }} />
              
              <div style={{ fontSize: '12px', color: '#666', textAlign: 'center' }}>
                To load: paste save data below, then click Import
              </div>
              
              <textarea
                value={showExportText ? '' : saveTextArea}
                onChange={(e) => { setSaveTextArea(e.target.value); setShowExportText(false); }}
                placeholder="Paste your save data here..."
                style={{
                  width: '100%',
                  height: '60px',
                  padding: '8px',
                  border: '2px solid #3b82f6',
                  borderRadius: '8px',
                  fontFamily: 'monospace',
                  fontSize: '10px',
                  resize: 'none',
                }}
              />
              
              <button
                onClick={handleImportSave}
                disabled={!saveTextArea.trim() || showExportText}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  padding: '12px',
                  border: 'none',
                  borderRadius: '10px',
                  background: (!saveTextArea.trim() || showExportText) ? '#e0e0e0' : '#3b82f6',
                  color: 'white',
                  cursor: (!saveTextArea.trim() || showExportText) ? 'not-allowed' : 'pointer',
                  fontWeight: 'bold',
                }}
              >
                <span>ðŸ“¥</span> Import Save
              </button>
            </div>
            
            <div style={{
              marginTop: '15px',
              padding: '10px',
              background: '#f8fafc',
              borderRadius: '8px',
              fontSize: '11px',
              color: '#64748b',
            }}>
              <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>ðŸ“Š Current Progress:</div>
              <div>Level {gameState.level} â€¢ {gameState.coins.toLocaleString()} coins â€¢ {gameState.stats.customersServed} served</div>
              <div>{gameState.stoves.length} stoves â€¢ {gameState.counters.length} counters â€¢ {gameState.tables.length} tables</div>
            </div>
            
            {/* Clear stuck coins button */}
            {flyingCoins.length > 0 && (
              <button
                onClick={() => {
                  setFlyingCoins([]);
                  setSaveMessage({ type: 'success', text: 'Cleared ' + flyingCoins.length + ' stuck coin(s)!' });
                  setTimeout(() => setSaveMessage(null), 2000);
                }}
                style={{
                  width: '100%',
                  marginTop: '10px',
                  padding: '10px',
                  border: '2px solid #f59e0b',
                  borderRadius: '8px',
                  background: '#fffbeb',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  fontSize: '13px',
                }}
              >
                <span>ðŸª™</span> Clear Stuck Coins ({flyingCoins.length})
              </button>
            )}
            
            <button
              onClick={() => { setShowSettings(false); setSaveTextArea(''); setShowExportText(false); setSaveMessage(null); }}
              style={{
                width: '100%',
                marginTop: '15px',
                padding: '10px',
                border: 'none',
                borderRadius: '8px',
                background: '#f0f0f0',
                cursor: 'pointer',
              }}
            >
              Close
            </button>
          </div>
        </div>
      )}
      
      {/* Level Up Celebration */}
      {showLevelUp && (() => {
        const unlockedRecipe = Object.values(RECIPES).find(r => r.level === gameState.level);
        return (
          <div style={{
            position: 'absolute',
            inset: 0,
            background: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 100,
            animation: 'fadeIn 0.3s ease',
          }}>
            <div style={{
              background: 'linear-gradient(135deg, #ffd700, #ffec8b)',
              borderRadius: '20px',
              padding: '30px 50px',
              textAlign: 'center',
              boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
              animation: 'bounceIn 0.5s ease',
            }}>
              <div style={{ fontSize: '48px', marginBottom: '10px' }}>ðŸŽ‰</div>
              <h2 style={{ margin: '0 0 10px', color: '#8b4513' }}>Level Up!</h2>
              <div style={{ fontSize: '36px', fontWeight: 'bold', color: '#8b4513' }}>Level {gameState.level}</div>
              <div style={{ marginTop: '10px', color: '#a0522d' }}>+1000 coins bonus!</div>
              {unlockedRecipe && (
                <div style={{ 
                  marginTop: '15px', 
                  padding: '10px 15px',
                  background: 'rgba(255,255,255,0.5)',
                  borderRadius: '10px',
                }}>
                  <div style={{ fontSize: '12px', color: '#666' }}>ðŸ”“ New Recipe Unlocked!</div>
                  <div style={{ fontSize: '24px', marginTop: '5px' }}>
                    {unlockedRecipe.icon} {unlockedRecipe.name}
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      })()}
      
      {/* Achievement Unlocked Popup */}
      {showAchievement && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.4)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 110,
          animation: 'fadeIn 0.3s ease',
        }}>
          <div style={{
            background: 'linear-gradient(180deg, #fef7ed 0%, #fdf2e3 50%, #f5e6d3 100%)',
            borderRadius: '20px',
            padding: '0',
            textAlign: 'center',
            boxShadow: '0 12px 40px rgba(139, 90, 43, 0.35), 0 4px 12px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8)',
            border: '3px solid #c9a66b',
            position: 'relative',
            minWidth: '280px',
            maxWidth: '320px',
            animation: 'bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55)',
            overflow: 'hidden',
          }}>
            {/* Close button */}
            <button
              onClick={() => setShowAchievement(null)}
              style={{
                position: 'absolute',
                top: '8px',
                right: '8px',
                background: 'rgba(139, 90, 43, 0.15)',
                border: 'none',
                borderRadius: '50%',
                width: '28px',
                height: '28px',
                cursor: 'pointer',
                fontSize: '16px',
                color: '#8b5a2b',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                transition: 'all 0.2s',
              }}
              onMouseOver={(e) => e.target.style.background = 'rgba(139, 90, 43, 0.3)'}
              onMouseOut={(e) => e.target.style.background = 'rgba(139, 90, 43, 0.15)'}
            >
              âœ•
            </button>
            
            {/* Ribbon banner at top */}
            <div style={{
              background: 'linear-gradient(135deg, #d4a574 0%, #c9956c 50%, #b8845c 100%)',
              padding: '10px 20px',
              marginBottom: '15px',
              boxShadow: '0 2px 8px rgba(139, 90, 43, 0.3)',
              position: 'relative',
            }}>
              <div style={{
                fontSize: '13px',
                fontWeight: 'bold',
                color: '#fff',
                textShadow: '0 1px 2px rgba(0,0,0,0.2)',
                letterSpacing: '1px',
                textTransform: 'uppercase',
              }}>
                ðŸ† Achievement Unlocked!
              </div>
              {/* Ribbon tails */}
              <div style={{
                position: 'absolute',
                bottom: '-6px',
                left: '20px',
                width: '0',
                height: '0',
                borderLeft: '8px solid transparent',
                borderRight: '8px solid transparent',
                borderTop: '6px solid #a07050',
              }} />
              <div style={{
                position: 'absolute',
                bottom: '-6px',
                right: '20px',
                width: '0',
                height: '0',
                borderLeft: '8px solid transparent',
                borderRight: '8px solid transparent',
                borderTop: '6px solid #a07050',
              }} />
            </div>
            
            {/* Content */}
            <div style={{ padding: '5px 25px 20px' }}>
              {/* Icon with decorative circle */}
              <div style={{
                width: '70px',
                height: '70px',
                margin: '0 auto 12px',
                background: 'linear-gradient(135deg, #fff9f0, #f5ebe0)',
                borderRadius: '50%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: '36px',
                boxShadow: '0 4px 12px rgba(139, 90, 43, 0.2), inset 0 -2px 4px rgba(139, 90, 43, 0.1)',
                border: '2px solid #d4a574',
              }}>
                {showAchievement.icon}
              </div>
              
              {/* Title */}
              <div style={{
                fontSize: '22px',
                fontWeight: 'bold',
                color: '#5c3d2e',
                marginBottom: '6px',
                textShadow: '0 1px 0 rgba(255,255,255,0.5)',
              }}>
                {showAchievement.name}
              </div>
              
              {/* Description */}
              <div style={{
                fontSize: '13px',
                color: '#8b6d5c',
                marginBottom: '15px',
                lineHeight: 1.4,
              }}>
                {showAchievement.description}
              </div>
              
              {/* Reward badge */}
              <div style={{
                display: 'inline-flex',
                alignItems: 'center',
                gap: '6px',
                background: 'linear-gradient(135deg, #ffd700, #ffb700)',
                padding: '8px 16px',
                borderRadius: '20px',
                boxShadow: '0 3px 8px rgba(255, 183, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.5)',
                marginBottom: '15px',
              }}>
                <span style={{ fontSize: '16px', fontWeight: 'bold', color: '#5c3d2e' }}>
                  +{showAchievement.reward}
                </span>
                <span style={{ fontSize: '18px' }}>ðŸª™</span>
              </div>
              
              {/* OK Button */}
              <div>
                <button
                  onClick={() => setShowAchievement(null)}
                  style={{
                    background: 'linear-gradient(135deg, #6b8e23, #556b2f)',
                    border: 'none',
                    borderRadius: '12px',
                    padding: '10px 40px',
                    fontSize: '15px',
                    fontWeight: 'bold',
                    color: 'white',
                    cursor: 'pointer',
                    boxShadow: '0 4px 12px rgba(85, 107, 47, 0.4), inset 0 1px 0 rgba(255,255,255,0.2)',
                    textShadow: '0 1px 2px rgba(0,0,0,0.2)',
                    transition: 'all 0.2s',
                  }}
                  onMouseOver={(e) => {
                    e.target.style.transform = 'scale(1.05)';
                    e.target.style.boxShadow = '0 6px 16px rgba(85, 107, 47, 0.5), inset 0 1px 0 rgba(255,255,255,0.2)';
                  }}
                  onMouseOut={(e) => {
                    e.target.style.transform = 'scale(1)';
                    e.target.style.boxShadow = '0 4px 12px rgba(85, 107, 47, 0.4), inset 0 1px 0 rgba(255,255,255,0.2)';
                  }}
                >
                  Awesome! âœ“
                </button>
              </div>
            </div>
            
            {/* Decorative corner flourishes */}
            <div style={{
              position: 'absolute',
              bottom: '10px',
              left: '10px',
              fontSize: '14px',
              opacity: 0.3,
            }}>â˜•</div>
            <div style={{
              position: 'absolute',
              bottom: '10px',
              right: '10px',
              fontSize: '14px',
              opacity: 0.3,
            }}>â˜•</div>
          </div>
        </div>
      )}
      
      {/* Floor Painting Confirm Popup */}
      {showFloorConfirm && placingFloorStyle && floorSelection.length > 0 && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 2000,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #fff8f0 0%, #ffecd2 100%)',
            padding: '25px 35px',
            borderRadius: '20px',
            textAlign: 'center',
            boxShadow: '0 10px 40px rgba(0,0,0,0.4)',
            border: '3px solid #D4A574',
            maxWidth: '320px',
          }}>
            <div style={{ fontSize: '28px', marginBottom: '10px' }}>ðŸŸ«</div>
            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#5D4037', marginBottom: '8px' }}>
              Apply {FLOOR_STYLES[placingFloorStyle]?.name}?
            </div>
            <div style={{ fontSize: '14px', color: '#666', marginBottom: '15px' }}>
              {floorSelection.length} tile{floorSelection.length !== 1 ? 's' : ''} selected
            </div>
            
            {/* Cost calculation */}
            {(() => {
              const style = FLOOR_STYLES[placingFloorStyle];
              const floorTiles = gameState.floorTiles || {};
              let tilesToChange = 0;
              floorSelection.forEach(({ gridX, gridZ }) => {
                const key = `${gridX},${gridZ}`;
                const currentStyle = floorTiles[key];
                const defaultStyle = gridZ < 3 ? 'whiteTile' : 'woodLight';
                const effectiveCurrentStyle = currentStyle || defaultStyle;
                if (effectiveCurrentStyle !== placingFloorStyle) {
                  tilesToChange++;
                }
              });
              const totalCost = tilesToChange * style.cost;
              const canAfford = gameState.coins >= totalCost;
              
              return (
                <>
                  <div style={{ 
                    fontSize: '20px', 
                    fontWeight: 'bold', 
                    color: canAfford ? '#D4A574' : '#e53935',
                    marginBottom: '20px',
                  }}>
                    {totalCost === 0 ? 'Free!' : `ðŸª™ ${totalCost}`}
                    {tilesToChange < floorSelection.length && (
                      <div style={{ fontSize: '11px', color: '#888', fontWeight: 'normal' }}>
                        ({floorSelection.length - tilesToChange} already this style)
                      </div>
                    )}
                  </div>
                  
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button
                      onClick={() => {
                        setShowFloorConfirm(false);
                        setFloorSelection([]);
                      }}
                      style={{
                        padding: '10px 25px',
                        border: '2px solid #999',
                        borderRadius: '10px',
                        background: '#fff',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: '#666',
                        cursor: 'pointer',
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      onClick={() => {
                        if (canAfford) {
                          dispatch({
                            type: 'PAINT_FLOOR_TILES',
                            payload: { tiles: floorSelection, floorStyle: placingFloorStyle }
                          });
                          SFX.purchase();
                          setShowFloorConfirm(false);
                          setFloorSelection([]);
                        }
                      }}
                      disabled={!canAfford}
                      style={{
                        padding: '10px 25px',
                        border: 'none',
                        borderRadius: '10px',
                        background: canAfford 
                          ? 'linear-gradient(135deg, #4CAF50, #388E3C)' 
                          : '#ccc',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: 'white',
                        cursor: canAfford ? 'pointer' : 'not-allowed',
                        boxShadow: canAfford ? '0 4px 12px rgba(76, 175, 80, 0.4)' : 'none',
                      }}
                    >
                      Confirm âœ“
                    </button>
                  </div>
                </>
              );
            })()}
          </div>
        </div>
      )}
      
      {/* Wallpaper Confirm Popup */}
      {showWallpaperConfirm && placingWallpaper && wallpaperSelection.length > 0 && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 2000,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #fff8f0 0%, #ffecd2 100%)',
            padding: '25px 35px',
            borderRadius: '20px',
            textAlign: 'center',
            boxShadow: '0 10px 40px rgba(0,0,0,0.4)',
            border: '3px solid #D4A574',
            maxWidth: '320px',
          }}>
            <div style={{ fontSize: '28px', marginBottom: '10px' }}>ðŸŽ¨</div>
            <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#5D4037', marginBottom: '8px' }}>
              Apply {WALLPAPERS[placingWallpaper]?.name}?
            </div>
            <div style={{ fontSize: '14px', color: '#666', marginBottom: '15px' }}>
              {wallpaperSelection.length} wall segment{wallpaperSelection.length !== 1 ? 's' : ''} selected
            </div>
            
            {/* Cost calculation */}
            {(() => {
              const wallpaper = WALLPAPERS[placingWallpaper];
              const paintedSegments = gameState.paintedSegments || [];
              let segmentsToChange = 0;
              wallpaperSelection.forEach(({ wall, position }) => {
                const existingPaint = paintedSegments.find(
                  p => p.wall === wall && p.position === position
                );
                if (!existingPaint || existingPaint.wallpaper !== placingWallpaper) {
                  segmentsToChange++;
                }
              });
              const totalCost = segmentsToChange * wallpaper.cost;
              const canAfford = gameState.coins >= totalCost;
              
              return (
                <>
                  <div style={{ 
                    fontSize: '20px', 
                    fontWeight: 'bold', 
                    color: canAfford ? '#D4A574' : '#e53935',
                    marginBottom: '20px',
                  }}>
                    {totalCost === 0 ? 'Free!' : `ðŸª™ ${totalCost}`}
                    {segmentsToChange < wallpaperSelection.length && (
                      <div style={{ fontSize: '11px', color: '#888', fontWeight: 'normal' }}>
                        ({wallpaperSelection.length - segmentsToChange} already this style)
                      </div>
                    )}
                  </div>
                  
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button
                      onClick={() => {
                        setShowWallpaperConfirm(false);
                        clearWallpaperSelection();
                      }}
                      style={{
                        padding: '10px 25px',
                        border: '2px solid #999',
                        borderRadius: '10px',
                        background: '#fff',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: '#666',
                        cursor: 'pointer',
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      onClick={() => {
                        if (canAfford) {
                          dispatch({
                            type: 'PAINT_WALL_SEGMENTS',
                            payload: { segments: wallpaperSelection, wallpaperType: placingWallpaper }
                          });
                          SFX.purchase();
                          setShowWallpaperConfirm(false);
                          clearWallpaperSelection();
                        }
                      }}
                      disabled={!canAfford}
                      style={{
                        padding: '10px 25px',
                        border: 'none',
                        borderRadius: '10px',
                        background: canAfford 
                          ? 'linear-gradient(135deg, #4CAF50, #388E3C)' 
                          : '#ccc',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        color: 'white',
                        cursor: canAfford ? 'pointer' : 'not-allowed',
                        boxShadow: canAfford ? '0 4px 12px rgba(76, 175, 80, 0.4)' : 'none',
                      }}
                    >
                      Confirm âœ“
                    </button>
                  </div>
                </>
              );
            })()}
          </div>
        </div>
      )}
      
      {/* Trophies Panel */}
      {showTrophies && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1a1a2e, #16213e)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '500px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: '#ffd700', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>ðŸ†</span> Achievements
              </h2>
              <button
                onClick={() => setShowTrophies(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >Ã—</button>
            </div>
            
            <div style={{ 
              color: 'rgba(255,255,255,0.6)', 
              marginBottom: '15px',
              fontSize: '14px',
            }}>
              {gameState.achievements.length} of {Object.keys(ACHIEVEMENTS).length} unlocked
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
              {Object.values(ACHIEVEMENTS).map(ach => {
                const unlocked = gameState.achievements.includes(ach.id);
                return (
                  <div key={ach.id} style={{
                    background: unlocked 
                      ? 'linear-gradient(135deg, rgba(147, 51, 234, 0.3), rgba(124, 58, 237, 0.2))'
                      : 'rgba(255,255,255,0.05)',
                    borderRadius: '12px',
                    padding: '12px 15px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '12px',
                    border: unlocked ? '1px solid rgba(147, 51, 234, 0.5)' : '1px solid rgba(255,255,255,0.1)',
                    opacity: unlocked ? 1 : 0.5,
                  }}>
                    <div style={{ 
                      fontSize: '28px',
                      filter: unlocked ? 'none' : 'grayscale(1)',
                    }}>
                      {ach.icon}
                    </div>
                    <div style={{ flex: 1 }}>
                      <div style={{ 
                        color: unlocked ? 'white' : 'rgba(255,255,255,0.5)', 
                        fontWeight: 'bold',
                        fontSize: '14px',
                      }}>
                        {ach.name}
                      </div>
                      <div style={{ 
                        color: 'rgba(255,255,255,0.5)', 
                        fontSize: '12px',
                      }}>
                        {ach.description}
                      </div>
                    </div>
                    <div style={{ 
                      color: unlocked ? '#ffd700' : 'rgba(255,255,255,0.3)',
                      fontSize: '12px',
                      fontWeight: 'bold',
                    }}>
                      {unlocked ? 'âœ“' : `+${ach.reward} ðŸª™`}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}
      
      {/* Settings Panel */}
      {showAudioSettings && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 120,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '450px',
            maxHeight: '80vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>âš™ï¸</span> Settings
              </h2>
              <button
                onClick={() => setShowAudioSettings(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >Ã—</button>
            </div>
            
            {/* Display Settings Section */}
            <div style={{ marginBottom: '20px' }}>
              <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '1px' }}>
                Display
              </div>
              
              {/* Brightness Slider */}
              <div style={{
                background: 'rgba(255,255,255,0.05)',
                borderRadius: '12px',
                padding: '12px 15px',
                marginBottom: '10px',
                border: '1px solid rgba(255,255,255,0.1)',
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ color: 'white', fontWeight: 'bold' }}>â˜€ï¸ Brightness</div>
                  <div style={{ color: 'rgba(255,255,255,0.7)', fontSize: '14px' }}>{Math.round(brightness * 100)}%</div>
                </div>
                <input
                  type="range"
                  min="50"
                  max="150"
                  value={brightness * 100}
                  onChange={(e) => setBrightness(Number(e.target.value) / 100)}
                  style={{
                    width: '100%',
                    height: '8px',
                    borderRadius: '4px',
                    background: `linear-gradient(to right, #4a5568 0%, #fbbf24 50%, #fef3c7 100%)`,
                    appearance: 'none',
                    cursor: 'pointer',
                  }}
                />
                <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '4px' }}>
                  <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: '10px' }}>Darker</span>
                  <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: '10px' }}>Brighter</span>
                </div>
              </div>
            </div>
            
            {/* Audio Settings Section */}
            <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '1px' }}>
              Audio
            </div>
            
            {/* Master Toggle */}
            <div style={{
              background: soundEnabled ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255,255,255,0.05)',
              borderRadius: '12px',
              padding: '12px 15px',
              marginBottom: '15px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              border: soundEnabled ? '1px solid rgba(34, 197, 94, 0.4)' : '1px solid rgba(255,255,255,0.1)',
            }}>
              <div style={{ color: 'white', fontWeight: 'bold' }}>ðŸ”Š Master Volume</div>
              <button
                onClick={() => setSoundEnabled(!soundEnabled)}
                style={{
                  background: soundEnabled ? '#22c55e' : '#666',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '6px 16px',
                  color: 'white',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                }}
              >
                {soundEnabled ? 'ON' : 'OFF'}
              </button>
            </div>
            
            <div style={{ color: 'rgba(255,255,255,0.5)', fontSize: '12px', marginBottom: '10px' }}>
              Individual Sounds (click ðŸ”ˆ to preview)
            </div>
            
            {/* Individual Sound Toggles */}
            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
              {[
                { key: 'cooking', name: 'Cooking Sizzle', icon: 'ðŸ”¥', sfx: () => SFX.cookStart() },
                { key: 'foodReady', name: 'Food Ready', icon: 'âœ¨', sfx: () => SFX.foodReady() },
                { key: 'foodSpoiled', name: 'Food Spoiled', icon: 'ðŸ’¨', sfx: () => SFX.foodSpoiled() },
                { key: 'customerArrive', name: 'Customer Arrives', icon: 'ðŸšª', sfx: () => SFX.customerArrive() },
                { key: 'customerServed', name: 'Customer Served', icon: 'ðŸ½ï¸', sfx: () => SFX.customerServed() },
                { key: 'customerHappy', name: 'Customer Happy', icon: 'ðŸ˜Š', sfx: () => SFX.customerHappy() },
                { key: 'customerAngry', name: 'Customer Angry', icon: 'ðŸ˜ ', sfx: () => SFX.customerAngry() },
                { key: 'coins', name: 'Coins', icon: 'ðŸ’°', sfx: () => SFX.coinEarn() },
                { key: 'purchase', name: 'Purchase', icon: 'ðŸ›’', sfx: () => SFX.purchase() },
                { key: 'levelUp', name: 'Level Up', icon: 'ðŸŽ‰', sfx: () => SFX.levelUp() },
                { key: 'achievement', name: 'Achievement', icon: 'ðŸ†', sfx: () => SFX.achievement() },
              ].map(sound => (
                <div key={sound.key} style={{
                  background: 'rgba(255,255,255,0.05)',
                  borderRadius: '10px',
                  padding: '10px 12px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '10px',
                  border: '1px solid rgba(255,255,255,0.1)',
                }}>
                  <span style={{ fontSize: '18px', width: '24px' }}>{sound.icon}</span>
                  <span style={{ flex: 1, color: 'white', fontSize: '13px' }}>{sound.name}</span>
                  
                  {/* Sample Button - works even if sound is toggled off, for testing */}
                  <button
                    onClick={() => {
                      if (soundEnabled) {
                        // Temporarily enable this sound for preview
                        const oldValue = soundTogglesGlobal[sound.key];
                        soundTogglesGlobal[sound.key] = true;
                        sound.sfx();
                        // Restore after sounds complete
                        setTimeout(() => { soundTogglesGlobal[sound.key] = oldValue; }, 1500);
                      }
                    }}
                    style={{
                      background: 'rgba(59, 130, 246, 0.3)',
                      border: 'none',
                      borderRadius: '6px',
                      padding: '4px 8px',
                      color: 'white',
                      cursor: soundEnabled ? 'pointer' : 'not-allowed',
                      fontSize: '12px',
                      opacity: soundEnabled ? 1 : 0.4,
                    }}
                    title="Preview sound"
                  >
                    ðŸ”ˆ
                  </button>
                  
                  {/* Toggle Button */}
                  <button
                    onClick={() => {
                      const newValue = !soundToggles[sound.key];
                      soundTogglesGlobal[sound.key] = newValue; // Sync immediately
                      setSoundToggles(prev => ({ ...prev, [sound.key]: newValue }));
                    }}
                    style={{
                      background: soundToggles[sound.key] ? '#22c55e' : '#666',
                      border: 'none',
                      borderRadius: '12px',
                      padding: '4px 10px',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '10px',
                      fontWeight: 'bold',
                      minWidth: '40px',
                    }}
                  >
                    {soundToggles[sound.key] ? 'ON' : 'OFF'}
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
      
      {/* Avatar Customization Panel */}
      {showAvatarCustomize && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.8)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 130,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #1e3a5f, #0f2439)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '700px',
            minWidth: '600px',
            maxHeight: '85vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>{gameState.avatar.gender === 'female' ? 'ðŸ‘©â€ðŸ³' : 'ðŸ‘¨â€ðŸ³'}</span> Customize Your Chef
              </h2>
              <button
                onClick={() => setShowAvatarCustomize(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >Ã—</button>
            </div>
            
            {/* Main content: Preview + Options side by side */}
            <div style={{ display: 'flex', gap: '25px', flexWrap: 'wrap' }}>
              
              {/* Left: Preview */}
              <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 100%)',
                borderRadius: '16px',
                padding: '15px',
                minWidth: '180px',
                flexShrink: 0,
              }}>
                <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '8px' }}>Preview</div>
                <canvas 
                  ref={avatarPreviewRef}
                  width={180}
                  height={220}
                  style={{
                    borderRadius: '12px',
                    background: 'radial-gradient(circle at 50% 80%, #4a6741 0%, #2d3a29 100%)',
                  }}
                />
                
                {/* Chef Name */}
                <div style={{ marginTop: '15px', width: '100%' }}>
                  <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '11px', marginBottom: '6px', textAlign: 'center' }}>
                    ðŸ‘¨â€ðŸ³ Chef Name
                  </div>
                  <input
                    type="text"
                    value={gameState.avatar.name || ''}
                    onChange={(e) => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'name', value: e.target.value.slice(0, 12) } })}
                    placeholder="Enter name..."
                    maxLength={12}
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      borderRadius: '8px',
                      border: '2px solid rgba(255,255,255,0.2)',
                      background: 'rgba(255,255,255,0.1)',
                      color: 'white',
                      fontSize: '14px',
                      textAlign: 'center',
                      outline: 'none',
                      boxSizing: 'border-box',
                    }}
                  />
                  <button
                    onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'showName', value: !gameState.avatar.showName } })}
                    style={{
                      width: '100%',
                      marginTop: '6px',
                      padding: '6px',
                      borderRadius: '8px',
                      border: 'none',
                      background: gameState.avatar.showName 
                        ? 'linear-gradient(135deg, #22c55e, #16a34a)' 
                        : 'rgba(255,255,255,0.1)',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '11px',
                    }}
                  >
                    {gameState.avatar.showName ? 'âœ“ Name Visible' : 'â—‹ Name Hidden'}
                  </button>
                </div>
                
                {/* Gender Toggle */}
                <div style={{ marginTop: '15px', width: '100%' }}>
                  <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '11px', marginBottom: '6px', textAlign: 'center' }}>
                    Gender
                  </div>
                  <div style={{ display: 'flex', gap: '6px' }}>
                    {AVATAR_OPTIONS.genders.map(g => (
                      <button
                        key={g.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'gender', value: g.id } })}
                        style={{
                          flex: 1,
                          padding: '8px',
                          borderRadius: '10px',
                          border: 'none',
                          background: gameState.avatar.gender === g.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.gender === g.id ? 'bold' : 'normal',
                          fontSize: '14px',
                        }}
                      >
                        {g.icon} {g.name}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              
              {/* Right: Options */}
              <div style={{ flex: 1, minWidth: '280px' }}>
                
                {/* Skin Tone */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ðŸŽ¨ Skin Tone
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.skinTones.map(skin => (
                      <button
                        key={skin.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'skinTone', value: skin.id } })}
                        style={{
                          width: '38px',
                          height: '38px',
                          borderRadius: '8px',
                          border: gameState.avatar.skinTone === skin.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${skin.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.skinTone === skin.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={skin.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ðŸ’‡ Hair Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairColors.map(hair => (
                      <button
                        key={hair.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairColor', value: hair.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '50%',
                          border: gameState.avatar.hairColor === hair.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${hair.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.hairColor === hair.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={hair.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Style */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    âœ‚ï¸ Hair Style
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairStyles.map(style => (
                      <button
                        key={style.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'hairStyle', value: style.id } })}
                        style={{
                          padding: '6px 12px',
                          borderRadius: '16px',
                          border: 'none',
                          background: gameState.avatar.hairStyle === style.id 
                            ? 'linear-gradient(135deg, #F472B6, #EC4899)' 
                            : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontWeight: gameState.avatar.hairStyle === style.id ? 'bold' : 'normal',
                          fontSize: '12px',
                        }}
                      >
                        {style.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {/* Apron Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ðŸ‘• Apron Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.apronColors.map(apron => (
                      <button
                        key={apron.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'apronColor', value: apron.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.apronColor === apron.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${apron.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.apronColor === apron.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={apron.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Outfit Color */}
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '13px', marginBottom: '6px', fontWeight: 'bold' }}>
                    ðŸ¥¼ Chef Coat Color
                  </div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.outfitColors.map(outfit => (
                      <button
                        key={outfit.id}
                        onClick={() => dispatch({ type: 'UPDATE_AVATAR', payload: { field: 'outfitColor', value: outfit.id } })}
                        style={{
                          width: '32px',
                          height: '32px',
                          borderRadius: '6px',
                          border: gameState.avatar.outfitColor === outfit.id ? '3px solid #F472B6' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${outfit.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: gameState.avatar.outfitColor === outfit.id ? '0 0 10px rgba(244, 114, 182, 0.5)' : 'none',
                        }}
                        title={outfit.name}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Done Button */}
            <button
              onClick={() => setShowAvatarCustomize(false)}
              style={{
                width: '100%',
                padding: '14px',
                borderRadius: '12px',
                border: 'none',
                background: 'linear-gradient(135deg, #F472B6, #EC4899)',
                color: 'white',
                fontSize: '16px',
                fontWeight: 'bold',
                cursor: 'pointer',
                marginTop: '15px',
              }}
            >
              âœ¨ Done!
            </button>
          </div>
        </div>
      )}
      
      {/* Waiter Edit Modal */}
      {editingWaiter && (
        <div style={{
          position: 'absolute',
          inset: 0,
          background: 'rgba(0,0,0,0.8)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 130,
        }}>
          <div style={{
            background: 'linear-gradient(135deg, #5b2c6f, #2c1445)',
            borderRadius: '20px',
            padding: '25px',
            width: '90%',
            maxWidth: '700px',
            minWidth: '600px',
            maxHeight: '85vh',
            overflow: 'auto',
            boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            border: '2px solid rgba(255,255,255,0.1)',
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
              <h2 style={{ margin: 0, color: 'white', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span>ðŸ§‘â€ðŸ³</span> Edit Staff Member
              </h2>
              <button
                onClick={() => setEditingWaiter(null)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: 'none',
                  borderRadius: '50%',
                  width: '32px',
                  height: '32px',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '18px',
                }}
              >Ã—</button>
            </div>
            
            {/* Main content: Preview + Options side by side */}
            <div style={{ display: 'flex', gap: '25px', flexWrap: 'nowrap' }}>
              
              {/* Left: Preview, Name, Show Name */}
              <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 100%)',
                borderRadius: '16px',
                padding: '15px',
                minWidth: '190px',
                flexShrink: 0,
              }}>
                <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '8px' }}>Preview</div>
                <canvas 
                  ref={waiterPreviewRef}
                  width={160}
                  height={200}
                  style={{
                    borderRadius: '12px',
                    background: 'radial-gradient(circle at 50% 80%, #4a3860 0%, #2d1f3a 100%)',
                  }}
                />
                
                {/* Name Input */}
                <div style={{ marginTop: '15px', width: '100%' }}>
                  <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '11px', marginBottom: '6px', textAlign: 'center' }}>
                    ðŸ“ Name
                  </div>
                  <input
                    type="text"
                    value={editingWaiter.name || ''}
                    onChange={(e) => setEditingWaiter({ ...editingWaiter, name: e.target.value.slice(0, 12) })}
                    placeholder="Enter name..."
                    maxLength={12}
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      borderRadius: '8px',
                      border: '2px solid rgba(255,255,255,0.2)',
                      background: 'rgba(255,255,255,0.1)',
                      color: 'white',
                      fontSize: '14px',
                      textAlign: 'center',
                      outline: 'none',
                      boxSizing: 'border-box',
                    }}
                  />
                  <div style={{ color: 'rgba(255,255,255,0.4)', fontSize: '10px', marginTop: '2px', textAlign: 'center' }}>
                    {(editingWaiter.name || '').length}/12 characters
                  </div>
                </div>
                
                {/* Show Name Toggle */}
                <div style={{ marginTop: '10px', width: '100%' }}>
                  <button
                    onClick={() => setEditingWaiter({ ...editingWaiter, showName: !editingWaiter.showName })}
                    style={{
                      width: '100%',
                      padding: '8px',
                      borderRadius: '8px',
                      border: editingWaiter.showName ? '2px solid #9333EA' : '2px solid transparent',
                      background: editingWaiter.showName 
                        ? 'rgba(147, 51, 234, 0.3)' 
                        : 'rgba(255,255,255,0.1)',
                      color: 'white',
                      cursor: 'pointer',
                      fontSize: '11px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '6px',
                    }}
                  >
                    <span style={{
                      width: '32px',
                      height: '18px',
                      borderRadius: '9px',
                      background: editingWaiter.showName ? '#9333EA' : 'rgba(255,255,255,0.2)',
                      position: 'relative',
                      display: 'inline-block',
                    }}>
                      <span style={{
                        width: '14px',
                        height: '14px',
                        borderRadius: '50%',
                        background: 'white',
                        position: 'absolute',
                        top: '2px',
                        left: editingWaiter.showName ? '16px' : '2px',
                        transition: 'all 0.2s',
                      }} />
                    </span>
                    {editingWaiter.showName ? 'Name Visible' : 'Name Hidden'}
                  </button>
                </div>
              </div>
              
              {/* Right: Appearance Options */}
              <div style={{ flex: 1, minWidth: '280px' }}>
                <div style={{ color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginBottom: '12px' }}>âœ¨ Appearance</div>
                
                {/* Skin Tone */}
                <div style={{ marginBottom: '14px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '12px', marginBottom: '6px', fontWeight: 'bold' }}>ðŸŽ¨ Skin Tone</div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.skinTones.map((skin, idx) => (
                      <button
                        key={idx}
                        onClick={() => setEditingWaiter({ ...editingWaiter, skin: idx })}
                        style={{
                          width: '36px',
                          height: '36px',
                          borderRadius: '8px',
                          border: editingWaiter.skin === idx ? '3px solid #9333EA' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${skin.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: editingWaiter.skin === idx ? '0 0 10px rgba(147, 51, 234, 0.5)' : 'none',
                        }}
                        title={skin.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Color */}
                <div style={{ marginBottom: '14px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '12px', marginBottom: '6px', fontWeight: 'bold' }}>ðŸ’‡ Hair Color</div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairColors.map((hair, idx) => (
                      <button
                        key={idx}
                        onClick={() => setEditingWaiter({ ...editingWaiter, hair: idx })}
                        style={{
                          width: '30px',
                          height: '30px',
                          borderRadius: '50%',
                          border: editingWaiter.hair === idx ? '3px solid #9333EA' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${hair.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: editingWaiter.hair === idx ? '0 0 10px rgba(147, 51, 234, 0.5)' : 'none',
                        }}
                        title={hair.name}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Hair Style */}
                <div style={{ marginBottom: '14px' }}>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '12px', marginBottom: '6px', fontWeight: 'bold' }}>ðŸ’ˆ Hair Style</div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.hairStyles.map((style, idx) => (
                      <button
                        key={idx}
                        onClick={() => setEditingWaiter({ ...editingWaiter, hairStyle: idx })}
                        style={{
                          padding: '8px 14px',
                          borderRadius: '10px',
                          border: editingWaiter.hairStyle === idx ? '2px solid #9333EA' : '2px solid rgba(255,255,255,0.2)',
                          background: editingWaiter.hairStyle === idx ? 'rgba(147, 51, 234, 0.3)' : 'rgba(255,255,255,0.1)',
                          color: 'white',
                          cursor: 'pointer',
                          fontSize: '12px',
                          fontWeight: editingWaiter.hairStyle === idx ? 'bold' : 'normal',
                        }}
                      >
                        {style.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {/* Outfit (Vest) Color */}
                <div>
                  <div style={{ color: 'rgba(255,255,255,0.8)', fontSize: '12px', marginBottom: '6px', fontWeight: 'bold' }}>ðŸŽ€ Vest Color</div>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {AVATAR_OPTIONS.outfitColors.map((outfit, idx) => (
                      <button
                        key={idx}
                        onClick={() => setEditingWaiter({ ...editingWaiter, outfit: idx })}
                        style={{
                          width: '36px',
                          height: '36px',
                          borderRadius: '8px',
                          border: editingWaiter.outfit === idx ? '3px solid #9333EA' : '2px solid rgba(255,255,255,0.2)',
                          background: `#${outfit.color.toString(16).padStart(6, '0')}`,
                          cursor: 'pointer',
                          boxShadow: editingWaiter.outfit === idx ? '0 0 10px rgba(147, 51, 234, 0.5)' : 'none',
                        }}
                        title={outfit.name}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Save Button */}
            <button
              onClick={() => {
                dispatch({ 
                  type: 'UPDATE_WAITER', 
                  payload: { 
                    waiterId: editingWaiter.id, 
                    updates: {
                      name: editingWaiter.name,
                      showName: editingWaiter.showName,
                      skin: editingWaiter.skin,
                      hair: editingWaiter.hair,
                      hairStyle: editingWaiter.hairStyle,
                      outfit: editingWaiter.outfit,
                    }
                  }
                });
                // Force recreate waiter model with new appearance
                if (objectsRef.current.waiters && objectsRef.current.waiters[editingWaiter.id]) {
                  const scene = sceneRef.current;
                  const oldObj = objectsRef.current.waiters[editingWaiter.id];
                  scene.remove(oldObj);
                  const waiter = gameState.waiters.find(w => w.id === editingWaiter.id);
                  if (waiter) {
                    const newObj = createWaiter(waiter.carryingFood !== null, {
                      skin: editingWaiter.skin,
                      hair: editingWaiter.hair,
                      hairStyle: editingWaiter.hairStyle,
                      outfit: editingWaiter.outfit,
                    });
                    newObj.position.copy(oldObj.position);
                    newObj.rotation.copy(oldObj.rotation);
                    newObj.userData = { id: editingWaiter.id, name: editingWaiter.name, showName: editingWaiter.showName };
                    scene.add(newObj);
                    objectsRef.current.waiters[editingWaiter.id] = newObj;
                  }
                }
                setEditingWaiter(null);
              }}
              style={{
                width: '100%',
                marginTop: '20px',
                padding: '14px',
                borderRadius: '12px',
                border: 'none',
                background: 'linear-gradient(135deg, #9333EA, #7C3AED)',
                color: 'white',
                fontSize: '16px',
                fontWeight: 'bold',
                cursor: 'pointer',
              }}
            >
              ðŸ’¾ Save Changes
            </button>
          </div>
        </div>
      )}
      
      {/* Trash Confirmation Modal */}
      {trashConfirm && (
        <div style={{
          position: 'absolute',
          top: 0, left: 0, right: 0, bottom: 0,
          background: 'rgba(0,0,0,0.6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 150,
        }} onClick={() => setTrashConfirm(null)}>
          <div style={{
            background: 'white',
            padding: '24px',
            borderRadius: '16px',
            textAlign: 'center',
            maxWidth: '300px',
            boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
          }} onClick={e => e.stopPropagation()}>
            <div style={{ fontSize: '48px', marginBottom: '12px' }}>ðŸ—‘ï¸</div>
            <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>
              Trash Food?
            </div>
            <div style={{ fontSize: '14px', color: '#666', marginBottom: '20px' }}>
              Throw away {trashConfirm.servings} {trashConfirm.icon} {trashConfirm.recipeName}?
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={() => setTrashConfirm(null)}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: '2px solid #ccc',
                  background: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  dispatch({ type: 'TRASH_COUNTER', payload: { counterId: trashConfirm.counterId } });
                  setTrashConfirm(null);
                }}
                style={{
                  padding: '10px 24px',
                  borderRadius: '8px',
                  border: 'none',
                  background: '#ef4444',
                  color: 'white',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: 'bold',
                }}
              >
                ðŸ—‘ï¸ Trash
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Toast Notification */}
      {saveMessage && !showSettings && (
        <div style={{
          position: 'absolute',
          top: '80px',
          left: '50%',
          transform: 'translateX(-50%)',
          padding: '12px 24px',
          borderRadius: '8px',
          background: saveMessage.type === 'success' ? '#22c55e' : '#ef4444',
          color: 'white',
          fontWeight: 'bold',
          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
          zIndex: 200,
          animation: 'fadeIn 0.3s ease-out',
        }}>
          {saveMessage.type === 'success' ? 'âœ…' : 'âŒ'} {saveMessage.text}
        </div>
      )}
    </div>
  );
}

// Render the app
ReactDOM.render(<CafeWorld3D />, document.getElementById('root'));
  </script>
</body>
</html>
